From 06aa85569c67e6d6a8f638c8428fd03fea760b04 Mon Sep 17 00:00:00 2001
From: glingo <cailly.florian.apple@gmail.com>
Date: Fri, 22 Dec 2017 15:55:04 +0100
Subject: [PATCH] Use maven

---
 .gitignore                                         |    3 +-
 demo/event/EventDemo.java                          |  172 ---
 demo/event/crud/CRUDEvent.java                     |   20 -
 demo/event/crud/CreateEvent.java                   |    9 -
 demo/event/crud/UpdateEvent.java                   |    9 -
 demo/event/event/UserCreatedEvent.java             |   12 -
 demo/event/event/UserUpdatedEvent.java             |   12 -
 demo/event/model/Role.java                         |   19 -
 demo/event/model/User.java                         |   20 -
 .../expressionLanguage/ExpressionLanguageDemo.java |   78 --
 demo/expressionLanguage/demo                       |    9 -
 demo/resolver/ResolverDemo.java                    |  116 --
 demo/resource/FileUtils.java                       |   39 -
 demo/resource/ResourceDemo.java                    |   67 -
 demo/resource/ResourceDemo2.java                   |   39 -
 demo/resource/ResourceUtils.java                   |   21 -
 demo/resource/demo                                 |    1 -
 demo/resource/demo_1.txt                           |    1 -
 demo/resource/demo_classpath                       |    1 -
 demo/resource/demo_file                            |    1 -
 demo/templating/TemplatingDemo.java                |  233 ----
 demo/templating/demo.view                          |   40 -
 demo/templating/demo_1.view                        |   42 -
 demo/templating_old/TemplatingDemo.java            |   17 -
 demo/templating_old/demo.view                      |    1 -
 pom.xml                                            |   15 +
 src/MarkupBuilder.java                             |   31 -
 src/Test.java                                      |  102 --
 src/builder/Builder.java                           |   42 -
 src/builder/BuilderInterface.java                  |   16 -
 src/builder/ConditionalBuilder.java                |   36 -
 src/builder/StepInterface.java                     |   12 -
 src/builder/SteppedBuilder.java                    |   74 --
 src/configuration/Configuration.java               |    9 -
 src/configuration/ConfigurationBuilder.java        |    5 -
 src/converter/Converter.java                       |   26 -
 src/converter/ConverterDelegate.java               |   27 -
 src/converter/ConverterResolver.java               |   49 -
 src/converter/support/BigDecimalConverter.java     |   36 -
 src/converter/support/BooleanConverter.java        |   37 -
 src/converter/support/ByteConverter.java           |   36 -
 src/converter/support/CharacterConverter.java      |   37 -
 src/converter/support/DoubleConverter.java         |   38 -
 src/converter/support/FloatConverter.java          |   40 -
 src/converter/support/IdentityConverter.java       |   22 -
 src/converter/support/IntegerConverter.java        |   40 -
 src/converter/support/LongConverter.java           |   40 -
 src/converter/support/ObjectConverter.java         |   63 -
 src/converter/support/ShortConverter.java          |   39 -
 src/converter/support/SqlDateConverter.java        |   41 -
 src/converter/support/SqlTimeConverter.java        |   39 -
 src/converter/support/SqlTimestampConverter.java   |   39 -
 src/converter/support/StringConverter.java         |   45 -
 src/environment/Environment.java                   |    5 -
 src/event/Event.java                               |   41 -
 src/event/dispatcher/Dispatcher.java               |  169 ---
 src/event/dispatcher/DispatcherInterface.java      |   26 -
 src/event/dispatcher/EventDispatcher.java          |   96 --
 src/event/handler/Handler.java                     |    9 -
 src/event/subscriber/Subscriber.java               |   11 -
 src/event_old/Event.java                           |   41 -
 src/event_old/EventConsumer.java                   |    7 -
 src/event_old/EventDispatcher.java                 |   27 -
 src/event_old/EventSubscriber.java                 |   14 -
 src/event_old/dispatcher/Dispatcher.java           |  104 --
 src/event_old/dispatcher/DispatcherInterface.java  |   15 -
 src/event_old/subscriber/Subscriber.java           |   11 -
 src/event_old/subscriber/SubscriberInterface.java  |   10 -
 src/expressionLanguage/Engine.java                 |  225 ----
 src/expressionLanguage/EvaluationContext.java      |  183 ---
 .../expression/BinaryExpression.java               |   24 -
 src/expressionLanguage/expression/Expression.java  |    9 -
 .../expression/UnaryExpression.java                |   14 -
 .../expression/parser/ExpressionParser.java        |  570 ---------
 src/expressionLanguage/extension/Extension.java    |   74 --
 .../extension/ExtensionRegistry.java               |  169 ---
 .../extension/core/CoreExtension.java              |  155 ---
 .../extension/core/expression/AddExpression.java   |   13 -
 .../extension/core/expression/AndExpression.java   |   15 -
 .../extension/core/expression/ArrayExpression.java |   39 -
 .../core/expression/BlockFunctionExpression.java   |   34 -
 .../core/expression/ConcatenateExpression.java     |   29 -
 .../core/expression/ContainsExpression.java        |  149 ---
 .../core/expression/ContextVariableExpression.java |   30 -
 .../core/expression/DivideExpression.java          |   14 -
 .../core/expression/EqualsExpression.java          |   14 -
 .../core/expression/FilterExpression.java          |   45 -
 .../expression/FilterInvocationExpression.java     |   46 -
 .../FunctionOrMacroInvocationExpression.java       |   55 -
 .../core/expression/GetAttributeExpression.java    |  376 ------
 .../expression/GreaterThanEqualsExpression.java    |   14 -
 .../core/expression/GreaterThanExpression.java     |   14 -
 .../core/expression/LessThanEqualsExpression.java  |   14 -
 .../core/expression/LessThanExpression.java        |   14 -
 .../core/expression/LiteralBooleanExpression.java  |   19 -
 .../core/expression/LiteralDoubleExpression.java   |   19 -
 .../core/expression/LiteralLongExpression.java     |   19 -
 .../core/expression/LiteralNullExpression.java     |   16 -
 .../core/expression/LiteralStringExpression.java   |   19 -
 .../extension/core/expression/MapExpression.java   |   41 -
 .../core/expression/ModulusExpression.java         |   14 -
 .../core/expression/MultiplyExpression.java        |   14 -
 .../core/expression/NegativeTestExpression.java    |   11 -
 .../core/expression/NotEqualsExpression.java       |   13 -
 .../extension/core/expression/OrExpression.java    |   15 -
 .../core/expression/ParentFunctionExpression.java  |   32 -
 .../core/expression/PositiveTestExpression.java    |   35 -
 .../extension/core/expression/RangeExpression.java |   31 -
 .../core/expression/RenderableNodeExpression.java  |   34 -
 .../core/expression/SubtractExpression.java        |   14 -
 .../core/expression/TernaryExpression.java         |   53 -
 .../core/expression/UnaryMinusExpression.java      |   14 -
 .../core/expression/UnaryNotExpression.java        |   14 -
 .../core/expression/UnaryPlusExpression.java       |   14 -
 .../extension/core/filter/AbbreviateFilter.java    |   50 -
 .../extension/core/filter/AbsFilter.java           |   26 -
 .../extension/core/filter/CapitalizeFilter.java    |   45 -
 .../extension/core/filter/DateFilter.java          |   52 -
 .../extension/core/filter/DefaultFilter.java       |   36 -
 .../extension/core/filter/FirstFilter.java         |   39 -
 .../extension/core/filter/JoinFilter.java          |   55 -
 .../extension/core/filter/LastFilter.java          |   45 -
 .../extension/core/filter/LengthFilter.java        |   52 -
 .../extension/core/filter/LowerFilter.java         |   22 -
 .../extension/core/filter/MergeFilter.java         |  103 --
 .../extension/core/filter/NumberFormatFilter.java  |   46 -
 .../extension/core/filter/ReplaceFilter.java       |   42 -
 .../extension/core/filter/RsortFilter.java         |   28 -
 .../extension/core/filter/SliceFilter.java         |  114 --
 .../extension/core/filter/SortFilter.java          |   25 -
 .../extension/core/filter/TitleFilter.java         |   42 -
 .../extension/core/filter/TrimFilter.java          |   23 -
 .../extension/core/filter/UpperFilter.java         |   22 -
 .../extension/core/filter/UrlEncoderFilter.java    |   28 -
 .../extension/core/function/MaxFunction.java       |   45 -
 .../extension/core/function/MinFunction.java       |   43 -
 .../extension/core/function/RangeFunction.java     |  105 --
 .../extension/core/test/DefinedTest.java           |   18 -
 .../extension/core/test/EmptyTest.java             |   29 -
 .../extension/core/test/EvenTest.java              |   19 -
 .../extension/core/test/IterableTest.java          |   11 -
 .../extension/core/test/MapTest.java               |   13 -
 .../extension/core/test/NullTest.java              |   11 -
 .../extension/core/test/OddTest.java               |   15 -
 .../core/token/AutoEscapeTokenParser.java          |   58 -
 .../extension/core/token/BlockTokenParser.java     |   64 -
 .../extension/core/token/ExtendsTokenParser.java   |   34 -
 .../extension/core/token/FilterTokenParser.java    |   70 --
 .../extension/core/token/FlushTokenParser.java     |   33 -
 .../extension/core/token/ForTokenParser.java       |   58 -
 .../extension/core/token/IfTokenParser.java        |   79 --
 .../extension/core/token/ImportTokenParser.java    |   36 -
 .../extension/core/token/IncludeTokenParser.java   |   56 -
 .../extension/core/token/MacroTokenParser.java     |   47 -
 .../extension/core/token/ParallelTokenParser.java  |   42 -
 .../extension/core/token/SetTokenParser.java       |   39 -
 .../extension/core/token/VerbatimTokenParser.java  |   24 -
 src/expressionLanguage/filter/DefaultFilter.java   |   48 -
 src/expressionLanguage/filter/Filter.java          |    8 -
 src/expressionLanguage/function/Function.java      |   60 -
 src/expressionLanguage/function/RangeFunction.java |  104 --
 src/expressionLanguage/lexer/Lexer.java            |  515 --------
 src/expressionLanguage/lexer/Syntax.java           |  245 ----
 .../model/position/Position.java                   |   27 -
 src/expressionLanguage/model/position/Source.java  |  210 ----
 src/expressionLanguage/model/template/Block.java   |   10 -
 .../model/template/Hierarchy.java                  |   85 --
 .../model/template/Template.java                   |  203 ---
 .../model/tree/ArgumentNode.java                   |   29 -
 .../model/tree/ArgumentsNode.java                  |   80 --
 .../model/tree/AutoEscapeNode.java                 |   42 -
 src/expressionLanguage/model/tree/BlockNode.java   |   58 -
 src/expressionLanguage/model/tree/BodyNode.java    |   63 -
 src/expressionLanguage/model/tree/ExtendsNode.java |   28 -
 src/expressionLanguage/model/tree/FlushNode.java   |   20 -
 src/expressionLanguage/model/tree/ForNode.java     |  214 ----
 .../model/tree/FunctionOrMacroNameNode.java        |   35 -
 src/expressionLanguage/model/tree/IfNode.java      |   74 --
 src/expressionLanguage/model/tree/ImportNode.java  |   29 -
 src/expressionLanguage/model/tree/IncludeNode.java |   44 -
 src/expressionLanguage/model/tree/MacroNode.java   |  120 --
 .../model/tree/NamedArgumentNode.java              |   26 -
 src/expressionLanguage/model/tree/Node.java        |   21 -
 .../model/tree/ParallelNode.java                   |   72 --
 src/expressionLanguage/model/tree/PrintNode.java   |   31 -
 src/expressionLanguage/model/tree/RootNode.java    |   33 -
 src/expressionLanguage/model/tree/SetNode.java     |   31 -
 .../model/tree/TestInvocationExpressionNode.java   |   28 -
 src/expressionLanguage/model/tree/TextNode.java    |   38 -
 .../model/visitor/BlockRegistrantVisitor.java      |   24 -
 .../model/visitor/MacroRegistrantVisitor.java      |   24 -
 .../model/visitor/NodeVisitor.java                 |    9 -
 src/expressionLanguage/operator/Associativity.java |    6 -
 .../operator/BinaryOperator.java                   |   17 -
 src/expressionLanguage/operator/Operator.java      |   33 -
 src/expressionLanguage/operator/OperatorUtils.java |  288 -----
 src/expressionLanguage/operator/UnaryOperator.java |   10 -
 src/expressionLanguage/scope/Scope.java            |   97 --
 src/expressionLanguage/scope/ScopeChain.java       |  190 ---
 src/expressionLanguage/test/Test.java              |    7 -
 src/expressionLanguage/token/Token.java            |   66 -
 src/expressionLanguage/token/TokenStream.java      |  114 --
 src/expressionLanguage/token/Type.java             |   15 -
 src/expressionLanguage/token/parser/Parser.java    |    7 -
 .../token/parser/TokenParser.java                  |   77 --
 .../token/parser/TokenStreamParser.java            |  201 ---
 src/extractor/Extractor.java                       |    7 -
 src/main/java/component/MarkupBuilder.java         |   33 +
 src/main/java/component/Test.java                  |  141 +++
 src/main/java/component/builder/Builder.java       |   42 +
 .../java/component/builder/BuilderInterface.java   |   16 +
 .../java/component/builder/ConditionalBuilder.java |   36 +
 src/main/java/component/builder/StepInterface.java |   12 +
 .../java/component/builder/SteppedBuilder.java     |   74 ++
 .../component/configuration/Configuration.java     |    9 +
 .../configuration/ConfigurationBuilder.java        |    5 +
 src/main/java/component/converter/Converter.java   |   26 +
 .../component/converter/ConverterDelegate.java     |   27 +
 .../component/converter/ConverterResolver.java     |   49 +
 .../converter/support/BigDecimalConverter.java     |   36 +
 .../converter/support/BooleanConverter.java        |   37 +
 .../component/converter/support/ByteConverter.java |   36 +
 .../converter/support/CharacterConverter.java      |   37 +
 .../converter/support/DoubleConverter.java         |   38 +
 .../converter/support/FloatConverter.java          |   40 +
 .../converter/support/IdentityConverter.java       |   22 +
 .../converter/support/IntegerConverter.java        |   40 +
 .../component/converter/support/LongConverter.java |   40 +
 .../converter/support/ObjectConverter.java         |   63 +
 .../converter/support/ShortConverter.java          |   39 +
 .../converter/support/SqlDateConverter.java        |   41 +
 .../converter/support/SqlTimeConverter.java        |   39 +
 .../converter/support/SqlTimestampConverter.java   |   39 +
 .../converter/support/StringConverter.java         |   47 +
 .../java/component/environment/Environment.java    |    5 +
 src/main/java/component/event/Event.java           |   41 +
 .../component/event/dispatcher/Dispatcher.java     |  169 +++
 .../event/dispatcher/DispatcherInterface.java      |   26 +
 .../event/dispatcher/EventDispatcher.java          |   96 ++
 src/main/java/component/event/handler/Handler.java |    9 +
 .../component/event/subscriber/Subscriber.java     |   11 +
 src/main/java/component/event_old/Event.java       |   41 +
 .../java/component/event_old/EventConsumer.java    |    7 +
 .../java/component/event_old/EventDispatcher.java  |   27 +
 .../java/component/event_old/EventSubscriber.java  |   14 +
 .../component/event_old/dispatcher/Dispatcher.java |  104 ++
 .../event_old/dispatcher/DispatcherInterface.java  |   15 +
 .../component/event_old/subscriber/Subscriber.java |   11 +
 .../event_old/subscriber/SubscriberInterface.java  |   10 +
 .../java/component/expressionLanguage/Engine.java  |  225 ++++
 .../expressionLanguage/EvaluationContext.java      |  183 +++
 .../expression/BinaryExpression.java               |   24 +
 .../expressionLanguage/expression/Expression.java  |    9 +
 .../expression/UnaryExpression.java                |   14 +
 .../expression/parser/ExpressionParser.java        |  569 +++++++++
 .../expressionLanguage/extension/Extension.java    |   74 ++
 .../extension/ExtensionRegistry.java               |  169 +++
 .../extension/core/CoreExtension.java              |  155 +++
 .../extension/core/expression/AddExpression.java   |   13 +
 .../extension/core/expression/AndExpression.java   |   15 +
 .../extension/core/expression/ArrayExpression.java |   39 +
 .../core/expression/BlockFunctionExpression.java   |   34 +
 .../core/expression/ConcatenateExpression.java     |   29 +
 .../core/expression/ContainsExpression.java        |  149 +++
 .../core/expression/ContextVariableExpression.java |   30 +
 .../core/expression/DivideExpression.java          |   14 +
 .../core/expression/EqualsExpression.java          |   14 +
 .../core/expression/FilterExpression.java          |   45 +
 .../expression/FilterInvocationExpression.java     |   46 +
 .../FunctionOrMacroInvocationExpression.java       |   55 +
 .../core/expression/GetAttributeExpression.java    |  376 ++++++
 .../expression/GreaterThanEqualsExpression.java    |   14 +
 .../core/expression/GreaterThanExpression.java     |   14 +
 .../core/expression/LessThanEqualsExpression.java  |   14 +
 .../core/expression/LessThanExpression.java        |   14 +
 .../core/expression/LiteralBooleanExpression.java  |   19 +
 .../core/expression/LiteralDoubleExpression.java   |   19 +
 .../core/expression/LiteralLongExpression.java     |   19 +
 .../core/expression/LiteralNullExpression.java     |   16 +
 .../core/expression/LiteralStringExpression.java   |   19 +
 .../extension/core/expression/MapExpression.java   |   41 +
 .../core/expression/ModulusExpression.java         |   14 +
 .../core/expression/MultiplyExpression.java        |   14 +
 .../core/expression/NegativeTestExpression.java    |   11 +
 .../core/expression/NotEqualsExpression.java       |   13 +
 .../extension/core/expression/OrExpression.java    |   15 +
 .../core/expression/ParentFunctionExpression.java  |   32 +
 .../core/expression/PositiveTestExpression.java    |   35 +
 .../extension/core/expression/RangeExpression.java |   31 +
 .../core/expression/RenderableNodeExpression.java  |   34 +
 .../core/expression/SubtractExpression.java        |   14 +
 .../core/expression/TernaryExpression.java         |   53 +
 .../core/expression/UnaryMinusExpression.java      |   14 +
 .../core/expression/UnaryNotExpression.java        |   14 +
 .../core/expression/UnaryPlusExpression.java       |   14 +
 .../extension/core/filter/AbbreviateFilter.java    |   50 +
 .../extension/core/filter/AbsFilter.java           |   26 +
 .../extension/core/filter/CapitalizeFilter.java    |   45 +
 .../extension/core/filter/DateFilter.java          |   52 +
 .../extension/core/filter/DefaultFilter.java       |   36 +
 .../extension/core/filter/FirstFilter.java         |   39 +
 .../extension/core/filter/JoinFilter.java          |   55 +
 .../extension/core/filter/LastFilter.java          |   45 +
 .../extension/core/filter/LengthFilter.java        |   52 +
 .../extension/core/filter/LowerFilter.java         |   22 +
 .../extension/core/filter/MergeFilter.java         |  103 ++
 .../extension/core/filter/NumberFormatFilter.java  |   46 +
 .../extension/core/filter/ReplaceFilter.java       |   42 +
 .../extension/core/filter/RsortFilter.java         |   28 +
 .../extension/core/filter/SliceFilter.java         |  114 ++
 .../extension/core/filter/SortFilter.java          |   25 +
 .../extension/core/filter/TitleFilter.java         |   42 +
 .../extension/core/filter/TrimFilter.java          |   23 +
 .../extension/core/filter/UpperFilter.java         |   22 +
 .../extension/core/filter/UrlEncoderFilter.java    |   28 +
 .../extension/core/function/MaxFunction.java       |   45 +
 .../extension/core/function/MinFunction.java       |   43 +
 .../extension/core/function/RangeFunction.java     |  105 ++
 .../extension/core/test/DefinedTest.java           |   18 +
 .../extension/core/test/EmptyTest.java             |   29 +
 .../extension/core/test/EvenTest.java              |   19 +
 .../extension/core/test/IterableTest.java          |   11 +
 .../extension/core/test/MapTest.java               |   13 +
 .../extension/core/test/NullTest.java              |   11 +
 .../extension/core/test/OddTest.java               |   15 +
 .../core/token/AutoEscapeTokenParser.java          |   58 +
 .../extension/core/token/BlockTokenParser.java     |   64 +
 .../extension/core/token/ExtendsTokenParser.java   |   34 +
 .../extension/core/token/FilterTokenParser.java    |   70 ++
 .../extension/core/token/FlushTokenParser.java     |   33 +
 .../extension/core/token/ForTokenParser.java       |   58 +
 .../extension/core/token/IfTokenParser.java        |   79 ++
 .../extension/core/token/ImportTokenParser.java    |   36 +
 .../extension/core/token/IncludeTokenParser.java   |   56 +
 .../extension/core/token/MacroTokenParser.java     |   47 +
 .../extension/core/token/ParallelTokenParser.java  |   42 +
 .../extension/core/token/SetTokenParser.java       |   39 +
 .../extension/core/token/VerbatimTokenParser.java  |   24 +
 .../expressionLanguage/filter/DefaultFilter.java   |   48 +
 .../expressionLanguage/filter/Filter.java          |    8 +
 .../expressionLanguage/function/Function.java      |   60 +
 .../expressionLanguage/function/RangeFunction.java |  104 ++
 .../component/expressionLanguage/lexer/Lexer.java  |  515 ++++++++
 .../component/expressionLanguage/lexer/Syntax.java |  245 ++++
 .../model/position/Position.java                   |   27 +
 .../expressionLanguage/model/position/Source.java  |  210 ++++
 .../expressionLanguage/model/template/Block.java   |   10 +
 .../model/template/Hierarchy.java                  |   85 ++
 .../model/template/Template.java                   |  203 +++
 .../model/tree/ArgumentNode.java                   |   29 +
 .../model/tree/ArgumentsNode.java                  |   80 ++
 .../model/tree/AutoEscapeNode.java                 |   42 +
 .../expressionLanguage/model/tree/BlockNode.java   |   58 +
 .../expressionLanguage/model/tree/BodyNode.java    |   63 +
 .../expressionLanguage/model/tree/ExtendsNode.java |   28 +
 .../expressionLanguage/model/tree/FlushNode.java   |   20 +
 .../expressionLanguage/model/tree/ForNode.java     |  214 ++++
 .../model/tree/FunctionOrMacroNameNode.java        |   35 +
 .../expressionLanguage/model/tree/IfNode.java      |   74 ++
 .../expressionLanguage/model/tree/ImportNode.java  |   29 +
 .../expressionLanguage/model/tree/IncludeNode.java |   44 +
 .../expressionLanguage/model/tree/MacroNode.java   |  120 ++
 .../model/tree/NamedArgumentNode.java              |   26 +
 .../expressionLanguage/model/tree/Node.java        |   21 +
 .../model/tree/ParallelNode.java                   |   72 ++
 .../expressionLanguage/model/tree/PrintNode.java   |   31 +
 .../expressionLanguage/model/tree/RootNode.java    |   33 +
 .../expressionLanguage/model/tree/SetNode.java     |   31 +
 .../model/tree/TestInvocationExpressionNode.java   |   28 +
 .../expressionLanguage/model/tree/TextNode.java    |   38 +
 .../model/visitor/BlockRegistrantVisitor.java      |   24 +
 .../model/visitor/MacroRegistrantVisitor.java      |   24 +
 .../model/visitor/NodeVisitor.java                 |    9 +
 .../expressionLanguage/operator/Associativity.java |    6 +
 .../operator/BinaryOperator.java                   |   17 +
 .../expressionLanguage/operator/Operator.java      |   33 +
 .../expressionLanguage/operator/OperatorUtils.java |  288 +++++
 .../expressionLanguage/operator/UnaryOperator.java |   10 +
 .../component/expressionLanguage/scope/Scope.java  |   97 ++
 .../expressionLanguage/scope/ScopeChain.java       |  190 +++
 .../component/expressionLanguage/test/Test.java    |    7 +
 .../component/expressionLanguage/token/Token.java  |   66 +
 .../expressionLanguage/token/TokenStream.java      |  114 ++
 .../component/expressionLanguage/token/Type.java   |   15 +
 .../expressionLanguage/token/parser/Parser.java    |    7 +
 .../token/parser/TokenParser.java                  |   77 ++
 .../token/parser/TokenStreamParser.java            |  201 +++
 src/main/java/component/extractor/Extractor.java   |    7 +
 src/main/java/component/node/Node.java             |  200 +++
 src/main/java/component/node/NodeFactory.java      |    5 +
 .../java/component/node/builder/NodeBuilder.java   |   63 +
 .../node/builder/NodeBuilderInterface.java         |   92 ++
 src/main/java/component/node/legacy/ArrayNode.java |  228 ++++
 .../java/component/node/legacy/BooleanNode.java    |    9 +
 src/main/java/component/node/legacy/EnumNode.java  |   16 +
 src/main/java/component/node/legacy/FloatNode.java |   13 +
 .../java/component/node/legacy/IntegerNode.java    |   13 +
 src/main/java/component/node/legacy/Node.java      |  219 ++++
 .../java/component/node/legacy/NumericNode.java    |   13 +
 .../component/node/legacy/PrototypedArrayNode.java |   18 +
 .../java/component/node/legacy/ScalarNode.java     |   13 +
 .../java/component/node/legacy/VariableNode.java   |   74 ++
 .../node/normalization/NodeNormalizer.java         |   12 +
 .../node/normalization/NodeValueNormalization.java |   33 +
 .../java/component/normalizer/Normalization.java   |   11 +
 src/main/java/component/normalizer/Normalizer.java |   45 +
 .../component/normalizer/NormalizerInterface.java  |    7 +
 src/main/java/component/others/Command.java        |   18 +
 src/main/java/component/others/Rule.java           |   70 ++
 src/main/java/component/others/Sequence.java       |  193 +++
 src/main/java/component/resolver/PathResolver.java |   51 +
 src/main/java/component/resolver/Resolver.java     |    9 +
 .../java/component/resolver/ResolverDelegate.java  |   47 +
 src/main/java/component/resource/FileSystem.java   |   43 +
 .../java/component/resource/ResourceService.java   |  107 ++
 .../resource/exceptions/ResourceException.java     |   16 +
 .../exceptions/ResourceNotFoundException.java      |   11 +
 .../component/resource/extractor/Extractor.java    |    7 +
 .../resource/loader/ClasspathResourceLoader.java   |   62 +
 .../resource/loader/FileResourceLoader.java        |   63 +
 .../resource/loader/InMemoryResourceLoader.java    |   61 +
 .../component/resource/loader/ResourceLoader.java  |   21 +
 .../resource/loader/ResourceLoaderDelegate.java    |   71 ++
 .../resource/loader/StringResourceLoader.java      |   20 +
 .../resource/loader/TypedResourceLoader.java       |   14 +
 .../resource/metatada/ResourceMetadata.java        |   13 +
 .../metatada/ResourceReferenceMetadata.java        |   43 +
 .../reference/PosixResourceReferenceExtractor.java |   18 +
 .../resource/reference/ResourceReference.java      |   71 ++
 .../reference/ResourceReferenceExtractor.java      |   36 +
 .../reference/UncResourceReferenceExtractor.java   |   25 +
 .../resource/reference/path/PathType.java          |    5 +
 .../resource/reference/path/PathTypeSupplier.java  |   16 +
 src/main/java/component/templating/Context.java    |   71 ++
 src/main/java/component/templating/Engine.java     |  170 +++
 .../java/component/templating/Environment.java     |   73 ++
 src/main/java/component/templating/Position.java   |   27 +
 src/main/java/component/templating/Renderer.java   |    8 +
 src/main/java/component/templating/Source.java     |  231 ++++
 src/main/java/component/templating/Template.java   |   94 ++
 .../templating/expression/Expression.java          |  120 ++
 .../component/templating/extention/Extension.java  |   36 +
 .../component/templating/extention/Filter.java     |    9 +
 .../component/templating/extention/Function.java   |    9 +
 .../java/component/templating/extention/Test.java  |    9 +
 .../templating/extention/core/CoreExtension.java   |  167 +++
 .../java/component/templating/node/BodyNode.java   |    5 +
 .../component/templating/node/ExecuteNode.java     |   16 +
 .../component/templating/node/ExpressionNode.java  |   25 +
 src/main/java/component/templating/node/Node.java  |    7 +
 .../java/component/templating/node/NodeParser.java |   65 +
 .../component/templating/node/NodeVisitor.java     |    7 +
 .../java/component/templating/node/PrintNode.java  |   16 +
 .../java/component/templating/node/TextNode.java   |   16 +
 .../java/component/templating/token/Token.java     |   73 ++
 .../component/templating/token/TokenParser.java    |  193 +++
 .../component/templating/token/TokenParsers.java   |   35 +
 .../component/templating/token/TokenStream.java    |  115 ++
 .../component/templating/token/TokenVisitor.java   |    5 +
 .../java/component/templating/token/Tokenizer.java |   40 +
 src/main/java/component/util/Assert.java           |  405 ++++++
 src/main/java/component/util/ClassUtils.java       | 1313 ++++++++++++++++++++
 src/main/java/component/util/CollectionUtils.java  |  367 ++++++
 src/main/java/component/util/ObjectUtils.java      | 1013 +++++++++++++++
 src/main/java/component/util/PathUtils.java        |   92 ++
 src/main/java/component/util/ReflectionUtils.java  |  877 +++++++++++++
 src/main/java/component/util/ResourceUtils.java    |  432 +++++++
 src/main/java/component/util/StringUtils.java      | 1304 +++++++++++++++++++
 src/main/java/component/utils/Assert.java          |  405 ++++++
 src/main/java/component/utils/ClassUtils.java      | 1313 ++++++++++++++++++++
 src/main/java/component/utils/CollectionUtils.java |  367 ++++++
 src/main/java/component/utils/ObjectUtils.java     | 1013 +++++++++++++++
 src/main/java/component/utils/PathUtils.java       |   92 ++
 src/main/java/component/utils/ReflectionUtils.java |  877 +++++++++++++
 src/main/java/component/utils/ResourceUtils.java   |  432 +++++++
 src/main/java/component/utils/StringUtils.java     | 1304 +++++++++++++++++++
 src/main/java/demo/event/EventDemo.java            |  172 +++
 src/main/java/demo/event/crud/CRUDEvent.java       |   20 +
 src/main/java/demo/event/crud/CreateEvent.java     |    9 +
 src/main/java/demo/event/crud/UpdateEvent.java     |    9 +
 .../java/demo/event/event/UserCreatedEvent.java    |   12 +
 .../java/demo/event/event/UserUpdatedEvent.java    |   12 +
 src/main/java/demo/event/model/Role.java           |   19 +
 src/main/java/demo/event/model/User.java           |   20 +
 .../expressionLanguage/ExpressionLanguageDemo.java |   79 ++
 src/main/java/demo/expressionLanguage/demo         |    9 +
 src/main/java/demo/resolver/ResolverDemo.java      |  118 ++
 src/main/java/demo/resource/FileUtils.java         |   39 +
 src/main/java/demo/resource/ResourceDemo.java      |   58 +
 src/main/java/demo/resource/ResourceDemo2.java     |   40 +
 src/main/java/demo/resource/ResourceUtils.java     |   21 +
 src/main/java/demo/resource/demo                   |    1 +
 src/main/java/demo/resource/demo_1.txt             |    1 +
 src/main/java/demo/resource/demo_classpath         |    1 +
 src/main/java/demo/resource/demo_file              |    1 +
 src/main/java/demo/templating/TemplatingDemo.java  |  227 ++++
 .../java/demo/templating_old/TemplatingDemo.java   |   17 +
 src/main/java/demo/templating_old/demo.view        |    1 +
 src/main/resources/demo/templating/demo.view       |   40 +
 src/main/resources/demo/templating/demo_1.view     |   42 +
 src/node/Node.java                                 |  200 ---
 src/node/NodeFactory.java                          |    5 -
 src/node/builder/NodeBuilder.java                  |   63 -
 src/node/builder/NodeBuilderInterface.java         |   92 --
 src/node/legacy/ArrayNode.java                     |  228 ----
 src/node/legacy/BooleanNode.java                   |    9 -
 src/node/legacy/EnumNode.java                      |   16 -
 src/node/legacy/FloatNode.java                     |   13 -
 src/node/legacy/IntegerNode.java                   |   13 -
 src/node/legacy/Node.java                          |  219 ----
 src/node/legacy/NumericNode.java                   |   13 -
 src/node/legacy/PrototypedArrayNode.java           |   18 -
 src/node/legacy/ScalarNode.java                    |   13 -
 src/node/legacy/VariableNode.java                  |   74 --
 src/node/normalization/NodeNormalizer.java         |   12 -
 src/node/normalization/NodeValueNormalization.java |   33 -
 src/normalizer/Normalization.java                  |   11 -
 src/normalizer/Normalizer.java                     |   45 -
 src/normalizer/NormalizerInterface.java            |    7 -
 src/others/Command.java                            |   18 -
 src/others/Rule.java                               |   70 --
 src/others/Sequence.java                           |  193 ---
 src/resolver/PathResolver.java                     |   51 -
 src/resolver/Resolver.java                         |    9 -
 src/resolver/ResolverDelegate.java                 |   47 -
 src/resource/FileSystem.java                       |   43 -
 src/resource/ResourceService.java                  |   90 --
 src/resource/exceptions/ResourceException.java     |   16 -
 .../exceptions/ResourceNotFoundException.java      |   11 -
 src/resource/loader/ClasspathResourceLoader.java   |   56 -
 src/resource/loader/FileResourceLoader.java        |   59 -
 src/resource/loader/InMemoryResourceLoader.java    |   61 -
 src/resource/loader/ResourceLoader.java            |   21 -
 src/resource/loader/ResourceLoaderDelegate.java    |   65 -
 src/resource/loader/StringResourceLoader.java      |   20 -
 src/resource/loader/TypedResourceLoader.java       |   14 -
 src/resource/metatada/ResourceMetadata.java        |   13 -
 .../metatada/ResourceReferenceMetadata.java        |   43 -
 .../reference/PosixResourceReferenceExtractor.java |   18 -
 src/resource/reference/ResourceReference.java      |   71 --
 .../reference/ResourceReferenceExtractor.java      |   34 -
 .../reference/UncResourceReferenceExtractor.java   |   25 -
 src/resource/reference/path/PathType.java          |    5 -
 src/resource/reference/path/PathTypeSupplier.java  |   16 -
 src/templating/Context.java                        |   71 --
 src/templating/Engine.java                         |  163 ---
 src/templating/Environment.java                    |   74 --
 src/templating/Position.java                       |   27 -
 src/templating/Renderer.java                       |    8 -
 src/templating/Source.java                         |  231 ----
 src/templating/Template.java                       |   94 --
 src/templating/expression/Expression.java          |  120 --
 src/templating/extention/Extension.java            |   36 -
 src/templating/extention/Filter.java               |    9 -
 src/templating/extention/Function.java             |    9 -
 src/templating/extention/Test.java                 |    9 -
 src/templating/extention/core/CoreExtension.java   |  167 ---
 src/templating/node/BodyNode.java                  |    5 -
 src/templating/node/ExecuteNode.java               |   14 -
 src/templating/node/ExpressionNode.java            |   20 -
 src/templating/node/Node.java                      |    8 -
 src/templating/node/NodeParser.java                |   64 -
 src/templating/node/NodeVisitor.java               |    7 -
 src/templating/node/PrintNode.java                 |   14 -
 src/templating/node/TextNode.java                  |   15 -
 src/templating/token/Token.java                    |   73 --
 src/templating/token/TokenParser.java              |  193 ---
 src/templating/token/TokenParsers.java             |   35 -
 src/templating/token/TokenStream.java              |  115 --
 src/templating/token/TokenVisitor.java             |    5 -
 src/templating/token/Tokenizer.java                |   40 -
 src/test/resolver/ResolverDelegateTest.java        |  101 ++
 src/util/Assert.java                               |  405 ------
 src/util/ClassUtils.java                           | 1313 --------------------
 src/util/CollectionUtils.java                      |  367 ------
 src/util/ObjectUtils.java                          | 1013 ---------------
 src/util/PathUtils.java                            |   92 --
 src/util/ReflectionUtils.java                      |  877 -------------
 src/util/ResourceUtils.java                        |  432 -------
 src/util/StringUtils.java                          | 1304 -------------------
 src/utils/Assert.java                              |  405 ------
 src/utils/ClassUtils.java                          | 1313 --------------------
 src/utils/CollectionUtils.java                     |  367 ------
 src/utils/ObjectUtils.java                         | 1013 ---------------
 src/utils/PathUtils.java                           |   92 --
 src/utils/ReflectionUtils.java                     |  877 -------------
 src/utils/ResourceUtils.java                       |  432 -------
 src/utils/StringUtils.java                         | 1304 -------------------
 test/resolver/ResolverDelegateTest.java            |  101 --
 589 files changed, 26624 insertions(+), 26519 deletions(-)
 delete mode 100644 demo/event/EventDemo.java
 delete mode 100644 demo/event/crud/CRUDEvent.java
 delete mode 100644 demo/event/crud/CreateEvent.java
 delete mode 100644 demo/event/crud/UpdateEvent.java
 delete mode 100644 demo/event/event/UserCreatedEvent.java
 delete mode 100644 demo/event/event/UserUpdatedEvent.java
 delete mode 100644 demo/event/model/Role.java
 delete mode 100644 demo/event/model/User.java
 delete mode 100644 demo/expressionLanguage/ExpressionLanguageDemo.java
 delete mode 100644 demo/expressionLanguage/demo
 delete mode 100644 demo/resolver/ResolverDemo.java
 delete mode 100644 demo/resource/FileUtils.java
 delete mode 100644 demo/resource/ResourceDemo.java
 delete mode 100644 demo/resource/ResourceDemo2.java
 delete mode 100644 demo/resource/ResourceUtils.java
 delete mode 100644 demo/resource/demo
 delete mode 100644 demo/resource/demo_1.txt
 delete mode 100644 demo/resource/demo_classpath
 delete mode 100644 demo/resource/demo_file
 delete mode 100644 demo/templating/TemplatingDemo.java
 delete mode 100644 demo/templating/demo.view
 delete mode 100644 demo/templating/demo_1.view
 delete mode 100644 demo/templating_old/TemplatingDemo.java
 delete mode 100644 demo/templating_old/demo.view
 create mode 100644 pom.xml
 delete mode 100644 src/MarkupBuilder.java
 delete mode 100644 src/Test.java
 delete mode 100644 src/builder/Builder.java
 delete mode 100644 src/builder/BuilderInterface.java
 delete mode 100644 src/builder/ConditionalBuilder.java
 delete mode 100644 src/builder/StepInterface.java
 delete mode 100644 src/builder/SteppedBuilder.java
 delete mode 100644 src/configuration/Configuration.java
 delete mode 100644 src/configuration/ConfigurationBuilder.java
 delete mode 100644 src/converter/Converter.java
 delete mode 100644 src/converter/ConverterDelegate.java
 delete mode 100644 src/converter/ConverterResolver.java
 delete mode 100644 src/converter/support/BigDecimalConverter.java
 delete mode 100644 src/converter/support/BooleanConverter.java
 delete mode 100644 src/converter/support/ByteConverter.java
 delete mode 100644 src/converter/support/CharacterConverter.java
 delete mode 100644 src/converter/support/DoubleConverter.java
 delete mode 100644 src/converter/support/FloatConverter.java
 delete mode 100644 src/converter/support/IdentityConverter.java
 delete mode 100644 src/converter/support/IntegerConverter.java
 delete mode 100644 src/converter/support/LongConverter.java
 delete mode 100644 src/converter/support/ObjectConverter.java
 delete mode 100644 src/converter/support/ShortConverter.java
 delete mode 100644 src/converter/support/SqlDateConverter.java
 delete mode 100644 src/converter/support/SqlTimeConverter.java
 delete mode 100644 src/converter/support/SqlTimestampConverter.java
 delete mode 100644 src/converter/support/StringConverter.java
 delete mode 100644 src/environment/Environment.java
 delete mode 100644 src/event/Event.java
 delete mode 100644 src/event/dispatcher/Dispatcher.java
 delete mode 100644 src/event/dispatcher/DispatcherInterface.java
 delete mode 100644 src/event/dispatcher/EventDispatcher.java
 delete mode 100644 src/event/handler/Handler.java
 delete mode 100644 src/event/subscriber/Subscriber.java
 delete mode 100644 src/event_old/Event.java
 delete mode 100644 src/event_old/EventConsumer.java
 delete mode 100644 src/event_old/EventDispatcher.java
 delete mode 100644 src/event_old/EventSubscriber.java
 delete mode 100644 src/event_old/dispatcher/Dispatcher.java
 delete mode 100644 src/event_old/dispatcher/DispatcherInterface.java
 delete mode 100644 src/event_old/subscriber/Subscriber.java
 delete mode 100644 src/event_old/subscriber/SubscriberInterface.java
 delete mode 100644 src/expressionLanguage/Engine.java
 delete mode 100644 src/expressionLanguage/EvaluationContext.java
 delete mode 100644 src/expressionLanguage/expression/BinaryExpression.java
 delete mode 100644 src/expressionLanguage/expression/Expression.java
 delete mode 100644 src/expressionLanguage/expression/UnaryExpression.java
 delete mode 100644 src/expressionLanguage/expression/parser/ExpressionParser.java
 delete mode 100644 src/expressionLanguage/extension/Extension.java
 delete mode 100644 src/expressionLanguage/extension/ExtensionRegistry.java
 delete mode 100644 src/expressionLanguage/extension/core/CoreExtension.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/AddExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/AndExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/ArrayExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/BlockFunctionExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/ConcatenateExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/ContainsExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/ContextVariableExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/DivideExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/EqualsExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/FilterExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/FilterInvocationExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/FunctionOrMacroInvocationExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/GetAttributeExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/GreaterThanEqualsExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/GreaterThanExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/LessThanEqualsExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/LessThanExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/LiteralBooleanExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/LiteralDoubleExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/LiteralLongExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/LiteralNullExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/LiteralStringExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/MapExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/ModulusExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/MultiplyExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/NegativeTestExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/NotEqualsExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/OrExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/ParentFunctionExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/PositiveTestExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/RangeExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/RenderableNodeExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/SubtractExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/TernaryExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/UnaryMinusExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/UnaryNotExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/expression/UnaryPlusExpression.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/AbbreviateFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/AbsFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/CapitalizeFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/DateFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/DefaultFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/FirstFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/JoinFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/LastFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/LengthFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/LowerFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/MergeFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/NumberFormatFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/ReplaceFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/RsortFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/SliceFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/SortFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/TitleFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/TrimFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/UpperFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/filter/UrlEncoderFilter.java
 delete mode 100644 src/expressionLanguage/extension/core/function/MaxFunction.java
 delete mode 100644 src/expressionLanguage/extension/core/function/MinFunction.java
 delete mode 100644 src/expressionLanguage/extension/core/function/RangeFunction.java
 delete mode 100644 src/expressionLanguage/extension/core/test/DefinedTest.java
 delete mode 100644 src/expressionLanguage/extension/core/test/EmptyTest.java
 delete mode 100644 src/expressionLanguage/extension/core/test/EvenTest.java
 delete mode 100644 src/expressionLanguage/extension/core/test/IterableTest.java
 delete mode 100644 src/expressionLanguage/extension/core/test/MapTest.java
 delete mode 100644 src/expressionLanguage/extension/core/test/NullTest.java
 delete mode 100644 src/expressionLanguage/extension/core/test/OddTest.java
 delete mode 100644 src/expressionLanguage/extension/core/token/AutoEscapeTokenParser.java
 delete mode 100644 src/expressionLanguage/extension/core/token/BlockTokenParser.java
 delete mode 100644 src/expressionLanguage/extension/core/token/ExtendsTokenParser.java
 delete mode 100644 src/expressionLanguage/extension/core/token/FilterTokenParser.java
 delete mode 100644 src/expressionLanguage/extension/core/token/FlushTokenParser.java
 delete mode 100644 src/expressionLanguage/extension/core/token/ForTokenParser.java
 delete mode 100644 src/expressionLanguage/extension/core/token/IfTokenParser.java
 delete mode 100644 src/expressionLanguage/extension/core/token/ImportTokenParser.java
 delete mode 100644 src/expressionLanguage/extension/core/token/IncludeTokenParser.java
 delete mode 100644 src/expressionLanguage/extension/core/token/MacroTokenParser.java
 delete mode 100644 src/expressionLanguage/extension/core/token/ParallelTokenParser.java
 delete mode 100644 src/expressionLanguage/extension/core/token/SetTokenParser.java
 delete mode 100644 src/expressionLanguage/extension/core/token/VerbatimTokenParser.java
 delete mode 100644 src/expressionLanguage/filter/DefaultFilter.java
 delete mode 100644 src/expressionLanguage/filter/Filter.java
 delete mode 100644 src/expressionLanguage/function/Function.java
 delete mode 100644 src/expressionLanguage/function/RangeFunction.java
 delete mode 100644 src/expressionLanguage/lexer/Lexer.java
 delete mode 100644 src/expressionLanguage/lexer/Syntax.java
 delete mode 100644 src/expressionLanguage/model/position/Position.java
 delete mode 100644 src/expressionLanguage/model/position/Source.java
 delete mode 100644 src/expressionLanguage/model/template/Block.java
 delete mode 100644 src/expressionLanguage/model/template/Hierarchy.java
 delete mode 100644 src/expressionLanguage/model/template/Template.java
 delete mode 100644 src/expressionLanguage/model/tree/ArgumentNode.java
 delete mode 100644 src/expressionLanguage/model/tree/ArgumentsNode.java
 delete mode 100644 src/expressionLanguage/model/tree/AutoEscapeNode.java
 delete mode 100644 src/expressionLanguage/model/tree/BlockNode.java
 delete mode 100644 src/expressionLanguage/model/tree/BodyNode.java
 delete mode 100644 src/expressionLanguage/model/tree/ExtendsNode.java
 delete mode 100644 src/expressionLanguage/model/tree/FlushNode.java
 delete mode 100644 src/expressionLanguage/model/tree/ForNode.java
 delete mode 100644 src/expressionLanguage/model/tree/FunctionOrMacroNameNode.java
 delete mode 100644 src/expressionLanguage/model/tree/IfNode.java
 delete mode 100644 src/expressionLanguage/model/tree/ImportNode.java
 delete mode 100644 src/expressionLanguage/model/tree/IncludeNode.java
 delete mode 100644 src/expressionLanguage/model/tree/MacroNode.java
 delete mode 100644 src/expressionLanguage/model/tree/NamedArgumentNode.java
 delete mode 100644 src/expressionLanguage/model/tree/Node.java
 delete mode 100644 src/expressionLanguage/model/tree/ParallelNode.java
 delete mode 100644 src/expressionLanguage/model/tree/PrintNode.java
 delete mode 100644 src/expressionLanguage/model/tree/RootNode.java
 delete mode 100644 src/expressionLanguage/model/tree/SetNode.java
 delete mode 100644 src/expressionLanguage/model/tree/TestInvocationExpressionNode.java
 delete mode 100644 src/expressionLanguage/model/tree/TextNode.java
 delete mode 100644 src/expressionLanguage/model/visitor/BlockRegistrantVisitor.java
 delete mode 100644 src/expressionLanguage/model/visitor/MacroRegistrantVisitor.java
 delete mode 100644 src/expressionLanguage/model/visitor/NodeVisitor.java
 delete mode 100644 src/expressionLanguage/operator/Associativity.java
 delete mode 100644 src/expressionLanguage/operator/BinaryOperator.java
 delete mode 100644 src/expressionLanguage/operator/Operator.java
 delete mode 100644 src/expressionLanguage/operator/OperatorUtils.java
 delete mode 100644 src/expressionLanguage/operator/UnaryOperator.java
 delete mode 100644 src/expressionLanguage/scope/Scope.java
 delete mode 100644 src/expressionLanguage/scope/ScopeChain.java
 delete mode 100644 src/expressionLanguage/test/Test.java
 delete mode 100644 src/expressionLanguage/token/Token.java
 delete mode 100644 src/expressionLanguage/token/TokenStream.java
 delete mode 100644 src/expressionLanguage/token/Type.java
 delete mode 100644 src/expressionLanguage/token/parser/Parser.java
 delete mode 100644 src/expressionLanguage/token/parser/TokenParser.java
 delete mode 100644 src/expressionLanguage/token/parser/TokenStreamParser.java
 delete mode 100644 src/extractor/Extractor.java
 create mode 100644 src/main/java/component/MarkupBuilder.java
 create mode 100644 src/main/java/component/Test.java
 create mode 100644 src/main/java/component/builder/Builder.java
 create mode 100644 src/main/java/component/builder/BuilderInterface.java
 create mode 100644 src/main/java/component/builder/ConditionalBuilder.java
 create mode 100644 src/main/java/component/builder/StepInterface.java
 create mode 100644 src/main/java/component/builder/SteppedBuilder.java
 create mode 100644 src/main/java/component/configuration/Configuration.java
 create mode 100644 src/main/java/component/configuration/ConfigurationBuilder.java
 create mode 100644 src/main/java/component/converter/Converter.java
 create mode 100644 src/main/java/component/converter/ConverterDelegate.java
 create mode 100644 src/main/java/component/converter/ConverterResolver.java
 create mode 100644 src/main/java/component/converter/support/BigDecimalConverter.java
 create mode 100644 src/main/java/component/converter/support/BooleanConverter.java
 create mode 100644 src/main/java/component/converter/support/ByteConverter.java
 create mode 100644 src/main/java/component/converter/support/CharacterConverter.java
 create mode 100644 src/main/java/component/converter/support/DoubleConverter.java
 create mode 100644 src/main/java/component/converter/support/FloatConverter.java
 create mode 100644 src/main/java/component/converter/support/IdentityConverter.java
 create mode 100644 src/main/java/component/converter/support/IntegerConverter.java
 create mode 100644 src/main/java/component/converter/support/LongConverter.java
 create mode 100644 src/main/java/component/converter/support/ObjectConverter.java
 create mode 100644 src/main/java/component/converter/support/ShortConverter.java
 create mode 100644 src/main/java/component/converter/support/SqlDateConverter.java
 create mode 100644 src/main/java/component/converter/support/SqlTimeConverter.java
 create mode 100644 src/main/java/component/converter/support/SqlTimestampConverter.java
 create mode 100644 src/main/java/component/converter/support/StringConverter.java
 create mode 100644 src/main/java/component/environment/Environment.java
 create mode 100644 src/main/java/component/event/Event.java
 create mode 100644 src/main/java/component/event/dispatcher/Dispatcher.java
 create mode 100644 src/main/java/component/event/dispatcher/DispatcherInterface.java
 create mode 100644 src/main/java/component/event/dispatcher/EventDispatcher.java
 create mode 100644 src/main/java/component/event/handler/Handler.java
 create mode 100644 src/main/java/component/event/subscriber/Subscriber.java
 create mode 100644 src/main/java/component/event_old/Event.java
 create mode 100644 src/main/java/component/event_old/EventConsumer.java
 create mode 100644 src/main/java/component/event_old/EventDispatcher.java
 create mode 100644 src/main/java/component/event_old/EventSubscriber.java
 create mode 100644 src/main/java/component/event_old/dispatcher/Dispatcher.java
 create mode 100644 src/main/java/component/event_old/dispatcher/DispatcherInterface.java
 create mode 100644 src/main/java/component/event_old/subscriber/Subscriber.java
 create mode 100644 src/main/java/component/event_old/subscriber/SubscriberInterface.java
 create mode 100644 src/main/java/component/expressionLanguage/Engine.java
 create mode 100644 src/main/java/component/expressionLanguage/EvaluationContext.java
 create mode 100644 src/main/java/component/expressionLanguage/expression/BinaryExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/expression/Expression.java
 create mode 100644 src/main/java/component/expressionLanguage/expression/UnaryExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/expression/parser/ExpressionParser.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/Extension.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/ExtensionRegistry.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/CoreExtension.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/AddExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/AndExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/ArrayExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/BlockFunctionExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/ConcatenateExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/ContainsExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/ContextVariableExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/DivideExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/EqualsExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/FilterExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/FilterInvocationExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/FunctionOrMacroInvocationExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/GetAttributeExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/GreaterThanEqualsExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/GreaterThanExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/LessThanEqualsExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/LessThanExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/LiteralBooleanExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/LiteralDoubleExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/LiteralLongExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/LiteralNullExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/LiteralStringExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/MapExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/ModulusExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/MultiplyExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/NegativeTestExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/NotEqualsExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/OrExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/ParentFunctionExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/PositiveTestExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/RangeExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/RenderableNodeExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/SubtractExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/TernaryExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/UnaryMinusExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/UnaryNotExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/expression/UnaryPlusExpression.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/AbbreviateFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/AbsFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/CapitalizeFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/DateFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/DefaultFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/FirstFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/JoinFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/LastFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/LengthFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/LowerFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/MergeFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/NumberFormatFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/ReplaceFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/RsortFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/SliceFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/SortFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/TitleFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/TrimFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/UpperFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/filter/UrlEncoderFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/function/MaxFunction.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/function/MinFunction.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/function/RangeFunction.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/test/DefinedTest.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/test/EmptyTest.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/test/EvenTest.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/test/IterableTest.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/test/MapTest.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/test/NullTest.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/test/OddTest.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/token/AutoEscapeTokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/token/BlockTokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/token/ExtendsTokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/token/FilterTokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/token/FlushTokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/token/ForTokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/token/IfTokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/token/ImportTokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/token/IncludeTokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/token/MacroTokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/token/ParallelTokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/token/SetTokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/extension/core/token/VerbatimTokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/filter/DefaultFilter.java
 create mode 100644 src/main/java/component/expressionLanguage/filter/Filter.java
 create mode 100644 src/main/java/component/expressionLanguage/function/Function.java
 create mode 100644 src/main/java/component/expressionLanguage/function/RangeFunction.java
 create mode 100644 src/main/java/component/expressionLanguage/lexer/Lexer.java
 create mode 100644 src/main/java/component/expressionLanguage/lexer/Syntax.java
 create mode 100644 src/main/java/component/expressionLanguage/model/position/Position.java
 create mode 100644 src/main/java/component/expressionLanguage/model/position/Source.java
 create mode 100644 src/main/java/component/expressionLanguage/model/template/Block.java
 create mode 100644 src/main/java/component/expressionLanguage/model/template/Hierarchy.java
 create mode 100644 src/main/java/component/expressionLanguage/model/template/Template.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/ArgumentNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/ArgumentsNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/AutoEscapeNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/BlockNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/BodyNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/ExtendsNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/FlushNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/ForNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/FunctionOrMacroNameNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/IfNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/ImportNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/IncludeNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/MacroNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/NamedArgumentNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/Node.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/ParallelNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/PrintNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/RootNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/SetNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/TestInvocationExpressionNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/tree/TextNode.java
 create mode 100644 src/main/java/component/expressionLanguage/model/visitor/BlockRegistrantVisitor.java
 create mode 100644 src/main/java/component/expressionLanguage/model/visitor/MacroRegistrantVisitor.java
 create mode 100644 src/main/java/component/expressionLanguage/model/visitor/NodeVisitor.java
 create mode 100644 src/main/java/component/expressionLanguage/operator/Associativity.java
 create mode 100644 src/main/java/component/expressionLanguage/operator/BinaryOperator.java
 create mode 100644 src/main/java/component/expressionLanguage/operator/Operator.java
 create mode 100644 src/main/java/component/expressionLanguage/operator/OperatorUtils.java
 create mode 100644 src/main/java/component/expressionLanguage/operator/UnaryOperator.java
 create mode 100644 src/main/java/component/expressionLanguage/scope/Scope.java
 create mode 100644 src/main/java/component/expressionLanguage/scope/ScopeChain.java
 create mode 100644 src/main/java/component/expressionLanguage/test/Test.java
 create mode 100644 src/main/java/component/expressionLanguage/token/Token.java
 create mode 100644 src/main/java/component/expressionLanguage/token/TokenStream.java
 create mode 100644 src/main/java/component/expressionLanguage/token/Type.java
 create mode 100644 src/main/java/component/expressionLanguage/token/parser/Parser.java
 create mode 100644 src/main/java/component/expressionLanguage/token/parser/TokenParser.java
 create mode 100644 src/main/java/component/expressionLanguage/token/parser/TokenStreamParser.java
 create mode 100644 src/main/java/component/extractor/Extractor.java
 create mode 100644 src/main/java/component/node/Node.java
 create mode 100644 src/main/java/component/node/NodeFactory.java
 create mode 100644 src/main/java/component/node/builder/NodeBuilder.java
 create mode 100644 src/main/java/component/node/builder/NodeBuilderInterface.java
 create mode 100644 src/main/java/component/node/legacy/ArrayNode.java
 create mode 100644 src/main/java/component/node/legacy/BooleanNode.java
 create mode 100644 src/main/java/component/node/legacy/EnumNode.java
 create mode 100644 src/main/java/component/node/legacy/FloatNode.java
 create mode 100644 src/main/java/component/node/legacy/IntegerNode.java
 create mode 100644 src/main/java/component/node/legacy/Node.java
 create mode 100644 src/main/java/component/node/legacy/NumericNode.java
 create mode 100644 src/main/java/component/node/legacy/PrototypedArrayNode.java
 create mode 100644 src/main/java/component/node/legacy/ScalarNode.java
 create mode 100644 src/main/java/component/node/legacy/VariableNode.java
 create mode 100644 src/main/java/component/node/normalization/NodeNormalizer.java
 create mode 100644 src/main/java/component/node/normalization/NodeValueNormalization.java
 create mode 100644 src/main/java/component/normalizer/Normalization.java
 create mode 100644 src/main/java/component/normalizer/Normalizer.java
 create mode 100644 src/main/java/component/normalizer/NormalizerInterface.java
 create mode 100644 src/main/java/component/others/Command.java
 create mode 100644 src/main/java/component/others/Rule.java
 create mode 100644 src/main/java/component/others/Sequence.java
 create mode 100644 src/main/java/component/resolver/PathResolver.java
 create mode 100644 src/main/java/component/resolver/Resolver.java
 create mode 100644 src/main/java/component/resolver/ResolverDelegate.java
 create mode 100644 src/main/java/component/resource/FileSystem.java
 create mode 100644 src/main/java/component/resource/ResourceService.java
 create mode 100644 src/main/java/component/resource/exceptions/ResourceException.java
 create mode 100644 src/main/java/component/resource/exceptions/ResourceNotFoundException.java
 create mode 100644 src/main/java/component/resource/extractor/Extractor.java
 create mode 100644 src/main/java/component/resource/loader/ClasspathResourceLoader.java
 create mode 100644 src/main/java/component/resource/loader/FileResourceLoader.java
 create mode 100644 src/main/java/component/resource/loader/InMemoryResourceLoader.java
 create mode 100644 src/main/java/component/resource/loader/ResourceLoader.java
 create mode 100644 src/main/java/component/resource/loader/ResourceLoaderDelegate.java
 create mode 100644 src/main/java/component/resource/loader/StringResourceLoader.java
 create mode 100644 src/main/java/component/resource/loader/TypedResourceLoader.java
 create mode 100644 src/main/java/component/resource/metatada/ResourceMetadata.java
 create mode 100644 src/main/java/component/resource/metatada/ResourceReferenceMetadata.java
 create mode 100644 src/main/java/component/resource/reference/PosixResourceReferenceExtractor.java
 create mode 100644 src/main/java/component/resource/reference/ResourceReference.java
 create mode 100644 src/main/java/component/resource/reference/ResourceReferenceExtractor.java
 create mode 100644 src/main/java/component/resource/reference/UncResourceReferenceExtractor.java
 create mode 100644 src/main/java/component/resource/reference/path/PathType.java
 create mode 100644 src/main/java/component/resource/reference/path/PathTypeSupplier.java
 create mode 100644 src/main/java/component/templating/Context.java
 create mode 100644 src/main/java/component/templating/Engine.java
 create mode 100644 src/main/java/component/templating/Environment.java
 create mode 100644 src/main/java/component/templating/Position.java
 create mode 100644 src/main/java/component/templating/Renderer.java
 create mode 100644 src/main/java/component/templating/Source.java
 create mode 100644 src/main/java/component/templating/Template.java
 create mode 100644 src/main/java/component/templating/expression/Expression.java
 create mode 100644 src/main/java/component/templating/extention/Extension.java
 create mode 100644 src/main/java/component/templating/extention/Filter.java
 create mode 100644 src/main/java/component/templating/extention/Function.java
 create mode 100644 src/main/java/component/templating/extention/Test.java
 create mode 100644 src/main/java/component/templating/extention/core/CoreExtension.java
 create mode 100644 src/main/java/component/templating/node/BodyNode.java
 create mode 100644 src/main/java/component/templating/node/ExecuteNode.java
 create mode 100644 src/main/java/component/templating/node/ExpressionNode.java
 create mode 100644 src/main/java/component/templating/node/Node.java
 create mode 100644 src/main/java/component/templating/node/NodeParser.java
 create mode 100644 src/main/java/component/templating/node/NodeVisitor.java
 create mode 100644 src/main/java/component/templating/node/PrintNode.java
 create mode 100644 src/main/java/component/templating/node/TextNode.java
 create mode 100644 src/main/java/component/templating/token/Token.java
 create mode 100644 src/main/java/component/templating/token/TokenParser.java
 create mode 100644 src/main/java/component/templating/token/TokenParsers.java
 create mode 100644 src/main/java/component/templating/token/TokenStream.java
 create mode 100644 src/main/java/component/templating/token/TokenVisitor.java
 create mode 100644 src/main/java/component/templating/token/Tokenizer.java
 create mode 100644 src/main/java/component/util/Assert.java
 create mode 100644 src/main/java/component/util/ClassUtils.java
 create mode 100644 src/main/java/component/util/CollectionUtils.java
 create mode 100644 src/main/java/component/util/ObjectUtils.java
 create mode 100644 src/main/java/component/util/PathUtils.java
 create mode 100644 src/main/java/component/util/ReflectionUtils.java
 create mode 100644 src/main/java/component/util/ResourceUtils.java
 create mode 100644 src/main/java/component/util/StringUtils.java
 create mode 100644 src/main/java/component/utils/Assert.java
 create mode 100644 src/main/java/component/utils/ClassUtils.java
 create mode 100644 src/main/java/component/utils/CollectionUtils.java
 create mode 100644 src/main/java/component/utils/ObjectUtils.java
 create mode 100644 src/main/java/component/utils/PathUtils.java
 create mode 100644 src/main/java/component/utils/ReflectionUtils.java
 create mode 100644 src/main/java/component/utils/ResourceUtils.java
 create mode 100644 src/main/java/component/utils/StringUtils.java
 create mode 100644 src/main/java/demo/event/EventDemo.java
 create mode 100644 src/main/java/demo/event/crud/CRUDEvent.java
 create mode 100644 src/main/java/demo/event/crud/CreateEvent.java
 create mode 100644 src/main/java/demo/event/crud/UpdateEvent.java
 create mode 100644 src/main/java/demo/event/event/UserCreatedEvent.java
 create mode 100644 src/main/java/demo/event/event/UserUpdatedEvent.java
 create mode 100644 src/main/java/demo/event/model/Role.java
 create mode 100644 src/main/java/demo/event/model/User.java
 create mode 100644 src/main/java/demo/expressionLanguage/ExpressionLanguageDemo.java
 create mode 100644 src/main/java/demo/expressionLanguage/demo
 create mode 100644 src/main/java/demo/resolver/ResolverDemo.java
 create mode 100644 src/main/java/demo/resource/FileUtils.java
 create mode 100644 src/main/java/demo/resource/ResourceDemo.java
 create mode 100644 src/main/java/demo/resource/ResourceDemo2.java
 create mode 100644 src/main/java/demo/resource/ResourceUtils.java
 create mode 100644 src/main/java/demo/resource/demo
 create mode 100644 src/main/java/demo/resource/demo_1.txt
 create mode 100644 src/main/java/demo/resource/demo_classpath
 create mode 100644 src/main/java/demo/resource/demo_file
 create mode 100644 src/main/java/demo/templating/TemplatingDemo.java
 create mode 100644 src/main/java/demo/templating_old/TemplatingDemo.java
 create mode 100644 src/main/java/demo/templating_old/demo.view
 create mode 100644 src/main/resources/demo/templating/demo.view
 create mode 100644 src/main/resources/demo/templating/demo_1.view
 delete mode 100644 src/node/Node.java
 delete mode 100644 src/node/NodeFactory.java
 delete mode 100644 src/node/builder/NodeBuilder.java
 delete mode 100644 src/node/builder/NodeBuilderInterface.java
 delete mode 100644 src/node/legacy/ArrayNode.java
 delete mode 100644 src/node/legacy/BooleanNode.java
 delete mode 100644 src/node/legacy/EnumNode.java
 delete mode 100644 src/node/legacy/FloatNode.java
 delete mode 100644 src/node/legacy/IntegerNode.java
 delete mode 100644 src/node/legacy/Node.java
 delete mode 100644 src/node/legacy/NumericNode.java
 delete mode 100644 src/node/legacy/PrototypedArrayNode.java
 delete mode 100644 src/node/legacy/ScalarNode.java
 delete mode 100644 src/node/legacy/VariableNode.java
 delete mode 100644 src/node/normalization/NodeNormalizer.java
 delete mode 100644 src/node/normalization/NodeValueNormalization.java
 delete mode 100644 src/normalizer/Normalization.java
 delete mode 100644 src/normalizer/Normalizer.java
 delete mode 100644 src/normalizer/NormalizerInterface.java
 delete mode 100644 src/others/Command.java
 delete mode 100644 src/others/Rule.java
 delete mode 100644 src/others/Sequence.java
 delete mode 100644 src/resolver/PathResolver.java
 delete mode 100644 src/resolver/Resolver.java
 delete mode 100644 src/resolver/ResolverDelegate.java
 delete mode 100644 src/resource/FileSystem.java
 delete mode 100644 src/resource/ResourceService.java
 delete mode 100644 src/resource/exceptions/ResourceException.java
 delete mode 100644 src/resource/exceptions/ResourceNotFoundException.java
 delete mode 100644 src/resource/loader/ClasspathResourceLoader.java
 delete mode 100644 src/resource/loader/FileResourceLoader.java
 delete mode 100644 src/resource/loader/InMemoryResourceLoader.java
 delete mode 100644 src/resource/loader/ResourceLoader.java
 delete mode 100644 src/resource/loader/ResourceLoaderDelegate.java
 delete mode 100644 src/resource/loader/StringResourceLoader.java
 delete mode 100644 src/resource/loader/TypedResourceLoader.java
 delete mode 100644 src/resource/metatada/ResourceMetadata.java
 delete mode 100644 src/resource/metatada/ResourceReferenceMetadata.java
 delete mode 100644 src/resource/reference/PosixResourceReferenceExtractor.java
 delete mode 100644 src/resource/reference/ResourceReference.java
 delete mode 100644 src/resource/reference/ResourceReferenceExtractor.java
 delete mode 100644 src/resource/reference/UncResourceReferenceExtractor.java
 delete mode 100644 src/resource/reference/path/PathType.java
 delete mode 100644 src/resource/reference/path/PathTypeSupplier.java
 delete mode 100644 src/templating/Context.java
 delete mode 100644 src/templating/Engine.java
 delete mode 100644 src/templating/Environment.java
 delete mode 100644 src/templating/Position.java
 delete mode 100644 src/templating/Renderer.java
 delete mode 100644 src/templating/Source.java
 delete mode 100644 src/templating/Template.java
 delete mode 100644 src/templating/expression/Expression.java
 delete mode 100644 src/templating/extention/Extension.java
 delete mode 100644 src/templating/extention/Filter.java
 delete mode 100644 src/templating/extention/Function.java
 delete mode 100644 src/templating/extention/Test.java
 delete mode 100644 src/templating/extention/core/CoreExtension.java
 delete mode 100644 src/templating/node/BodyNode.java
 delete mode 100644 src/templating/node/ExecuteNode.java
 delete mode 100644 src/templating/node/ExpressionNode.java
 delete mode 100644 src/templating/node/Node.java
 delete mode 100644 src/templating/node/NodeParser.java
 delete mode 100644 src/templating/node/NodeVisitor.java
 delete mode 100644 src/templating/node/PrintNode.java
 delete mode 100644 src/templating/node/TextNode.java
 delete mode 100644 src/templating/token/Token.java
 delete mode 100644 src/templating/token/TokenParser.java
 delete mode 100644 src/templating/token/TokenParsers.java
 delete mode 100644 src/templating/token/TokenStream.java
 delete mode 100644 src/templating/token/TokenVisitor.java
 delete mode 100644 src/templating/token/Tokenizer.java
 create mode 100644 src/test/resolver/ResolverDelegateTest.java
 delete mode 100644 src/util/Assert.java
 delete mode 100644 src/util/ClassUtils.java
 delete mode 100644 src/util/CollectionUtils.java
 delete mode 100644 src/util/ObjectUtils.java
 delete mode 100644 src/util/PathUtils.java
 delete mode 100644 src/util/ReflectionUtils.java
 delete mode 100644 src/util/ResourceUtils.java
 delete mode 100644 src/util/StringUtils.java
 delete mode 100644 src/utils/Assert.java
 delete mode 100644 src/utils/ClassUtils.java
 delete mode 100644 src/utils/CollectionUtils.java
 delete mode 100644 src/utils/ObjectUtils.java
 delete mode 100644 src/utils/PathUtils.java
 delete mode 100644 src/utils/ReflectionUtils.java
 delete mode 100644 src/utils/ResourceUtils.java
 delete mode 100644 src/utils/StringUtils.java
 delete mode 100644 test/resolver/ResolverDelegateTest.java

diff --git a/.gitignore b/.gitignore
index 4fd11cb..b01b996 100644
--- a/.gitignore
+++ b/.gitignore
@@ -54,4 +54,5 @@ nbproject/project.properties
 nbproject/project.xml
 /build/
 /nbproject/private/
-/dist/
\ No newline at end of file
+/dist/
+/target/
\ No newline at end of file
diff --git a/demo/event/EventDemo.java b/demo/event/EventDemo.java
deleted file mode 100644
index 9d302e7..0000000
--- a/demo/event/EventDemo.java
+++ /dev/null
@@ -1,172 +0,0 @@
-
-package event;
-
-import event.dispatcher.EventDispatcher;
-import event.crud.CreateEvent;
-import event.crud.UpdateEvent;
-import event.dispatcher.DispatcherInterface;
-import event.handler.Handler;
-import event.model.Role;
-import event.model.User;
-import event.subscriber.Subscriber;
-
-public class EventDemo {
-    
-    public static void main(String[] args) throws Exception {
-        
-        EventDispatcher.builder()
-                .register("update", 90, (Event event) -> {
-                    System.out.println("builder handle Event ".concat(event.toString()));
-                })
-                .subscribe(new RepositorySubscriber())
-                .subscribe(new Subscriber() {
-                    @Override
-                    public void subscribe(DispatcherInterface dispatcher) {
-                        dispatcher.register("create", (Event event) -> {
-                            System.out.println("builder handle Event ".concat(event.toString()));
-                        });
-                    }
-                })
-                .subscribe(new Subscriber<Event>() {
-                    @Override
-                    public void subscribe(DispatcherInterface<Event> dispatcher) {
-                        dispatcher.of(UpdateEvent.class).register("update", (UpdateEvent event) -> {
-                            System.out.println("builder handle Event ".concat(event.getObject().toString()));
-                        });
-                    }
-                })
-                .subscribe((DispatcherInterface<Event> dispatcher) -> {
-                    dispatcher.of(UpdateEvent.class).register("update", (UpdateEvent event) -> {
-                        System.out.println("builder handle Event ".concat(event.getObject().toString()));
-                    });
-                })
-                .build()
-                .dispatch("create", new CreateEvent("qsd"))
-                .dispatch("update", new UpdateEvent("qsd"))
-                .dispatch("terminate", new UpdateEvent("qsd"));
-        
-        EventDispatcher dispatcher = new EventDispatcher();
-        Subscriber repoSubscriber = new RepositorySubscriber();
-        repoSubscriber.subscribe(dispatcher);
-        Subscriber userSubscriber = new UserSubscriber();
-        userSubscriber.subscribe(dispatcher);
-        Subscriber roleSubscriber = new RoleSubscriber();
-        roleSubscriber.subscribe(dispatcher);
-        
-        dispatcher.register("create", (Event event) -> {
-            System.out.println("handle CreateEvent");
-        });
-        
-        dispatcher.of(CreateEvent.class).register("create", (CreateEvent event) -> {
-            System.out.println("Annon handle CreateEvent".concat(event.getObject().toString()));
-        });
-        dispatcher.of(UpdateEvent.class).register("update", 60, (UpdateEvent event) -> {
-            System.out.println("Annon handle Event".concat(event.toString()));
-        });
-        
-        User user = new User("bernard");
-        
-        dispatcher.dispatch("create", new CreateEvent(user));
-        dispatcher.dispatch("update", new UpdateEvent(user));
-        
-//        dispatcher.dispatch("create", new UserCreatedEvent(user));
-//        dispatcher.dispatch("update", new UserUpdatedEvent(user));
-        
-        Role admin = new Role("admin");
-        
-        dispatcher.dispatch("create", new CreateEvent(admin));
-        dispatcher.dispatch("update", new UpdateEvent(admin));
-        
-//        dispatcher.register("create", UserSubscriber::onCreate);
-        
-//        EventDispatcher dispatcher = new EventDispatcher();
-//        dispatcher.register("user_created", (UserCreatedEvent event) -> {
-//            event.getObject().getUsername();
-//        });
-////        dispatcher.addSubscriber(sub);
-    }
-    
-    public static class RepositorySubscriber implements Subscriber {
-        
-        public Handler<CreateEvent> onCreate() {
-            return u -> {
-//                u.stopEventPropagation();
-                System.out.println("handle RepositorySubscriber CreateEvent".concat(u.getObject().toString()));
-            };
-        }
-        
-        public Handler<UpdateEvent> onUpdate() {
-            return u -> System.out.println("handle RepositorySubscriber UpdateEvent".concat(u.getObject().toString()));
-        }
-
-        @Override
-        public void subscribe(DispatcherInterface dispatcher) {
-            dispatcher.register("create", 1, onCreate());
-            dispatcher.register("update", 1, onUpdate());
-        }
-    }
-    
-    public static class UserSubscriber implements Subscriber {
-        
-        public Handler<CreateEvent> onCreate() {
-            return u -> {
-                if (!(u.getObject() instanceof User)) {
-                    return;
-                }
-                
-                System.out.println("handle UserSubscriber CreateEvent".concat(u.getObject().toString()));
-            };
-        }
-        
-        public Handler<UpdateEvent> onUpdate() {
-            return u -> {
-                if (!(u.getObject() instanceof User)) {
-                    return;
-                }
-                
-                System.out.println("handle UserSubscriber UpdateEvent".concat(u.getObject().toString()));
-            };
-        }
-        
-        public void onUpdate2(Event event) {
-            System.out.println("handle UserSubscriber onUpdate2".concat(event.toString()));
-        }
-
-        @Override
-        public void subscribe(DispatcherInterface dispatcher) {
-            dispatcher.register("create", 5, onCreate());
-            dispatcher.register("update", 5, onUpdate());
-            dispatcher.register("update", 99, this::onUpdate2);
-        }
-    }
-        
-    public static class RoleSubscriber implements Subscriber {
-        
-        public Handler<CreateEvent> onCreate() {
-            return u -> {
-                if (!(u.getObject() instanceof Role)) {
-                    return;
-                }
-                
-                System.out.println("handle RoleSubscriber CreateEvent".concat(u.getObject().toString()));
-            };
-        }
-        
-        public Handler<UpdateEvent> onUpdate() {
-            return u -> {
-                if (!(u.getObject() instanceof Role)) {
-                    return;
-                }
-                
-                System.out.println("handle RoleSubscriber UpdateEvent".concat(u.getObject().toString()));
-            };
-        }
-
-        @Override
-        public void subscribe(DispatcherInterface dispatcher) {
-            dispatcher.register("create", 10, onCreate());
-            dispatcher.register("update", 10, onUpdate());
-        }
-    }
-    
-}
diff --git a/demo/event/crud/CRUDEvent.java b/demo/event/crud/CRUDEvent.java
deleted file mode 100644
index a7d51d7..0000000
--- a/demo/event/crud/CRUDEvent.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package event.crud;
-
-import event.Event;
-
-public class CRUDEvent<O> extends Event {
-    
-    private O object;
-
-    public CRUDEvent(O object) {
-        this.object = object;
-    }
-
-    public O getObject() {
-        return object;
-    }
-
-    public void setObject(O object) {
-        this.object = object;
-    }
-}
diff --git a/demo/event/crud/CreateEvent.java b/demo/event/crud/CreateEvent.java
deleted file mode 100644
index 2e61937..0000000
--- a/demo/event/crud/CreateEvent.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package event.crud;
-
-public class CreateEvent<O> extends CRUDEvent<O> {
-    
-    public CreateEvent(O object) {
-        super(object);
-    }
-    
-}
diff --git a/demo/event/crud/UpdateEvent.java b/demo/event/crud/UpdateEvent.java
deleted file mode 100644
index bda8a31..0000000
--- a/demo/event/crud/UpdateEvent.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package event.crud;
-
-public class UpdateEvent<O> extends CRUDEvent<O> {
-    
-    public UpdateEvent(O object) {
-        super(object);
-    }
-    
-}
diff --git a/demo/event/event/UserCreatedEvent.java b/demo/event/event/UserCreatedEvent.java
deleted file mode 100644
index e912b35..0000000
--- a/demo/event/event/UserCreatedEvent.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package event.event;
-
-import event.crud.CreateEvent;
-import event.model.User;
-
-public class UserCreatedEvent extends CreateEvent<User>{
-    
-    public UserCreatedEvent(User object) {
-        super(object);
-    }
-    
-}
diff --git a/demo/event/event/UserUpdatedEvent.java b/demo/event/event/UserUpdatedEvent.java
deleted file mode 100644
index 752c22a..0000000
--- a/demo/event/event/UserUpdatedEvent.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package event.event;
-
-import event.crud.CreateEvent;
-import event.model.User;
-
-public class UserUpdatedEvent extends CreateEvent<User>{
-    
-    public UserUpdatedEvent(User object) {
-        super(object);
-    }
-    
-}
diff --git a/demo/event/model/Role.java b/demo/event/model/Role.java
deleted file mode 100644
index 768a678..0000000
--- a/demo/event/model/Role.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package event.model;
-
-public class Role {
-
-    private String name;
-
-    public Role(String name) {
-        this.name = name;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    @Override
-    public String toString() {
-        return "Role{" + "name=" + name + '}';
-    }
-}
diff --git a/demo/event/model/User.java b/demo/event/model/User.java
deleted file mode 100644
index 5e16179..0000000
--- a/demo/event/model/User.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package event.model;
-
-public class User {
-
-    private String username;
-
-    public User(String username) {
-        this.username = username;
-    }
-
-    public String getUsername() {
-        return username;
-    }
-
-    @Override
-    public String toString() {
-        return "User{" + "username=" + username + '}';
-    }
-
-}
diff --git a/demo/expressionLanguage/ExpressionLanguageDemo.java b/demo/expressionLanguage/ExpressionLanguageDemo.java
deleted file mode 100644
index a004c3a..0000000
--- a/demo/expressionLanguage/ExpressionLanguageDemo.java
+++ /dev/null
@@ -1,78 +0,0 @@
-package expressionLanguage;
-
-import expressionLanguage.extension.ExtensionRegistry;
-import expressionLanguage.extension.core.CoreExtension;
-import expressionLanguage.lexer.Lexer;
-import expressionLanguage.lexer.Syntax;
-import expressionLanguage.model.template.Template;
-import expressionLanguage.token.parser.Parser;
-import expressionLanguage.token.parser.TokenStreamParser;
-import java.io.File;
-import java.util.Locale;
-import java.util.concurrent.ExecutorService;
-import java.util.concurrent.Executors;
-import resource.ResourceService;
-import resource.loader.ClasspathResourceLoader;
-import resource.loader.FileResourceLoader;
-import resource.loader.InMemoryResourceLoader;
-import resource.loader.StringResourceLoader;
-import resource.reference.ResourceReference;
-
-public class ExpressionLanguageDemo {
-    
-    public static void main(String[] args) throws Exception {
-        ResourceService resourceService = ResourceService.builder()
-                .with(ResourceReference.FILE, FileResourceLoader.instance())
-                .with(ResourceReference.FILE, FileResourceLoader.instance(new File("/Users/florian/Documents/sources/sand-box/demo")))
-                .with(ResourceReference.CLASSPATH, new ClasspathResourceLoader(ClassLoader.getSystemClassLoader()))
-                .with(ResourceReference.MEMORY, InMemoryResourceLoader.builder()
-                        .withResource("test", "Demo in memory String")
-                        .build())
-                .with(ResourceReference.STRING, new StringResourceLoader())
-                .with(ResourceReference.ANY_TYPE, new StringResourceLoader())
-                .build();
-        
-        Syntax syntax = Syntax.builder()
-                .comment("{#", "#}")
-                .execute("{%", "%}")
-                .print("{{", "}}")
-                .wsTrim("-")
-                .build();
-        
-        ExtensionRegistry registry = ExtensionRegistry.builder()
-                .with(new CoreExtension())
-                .build();
-        
-        Lexer lexer = Lexer.builder()
-                .syntax(syntax)
-                .operators(registry.getOperators())
-                .build();
-        
-        Parser parser = new TokenStreamParser(registry.getOperators(), registry.getTokenParsers());
-        ExecutorService executorService = Executors.newFixedThreadPool(3);
-        Engine engine = new Engine(resourceService, lexer, parser, registry, true, Locale.getDefault(), executorService);
-        
-        Template template = engine.load("expressionLanguage/demo");
-        
-        
-        System.out.println(template);
-//        Lexer lexer = new Lexer(syntax, registry.getUnaryOperators(), registry.getBinaryOperators());
-       
-//        Parser parser,
-//        ExtensionRegistry extensionRegistry,
-//        boolean strictVariables, 
-//        Locale defaultLocale, 
-//        ExecutorService executorService
-//        Collection<UnaryOperator> unaries = Arrays.asList();
-//        Collection<BinaryOperator> binaries = Arrays.asList();
-//        Lexer lexer = new Lexer(),
-//        Parser parser,
-//        ExtensionRegistry extensionRegistry,
-//        boolean strictVariables, 
-//        Locale defaultLocale, 
-//        ExecutorService executorService
-        
-//        Engine engine = new Engine();
-    }
-    
-}
diff --git a/demo/expressionLanguage/demo b/demo/expressionLanguage/demo
deleted file mode 100644
index 0051d97..0000000
--- a/demo/expressionLanguage/demo
+++ /dev/null
@@ -1,9 +0,0 @@
-C'est la dmo !
-
-{% set name = "World" %}
-
-Hello {{ name }}
-
-{% for item in [3, 2, 1, 0] %}
-    ... {{ item }} !
-{% endfor %} 
\ No newline at end of file
diff --git a/demo/resolver/ResolverDemo.java b/demo/resolver/ResolverDemo.java
deleted file mode 100644
index 13dbca2..0000000
--- a/demo/resolver/ResolverDemo.java
+++ /dev/null
@@ -1,116 +0,0 @@
-package resolver;
-
-import java.util.HashMap;
-import java.util.Locale;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import resource.reference.ResourceReference;
-
-public class ResolverDemo {
-    
-    public static void main(String[] args) {
-        greet();
-        resource();
-        delegate();
-    }
-    
-    public static void greet() {
-        System.out.println("=== GREET ===");
-        greet1();
-    }
-    
-    public static void resource() {
-        System.out.println("=== Resource ===");
-        resource1();
-    }    
-    
-    public static class Greeter {
-        
-        private final Pattern pattern = Pattern.compile("\\{.*?\\}");
-        
-        public Greeter() {
-        }
-        
-        public void greet(String name, String lang) {
-            this.model.put("name", name);
-            Locale locale = new LocaleResolver().resolve(lang).get();
-            if (locale.equals(Locale.FRANCE)) {
-                System.out.println(evaluate("Bonjour {name} !", model));
-            } else if (locale.equals(Locale.ENGLISH)) {
-                System.out.println(evaluate("Hello {name} !", model));
-            }
-        }
-        
-        private Map<String, Object> model = new HashMap<>();
-        private String evaluate(String subject, Map<String, Object> model) {
-            Matcher matcher = this.pattern.matcher(subject);
-            StringBuffer sb = new StringBuffer();
-        
-            while (matcher.find()) {
-                String key = matcher.group().replaceAll("[{}]", "");
-                if (this.model.containsKey(key)) {
-                    matcher.appendReplacement(sb, Objects.toString(this.model.get(key), "null"));
-                }
-            }
-        
-            matcher.appendTail(sb);
-            
-            return sb.toString();
-        }
-
-    };
-    
-    public static class LocaleResolver implements Resolver<String, Locale> {
-        
-        public LocaleResolver() {
-        }
-        
-        @Override
-        public Optional<Locale> resolve(String locale) {
-            switch(locale) {
-                case "fr" :
-                    return Optional.of(Locale.FRANCE);
-                case "en" :
-                    return Optional.of(Locale.ENGLISH);
-                default :
-                    return Optional.of(Locale.getDefault());
-            }
-        }
-    }
-    
-    public static void greet1() {
-        System.out.println("=== GREET 1 ===");
-        Greeter greeter = new Greeter();
-        greeter.greet("world", "fr");
-    }
-    
-    public static void resource1() {
-        System.out.println("=== RESOURCE 2 ===");
-        
-        Resolver<String, ResourceReference> resolver = (String path) -> Optional.of(ResourceReference.file(path));
-        
-        System.out.println(resolver.resolve("/").get());
-    }
-    
-    public static void delegate() {
-        System.out.println("=== delegate ===");
-        
-        ResolverDelegate<String, Object> delegate = new ResolverDelegate<>();
-        
-        delegate.addResolver((s) -> s.startsWith("/"), (String path) -> Optional.of(path + " ../"));
-        delegate.addResolver((s) -> s.startsWith("test"), (String path) -> Optional.of("Ceci est un test"));
-        
-        System.out.println(delegate.resolve("/").get());
-        System.out.println(delegate.resolve("test").get());
-        
-        Resolver<String, ResourceReference> resolver = (String path) -> {
-            return Optional.of(new ResourceReference("file", path));
-        };
-        
-        System.out.println(resolver.resolve("/").get());
-        System.out.println(resolver.resolve("test").get());
-    }
-    }
diff --git a/demo/resource/FileUtils.java b/demo/resource/FileUtils.java
deleted file mode 100644
index ea1d6d0..0000000
--- a/demo/resource/FileUtils.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package resource;
-
-import java.io.File;
-import java.util.Arrays;
-import java.util.Objects;
-
-public class FileUtils {
-
-    public static void exists(File file, boolean deep) {
-        System.out.format("File %s exists ? %s \n", file.getPath(), file.exists());
-        if (file.exists()) {
-            directory(file, deep);
-        }
-    }
-
-    public static void directory(File file, boolean deep) {
-        System.out.format("File %s is directory ? %s \n", file.getPath(), file.isDirectory());
-
-        if (file.isDirectory()) {
-            File[] children = file.listFiles();
-            System.out.format("Children : %s \n", Arrays.toString(children));
-
-            if (deep && Objects.nonNull(children)) {
-                Arrays.stream(file.listFiles())
-                        .filter(Objects::nonNull)
-                        .forEach((child) -> details(child, deep));
-            }
-        }
-    }
-
-    public static void details(String path, boolean deep) {
-        details(new File(path), deep);
-    }
-
-    public static void details(File file, boolean deep) {
-        exists(file, deep);
-    }
-
-}
diff --git a/demo/resource/ResourceDemo.java b/demo/resource/ResourceDemo.java
deleted file mode 100644
index 5d1da55..0000000
--- a/demo/resource/ResourceDemo.java
+++ /dev/null
@@ -1,67 +0,0 @@
-package resource;
-
-import java.io.File;
-import java.net.URL;
-import java.net.URLDecoder;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Enumeration;
-import java.util.HashSet;
-import java.util.Set;
-import java.util.jar.JarEntry;
-import java.util.jar.JarFile;
-import resource.loader.ClasspathResourceLoader;
-import resource.loader.FileResourceLoader;
-import resource.loader.InMemoryResourceLoader;
-import resource.loader.StringResourceLoader;
-import resource.loader.TypedResourceLoader;
-import resource.reference.ResourceReference;
-
-public class ResourceDemo {
-
-    public static void main(String[] args) throws ClassNotFoundException, Exception {
-        ResourceService service = service();
-
-//        services.forEach((service) -> {
-//            System.out.println("======= metadata ".concat(service.toString()).concat("======="));
-////            print(service.metadata("file:sources/sand_box/demo/resource/demo_file"));
-//            print(service.metadata("demo"));
-//            print(service.metadata("file:demo_file"));
-////            print(service.metadata("classpath:sources/sand_box/demo/resource/demo_classpath"));
-//            print(service.metadata("classpath:demo_classpath"));
-////            print(service.metadata("classpath:../../src/Test.java"));
-//            print(service.metadata("memory:test"));
-//            print(service.metadata("Voila voila"));
-//            print(service.metadata("test"));
-//            System.out.println("=======Fin - ".concat(service.toString()).concat("======="));
-//        });
-        System.out.println("======= load ".concat(service.toString()).concat("======="));
-//            print(service.metadata("file:sources/sand_box/demo/resource/demo_file"));
-//            print(service.load("demo"));
-//            print(service.load("file:demo_file"));
-//            print(service.metadata("classpath:sources/sand_box/demo/resource/demo_classpath"));
-        //ResourceUtils.print(service.load("classpath:demo_classpath"));
-        //ResourceUtils.print(service.load("classpath:demo_1.txt"));
-        ResourceUtils.print(service.load("classpath:demo/resource/demo_classpath"));
-//            print(service.metadata("classpath:../../src/Test.java"));
-//            print(service.load("memory:test"));
-//            print(service.load("Voila voila"));
-//            print(service.load("test"));
-        System.out.println("=======Fin - ".concat(service.toString()).concat("======="));
-    }
-
-    public static ResourceService service() {
-
-        return ResourceService.builder()
-                .with(ResourceReference.FILE, FileResourceLoader.instance())
-                .with(ResourceReference.FILE, FileResourceLoader.instance(new File("/sources/sand_box/demo/resource")))
-                .with(ResourceReference.FILE, FileResourceLoader.instance(new File("/Users/florian/Documents/sources/sand-box/demo/resource")))
-                .with(ResourceReference.CLASSPATH, new ClasspathResourceLoader(ClassLoader.getSystemClassLoader()))
-                .with(ResourceReference.MEMORY, InMemoryResourceLoader.builder().withResource("test", "Demo in memory String").build())
-                .with(ResourceReference.MEMORY, InMemoryResourceLoader.builder().withResource("test", "Demo in memory String ANY_TYPE").build())
-                .with(ResourceReference.STRING, new StringResourceLoader())
-                .with(ResourceReference.ANY_TYPE, new StringResourceLoader())
-                .build();
-    }
-
-}
diff --git a/demo/resource/ResourceDemo2.java b/demo/resource/ResourceDemo2.java
deleted file mode 100644
index 3d58aaa..0000000
--- a/demo/resource/ResourceDemo2.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package resource;
-
-import java.io.File;
-import resource.loader.ClasspathResourceLoader;
-import resource.loader.FileResourceLoader;
-import resource.loader.InMemoryResourceLoader;
-import resource.loader.StringResourceLoader;
-import resource.reference.ResourceReference;
-
-public class ResourceDemo2 {
-
-    public static void main(String[] args) throws ClassNotFoundException, Exception {
-        ResourceService service = ResourceService.builder()
-                .with(ResourceReference.FILE, FileResourceLoader.instance())
-                .with(ResourceReference.FILE, FileResourceLoader.instance(new File("/Users/florian/Documents/sources/sand-box/demo")))
-                .with(ResourceReference.FILE, FileResourceLoader.instance(new File("D:\\sources/sand-box/demo/resource")))
-                .with(ResourceReference.FILE, FileResourceLoader.instance(new File("D:\\sources\\sand-box\\demo\\resource")))
-                .with(ResourceReference.CLASSPATH, new ClasspathResourceLoader(ClassLoader.getSystemClassLoader()))
-                .with(ResourceReference.MEMORY, InMemoryResourceLoader.builder()
-                        .withResource("test", "Demo in memory String")
-                        .build())
-                .with(ResourceReference.STRING, new StringResourceLoader())
-                .with(ResourceReference.ANY_TYPE, new StringResourceLoader())
-                .build();
-
-        System.out.println("======= load ".concat(service.toString()).concat("======="));
-//        ResourceUtils.print(service.load("resource/demo"));
-//        ResourceUtils.print(service.load("file:resource/demo"));
-//        ResourceUtils.print(service.load("resource/demo_1.txt"));
-//        ResourceUtils.print(service.load("file:D:\\sources\\sand-box\\demo\\resource\\demo_1.txt"));
-        ResourceUtils.print(service.load("D:\\sources/sand-box/demo/resource/demo_1.txt"));
-        ResourceUtils.print(service.load("file:D:\\sources/sand-box/demo/resource/demo_1.txt"));
-        ResourceUtils.print(service.load("classpath:resource/demo_classpath"));
-        ResourceUtils.print(service.load("classpath:resource/demo_1.txt"));
-        ResourceUtils.print(service.load("Hello World !"));
-        ResourceUtils.print(service.load("test"));
-        System.out.println("=======Fin - ".concat(service.toString()).concat("======="));
-    }
-}
diff --git a/demo/resource/ResourceUtils.java b/demo/resource/ResourceUtils.java
deleted file mode 100644
index 70d79ca..0000000
--- a/demo/resource/ResourceUtils.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package resource;
-
-import java.io.BufferedReader;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import resource.metatada.ResourceMetadata;
-
-public class ResourceUtils {
-
-    public static void print(InputStream stream) {
-        Reader reader = new InputStreamReader(stream);
-        BufferedReader bf = new BufferedReader(reader);
-        bf.lines().forEach(System.out::println);
-    }
-
-    public static void print(ResourceMetadata metadata) {
-        System.out.println();
-        print(metadata.load());
-    }
-}
diff --git a/demo/resource/demo b/demo/resource/demo
deleted file mode 100644
index 537a1dc..0000000
--- a/demo/resource/demo
+++ /dev/null
@@ -1 +0,0 @@
-C'est la dmo !
\ No newline at end of file
diff --git a/demo/resource/demo_1.txt b/demo/resource/demo_1.txt
deleted file mode 100644
index ff08dca..0000000
--- a/demo/resource/demo_1.txt
+++ /dev/null
@@ -1 +0,0 @@
-C'est la dmo .txt !
\ No newline at end of file
diff --git a/demo/resource/demo_classpath b/demo/resource/demo_classpath
deleted file mode 100644
index c7bb7c7..0000000
--- a/demo/resource/demo_classpath
+++ /dev/null
@@ -1 +0,0 @@
-C'est la dmo depuis le classpath !
\ No newline at end of file
diff --git a/demo/resource/demo_file b/demo/resource/demo_file
deleted file mode 100644
index b162ccd..0000000
--- a/demo/resource/demo_file
+++ /dev/null
@@ -1 +0,0 @@
-C'est la dmo depuis un fichier !
\ No newline at end of file
diff --git a/demo/templating/TemplatingDemo.java b/demo/templating/TemplatingDemo.java
deleted file mode 100644
index fa9712c..0000000
--- a/demo/templating/TemplatingDemo.java
+++ /dev/null
@@ -1,233 +0,0 @@
-package templating;
-
-import resource.ResourceService;
-import resource.loader.ClasspathResourceLoader;
-import resource.reference.ResourceReference;
-import templating.extention.core.CoreExtension;
-import templating.token.Tokenizer;
-
-public class TemplatingDemo {
-//    private static final Pattern PATTERN_STRING = compile("((\").*?(?<!\\\\)(\"))|((').*?(?<!\\\\)('))", Pattern.DOTALL);
-    
-    public static void main(String[] args) throws Exception {
-        ResourceService resourceService = ResourceService.builder()
-//                .with(ResourceReference.FILE, FileResourceLoader.instance())
-//                .with(ResourceReference.FILE, FileResourceLoader.instance(new File("/Users/florian/Documents/sources/sand-box/demo")))
-//                .with(ResourceReference.CLASSPATH, new ClasspathResourceLoader(ClassLoader.getSystemClassLoader()))
-                .with(ResourceReference.CLASSPATH, new ClasspathResourceLoader(TemplatingDemo.class.getClassLoader()))
-                .build();
-
-//        Syntax syntax = Syntax.builder().build();
-
-        Environment env = Environment.builder()
-                .resourceService(resourceService)
-//                .syntax(syntax)
-                .build();
-
-        Engine engine = Engine.builder()
-                .environment(env)
-                .execute("{%", "%}")
-                .comment("{#", "#}")
-                .print("{{", "}}")
-                .build();
-
-        Template demo = engine.load("templating/demo.view");  
-        engine.render(demo);
-//        engine.render(demo, Renderer.debug());    
-//        engine.render(demo, CoreExtension.debug());   
-    }
-}
-//        engine.render(demo, new StreamRenderer());  
-                
-//        engine.render(demo, (t, e) -> {
-//            t.getTokens().forEach(System.out::println);
-//            System.out.println(t);
-//        });             
-        
-//        Template template = Template.builder().named("first")
-//                .build();
-//        
-//        Template home = Template.builder().named("home")
-//                .extend(template)
-//                .build();
-    
-//    public static class StreamRenderer implements Renderer {
-//        
-//        @Override
-//        public void render(Template template, Environment environment) throws Exception {
-//            Context context = new Context();
-//            Writer writer = new OutputStreamWriter(System.out);
-//            
-//            TokenStream stream = template.stream();
-//            Token token = stream.current();
-//            
-//            while (!Token.isEOF(token)) {
-//                switch (token.getType()) {
-//                    case "comment_open":
-//                        token = stream.expect("comment_open");
-//                        token = stream.expect("expression");
-//                        token = stream.expect("comment_close");                        
-//                        break;
-//                    case "evaluate_open":
-//                        token = stream.expect("evaluate_open");
-//                        token = stream.expect("expression");
-//                        token = stream.expect("evaluate_close");     
-////                        token = stream.next();
-////                        Optional<Object> evaluated = context.evaluate(token.getValue(), Object.class);
-////                        if (evaluated.isPresent()) {
-////                            writer.write(evaluated.get().toString());
-////                        }
-//                        break;
-//                    case "execute_open":
-////                        token = stream.expect("expression");
-//                        // evaluate the expression
-////                        environment.getSyntax().getExpressions().values().forEach((e) -> {
-////                            e.evalute(token.getValue().trim(), context);
-////                        });
-//                        break;
-//                    case "text":
-//                        writer.write(token.getValue());
-//                        break;
-//                    default:
-//                        break;
-//                }
-//                token = stream.next();
-//            }
-//            
-//            writer.flush();
-//        }
-//    }
-//    
-//    public static class ForExpression extends BinaryExpression {
-//        
-//        public ForExpression(String name, String[] operators, BiConsumer consumer) {
-//            super(name, operators, consumer);
-//        }
-//        
-//    }
-
-//        Rule executeStart = Rule.group("start", Pattern.quote("{%"));
-//        Rule executeEnd = Rule.group("end", Pattern.quote("%}"));
-//        
-//        Rule expression = Rule.group("var", ".*");
-//        Rule ltrim = Rule.group("ltrim", "-", "?+");
-//        Rule rtrim = Rule.group("rtrim", "-", "?+");
-//        
-////        Rule execute = Rule.expect("(?<start>\\Q{%\\E)(?<ltrim>\\Q-\\E*)(?<expression>.*)(?<rtrim>\\Q-\\E*)(?<end>\\Q%}\\E)");
-//        
-//        Sequence command = Sequence.builder()
-//                .withRule(executeStart)
-//                .withRule(ltrim)
-//                .withRule(expression)
-//                .withRule(rtrim)
-//                .withRule(executeEnd)
-//                .build();
-//        
-//        System.out.println(command.validate("{% if true %}\nbonjour\n{% endif %}"));
-//        System.out.println(command.groups("{% if true %} bonjour {% endif %}"));
-//        System.out.println(command.groups("{%- if true %}\nbonjour\n{% endif %}"));
-//        System.out.println(command.groups("{% %} {% %}"));
-//        System.out.println(command.groups("aze"));
-//        System.out.println(command.groups("aze"));
-//        System.out.println(command.validate("{# this is a comment #}"));
-        
-
-//        Syntax syntax = Syntax.builder()
-//                .trim("-")
-//                .command("comment", "{#", "#}", (stream, context) -> {})
-//                .command("print", "{{", "}}", (stream, context) -> {
-//                    Token current = stream.current();
-//                    String value = current.getValue();
-//                    
-//                    Optional<Object> result = context.evaluate(value);
-//                    
-//                })
-//                .command("execute", "{%", "%}", (stream, context) -> {})
-//                
-//                .expression("if", (value, context) -> {
-//                    System.out.println("if");
-//                    Optional<Object> result = context.evaluate(value);
-//                    
-//                    if (result.isPresent()) {
-//                        System.out.println(result);
-//                    }
-//                })
-//                .expression("not", (value, context) -> {
-//                    System.out.println("not");
-//                
-//                })
-//                .expression("set", (value, context) -> {
-//                    System.out.println("set");
-//                
-//                })
-//                .expression("for", "in", (value, context) -> {
-//                    System.out.println("for");
-//                
-//                })
-//                .build();
-//        
-
-
-
-//
-//                .expression("if", (String value, Context context) -> {
-//                    Optional<Boolean> result = context.evaluate(value, Boolean.class);
-//                    if (result.isPresent() && result.get()) {
-//                        System.out.println(result.get());
-//                    }
-//                })
-//                .binary("for", new String[]{"in"}, (String value, Context context) -> {
-//                    String[] values = value.split("in");
-//                    
-//                    if (values.length < 2) {
-//                        throw new IllegalArgumentException("'for' should be followed by an itteration exression('a in b')");
-//                    }
-//                    
-////                    Token next = context.getStream().next();
-//                    
-//                    String key = values[0].trim();
-//                    String v = values[1].trim();
-//                    
-//                    // is form : ["", "", "", "", ""] ?
-//                    // is form : {a : "", b : ""} ?
-//                    
-//                    // is a var : a ?
-//                    Optional<Object> evaluated = context.evaluate(v, Object.class);
-//                    
-//                    if (!evaluated.isPresent()) {
-//                        return;
-//                    }
-//                    
-//                    Collection list = new ArrayList();
-//                    Object o = evaluated.get();
-//                    
-//                    if (o instanceof Collection) {
-//                        list = (Collection) o;
-//                    }
-//                    
-//                    if (o instanceof String) {
-//                        char[] chars = ((String) o).toCharArray();
-//                        for(char c : chars) {
-//                            list.add(c);
-//                        }
-//                    }
-//                    
-//                    int i = 0;
-//                    for (Object object : list) {
-//                        context.getModel().put("index", i++);
-//                        context.getModel().put(key, object);
-//                        System.out.println(object);
-//                    }
-//                })
-//                .binary("set", new String[]{"="}, (String value, Context context) -> {
-//                    String[] values = value.split("=");
-//                    
-//                    if (values.length < 2) {
-//                        throw new IllegalArgumentException("'set' should be followed by a attribution exression('a = b')");
-//                    }
-//                    
-//                    String key = values[0].trim();
-//                    String v = values[1].trim().replaceAll("(\\Q\"\\E)", "");
-//                    
-//                    context.getModel().put(key, v);
-//                })
\ No newline at end of file
diff --git a/demo/templating/demo.view b/demo/templating/demo.view
deleted file mode 100644
index 844e58e..0000000
--- a/demo/templating/demo.view
+++ /dev/null
@@ -1,40 +0,0 @@
-
-
-Leading text
-
-{% show(1) %}
-
-{% show([1, 2, 3, 4]) %}
-
-{% if (a == b) %}
-{% endif %}
-
-{% if not something %}
-{% endif %}
-
-{% if something %}
-{% endif %}
-
-{% block test %}
-    Ceci est dans le block test
-
-    {% if true %}
-        Ceci est dans la if condition
-    {% endif %}
-{% endblock %}
-
-{# comment [1, 2, 3, 4] #}
-
-{{ show [1, 2, 3, 4] }}
-
-Some text, to say hello ...
-
-Hello {{ name }} {{ person.name }}!
-
-{% if true %}
-    This is true !
-{% endif %} 
-
-{% do it %}
-
-qsdqsdsqdsdq
diff --git a/demo/templating/demo_1.view b/demo/templating/demo_1.view
deleted file mode 100644
index 5373d60..0000000
--- a/demo/templating/demo_1.view
+++ /dev/null
@@ -1,42 +0,0 @@
-
-
-Leading text
-
-{% block 'test' %}
-    Ceci est dans le block test
-
-    {% if t %}
-        Ceci est dans la if condition
-    {% endif %}
-{% endblock %}
-
-{# comment #}
-{% set name = "World" %}
-
-Some text, to say hello ...
-
-Hello {{ name }} !
-
-
-{% if true -%}
-    This is true !
-{%- endif %} 
-
-
-{% if false %}
-    This is not true !
-{% endif %} 
-
-{% for letter in name %}
-    {{ letter }} 
-{% endfor %} 
-
-{% for i in tab %}
-    {% if i > 0 %}
-        Greater than 0
-    {% endif %}
-{% endfor %} 
-
-{{ unclosed 
-
-{% do it %}
diff --git a/demo/templating_old/TemplatingDemo.java b/demo/templating_old/TemplatingDemo.java
deleted file mode 100644
index 526a16a..0000000
--- a/demo/templating_old/TemplatingDemo.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package templating_old;
-
-public class TemplatingDemo {
-    
-    public static void main(String[] args) throws Exception {
-//        EngineBuilder engineBuilder = new EngineBuilder();
-//        Engine engine = engineBuilder.build();
-//        
-//        Template template = engine.getTemplate("demo/templating/demo.view");
-//        
-//        Writer writer = new StringWriter();
-//        template.evaluate(writer);
-//        
-//        System.out.println(writer.toString());
-        
-    }
-}
diff --git a/demo/templating_old/demo.view b/demo/templating_old/demo.view
deleted file mode 100644
index 537a1dc..0000000
--- a/demo/templating_old/demo.view
+++ /dev/null
@@ -1 +0,0 @@
-C'est la dmo !
\ No newline at end of file
diff --git a/pom.xml b/pom.xml
new file mode 100644
index 0000000..7632d7e
--- /dev/null
+++ b/pom.xml
@@ -0,0 +1,15 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+    <groupId>com.marvin</groupId>
+    <artifactId>marvin-sand-box</artifactId>
+    <version>1.0-SNAPSHOT</version>
+    <packaging>jar</packaging>
+    <properties>
+        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
+        <maven.compiler.source>1.8</maven.compiler.source>
+        <maven.compiler.target>1.8</maven.compiler.target>
+    </properties>
+    <dependencies>
+    </dependencies>
+</project>
\ No newline at end of file
diff --git a/src/MarkupBuilder.java b/src/MarkupBuilder.java
deleted file mode 100644
index f1d698b..0000000
--- a/src/MarkupBuilder.java
+++ /dev/null
@@ -1,31 +0,0 @@
-
-
-import node.builder.NodeBuilder;
-import java.util.function.Supplier;
-
-public abstract class MarkupBuilder extends NodeBuilder {
-
-    boolean rootElement = false;
-
-    public MarkupBuilder() {
-        super();
-    }
-
-    protected String spacer(int len){
-       StringBuilder b = new StringBuilder();
-        for (int i = 0; i < len; i++) {
-             b.append('\t');
-        }
-        return b.toString();
-    }
-
-    public MarkupBuilder element(String name) {
-        this.child(name);
-        return this;
-    }
-
-    public MarkupBuilder content(String name) {
-        this.child(name);
-        return this;
-    }
-}
diff --git a/src/Test.java b/src/Test.java
deleted file mode 100644
index 206c242..0000000
--- a/src/Test.java
+++ /dev/null
@@ -1,102 +0,0 @@
-
-
-import node.builder.NodeBuilder;
-import node.Node;
-import builder.Builder;
-
-
-public class Test {
-    
-    public static void main(String[] args) {
-        
-//        
-//        Node node = Builder.of(Node::new).consume(
-//            n -> n.attr("info", "Informations")
-//        ).consume((n) -> {
-//            System.out.append("visiting");
-//        }).build();
-//        
-//        node = NodeBuilder.root()
-//                .info("Root informations")
-//                .attribute("attribute", 17)
-//                .array("child - 1")
-//                    .info("child - 1 informations")
-//                    .array("child - 1 - 2")
-//                        .info("child - 1 - 2 informations")
-//                    .end()
-//                .end()
-//                .bool("boolean")
-//                    .info("Information")
-//                    .defaultTrue()
-//                .end()
-//                .array("child - 2")
-//                    .info("child - 2 informations")
-//                .end()
-//                .build();
-//        
-//        System.out.append("" + node);
-//        
-//        new TreeNodeBuilder()
-//                .root("root")
-//                    .info("Root informations")
-//                    .attribute("attribute", 17)
-//                .child("child")
-//                    .info("child informations")
-//                .end()
-//                .bool("boolean")
-//                    .info("Information")
-//                    .defaultTrue()
-//                .end()
-//                .array("root")
-//                    .info("root informations")
-//                    .child();
-
-//        Builder.of(Node::new)
-//            .before((product, builder) -> {
-//                System.out.println(Builder.BEFORE);
-//                System.out.println(product);
-//            })
-//            .with((product) -> {
-//                System.out.println(Builder.WITH);
-//                product.child(new Node("1", "1", "1"));
-//                System.out.println(product);
-//            })
-//            .with((product) -> {
-//                System.out.println(Builder.WITH);
-//                product.child(new Node("2", "2", "2"));
-//                System.out.println(product);
-//            })
-//            .after((product, builder) -> {
-//                System.out.println(Builder.AFTER);
-//                System.out.println(product);
-//            })
-//            .build();
-//            .child(new Node())
-//            .visit((node) -> System.out.println(node));
-
-//            new NodeBuilder().info(info)
-//                    .child("services")
-                    
-                
-//        Node.builder()
-//                .child(new Node())
-//                .visit((node) -> System.out.println(node));
-
-//            .arrayNode("router")
-//                .info("router configuration")
-//                .scalarNode("resource")
-//                    .info("Resource path")
-//                    .required()
-//                .end()
-//            .end()
-                    
-//          Configruation.builder().root()
-//                .array("parameters")
-//                    .info("")
-//                    .scalar("resource")
-//                        .info("Resource path")
-//                        .required()
-//                    .end()
-//                .end();
-    }
-}
diff --git a/src/builder/Builder.java b/src/builder/Builder.java
deleted file mode 100644
index f8d2e23..0000000
--- a/src/builder/Builder.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package builder;
-
-import java.util.function.Consumer;
-import java.util.function.Function;
-import java.util.function.Supplier;
-
-public class Builder<P> implements BuilderInterface<P> {
-    
-    protected P product;
-
-    public Builder(P product) {
-        this.product = product;
-    }
-    
-    public static <P> BuilderInterface<P> of(Class<P> clazz) throws Exception {
-        return of(clazz.newInstance());
-    }
-    
-    public static <P> BuilderInterface<P> of(Supplier<P> supplier) {
-        return of(supplier.get());
-    }
-    
-    public static <P> BuilderInterface<P> of(P product) {
-        return new Builder(product);
-    }
-
-    @Override
-    public P build(Function<P, P> build) {
-        return build.apply(product);
-    }
-    
-    @Override
-    public BuilderInterface consume(Consumer<P> visitor) {
-        visitor.accept(product);
-        return this;
-    }
-
-    public P getProduct() {
-        return product;
-    }
-
-}
diff --git a/src/builder/BuilderInterface.java b/src/builder/BuilderInterface.java
deleted file mode 100644
index 2d2e1e4..0000000
--- a/src/builder/BuilderInterface.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package builder;
-
-import java.util.function.Consumer;
-import java.util.function.Function;
-
-public interface BuilderInterface<P> {
-
-    default P build() {
-        return build(Function.identity());
-    };
-    public P build(Function<P, P> build);
-    
-//    public P getProduct();
-    public BuilderInterface<P> consume(Consumer<P> visitor);
-    
-}
diff --git a/src/builder/ConditionalBuilder.java b/src/builder/ConditionalBuilder.java
deleted file mode 100644
index 596476d..0000000
--- a/src/builder/ConditionalBuilder.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package builder;
-
-import builder.Builder;
-import java.util.function.BooleanSupplier;
-import java.util.function.Consumer;
-
-public abstract class ConditionalBuilder<T> extends Builder<T> {
-    
-    private boolean ifCond = Boolean.TRUE;
-
-    public ConditionalBuilder(T product) {
-        super(product);
-    }
-
-//    public ConditionalBuilder(T product) {
-//        super(product);
-//    }
-
-//    @Override
-//    protected Builder<T> with(Consumer<T> setter) {
-//        if (!ifCond) {
-//           super.with(setter);
-//        }
-//        return this;
-//    }
-    
-    public Builder<T> require(BooleanSupplier condition) {
-        this.ifCond = condition.getAsBoolean();
-        return this;
-    }
-
-    public Builder<T> endRequire() {
-        this.ifCond = true;
-        return this;
-    }
-}
diff --git a/src/builder/StepInterface.java b/src/builder/StepInterface.java
deleted file mode 100644
index b544457..0000000
--- a/src/builder/StepInterface.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package builder;
-
-import builder.BuilderInterface;
-import java.util.function.BiConsumer;
-
-@FunctionalInterface
-public interface StepInterface<P> extends BiConsumer<P, BuilderInterface<P>> {
-
-    @Override
-    public void accept(P product, BuilderInterface<P> builder);
-    
-}
diff --git a/src/builder/SteppedBuilder.java b/src/builder/SteppedBuilder.java
deleted file mode 100644
index f2a8f72..0000000
--- a/src/builder/SteppedBuilder.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package builder;
-
-import builder.BuilderInterface;
-import builder.Builder;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-import java.util.function.Consumer;
-
-public class SteppedBuilder<P> extends Builder<P> {
-    
-    public final static String AFTER       = "AFTER";
-    public final static String BEFORE      = "BEFORE";
-    public final static String WITH        = "WITH";
-    public final static String VISIT        = "VISIT";
-    
-    protected Map<String, List<StepInterface<P>>> steps;
-
-    public SteppedBuilder(P product) {
-        super(product);
-    }
-
-    public BuilderInterface<P> step(String event, StepInterface<P> step) {
-        this.steps.computeIfAbsent(event, (e) -> new ArrayList<>()).add(step);
-        return this;
-    }
-    
-    public P build() {
-        getSteps().stream().forEach((step) -> {
-            step.accept(product, this);
-        });
-        
-        return product;
-    }
-    
-    protected List<StepInterface<P>> getSteps(String step) {
-        return this.steps.computeIfAbsent(step, (a) -> new ArrayList<>());
-    }
-    
-    protected List<StepInterface<P>> getSteps() {
-        return Arrays.asList(
-                getSteps(BEFORE), 
-                getSteps(WITH), 
-                getSteps(AFTER), 
-                getSteps(VISIT)).stream()
-                .collect(ArrayList::new, List::addAll, List::addAll);
-    }
-    
-//    public BuilderInterface<P> step(String event, StepInterface<P> step);
-//    public BuilderInterface<P> with(Consumer<P> setter);
-//    public BuilderInterface<P> after(StepInterface<P> step);
-//    public BuilderInterface<P> before(StepInterface<P> step);
-    
-    public BuilderInterface<P> with(Consumer<P> setter) {
-        step(WITH, (P product, BuilderInterface<P> builder) -> {
-            setter.accept(product);
-        });
-//        setter.accept(product);
-        return this;
-    }
-    
-    public BuilderInterface<P> before(StepInterface step) {
-        return step(BEFORE, step);
-    }
-    
-    public BuilderInterface<P> after(StepInterface step) {
-        return step(AFTER, step);
-    }
-    
-    public BuilderInterface<P> visit(StepInterface step) {
-        return step(VISIT, step);
-    }
-}
diff --git a/src/configuration/Configuration.java b/src/configuration/Configuration.java
deleted file mode 100644
index 6854f89..0000000
--- a/src/configuration/Configuration.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package configuration;
-
-import node.builder.NodeBuilder;
-
-public class Configuration {
-    public static NodeBuilder builder() {
-        return new NodeBuilder();
-    }
-}
diff --git a/src/configuration/ConfigurationBuilder.java b/src/configuration/ConfigurationBuilder.java
deleted file mode 100644
index 875e18f..0000000
--- a/src/configuration/ConfigurationBuilder.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package configuration;
-
-public class ConfigurationBuilder {
-    
-}
diff --git a/src/converter/Converter.java b/src/converter/Converter.java
deleted file mode 100644
index 2ee3371..0000000
--- a/src/converter/Converter.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package converter;
-
-import java.util.Collections;
-import java.util.List;
-
-@FunctionalInterface
-public interface Converter<I, O> {
-    
-    O convert(I value);
-    
-    default O convert(I value, Object type) {
-        if (support(type)) {
-            return convert(value);
-        }
-        
-        return null;
-    }
-    
-    default List<Object> getTypes(){
-        return Collections.EMPTY_LIST;
-    };
-
-    default boolean support(Object type) {
-        return getTypes().contains(type);
-    }
-}
diff --git a/src/converter/ConverterDelegate.java b/src/converter/ConverterDelegate.java
deleted file mode 100644
index 9997146..0000000
--- a/src/converter/ConverterDelegate.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package converter;
-
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Optional;
-
-public class ConverterDelegate<I, O> {
-    
-    List<Converter<I, O>> converters;
-
-    public ConverterDelegate() {
-        this.converters = new ArrayList<>();
-    }
-
-    public O convert(I value, Object type) {
-        Optional<Converter<I, O>> first = this.converters.stream().filter((Converter<I, O> converter)->{
-            return converter.support(type);
-        }).findFirst();
-        
-        if (first.isPresent()) {
-            return first.get().convert(value, type);
-        }
-        
-        return null;      
-    }
-    
-}
diff --git a/src/converter/ConverterResolver.java b/src/converter/ConverterResolver.java
deleted file mode 100644
index cbdc1b3..0000000
--- a/src/converter/ConverterResolver.java
+++ /dev/null
@@ -1,49 +0,0 @@
-package converter;
-
-import java.util.Arrays;
-import converter.support.*;
-import java.util.Optional;
-
-public class ConverterResolver {
-
-    Converter[] converters;
-
-    public ConverterResolver() {
-        this.converters = new Converter[]{
-            new BigDecimalConverter(),
-            new BooleanConverter(),
-            new ByteConverter(),
-            new CharacterConverter(),
-            new DoubleConverter(),
-            new FloatConverter(),
-            new IdentityConverter(),
-            new IntegerConverter(),
-            new LongConverter(),
-            new ObjectConverter(),
-            new ShortConverter(),
-            new SqlDateConverter(),
-            new SqlTimestampConverter(),
-            new StringConverter()
-        };
-    }
-    
-    public boolean support(Object toConvert) {
-        return Arrays.stream(this.converters).anyMatch((Converter converter)->{
-            return converter.getTypes().contains(toConvert);
-        });
-    }
-    
-    public Converter resolve(Object toConvert) {
-        Optional<Converter> converter = Arrays.stream(this.converters)
-                .filter((Converter c) -> {
-            return c.getTypes().contains(toConvert);
-        }).findFirst();
-        
-        if (!converter.isPresent()) {
-            return null;
-        }
-        
-        return converter.get();
-    }
-    
-}
diff --git a/src/converter/support/BigDecimalConverter.java b/src/converter/support/BigDecimalConverter.java
deleted file mode 100644
index 38f145a..0000000
--- a/src/converter/support/BigDecimalConverter.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.math.BigDecimal;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Convert to a {@link BigDecimal} by parsing the value as a string
- */
-public class BigDecimalConverter implements Converter<Object, BigDecimal> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(BigDecimal.class, BigDecimal.class.getName());
-    }
-
-    @Override
-    public BigDecimal convert(Object value) {
-        if (value == null) {
-            return null;
-        }
-        
-        if (value instanceof BigDecimal) {
-            return (BigDecimal) value;
-        } else {
-            String v = value.toString();
-            if (v.trim().length() != 0) {
-                return new BigDecimal(v);
-            }
-        }
-        
-        return null;
-    }
-
-}
diff --git a/src/converter/support/BooleanConverter.java b/src/converter/support/BooleanConverter.java
deleted file mode 100644
index 79c3d2d..0000000
--- a/src/converter/support/BooleanConverter.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Convert to a boolean by parsing the value as a string
- */
-public class BooleanConverter implements Converter<Object, Boolean> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(Boolean.class,
-            Boolean.TYPE,
-            Boolean.class.getName());
-    }
-
-    @Override
-    public Boolean convert(Object value) {
-        
-        if (value == null) {
-            return null;
-        }
-        
-        if(value instanceof Boolean) {
-            return (Boolean) value;
-        } else {
-            String v = value.toString();
-            if (v.trim().length() != 0) {
-                return Boolean.parseBoolean(v);
-            }
-        }
-        
-        return null;
-    }
-}
diff --git a/src/converter/support/ByteConverter.java b/src/converter/support/ByteConverter.java
deleted file mode 100644
index 6333555..0000000
--- a/src/converter/support/ByteConverter.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Convert to a byte by parsing the value as a string
- */
-public class ByteConverter implements Converter<Object, Byte> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(Byte.class,
-            Byte.TYPE,
-            Byte.class.getName());
-    }
-
-    @Override
-    public Byte convert(Object value) {
-        if (value == null) {
-            return null;
-        }
-
-        if (value instanceof Byte) {
-            return (Byte) value;
-        } else {
-            String v = value.toString();
-            if (v.trim().length() != 0) {
-                return Byte.parseByte(v);
-            }
-        }
-
-        return null;
-    }
-}
diff --git a/src/converter/support/CharacterConverter.java b/src/converter/support/CharacterConverter.java
deleted file mode 100644
index bdcfff2..0000000
--- a/src/converter/support/CharacterConverter.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Convert to a character by parsing the first character of the value as a
- * string
- *
- */
-public class CharacterConverter implements Converter<Object, Character> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(
-            Character.class,
-            Character.TYPE,
-            Character.class.getName()
-        );
-    }
-
-    @Override
-    public Character convert(Object value) {
-        if (value == null) {
-            return null;
-        }
-        if (value instanceof Character) {
-            return (Character) value;
-        }
-        String v = value.toString();
-        if (v.trim().length() == 0) {
-            return null;
-        }
-        return v.charAt(0);
-    }
-}
diff --git a/src/converter/support/DoubleConverter.java b/src/converter/support/DoubleConverter.java
deleted file mode 100644
index 4950958..0000000
--- a/src/converter/support/DoubleConverter.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Convert to a double by parsing the value as a string
- *
- */
-public class DoubleConverter implements Converter<Object, Double> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(
-            Double.class,
-            Double.TYPE,
-            Double.class.getName()
-        );
-    }
-
-    @Override
-    public Double convert(Object value) {
-        if (value == null) {
-            return null;
-        }
-        
-        if (value instanceof Double) {
-            return (Double) value;
-        } else {
-            String v = value.toString();
-            if (v.trim().length() != 0) {
-                return Double.parseDouble(v);
-            }
-        }
-        return null;
-    }
-}
diff --git a/src/converter/support/FloatConverter.java b/src/converter/support/FloatConverter.java
deleted file mode 100644
index f364f31..0000000
--- a/src/converter/support/FloatConverter.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Convert to a float by parsing the value as a string
- *
- */
-public class FloatConverter implements Converter<Object, Float> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(
-            Float.class,
-            Float.TYPE,
-            Float.class.getName()
-        );
-    }
-
-    @Override
-    public Float convert(Object value) {
-        
-        if (value == null) {
-            return null;
-        }
-        
-        if (value instanceof Float) {
-            return (Float) value;
-        } else {
-            String v = value.toString();
-            if (v.trim().length() != 0) {
-                return Float.parseFloat(v);
-            }
-        }
-        
-        return null;
-    }
-}
diff --git a/src/converter/support/IdentityConverter.java b/src/converter/support/IdentityConverter.java
deleted file mode 100644
index 0ecec54..0000000
--- a/src/converter/support/IdentityConverter.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Returns the value as-is (no conversion)
- *
- */
-public class IdentityConverter implements Converter<Object, Object> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList();
-    }
-
-    @Override
-    public Object convert(Object value) {
-        return value;
-    }
-}
diff --git a/src/converter/support/IntegerConverter.java b/src/converter/support/IntegerConverter.java
deleted file mode 100644
index 189efed..0000000
--- a/src/converter/support/IntegerConverter.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Convert to an integer by parsing the value as a string
- *
- */
-public class IntegerConverter implements Converter<Object, Integer> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(
-            Integer.class,
-            Integer.TYPE,
-            Integer.class.getName()
-        );
-    }
-
-    @Override
-    public Integer convert(Object value) {
-        
-        if (value == null) {
-            return null;
-        }
-        
-        if (value instanceof Integer) {
-            return (Integer) value;
-        } else {
-            String v = value.toString();
-            if (v.trim().length() != 0) {
-                return Integer.parseInt(v);
-            }
-        }
-        
-        return null;
-    }
-}
diff --git a/src/converter/support/LongConverter.java b/src/converter/support/LongConverter.java
deleted file mode 100644
index 3be40e4..0000000
--- a/src/converter/support/LongConverter.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Convert to a long by parsing the value as a string
- *
- */
-public class LongConverter implements Converter<Object, Long> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(
-            Long.class,
-            Long.TYPE,
-            Long.class.getName()
-        );
-    }
-
-    @Override
-    public Long convert(Object value) {
-
-        if (value == null) {
-            return null;
-        }
-
-        if (value instanceof Long) {
-            return (Long) value;
-        } else {
-            String v = value.toString();
-            if (v.trim().length() != 0) {
-                return Long.parseLong(v);
-            }
-        }
-
-        return null;
-    }
-}
diff --git a/src/converter/support/ObjectConverter.java b/src/converter/support/ObjectConverter.java
deleted file mode 100644
index bd03802..0000000
--- a/src/converter/support/ObjectConverter.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.ObjectInputStream;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Converts a byte array to an object via deserialization, or returns the value
- * as-is
- *
- */
-public class ObjectConverter implements Converter<Object, Object> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(
-            Object.class,
-            Object.class.getName()
-        );
-    }
-
-    @Override
-    public Object convert(Object value) {
-        if (value == null) {
-            return null;
-        }
-        if (value.getClass().isArray()) {
-            // This is a byte array; presume we can convert it to an object
-            if (value.getClass().getComponentType() == Byte.TYPE) {
-                ByteArrayInputStream bis
-                        = new ByteArrayInputStream((byte[]) value);
-                ObjectInputStream ois = null;
-                try {
-                    ois = new ObjectInputStream(bis);
-                    value = ois.readObject();
-                } catch (IOException | ClassNotFoundException e) {
-                    throw new IllegalArgumentException(
-                            "Could not deserialize object", e);
-                } finally {
-                    try {
-                        if (ois != null) {
-                            ois.close();
-                        }
-                    } catch (IOException e) {
-                        // Ignore
-                    }
-                    try {
-                        if (bis != null) {
-                            bis.close();
-                        }
-                    } catch (IOException e) {
-                        // Ignore
-                    }
-                }
-            }
-        }
-
-        return value;
-    }
-}
diff --git a/src/converter/support/ShortConverter.java b/src/converter/support/ShortConverter.java
deleted file mode 100644
index b8cc6df..0000000
--- a/src/converter/support/ShortConverter.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Convert to a short by parsing the value as a string
- *
- */
-public class ShortConverter implements Converter<Object, Short> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(
-            Short.class,
-            Short.TYPE,
-            Short.class.getName()
-        );
-    }
-
-    @Override
-    public Short convert(Object value) {
-        
-        if (value == null) {
-            return null;
-        }
-        
-        if (value instanceof Short) {
-            return (Short) value;
-        } else {
-            String v = value.toString();
-            if (v.trim().length() != 0) {
-                return Short.parseShort(v);
-            }
-        }
-        return null;
-    }
-}
diff --git a/src/converter/support/SqlDateConverter.java b/src/converter/support/SqlDateConverter.java
deleted file mode 100644
index bbf176c..0000000
--- a/src/converter/support/SqlDateConverter.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.sql.Date;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Convert to a {@link SqlDate} by parsing a value as a string of form
- * <code>yyyy-[m]m-[d]d</code>.
- *
- * @see	java.sql.Date#valueOf(String)
- */
-public class SqlDateConverter implements Converter<Object, Date> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(
-            java.sql.Date.class,
-            java.sql.Date.class.getName()
-        );
-    }
-
-    @Override
-    public Date convert(Object value) {
-        if (value == null) {
-            return null;
-        }
-        
-        if (value instanceof Date) {
-            return (Date) value;
-        } else {
-            String v = value.toString();
-            if (v.trim().length() != 0) {
-                return Date.valueOf(v);
-            }
-        }
-        
-        return null;
-    }
-}
diff --git a/src/converter/support/SqlTimeConverter.java b/src/converter/support/SqlTimeConverter.java
deleted file mode 100644
index 36d18e5..0000000
--- a/src/converter/support/SqlTimeConverter.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.sql.Time;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Convert to a {@link SqlTime} by parsing a value as a string of form
- * <code>hh:mm:ss</code>.
- *
- * @see	java.sql.Date#valueOf(String)
- */
-public class SqlTimeConverter implements Converter<Object, Time> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(
-            Time.class,
-            Time.class.getName()
-        );
-    }
-
-    @Override
-    public Time convert(Object value) {
-        if (value == null) {
-            return null;
-        }
-        if (value instanceof Time) {
-            return (Time) value;
-        } else {
-            String v = value.toString();
-            if (v.trim().length() != 0) {
-                return Time.valueOf(v);
-            }
-        }
-        return null;
-    }
-}
diff --git a/src/converter/support/SqlTimestampConverter.java b/src/converter/support/SqlTimestampConverter.java
deleted file mode 100644
index cd28769..0000000
--- a/src/converter/support/SqlTimestampConverter.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.sql.Timestamp;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Convert to a {@link SqlTimestamp} by parsing a value as a string of form
- * <code>yyyy-[m]m-[d]d hh:mm:ss[.f...]</code>.
- *
- * @see	java.sql.Date#valueOf(String)
- */
-public class SqlTimestampConverter implements Converter<Object, Timestamp> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(
-            Timestamp.class,
-            Timestamp.class.getName()
-        );
-    }
-
-    @Override
-    public Timestamp convert(Object value) {
-        if (value == null) {
-            return null;
-        }
-        if (value instanceof Timestamp) {
-            return (Timestamp) value;
-        } else {
-            String v = value.toString();
-            if (v.trim().length() == 0) {
-                return Timestamp.valueOf(v);
-            }
-        }
-        return null;
-    }
-}
diff --git a/src/converter/support/StringConverter.java b/src/converter/support/StringConverter.java
deleted file mode 100644
index a3090b8..0000000
--- a/src/converter/support/StringConverter.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package converter.support;
-
-import converter.Converter;
-import java.util.Arrays;
-import java.util.List;
-
-/**
- * Converts the value to a string. If the value is a byte or char array, it is
- * converted to a string via {@link toString()}.
- *
- */
-public class StringConverter implements Converter<Object, String> {
-
-    @Override
-    public List<Object> getTypes() {
-        return Arrays.asList(
-            String.class,
-            String.class.getName(),
-            "string",
-            "String"
-        );
-    }
-
-    @Override
-    public String convert(Object value) {
-        if (value == null) {
-            return null;
-        }
-
-        if (value.getClass().isArray()) {
-            // This is a byte array; we can convert it to a string
-            if (value.getClass().getComponentType() == Byte.TYPE) {
-                return new String((byte[]) value);
-            } else if (value.getClass().getComponentType() == Character.TYPE) {
-                return new String((char[]) value);
-            }
-        } else if (!(value instanceof String)) {
-            return value.toString();
-        } else {
-            return (String) value;
-        }
-
-        return null;
-    }
-}
diff --git a/src/environment/Environment.java b/src/environment/Environment.java
deleted file mode 100644
index 320d82f..0000000
--- a/src/environment/Environment.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package environment;
-
-public class Environment {
-    
-}
diff --git a/src/event/Event.java b/src/event/Event.java
deleted file mode 100644
index 69e7d83..0000000
--- a/src/event/Event.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package event;
-
-import event.dispatcher.Dispatcher;
-import java.util.UUID;
-
-public class Event {
-
-    private long id;
-    private boolean propagationStopped = false;
-    private Dispatcher dispatcher;
-
-    public Event() {
-        super();
-        this.id = UUID.randomUUID().getMostSignificantBits();
-    }
-
-    public long getId() {
-        return id;
-    }
-
-    public void setId(long id) {
-        this.id = id;
-    }
-
-    public Dispatcher getDispatcher() {
-        return dispatcher;
-    }
-
-    public void setDispatcher(Dispatcher dispatcher) {
-        this.dispatcher = dispatcher;
-    }
-
-    public boolean isPropagationStopped() {
-        return propagationStopped;
-    }
-
-    public void stopEventPropagation() {
-        this.propagationStopped = true;
-    }
-
-}
diff --git a/src/event/dispatcher/Dispatcher.java b/src/event/dispatcher/Dispatcher.java
deleted file mode 100644
index 5fbc9ff..0000000
--- a/src/event/dispatcher/Dispatcher.java
+++ /dev/null
@@ -1,169 +0,0 @@
-package event.dispatcher;
-
-import event.Event;
-import event.handler.Handler;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-
-import java.util.function.Predicate;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-public abstract class Dispatcher<E extends Event> implements DispatcherInterface<E> {
-
-    protected final Logger logger = Logger.getLogger(getClass().getName());
-
-    private Map<String, Map<Integer, Handler<E>>> handlers;
-    
-    private Predicate<E> stopCondition;
-
-    public Dispatcher() {}
-    
-    public Dispatcher(Map<String, Map<Integer, Handler<E>>> handlers) {
-        this.handlers = handlers;
-    }
-    
-    public Dispatcher(Predicate<E> stopCondition) {
-        this.stopCondition = stopCondition;
-    }
-
-    public Dispatcher(Map<String, Map<Integer, Handler<E>>> handlers, Predicate<E> stopCondition) {
-        this.handlers = handlers;
-        this.stopCondition = stopCondition;
-    }
-    
-    public Map<String, Map<Integer, Handler<E>>> getHandlers() {
-        if(this.handlers == null) {
-            this.handlers = new HashMap<>();
-        }
-        
-        return this.handlers;
-    }
-    
-    public Map<Integer, Handler<E>> getHandlers(String name) {
-        return getHandlers().computeIfAbsent(name, (handlers) -> new HashMap<>());
-    }
-    
-    public Handler<E> getHandler(String name, Integer priority) {
-        return getHandlers(name).get(priority);
-    }
-    
-    public boolean hasStopCondition(){
-        return this.stopCondition != null;
-    }
-
-    public <T extends E> Dispatcher<T> of(Class<T> clazz) {
-        return (Dispatcher<T>) this;
-    }
-    
-    @Override
-    public DispatcherInterface<E> register(String name, Integer priority, Handler<E> handler) {
-        
-        if (getHandler(name, priority) != null) {
-            priority = Integer.MAX_VALUE;
-        }
-        
-        getHandlers(name).put(priority, handler);
-        return this;
-    }
-    
-    @Override
-    public DispatcherInterface<E> dispatch(String name, E event) throws Exception {
-        if(!getHandlers().containsKey(name)) {
-            this.logger.log(Level.FINE, "No handlers for {}", name);
-            return this;
-        }
-        
-        String msg = String.format("%s is dispatching an event : %s ", this.getClass().getName(), name);
-        this.logger.finest(msg);
-        
-        Collection<Handler<E>> values = getHandlers(name).values();
-        
-        for (Handler<E> handler : values) {
-            if(hasStopCondition() && this.stopCondition.test(event)) {
-                break;
-            }
-            
-            handler.handle(event);
-        }
-        
-        return this;
-    }
-    
-//    private Handler<E> getLowestPriority(String name) {
-//        
-//        getHandlers().get(name).entrySet()
-//    }
-    
-    
-//    @Override
-//    public void addSubscriber(SubscriberInterface<E> sub) {
-//        if (Objects.isNull(sub)) {
-//            return;
-//        }
-//        
-//        getSubscribers().add(sub);
-//        this.logger.finest(String.format("Subscriber %s has been added to %s.", sub.getClass().getName(), this.getClass().getName()));
-//    }
-    
-//    @Override
-//    public void removeSubscriber(SubscriberInterface<E> subscriber) {
-//        if (getSubscribers().isEmpty() || !getSubscribers().contains(subscriber)) {
-//            return;
-//        }
-//
-//        getSubscribers().remove(subscriber);
-//        this.logger.finest(String.format("Subscriber %s has been removed from %s.", subscriber.getClass().getName(), this.getClass().getName()));
-//    }
-
-    
-//    @Override
-//    public void register(String name, Map<Integer, Handler<E>> handler) {
-//        if (Objects.isNull(handler)) {
-//            return;
-//        }
-//
-//        getHandlers().put(name, handler);
-//        this.logger.finest(String.format("Subscriber %s has been added to %s.", handler.getClass().getName(), this.getClass().getName()));
-//    }
-    
-//        getHandlers().containsKey(msg)
-
-//        for (Handler<E> handler : handlers.values()) {
-//            if(hasStopCondition() || this.stopCondition.test(event)) {
-//                break;
-//            }
-//            handler.handle(event);
-//        }
-        
-//        List<SubscriberInterface<E>> subscribers = getSubscribers().stream()
-//            .filter(Objects::nonNull)
-//            .collect(Collectors.toList());
-//        
-//        for (SubscriberInterface<E> subscriber : subscribers) {
-//            Map<String, Handler<E>> handlers = subscriber.getHandlers();
-//            
-//            for (Handler<E> handler : handlers.values()) {
-//                if(hasStopCondition() || this.stopCondition.test(event)) {
-//                    break;
-//                }
-//                handler.handle(event);
-//            }
-//        }
-        
-//        getSubscribers().stream()
-//            .filter(subscriber -> subscriber != null)
-//            .forEach((SubscriberInterface<T> subscriber) -> {
-//                subscriber.getSubscribedEvents().entrySet().stream()
-//                    .filter(entry -> name.equals(entry.getKey()))
-//                    .map(entry -> entry.getValue())
-//                    .forEach(listener -> {
-//                        if(!hasStopCondition() || !this.stopCondition.test(event)) {
-//                            listener.consume(event);
-//                        }
-//                    });
-//            });
-//    }
-    
-}
diff --git a/src/event/dispatcher/DispatcherInterface.java b/src/event/dispatcher/DispatcherInterface.java
deleted file mode 100644
index b2d9b8c..0000000
--- a/src/event/dispatcher/DispatcherInterface.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package event.dispatcher;
-
-import event.Event;
-import event.handler.Handler;
-import java.util.Map;
-
-public interface DispatcherInterface<E extends Event> {
-    
-    <T extends E> Dispatcher<T> of(Class<T> clazz);
-    DispatcherInterface<E> dispatch(String name, E event) throws Exception;
-    DispatcherInterface<E> register(String name, Integer priority, Handler<E> handler);
-    
-    default DispatcherInterface<E> register(String name, Handler<E> handler) {
-        register(name, 1, handler);
-        return this;
-    }
-    
-    default DispatcherInterface<E> register(String name, Map<Integer, Handler<E>> handlers) {
-        if (handlers == null || handlers.isEmpty()) {
-            return this;
-        }
-        
-        handlers.forEach((priority, handler) -> register(name, priority, handler));
-        return this;
-    }
-}
diff --git a/src/event/dispatcher/EventDispatcher.java b/src/event/dispatcher/EventDispatcher.java
deleted file mode 100644
index bbb553e..0000000
--- a/src/event/dispatcher/EventDispatcher.java
+++ /dev/null
@@ -1,96 +0,0 @@
-package event.dispatcher;
-
-import event.Event;
-import event.handler.Handler;
-import event.subscriber.Subscriber;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.function.Predicate;
-
-public class EventDispatcher extends Dispatcher<Event> {
-
-    public EventDispatcher() {
-        super();
-    }
-    
-    public EventDispatcher(Predicate<Event> stopCondition) {
-        super(stopCondition);
-    }
-
-    @Override
-    public DispatcherInterface<Event> dispatch(final String name, Event event) throws Exception {
-        if (event == null) {
-            event = this.create();
-            this.logger.info(String.format("%s has created an event.", this.getClass().getName()));
-        }
-
-        event.setDispatcher(this);
-        
-        return super.dispatch(name, event);
-    }
-
-    public Event create() {
-        return new Event();
-    }
-    
-    public static EventDispatcherBuilder builder() {
-        return new EventDispatcherBuilder();
-    }
-    
-    public static class EventDispatcherBuilder {
-        
-        private Predicate<Event> stop;
-        
-        private Collection<Subscriber<Event>> subscribers = new ArrayList<>();
-        
-        private Map<String, Map<Integer, Handler<Event>>> handlers;
-    
-        public EventDispatcherBuilder willStopWhen(Predicate<Event> stop) {
-            this.stop = stop;
-            return this;
-        }
-        
-        public EventDispatcherBuilder subscribe(Subscriber<Event> subscriber) {
-            this.subscribers.add(subscriber);
-            return this;
-        }
-        
-        public EventDispatcherBuilder register(String name, Integer priority, Handler<Event> handler) {
-            if (getHandler(name, priority) != null) {
-                priority = Integer.MAX_VALUE;
-            }
-
-            getHandlers(name).put(priority, handler);
-            return this;
-        }
-        
-        public EventDispatcher build() {
-            EventDispatcher dispatcher = new EventDispatcher(this.stop);
-            
-            this.subscribers.forEach((subscriber) -> {
-                subscriber.subscribe(dispatcher);
-            });
-            
-            return dispatcher;
-        }
-        
-        public Map<String, Map<Integer, Handler<Event>>> getHandlers() {
-            if(this.handlers == null) {
-                this.handlers = new HashMap<>();
-            }
-
-            return this.handlers;
-        }
-
-        public Map<Integer, Handler<Event>> getHandlers(String name) {
-            return getHandlers().computeIfAbsent(name, (handlers) -> new HashMap<>());
-        }
-
-        public Handler getHandler(String name, Integer priority) {
-            return getHandlers(name).get(priority);
-        }
-    }
-
-}
diff --git a/src/event/handler/Handler.java b/src/event/handler/Handler.java
deleted file mode 100644
index ff54952..0000000
--- a/src/event/handler/Handler.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package event.handler;
-
-import event.Event;
-
-@FunctionalInterface
-public interface Handler<E extends Event> {
-    
-    void handle(E event);
-}
diff --git a/src/event/subscriber/Subscriber.java b/src/event/subscriber/Subscriber.java
deleted file mode 100644
index 2e2f596..0000000
--- a/src/event/subscriber/Subscriber.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package event.subscriber;
-
-import event.Event;
-import event.dispatcher.DispatcherInterface;
-
-@FunctionalInterface
-public interface Subscriber<E extends Event> {
-
-    void subscribe(DispatcherInterface<E> dispatcher);
-
-}
diff --git a/src/event_old/Event.java b/src/event_old/Event.java
deleted file mode 100644
index 7bf1314..0000000
--- a/src/event_old/Event.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package event_old;
-
-import event_old.dispatcher.Dispatcher;
-import java.util.UUID;
-
-public class Event {
-
-    private long id;
-    private boolean propagationStopped = false;
-    private Dispatcher dispatcher;
-
-    public Event() {
-        super();
-        this.id = UUID.randomUUID().getMostSignificantBits();
-    }
-
-    public long getId() {
-        return id;
-    }
-
-    public void setId(long id) {
-        this.id = id;
-    }
-
-    public Dispatcher getDispatcher() {
-        return dispatcher;
-    }
-
-    public void setDispatcher(Dispatcher dispatcher) {
-        this.dispatcher = dispatcher;
-    }
-
-    public boolean isPropagationStopped() {
-        return propagationStopped;
-    }
-
-    public void stopEventPropagation() {
-        this.propagationStopped = true;
-    }
-
-}
diff --git a/src/event_old/EventConsumer.java b/src/event_old/EventConsumer.java
deleted file mode 100644
index 92e44fc..0000000
--- a/src/event_old/EventConsumer.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package event_old;
-
-@FunctionalInterface
-public interface EventConsumer<T> {
-    
-    void consume(T event) throws Exception;
-}
diff --git a/src/event_old/EventDispatcher.java b/src/event_old/EventDispatcher.java
deleted file mode 100644
index bf70a5d..0000000
--- a/src/event_old/EventDispatcher.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package event_old;
-
-import event_old.dispatcher.Dispatcher;
-
-public class EventDispatcher extends Dispatcher<Event> {
-
-    public EventDispatcher() {
-        super(event -> event.isPropagationStopped());
-    }
-
-    @Override
-    public void dispatch(final String name, Event event) throws Exception {
-        if (event == null) {
-            event = this.create();
-            this.logger.info(String.format("%s has created an event.", this.getClass().getName()));
-        }
-
-        event.setDispatcher(this);
-        
-        super.dispatch(name, event);
-    }
-
-    @Override
-    public Event create() {
-        return new Event();
-    }
-}
diff --git a/src/event_old/EventSubscriber.java b/src/event_old/EventSubscriber.java
deleted file mode 100644
index c8ecff6..0000000
--- a/src/event_old/EventSubscriber.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package event_old;
-
-import event_old.subscriber.SubscriberInterface;
-import java.util.Map;
-import java.util.logging.Logger;
-
-public abstract class EventSubscriber<T extends Event> implements SubscriberInterface<T> {
-
-    protected final Logger logger = Logger.getLogger(getClass().getName());
-    
-    @Override
-    public abstract Map<String, EventConsumer<T>> getSubscribedEvents();
-
-}
diff --git a/src/event_old/dispatcher/Dispatcher.java b/src/event_old/dispatcher/Dispatcher.java
deleted file mode 100644
index c93d493..0000000
--- a/src/event_old/dispatcher/Dispatcher.java
+++ /dev/null
@@ -1,104 +0,0 @@
-package event_old.dispatcher;
-
-import event_old.Event;
-import event_old.EventConsumer;
-import java.util.List;
-import java.util.ArrayList;
-
-import event_old.subscriber.SubscriberInterface;
-import java.util.Map;
-import java.util.Objects;
-import java.util.function.Predicate;
-import java.util.logging.Logger;
-import java.util.stream.Collectors;
-
-public abstract class Dispatcher<T extends Event> implements DispatcherInterface<T> {
-
-    protected final Logger logger = Logger.getLogger(getClass().getName());
-
-    private List<SubscriberInterface<T>> subscribers;
-    
-    private Predicate<T> stopCondition;
-
-    public Dispatcher() {}
-    
-    public Dispatcher(List<SubscriberInterface<T>> subscribers) {
-        this.subscribers = subscribers;
-    }
-    
-    public Dispatcher(Predicate<T> stopCondition) {
-        this.stopCondition = stopCondition;
-    }
-    
-    public Dispatcher(List<SubscriberInterface<T>> subscribers, Predicate<T> stopCondition) {
-        this.subscribers = subscribers;
-        this.stopCondition = stopCondition;
-    }
-
-    public List<SubscriberInterface<T>> getSubscribers() {
-        if(this.subscribers == null) {
-            this.subscribers = new ArrayList<>();
-        }
-        
-        return this.subscribers;
-    }
-    
-    public boolean hasStopCondition(){
-        return this.stopCondition != null;
-    }
-    
-    @Override
-    public void addSubscriber(SubscriberInterface<T> sub) {
-        if (Objects.isNull(sub)) {
-            return;
-        }
-        
-        getSubscribers().add(sub);
-        this.logger.finest(String.format("Subscriber %s has been added to %s.", sub.getClass().getName(), this.getClass().getName()));
-    }
-    
-    @Override
-    public void removeSubscriber(SubscriberInterface<T> subscriber) {
-        if (getSubscribers().isEmpty() || !getSubscribers().contains(subscriber)) {
-            return;
-        }
-
-        getSubscribers().remove(subscriber);
-        this.logger.finest(String.format("Subscriber %s has been removed from %s.", subscriber.getClass().getName(), this.getClass().getName()));
-    }
-
-    @Override
-    public void dispatch(String name, T event) throws Exception {
-        String msg = String.format("%s is dispatching an event : %s ", this.getClass().getName(), name);
-        this.logger.finest(msg);
-        
-        List<SubscriberInterface<T>> subscribers = getSubscribers().stream()
-            .filter(Objects::nonNull)
-            .collect(Collectors.toList());
-        
-        for (SubscriberInterface<T> subscriber : subscribers) {
-            
-            Map<String, EventConsumer<T>> subscribedEvents = subscriber.getSubscribedEvents();
-            
-            for (EventConsumer<T> consumer : subscribedEvents.values()) {
-                if(!hasStopCondition() || !this.stopCondition.test(event)) {
-                    consumer.consume(event);
-                }
-            }
-        }
-        
-//        getSubscribers().stream()
-//            .filter(subscriber -> subscriber != null)
-//            .forEach((SubscriberInterface<T> subscriber) -> {
-//                subscriber.getSubscribedEvents().entrySet().stream()
-//                    .filter(entry -> name.equals(entry.getKey()))
-//                    .map(entry -> entry.getValue())
-//                    .forEach(listener -> {
-//                        if(!hasStopCondition() || !this.stopCondition.test(event)) {
-//                            listener.consume(event);
-//                        }
-//                    });
-//            });
-    }
-    
-}
diff --git a/src/event_old/dispatcher/DispatcherInterface.java b/src/event_old/dispatcher/DispatcherInterface.java
deleted file mode 100644
index 0eb19de..0000000
--- a/src/event_old/dispatcher/DispatcherInterface.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package event_old.dispatcher;
-
-import event_old.subscriber.SubscriberInterface;
-
-public interface DispatcherInterface<T> {
-
-    T create();
-    
-    void dispatch(String name, T event) throws Exception;
-
-    void addSubscriber(SubscriberInterface<T> sub);
-    
-    void removeSubscriber(SubscriberInterface<T> sub);
-
-}
diff --git a/src/event_old/subscriber/Subscriber.java b/src/event_old/subscriber/Subscriber.java
deleted file mode 100644
index a2cbd0c..0000000
--- a/src/event_old/subscriber/Subscriber.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package event_old.subscriber;
-
-import event_old.EventConsumer;
-import java.util.Map;
-
-public abstract class Subscriber<T> implements SubscriberInterface<T> {
-
-    @Override
-    public abstract Map<String, EventConsumer<T>> getSubscribedEvents();
-    
-}
diff --git a/src/event_old/subscriber/SubscriberInterface.java b/src/event_old/subscriber/SubscriberInterface.java
deleted file mode 100644
index 3027369..0000000
--- a/src/event_old/subscriber/SubscriberInterface.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package event_old.subscriber;
-
-import event_old.EventConsumer;
-import java.util.Map;
-
-public interface SubscriberInterface<T> {
-    
-    Map<String, EventConsumer<T>> getSubscribedEvents();
-    
-}
diff --git a/src/expressionLanguage/Engine.java b/src/expressionLanguage/Engine.java
deleted file mode 100644
index 15cf06f..0000000
--- a/src/expressionLanguage/Engine.java
+++ /dev/null
@@ -1,225 +0,0 @@
-package expressionLanguage;
-
-import expressionLanguage.extension.ExtensionRegistry;
-import expressionLanguage.lexer.Lexer;
-import expressionLanguage.model.position.Source;
-import expressionLanguage.model.template.Template;
-import expressionLanguage.model.tree.RootNode;
-import expressionLanguage.model.visitor.BlockRegistrantVisitor;
-import expressionLanguage.model.visitor.MacroRegistrantVisitor;
-import expressionLanguage.token.parser.Parser;
-import expressionLanguage.scope.ScopeChain;
-import expressionLanguage.token.TokenStream;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.Locale;
-import java.util.Map;
-import java.util.concurrent.ExecutorService;
-import java.util.function.Predicate;
-import java.util.stream.Stream;
-import resource.ResourceService;
-
-/**
- * The main class used for compiling templates. The PebbleEngine is responsible
- * for delegating responsibility to the lexer, parser, compiler, and template
- * cache.
- */
-public class Engine {
-
-    private final ResourceService resourceService;
-
-    private final Lexer lexer;
-
-    private final Parser<TokenStream, RootNode> parser;
-
-    private final boolean strictVariables;
-
-    private final ExtensionRegistry extensionRegistry;
-
-    private final Locale defaultLocale;
-
-    private final ExecutorService executorService;
-
-    public Engine(ResourceService resourceService,
-            Lexer lexer,
-            Parser parser,
-            ExtensionRegistry extensionRegistry,
-            boolean strictVariables,
-            Locale defaultLocale,
-            ExecutorService executorService) {
-
-        this.resourceService = resourceService;
-        this.lexer = lexer;
-        this.parser = parser;
-        this.extensionRegistry = extensionRegistry;
-        this.strictVariables = strictVariables;
-        this.defaultLocale = defaultLocale;
-        this.executorService = executorService;
-    }
-
-    /**
-     * Loads, parses, and compiles a template into an instance of PebbleTemplate
-     * and returns this instance.
-     *
-     * @param name The name of the template
-     * @return Template The compiled version of the template
-     * @throws Exception Thrown if an error occurs while parsing the template.
-     */
-    public Template load(final String name) throws Exception {
-
-        /*
-         * template name will be null if user uses the extends tag with an
-         * expression that evaluates to null
-         */
-        if (name == null) {
-            return null;
-        }
-
-        InputStream stream = this.resourceService.load(name);
-        Reader reader = new InputStreamReader(stream);
-        Source source = Source.builder(name).read(reader).build();
-        TokenStream tokenStream = this.lexer.tokenize(source);
-        RootNode root = this.parser.parse(tokenStream);
-
-//        final Engine self = this;
-        Template instance = new Template(this, root, name);
-
-        evaluate(instance);
-
-        return instance;
-    }
-
-    public void evaluate(Template root) throws Exception {
-        EvaluationContext context = initContext(root, null);
-        evaluate(root, context);
-    }
-
-    public void evaluate(Template root, Locale locale) throws Exception {
-        EvaluationContext context = initContext(root, locale);
-        evaluate(root, context);
-    }
-
-    public void evaluate(Template root, Map<String, Object> map) throws Exception {
-        EvaluationContext context = initContext(root, null);
-        context.getScopeChain().pushScope(map);
-        evaluate(root, context);
-    }
-
-    public void evaluate(Template root, Map<String, Object> map, Locale locale) throws Exception {
-        EvaluationContext context = initContext(root, locale);
-        context.getScopeChain().pushScope(map);
-        evaluate(root, context);
-    }
-
-    /**
-     * This is the authoritative evaluate method. It will evaluate the template
-     * starting at the root node.
-     *
-     * @param writer The writer used to write the final output of the template
-     * @param context The evaluation context
-     * @throws Exception Thrown from the writer object
-     */
-    private void evaluate(Template root, EvaluationContext context) throws Exception {
-
-//        root.accept((node) -> {
-//            System.out.println("Node : ");
-//            System.out.println(Objects.toString(node));
-//        });
-//        System.out.println(root);
-        // Eval logic HERE 
-//        template.
-//        rootNode.render(this, context);
-
-        Stream.concat(
-            Stream.of(new BlockRegistrantVisitor(root), new MacroRegistrantVisitor(root)), 
-            this.extensionRegistry.getVisitors().stream()
-        ).forEach(root.getRootNode()::accept);
-
-        /*
-         * If the current template has a parent then we know the current template
-         * was only used to evaluate a very small subset of tags such as "set" and "import".
-         * We now evaluate the parent template as to evaluate all of the actual content.
-         * When evaluating the parent template, it will check the child template for overridden blocks.
-         */
-        if (context.getHierarchy().getParent() != null) {
-            Template parent = context.getHierarchy().getParent();
-            context.getHierarchy().ascend();
-            evaluate(parent, context);
-        }
-    }
-
-    /**
-     * Initializes the evaluation context with settings from the engine.
-     *
-     * @param locale The desired locale
-     * @return The evaluation context
-     */
-    private EvaluationContext initContext(Template root, Locale locale) {
-        locale = locale == null ? getDefaultLocale() : locale;
-
-        // globals
-        Map<String, Object> globals = new HashMap<>();
-        globals.put("locale", locale);
-        globals.put("template", root);
-        ScopeChain scopeChain = new ScopeChain(globals);
-
-        // global vars provided from extensions
-        scopeChain.pushScope(getExtensionRegistry().getGlobalVariables());
-
-        EvaluationContext context = new EvaluationContext(root,
-                isStrictVariables(), locale,
-                getExtensionRegistry(), getExecutorService(),
-                new ArrayList<>(), scopeChain, null);
-        return context;
-    }
-
-    /**
-     * Returns the resourceService
-     *
-     * @return The resourceService
-     */
-    public ResourceService getResourceService() {
-        return resourceService;
-    }
-
-    /**
-     * Returns the strict variables setting
-     *
-     * @return The strict variables setting
-     */
-    public boolean isStrictVariables() {
-        return strictVariables;
-    }
-
-    /**
-     * Returns the default locale
-     *
-     * @return The default locale
-     */
-    public Locale getDefaultLocale() {
-        return defaultLocale;
-    }
-
-    /**
-     * Returns the executor service
-     *
-     * @return The executor service
-     */
-    public ExecutorService getExecutorService() {
-        return executorService;
-    }
-
-    /**
-     * Returns the extension registry.
-     *
-     * @return The extension registry
-     */
-    public ExtensionRegistry getExtensionRegistry() {
-        return extensionRegistry;
-    }
-
-}
diff --git a/src/expressionLanguage/EvaluationContext.java b/src/expressionLanguage/EvaluationContext.java
deleted file mode 100644
index d401696..0000000
--- a/src/expressionLanguage/EvaluationContext.java
+++ /dev/null
@@ -1,183 +0,0 @@
-package expressionLanguage;
-
-import expressionLanguage.model.template.Hierarchy;
-import expressionLanguage.extension.ExtensionRegistry;
-import expressionLanguage.model.template.Template;
-import expressionLanguage.scope.ScopeChain;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Locale;
-import java.util.concurrent.ExecutorService;
-
-/**
- * An evaluation context will store all stateful data that is necessary for the
- * evaluation of a template. Passing the entire state around will assist with
- * thread safety.
- *
- */
-public class EvaluationContext {
-
-    private final boolean strictVariables;
-
-    /**
-     * A template will look to it's parent and children for overridden macros
-     * and other features; this inheritance chain will help the template keep
-     * track of where in the inheritance chain it currently is.
-     */
-    private final Hierarchy hierarchy;
-
-    /**
-     * A scope is a set of visible variables. A trivial template will only have
-     * one scope. New scopes are added with for loops and macros for example.
-     * <p>
-     * Most scopes will have a link to their parent scope which allow an
-     * evaluation to look up the scope chain for variables. A macro is an
-     * exception to this as it only has access to it's local variables.
-     */
-    private final ScopeChain scopeChain;
-
-    /**
-     * The locale of this template.
-     */
-    private final Locale locale;
-
-    /**
-     * All the available filters/tests/functions for this template.
-     */
-    private final ExtensionRegistry extensionRegistry;
-
-    /**
-     * The user-provided ExecutorService (can be null).
-     */
-    private final ExecutorService executorService;
-
-    /**
-     * The imported templates are used to look up macros.
-     */
-    private final List<Template> imported;
-    
-    /**
-     * Constructor used to provide all final variables.
-     *
-     * @param self The template implementation
-     * @param strictVariables Whether strict variables is to be used
-     * @param locale The locale of the template
-     * @param extensionRegistry The extension registry
-     * @param executorService The optional executor service
-     * @param imported
-     * @param scopeChain The scope chain
-     * @param hierarchy The inheritance chain
-     */
-    public EvaluationContext(Template self, boolean strictVariables, Locale locale,
-            ExtensionRegistry extensionRegistry,
-            ExecutorService executorService, List<Template> imported, ScopeChain scopeChain,
-            Hierarchy hierarchy) {
-
-        if (hierarchy == null) {
-            hierarchy = new Hierarchy(self);
-        }
-
-        this.strictVariables = strictVariables;
-        this.locale = locale;
-        this.extensionRegistry = extensionRegistry;
-        this.executorService = executorService;
-        this.imported = imported;
-        this.scopeChain = scopeChain;
-        this.hierarchy = hierarchy;
-    }
-
-    /**
-     * Makes an exact copy of the evaluation context EXCEPT for the inheritance
-     * chain. This is necessary for the "include" tag.
-     *
-     * @param self The template implementation
-     * @return A copy of the evaluation context
-     */
-    public EvaluationContext shallowCopyWithoutInheritanceChain(Template self) {
-        EvaluationContext result = new EvaluationContext(self, strictVariables, locale, extensionRegistry, executorService, imported, scopeChain, null);
-        return result;
-    }
-
-    /**
-     * Makes a "snapshot" of the evaluation context. The scopeChain object will
-     * be a deep copy and the imported templates will be a new list. This is
-     * used for the "parallel" tag.
-     *
-     * @param self The template implementation
-     * @return A copy of the evaluation context
-     */
-    public EvaluationContext threadSafeCopy(Template self) {
-        EvaluationContext result = new EvaluationContext(self, strictVariables, locale, extensionRegistry, executorService, new ArrayList<>(imported), scopeChain.deepCopy(), hierarchy);
-        return result;
-    }
-
-    /**
-     * Returns whether or not this template is being evaluated in "strict
-     * templates" mode
-     *
-     * @return Whether or not this template is being evaluated in "strict
-     * tempaltes" mode.
-     */
-    public boolean isStrictVariables() {
-        return strictVariables;
-    }
-
-    /**
-     * Returns the locale
-     *
-     * @return The current locale
-     */
-    public Locale getLocale() {
-        return locale;
-    }
-
-    /**
-     * Returns the extension registry used to access all of the
-     * tests/filters/functions
-     *
-     * @return The extension registry
-     */
-    public ExtensionRegistry getExtensionRegistry() {
-        return extensionRegistry;
-    }
-
-    /**
-     * Returns the executor service if exists or null
-     *
-     * @return The executor service if exists, or null
-     */
-    public ExecutorService getExecutorService() {
-        return executorService;
-    }
-
-    /**
-     * Returns a list of imported Templates.
-     *
-     * @return A list of imported Templates.
-     */
-    public List<Template> getImported() {
-        return this.imported;
-    }
-    
-    /**
-     * Returns the scope chain data structure that allows variables to be
-     * added/removed from the current scope and retrieved from the nearest
-     * visible scopes.
-     *
-     * @return The scope chain.
-     */
-    public ScopeChain getScopeChain() {
-        return scopeChain;
-    }
-
-    /**
-     * Returns the data structure representing the entire hierarchy of the
-     * template currently being evaluated.
-     *
-     * @return The inheritance chain
-     */
-    public Hierarchy getHierarchy() {
-        return hierarchy;
-    }
-
-}
diff --git a/src/expressionLanguage/expression/BinaryExpression.java b/src/expressionLanguage/expression/BinaryExpression.java
deleted file mode 100644
index 696ea70..0000000
--- a/src/expressionLanguage/expression/BinaryExpression.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package expressionLanguage.expression;
-
-public abstract class BinaryExpression<T> implements Expression<T> {
-
-    private Expression<?> leftExpression;
-
-    private Expression<?> rightExpression;
-
-    public void setLeftExpression(Expression<?> left) {
-        this.leftExpression = left;
-    }
-
-    public void setRightExpression(Expression<?> right) {
-        this.rightExpression = right;
-    }
-
-    public Expression<?> getLeftExpression() {
-        return leftExpression;
-    }
-
-    public Expression<?> getRightExpression() {
-        return rightExpression;
-    }
-}
diff --git a/src/expressionLanguage/expression/Expression.java b/src/expressionLanguage/expression/Expression.java
deleted file mode 100644
index 93408ab..0000000
--- a/src/expressionLanguage/expression/Expression.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package expressionLanguage.expression;
-
-import expressionLanguage.EvaluationContext;
-
-@FunctionalInterface
-public interface Expression<T> {
-
-    T evaluate(EvaluationContext context);
-}
diff --git a/src/expressionLanguage/expression/UnaryExpression.java b/src/expressionLanguage/expression/UnaryExpression.java
deleted file mode 100644
index 4ee7603..0000000
--- a/src/expressionLanguage/expression/UnaryExpression.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package expressionLanguage.expression;
-
-public abstract class UnaryExpression implements Expression<Object> {
-
-    private Expression<?> childExpression;
-
-    public Expression<?> getChildExpression() {
-        return childExpression;
-    }
-
-    public void setChildExpression(Expression<?> childExpression) {
-        this.childExpression = childExpression;
-    }
-}
diff --git a/src/expressionLanguage/expression/parser/ExpressionParser.java b/src/expressionLanguage/expression/parser/ExpressionParser.java
deleted file mode 100644
index b35f77b..0000000
--- a/src/expressionLanguage/expression/parser/ExpressionParser.java
+++ /dev/null
@@ -1,570 +0,0 @@
-package expressionLanguage.expression.parser;
-
-import expressionLanguage.token.parser.Parser;
-import expressionLanguage.extension.core.expression.*;
-
-import expressionLanguage.expression.*;
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.tree.*;
-import expressionLanguage.operator.*;
-import expressionLanguage.token.*;
-import expressionLanguage.token.parser.TokenStreamParser;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-
-import jdk.nashorn.internal.runtime.ParserException;
-
-/**
- * Parses expressions.
- */
-public class ExpressionParser {
-
-    private static final Set<String> RESERVED_KEYWORDS = new HashSet<>(Arrays.asList("true", "false", "null", "none"));
-
-    private final TokenStreamParser parser;
-
-    private TokenStream stream;
-
-    private final Map<String, Operator> operators;
-
-    /**
-     * Constructor
-     *
-     * @param parser A reference to the main parser
-     * @param operators All the operators
-     */
-    public ExpressionParser(TokenStreamParser parser, Map<String, Operator> operators) {
-        this.parser = parser;
-        this.operators = operators;
-    }
-
-    /**
-     * The public entry point for parsing an expression.
-     *
-     * @return NodeExpression the expression that has been parsed.
-     */
-    public Expression<?> parseExpression() {
-        return parseExpression(0);
-    }
-
-    /**
-     * A private entry point for parsing an expression. This method takes in the
-     * precedence required to operate a "precedence climbing" parsing algorithm.
-     * It is a recursive method.
-     *
-     * @see http://en.wikipedia.org/wiki/Operator-precedence_parser
-     *
-     * @return The NodeExpression representing the parsed expression.
-     * @throws ParserException Thrown if a parsing error occurs.
-     */
-    private Expression<?> parseExpression(int minPrecedence) {
-
-        this.stream = parser.getStream();
-        Token token = stream.current();
-        Expression<?> expression = null;
-
-        /*
-         * The first check is to see if the expression begins with a unary
-         * operator, or an opening bracket, or neither.
-         */
-        if (isUnary(token)) {
-            Operator operator = this.operators.get(token.getValue());
-            stream.next();
-            expression = parseExpression(operator.getPrecedence());
-
-            UnaryExpression unaryExpression = null;
-            Class<? extends Expression<?>> operatorExpression = operator.getExpression();
-            try {
-                unaryExpression = (UnaryExpression) operatorExpression.newInstance();
-//                unaryExpression.setLineNumber(stream.current().getLineNumber());
-            } catch (InstantiationException | IllegalAccessException e) {
-                throw new RuntimeException(e);
-            }
-            unaryExpression.setChildExpression(expression);
-
-            expression = unaryExpression;
-
-        } else if (token.isA(Type.PUNCTUATION, "(")) {
-
-            stream.next();
-            expression = parseExpression();
-            stream.expect(Type.PUNCTUATION, ")");
-            expression = parsePostfixExpression(expression);
-
-        }  else if (token.isA(Type.PUNCTUATION, "[")) { // array definition syntax
-
-            // preserve [ token for array parsing
-            expression = parseArrayDefinitionExpression();
-            // don't expect ], because it has been already expected
-            // currently, postfix expressions are not supported for arrays
-            // expression = parsePostfixExpression(expression);
-        }  else if (token.isA(Type.PUNCTUATION, "{")) { // map definition syntax
-
-            // preserve { token for map parsing
-            expression = parseMapDefinitionExpression();
-            // don't expect }, because it has been already expected
-            // currently, postfix expressions are not supported for maps
-            // expression = parsePostfixExpression(expression);
-
-        } else {
-            /*
-             * starts with neither. Let's parse out the first expression that we
-             * can find. There may be one, there may be many (separated by
-             * binary operators); right now we are just looking for the first.
-             */
-            expression = subparseExpression();
-        }
-
-        /*
-         * If, after parsing the first expression we encounter a binary operator
-         * then we know we have another expression on the other side of the
-         * operator that requires parsing. Otherwise we're done.
-         */
-        token = stream.current();
-        while (isBinary(token) && operators.get(token.getValue()).getPrecedence() >= minPrecedence) {
-
-            // find out which operator we are dealing with and then skip over it
-            Operator operator = operators.get(token.getValue());
-            stream.next();
-
-            Expression<?> expressionRight = null;
-
-            // the right hand expression of the FILTER operator is handled in a
-            // unique way
-            if (FilterExpression.class.equals(operator.getExpression())) {
-                expressionRight = parseFilterInvocationExpression();
-            }  else if (PositiveTestExpression.class.equals(operator.getExpression())
-                    || NegativeTestExpression.class.equals(operator.getExpression())) {
-                // the right hand expression of TEST operators is handled in a
-                // unique way
-//                expressionRight = parseTestInvocationExpression();
-            } else {
-                /*
-                 * parse the expression on the right hand side of the operator
-                 * while maintaining proper associativity and precedence
-                 */
-//                Associativity.LEFT.equals(operator.getAssociativity()) ? operator.getPrecedence() + 1 : operator.getPrecedence();
-                expressionRight = parseExpression(operator.getPrecedence());
-            }
-
-            /*
-             * we have to wrap the left and right side expressions into one
-             * final expression. The operator provides us with the type of
-             * expression we are creating.
-             */
-            BinaryExpression<?> finalExpression = null;
-            Class<? extends Expression<?>> operatorExpression = operator.getExpression();
-            try {
-                finalExpression = (BinaryExpression<?>) operatorExpression.newInstance();
-//                finalExpression.setLineNumber(stream.current().getPosition());
-            } catch (InstantiationException | IllegalAccessException e) {
-                String msg = String.format("Error instantiating operator node [%s] at %s.", operatorExpression.getName(), token.getPosition());
-                throw new IllegalStateException(msg);
-            }
-
-            finalExpression.setLeftExpression(expression);
-            finalExpression.setRightExpression(expressionRight);
-
-            expression = finalExpression;
-
-            token = stream.current();
-        }
-
-        if (minPrecedence == 0) {
-            return parseTernaryExpression(expression);
-        }
-
-        return expression;
-    }
-
-    /**
-     * Checks if a token is a unary operator.
-     *
-     * @param token The token that we are checking
-     * @return boolean Whether the token is a unary operator or not
-     */
-    private boolean isUnary(Token token) {
-        return token.isA(Type.OPERATOR) && this.operators.containsKey(token.getValue()) && (this.operators.get(token.getValue()) instanceof UnaryOperator);
-    }
-
-    /**
-     * Checks if a token is a binary operator.
-     *
-     * @param token The token that we are checking
-     * @return boolean Whether the token is a binary operator or not
-     */
-    private boolean isBinary(Token token) {
-        return token.isA(Type.OPERATOR) && this.operators.containsKey(token.getValue()) && (this.operators.get(token.getValue()) instanceof BinaryOperator);
-    }
-
-    /**
-     * Finds and returns the next "simple" expression; an expression of which
-     * can be found on either side of a binary operator but does not contain a
-     * binary operator. Ex. "var.field", "true", "12", etc.
-     *
-     * @return NodeExpression The expression that it found.
-     * @throws Exception Thrown if a parsing error occurs.
-     */
-    private Expression<?> subparseExpression() {
-        final Token token = stream.current();
-        Expression<?> node = null;
-
-        switch (token.getType()) {
-
-            case NAME:
-                switch (token.getValue()) {
-
-                    // a constant?
-                    case "true":
-                    case "TRUE":
-                        node = new LiteralBooleanExpression(true);
-                        break;
-                    case "false":
-                    case "FALSE":
-                        node = new LiteralBooleanExpression(false);
-                        break;
-                    case "none":
-                    case "NONE":
-                    case "null":
-                    case "NULL":
-                        node = new LiteralNullExpression();
-                        break;
-
-                    default:
-
-                        // name of a function?
-                        if (stream.peek().isA(Type.PUNCTUATION, "(")) {
-                            node = new FunctionOrMacroNameNode(stream.peek().getPosition(), token.getValue());
-                        } // variable name
-                        else {
-                            node = new ContextVariableExpression(token.getValue());
-                        }
-                        break;
-                }
-                break;
-
-            case NUMBER:
-                final String numberValue = token.getValue();
-                if (numberValue.contains(".")) {
-                    node = new LiteralDoubleExpression(Double.valueOf(numberValue));
-                } else {
-                    node = new LiteralLongExpression(Long.valueOf(numberValue));
-                }
-
-                break;
-
-            case STRING:
-                node = new LiteralStringExpression(token.getValue());
-                break;
-
-            // not found, syntax error
-            default:
-                String msg = String.format("Unexpected token \"%s\" of value \"%s\" at line %s in file %s.", token.getType()
-                        .toString(), token.getValue(), token.getPosition(), stream.getFilename());
-                throw new IllegalStateException(msg);
-        }
-
-        // there may or may not be more to this expression - let's keep looking
-        stream.next();
-        return parsePostfixExpression(node);
-    }
-
-    private Expression<?> parseTernaryExpression(Expression<?> expression) {
-        // if the next token isn't a ?, we're not dealing with a ternary expression
-        if (!stream.current().isA(Type.PUNCTUATION, "?")) {
-            return expression;
-        }
-
-        stream.next();
-        Expression<?> expression2 = parseExpression();
-        stream.expect(Type.PUNCTUATION, ":");
-        Expression<?> expression3 = parseExpression();
-
-        expression = new TernaryExpression((Expression<Boolean>) expression, expression2, expression3, stream.getFilename());
-        return expression;
-    }
-
-    /**
-     * Determines if there is more to the provided expression than we originally
-     * thought. We will look for the filter operator or perhaps we are getting
-     * an attribute from a variable (ex. var.attribute or var['attribute'] or
-     * var.attribute(bar)).
-     *
-     * @param node The expression that we have already discovered
-     * @return Either the original expression that was passed in or a slightly
-     * modified version of it, depending on what was discovered.
-     */
-    private Expression<?> parsePostfixExpression(Expression<?> node) {
-        Token current;
-        while (true) {
-            current = stream.current();
-
-            if (current.isA(Type.PUNCTUATION, ".") || current.isA(Type.PUNCTUATION, "[")) {
-
-                // a period represents getting an attribute from a variable or
-                // calling a method
-                node = parseBeanAttributeExpression(node);
-
-            } else if (current.isA(Type.PUNCTUATION, "(")) {
-
-                // function call
-                node = parseFunctionOrMacroInvocation(node);
-
-            } else {
-                break;
-            }
-        }
-        return node;
-    }
-
-    private Expression<?> parseFunctionOrMacroInvocation(Expression<?> node) {
-        String functionName = ((FunctionOrMacroNameNode) node).getName();
-        ArgumentsNode args = parseArguments();
-
-        /*
-         * The following core functions have their own Nodes and are rendered in
-         * unique ways for the sake of performance.
-         */
-        switch (functionName) {
-            case "parent":
-                return new ParentFunctionExpression(parser.peekBlockStack());
-            case "block":
-                return new BlockFunctionExpression(args);
-        }
-
-        return new FunctionOrMacroInvocationExpression(functionName, args);
-    }
-
-    public FilterInvocationExpression parseFilterInvocationExpression() {
-        TokenStream stream = parser.getStream();
-        Token filterToken = stream.expect(Type.NAME);
-
-        ArgumentsNode args = null;
-        if (stream.current().isA(Type.PUNCTUATION, "(")) {
-            args = this.parseArguments();
-        } else {
-//            args = new ArgumentsNode(filterToken.getPosition(), null, null);
-        }
-
-        return new FilterInvocationExpression(filterToken.getValue(), args);
-    }
-
-//    private Expression<?> parseTestInvocationExpression() {
-//        TokenStream stream = parser.getStream();
-//        Position position = stream.current().getPosition();
-//
-//        Token testToken = stream.expect(Type.NAME);
-//
-//        ArgumentsNode args = null;
-//        if (stream.current().isA(Type.PUNCTUATION, "(")) {
-//            args = this.parseArguments();
-//        } else {
-////            args = new ArgumentsNode(testToken.getPosition(), null, null);
-//        }
-//
-////        return new TestInvocationExpression(position, testToken.getValue(), args);
-//        return new TestInvocationExpression(position, testToken.getValue());
-//    }
-
-    /**
-     * A bean attribute expression can either be an expression getting an
-     * attribute from a variable in the context, or calling a method from a
-     * variable.
-     *
-     * Ex. foo.bar or foo['bar'] or foo.bar('baz')
-     *
-     * @param node The expression parsed so far
-     * @return NodeExpression The parsed subscript expression
-     */
-    private Expression<?> parseBeanAttributeExpression(Expression<?> node) {
-        TokenStream stream = parser.getStream();
-
-        if (stream.current().isA(Type.PUNCTUATION, ".")) {
-
-            // skip over the '.' token
-            stream.next();
-
-            Token token = stream.expect(Type.NAME);
-
-            ArgumentsNode args = null;
-            if (stream.current().isA(Type.PUNCTUATION, "(")) {
-                args = this.parseArguments();
-//                if (!args.getNamedArgs().isEmpty()) {
-//                    String msg = String.format("Can not use named arguments when calling a bean method at line %s in file %s.", stream.current().getPosition(), stream.getFilename());
-//                    throw new IllegalStateException(msg);
-//                }
-            }
-
-            node = new GetAttributeExpression(node, new LiteralStringExpression(token.getValue()), args,
-                    stream.getFilename());
-
-        } else if (stream.current().isA(Type.PUNCTUATION, "[")) {
-            // skip over opening '[' bracket
-            stream.next();
-
-            node = new GetAttributeExpression(node, parseExpression(), stream.getFilename());
-
-            // move past the closing ']' bracket
-            stream.expect(Type.PUNCTUATION, "]");
-        }
-
-        return node;
-    }
-
-    public ArgumentsNode parseArguments() {
-        return parseArguments(false);
-    }
-
-    public ArgumentsNode parseArguments(boolean isMacroDefinition) {
-
-        List<ArgumentNode> positionalArgs = new ArrayList<>();
-        List<NamedArgumentNode> namedArgs = new ArrayList<>();
-        this.stream = this.parser.getStream();
-
-        stream.expect(Type.PUNCTUATION, "(");
-
-        while (!stream.current().isA(Type.PUNCTUATION, ")")) {
-
-            String argumentName = null;
-            Expression<?> argumentValue = null;
-
-            if (!namedArgs.isEmpty() || !positionalArgs.isEmpty()) {
-                stream.expect(Type.PUNCTUATION, ",");
-            }
-
-            /*
-             * Most arguments consist of VALUES with optional NAMES but in the
-             * case of a macro definition the user is specifying NAMES with
-             * optional VALUES. Therefore the logic changes slightly.
-             */
-            if (isMacroDefinition) {
-                argumentName = parseNewVariableName();
-                if (stream.current().isA(Type.PUNCTUATION, "=")) {
-                    stream.expect(Type.PUNCTUATION, "=");
-                    argumentValue = parseExpression();
-                }
-            } else {
-                if (stream.peek().isA(Type.PUNCTUATION, "=")) {
-                    argumentName = parseNewVariableName();
-                    stream.expect(Type.PUNCTUATION, "=");
-                }
-                argumentValue = parseExpression();
-            }
-
-            if (argumentName == null) {
-                if (!namedArgs.isEmpty()) {
-                    String msg = String.format("Positional arguments must be declared before any named arguments at line %s in file %s.", stream.current()
-                            .getPosition(), stream.getFilename());
-                    throw new IllegalArgumentException(msg);
-                }
-                positionalArgs.add(new ArgumentNode(stream.current()
-                            .getPosition(), argumentValue));
-            } else {
-                namedArgs.add(new NamedArgumentNode(stream.current()
-                            .getPosition(), argumentName, argumentValue));
-            }
-
-        }
-
-        stream.expect(Type.PUNCTUATION, ")");
-
-//        return new ArgumentsNode(stream.current()
-//                            .getPosition(), positionalArgs, namedArgs);
-        return new ArgumentsNode(stream.current()
-                            .getPosition(), positionalArgs);
-    }
-
-    /**
-     * Parses a new variable that will need to be initialized in the Java code.
-     *
-     * This is used for the set tag, the for loop, and in named arguments.
-     *
-     * @return A variable name
-     */
-    public String parseNewVariableName() {
-
-        // set the stream because this function may be called externally (for
-        // and set token parsers)
-        this.stream = this.parser.getStream();
-        Token token = stream.current();
-        token.isA(Type.NAME);
-
-        if (RESERVED_KEYWORDS.contains(token.getValue())) {
-            String msg = String.format("Can not assign a value to %s at line %s in file %s.", token.getValue(), token.getPosition(), stream.getFilename());
-            throw new IllegalAccessError(msg);
-        }
-
-        stream.next();
-        return token.getValue();
-    }
-
-    private Expression<?> parseArrayDefinitionExpression() {
-        TokenStream stream = parser.getStream();
-
-        // expect the opening bracket and check for an empty array
-        stream.expect(Type.PUNCTUATION, "[");
-        if (stream.current().isA(Type.PUNCTUATION, "]")) {
-            stream.next();
-            return new ArrayExpression();
-        }
-
-        // there's at least one expression in the array
-        List<Expression<?>> elements = new ArrayList<>();
-        while (true) {
-            Expression<?> expr = parseExpression();
-            elements.add(expr);
-            if (stream.current().isA(Type.PUNCTUATION, "]")) {
-                // this seems to be the end of the array
-                break;
-            }
-            // expect the comma separator, until we either find a closing
-            // bracket or fail the expect
-            stream.expect(Type.PUNCTUATION, ",");
-        }
-
-        // expect the closing bracket
-        stream.expect(Type.PUNCTUATION, "]");
-
-        return new ArrayExpression(elements);
-    }
-
-    private Expression<?> parseMapDefinitionExpression() {
-        TokenStream stream = parser.getStream();
-
-        // expect the opening brace and check for an empty map
-        stream.expect(Type.PUNCTUATION, "{");
-        if (stream.current().isA(Type.PUNCTUATION, "}")) {
-            stream.next();
-            return new MapExpression();
-        }
-
-        // there's at least one expression in the map
-        Map<Expression<?>, Expression<?>> elements = new HashMap<>();
-        while (true) {
-            // key : value
-            Expression<?> keyExpr = parseExpression();
-            stream.expect(Type.PUNCTUATION, ":");
-            Expression<?> valueExpr = parseExpression();
-            elements.put(keyExpr, valueExpr);
-            if (stream.current().isA(Type.PUNCTUATION, "}")) {
-                // this seems to be the end of the map
-                break;
-            }
-            // expect the comma separator, until we either find a closing brace
-            // or fail the expect
-            stream.expect(Type.PUNCTUATION, ",");
-        }
-
-        // expect the closing brace
-        stream.expect(Type.PUNCTUATION, "}");
-
-        return new MapExpression(elements);
-    }
-
-}
diff --git a/src/expressionLanguage/extension/Extension.java b/src/expressionLanguage/extension/Extension.java
deleted file mode 100644
index f98d459..0000000
--- a/src/expressionLanguage/extension/Extension.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package expressionLanguage.extension;
-
-import expressionLanguage.filter.Filter;
-import expressionLanguage.function.Function;
-import expressionLanguage.model.visitor.NodeVisitor;
-import expressionLanguage.operator.Operator;
-import expressionLanguage.test.Test;
-import expressionLanguage.token.parser.TokenParser;
-import java.util.List;
-import java.util.Map;
-
-public interface Extension {
-
-    /**
-     * Use this method to provide custom filters.
-     *
-     * @return A list of filters. It is okay to return null.
-     */
-    default Map<String, Filter> getFilters() {
-        return null;
-    }
-
-    /**
-     * Use this method to provide custom tests.
-     *
-     * @return A list of tests. It is okay to return null.
-     */
-    default Map<String, Test> getTests(){
-        return null;
-    }
-
-    /**
-     * Use this method to provide custom functions.
-     *
-     * @return A list of functions. It is okay to return null.
-     */
-    default Map<String, Function> getFunctions(){
-        return null;
-    }
-
-    /**
-     * Use this method to provide custom tags.
-     *
-     * A TokenParser is used to parse a stream of tokens into Nodes which are
-     * then responsible for compiling themselves into Java.
-     *
-     * @return A list of TokenParsers. It is okay to return null.
-     */
-    default Map<String, TokenParser> getTokenParsers(){
-        return null;
-    }
-
-    default Map<String, Operator> getOperators(){
-        return null;
-    }
-
-    /**
-     * Use this method to provide variables available to all templates
-     *
-     * @return Map of global variables available to all templates
-     */
-    default Map<String, Object> getGlobalVariables(){
-        return null;
-    }
-
-    /**
-     * Node visitors will travel the AST tree during the compilation phase.
-     *
-     * @return a list of node visitors
-     */
-    default List<NodeVisitor> getVisitors(){
-        return null;
-    }
-}
diff --git a/src/expressionLanguage/extension/ExtensionRegistry.java b/src/expressionLanguage/extension/ExtensionRegistry.java
deleted file mode 100644
index c3c2b96..0000000
--- a/src/expressionLanguage/extension/ExtensionRegistry.java
+++ /dev/null
@@ -1,169 +0,0 @@
-package expressionLanguage.extension;
-
-import expressionLanguage.filter.Filter;
-import expressionLanguage.function.Function;
-import expressionLanguage.model.visitor.NodeVisitor;
-import expressionLanguage.operator.Operator;
-import expressionLanguage.test.Test;
-import expressionLanguage.token.parser.TokenParser;
-import java.util.*;
-
-/**
- * Storage for the extensions and the components retrieved from the various
- * extensions.
- */
-public class ExtensionRegistry {
-
-    /**
-     * Extensions
-     */
-    private final Collection<Extension> extensions = new ArrayList();
-    
-    /**
-     * Operators used during the lexing phase.
-     */
-    private Map<String, Operator> operators;
-
-    /**
-     * Token parsers used during the parsing phase.
-     */
-    private Map<String, TokenParser> tokenParsers = new HashMap<>();
-
-    /**
-     * Visitors available during the parsing phase.
-     */
-    private final List<NodeVisitor> visitors = new ArrayList<>();
-
-    /**
-     * Filters used during the evaluation phase.
-     */
-    private final Map<String, Filter> filters = new HashMap<>();
-
-    /**
-     * Tests used during the evaluation phase.
-     */
-    private final Map<String, Test> tests = new HashMap<>();
-
-    /**
-     * Functions used during the evaluation phase.
-     */
-    private final Map<String, Function> functions = new HashMap<>();
-
-    /**
-     * Global variables available during the evaluation phase.
-     */
-    private final Map<String, Object> globalVariables = new HashMap<>();
-    
-    public ExtensionRegistry() {
-    }
-    
-    public ExtensionRegistry(Collection<Extension> extensions) {
-        addExtensions(extensions);
-    }
-    
-    private void addExtensions(Collection<Extension> extensions) {
-        extensions.forEach(this::addExtension);
-    }
-    
-    private void addExtension(Extension extension) {
-        
-        // filters
-        Map<String, Filter> efilters = extension.getFilters();
-        if (efilters != null) {
-            this.filters.putAll(efilters);
-        }
-        // tests
-        Map<String, Test> etests = extension.getTests();
-        if (etests != null) {
-            this.tests.putAll(etests);
-        }
-        // tests
-        Map<String, Function> efunctions = extension.getFunctions();
-        if (efunctions != null) {
-            this.functions.putAll(efunctions);
-        }
-        // global variables
-        Map<String, Object> eglobalVariables = extension.getGlobalVariables();
-        if (eglobalVariables != null) {
-            this.globalVariables.putAll(eglobalVariables);
-        }
-        
-        List<NodeVisitor> visitors = extension.getVisitors();
-        
-        if (visitors != null) {
-            this.visitors.addAll(visitors);
-        }
-        
-        this.extensions.add(extension);
-    }
-
-    public Filter getFilter(String name) {
-        return this.filters.get(name);
-    }
-
-    public Test getTest(String name) {
-        return this.tests.get(name);
-    }
-
-    public Function getFunction(String name) {
-        return this.functions.get(name);
-    }
-
-    public Map<String, Operator> getOperators() {
-        if (this.operators == null) {
-            this.operators = new HashMap<>();
-        }
-
-        this.extensions.stream()
-                .map((extension) -> extension.getOperators())
-                .forEach(this.operators::putAll);
-
-        return operators;
-    }
-
-    public List<NodeVisitor> getVisitors() {
-        return this.visitors;
-    }
-
-    public Map<String, Object> getGlobalVariables() {
-        return this.globalVariables;
-    }
-
-    public Map<String, TokenParser> getTokenParsers() {
-        if (this.tokenParsers == null) {
-            this.tokenParsers = new HashMap<>();
-        }
-
-        this.extensions.stream()
-                .map((extension) -> extension.getTokenParsers())
-                .forEach(this.tokenParsers::putAll);
-
-        return tokenParsers;
-    }
-    
-    public static ExtensionRegistryBuilder builder() {
-        return new ExtensionRegistryBuilder();
-    }
-    
-    public static class ExtensionRegistryBuilder {
-        
-        private Collection<Extension> extensions = new ArrayList<>();
-        
-        public ExtensionRegistryBuilder with(Extension extension) {
-            this.extensions.add(extension);
-            return this;
-        }
-        
-        public ExtensionRegistryBuilder and(Extension extension) {
-            return with(extension);
-        }
-        
-        public ExtensionRegistry build() {
-            ExtensionRegistry registry = new ExtensionRegistry();
-            
-            registry.addExtensions(extensions);
-            
-            return registry;
-        }
-    }
-}
diff --git a/src/expressionLanguage/extension/core/CoreExtension.java b/src/expressionLanguage/extension/core/CoreExtension.java
deleted file mode 100644
index 17870a3..0000000
--- a/src/expressionLanguage/extension/core/CoreExtension.java
+++ /dev/null
@@ -1,155 +0,0 @@
-package expressionLanguage.extension.core;
-
-import expressionLanguage.extension.core.test.IterableTest;
-import expressionLanguage.extension.core.function.RangeFunction;
-import expressionLanguage.extension.core.function.MinFunction;
-import expressionLanguage.extension.core.function.MaxFunction;
-import expressionLanguage.extension.Extension;
-import expressionLanguage.extension.core.expression.*;
-import expressionLanguage.extension.core.filter.*;
-import expressionLanguage.extension.core.token.*;
-import expressionLanguage.filter.Filter;
-import expressionLanguage.function.Function;
-import expressionLanguage.model.visitor.NodeVisitor;
-import expressionLanguage.operator.Associativity;
-import expressionLanguage.operator.BinaryOperator;
-import expressionLanguage.operator.Operator;
-import expressionLanguage.operator.UnaryOperator;
-import expressionLanguage.test.Test;
-import expressionLanguage.token.parser.TokenParser;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.stream.Collectors;
-
-public class CoreExtension implements Extension {
-
-    @Override
-    public Map<String, TokenParser> getTokenParsers() {
-        ArrayList<TokenParser> parsers = new ArrayList<>();
-        parsers.add(new BlockTokenParser());
-        parsers.add(new ExtendsTokenParser());
-        parsers.add(new FilterTokenParser());
-        parsers.add(new FlushTokenParser());
-        parsers.add(new ForTokenParser());
-        parsers.add(new IfTokenParser());
-        parsers.add(new ImportTokenParser());
-        parsers.add(new IncludeTokenParser());
-        parsers.add(new MacroTokenParser());
-        parsers.add(new ParallelTokenParser());
-        parsers.add(new SetTokenParser());
-        return parsers.stream().collect(Collectors.toMap(TokenParser::getTag, a -> a));
-    }
-
-//    @Override
-    public Map<String, UnaryOperator> getUnaryOperators() {
-        Map<String, UnaryOperator> operators = new HashMap<>();
-        operators.put("not", new UnaryOperator(5, UnaryNotExpression.class));
-        operators.put("+", new UnaryOperator(500, UnaryPlusExpression.class));
-        operators.put("-", new UnaryOperator(500, UnaryMinusExpression.class));
-        return operators;
-    }
-
-//    @Override
-    public Map<String, BinaryOperator> getBinaryOperators() {
-        Map<String, BinaryOperator> operators = new HashMap<>();
-        operators.put("or", new BinaryOperator(10, OrExpression.class, Associativity.LEFT));
-        operators.put("and", new BinaryOperator(15, AndExpression.class, Associativity.LEFT));
-        operators.put("is", new BinaryOperator(20, PositiveTestExpression.class, Associativity.LEFT));
-        operators.put("is not", new BinaryOperator(20, NegativeTestExpression.class, Associativity.LEFT));
-        operators.put("contains", new BinaryOperator(20, ContainsExpression.class, Associativity.LEFT));
-        operators.put("==", new BinaryOperator(30, EqualsExpression.class, Associativity.LEFT));
-        operators.put("equals", new BinaryOperator(30, EqualsExpression.class, Associativity.LEFT));
-        operators.put("!=", new BinaryOperator(30, NotEqualsExpression.class, Associativity.LEFT));
-        operators.put(">", new BinaryOperator(30, GreaterThanExpression.class, Associativity.LEFT));
-        operators.put("<", new BinaryOperator(30, LessThanExpression.class, Associativity.LEFT));
-        operators.put(">=", new BinaryOperator(30, GreaterThanEqualsExpression.class, Associativity.LEFT));
-        operators.put("<=", new BinaryOperator(30, LessThanEqualsExpression.class, Associativity.LEFT));
-        operators.put("+", new BinaryOperator(40, AddExpression.class, Associativity.LEFT));
-        operators.put("-", new BinaryOperator(40, SubtractExpression.class, Associativity.LEFT));
-        operators.put("*", new BinaryOperator(60, MultiplyExpression.class, Associativity.LEFT));
-        operators.put("/", new BinaryOperator(60, DivideExpression.class, Associativity.LEFT));
-        operators.put("%", new BinaryOperator(60, ModulusExpression.class, Associativity.LEFT));
-        operators.put("|", new BinaryOperator(100, FilterExpression.class, Associativity.LEFT));
-        operators.put("~", new BinaryOperator(110, ConcatenateExpression.class, Associativity.LEFT));
-        operators.put("..", new BinaryOperator(120, RangeExpression.class, Associativity.LEFT));
-
-        return operators;
-    }
-    
-    @Override
-    public Map<String, Operator> getOperators() {
-        Map<String, Operator> operators = new HashMap<>();
-        
-        operators.putAll(getUnaryOperators());
-        operators.putAll(getBinaryOperators());
-        
-        return operators;
-    }
-
-    @Override
-    public Map<String, Filter> getFilters() {
-        Map<String, Filter> filters = new HashMap<>();
-        filters.put("abbreviate", new AbbreviateFilter());
-        filters.put("abs", new AbsFilter());
-        filters.put("capitalize", new CapitalizeFilter());
-        filters.put("date", new DateFilter());
-        filters.put("default", new DefaultFilter());
-        filters.put("first", new FirstFilter());
-        filters.put("join", new JoinFilter());
-        filters.put("last", new LastFilter());
-        filters.put("lower", new LowerFilter());
-        filters.put("numberformat", new NumberFormatFilter());
-        filters.put("slice", new SliceFilter());
-        filters.put("sort", new SortFilter());
-        filters.put("rsort", new RsortFilter());
-        filters.put("title", new TitleFilter());
-        filters.put("trim", new TrimFilter());
-        filters.put("upper", new UpperFilter());
-        filters.put("urlencode", new UrlEncoderFilter());
-        filters.put("length", new LengthFilter());
-        filters.put(ReplaceFilter.FILTER_NAME, new ReplaceFilter());
-        filters.put(MergeFilter.FILTER_NAME, new MergeFilter());
-        return filters;
-    }
-
-    @Override
-    public Map<String, Test> getTests() {
-        Map<String, Test> tests = new HashMap<>();
-//        tests.put("empty", new EmptyTest());
-//        tests.put("even", new EvenTest());
-        tests.put("iterable", new IterableTest());
-//        tests.put("map", new MapTest());
-//        tests.put("null", new NullTest());
-//        tests.put("odd", new OddTest());
-//        tests.put("defined", new DefinedTest());
-        return tests;
-    }
-
-    @Override
-    public Map<String, Function> getFunctions() {
-        Map<String, Function> functions = new HashMap<>();
-
-        /*
-         * For efficiency purposes, some core functions are individually parsed
-         * by our expression parser and compiled in their own unique way. This
-         * includes the block and parent functions.
-         */
-
-        functions.put("max", new MaxFunction());
-        functions.put("min", new MinFunction());
-        functions.put(RangeFunction.FUNCTION_NAME, new RangeFunction());
-        return functions;
-    }
-
-    @Override
-    public List<NodeVisitor> getVisitors() {
-        List<NodeVisitor> visitors = new ArrayList<>();
-        visitors.add((node) -> {
-            System.out.println(node);
-        });
-        return visitors;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/AddExpression.java b/src/expressionLanguage/extension/core/expression/AddExpression.java
deleted file mode 100644
index 47d0a0d..0000000
--- a/src/expressionLanguage/extension/core/expression/AddExpression.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.operator.OperatorUtils;
-
-public class AddExpression extends BinaryExpression<Object> {
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        return OperatorUtils.add(getLeftExpression().evaluate(context), getRightExpression().evaluate(context));
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/AndExpression.java b/src/expressionLanguage/extension/core/expression/AndExpression.java
deleted file mode 100644
index 6f51f01..0000000
--- a/src/expressionLanguage/extension/core/expression/AndExpression.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.expression.Expression;
-
-public class AndExpression extends BinaryExpression<Boolean> {
-
-    @Override
-    public Boolean evaluate(EvaluationContext context) {
-        Expression<Boolean> left = (Expression<Boolean>) getLeftExpression();
-        Expression<Boolean> right = (Expression<Boolean>) getRightExpression();
-        return left.evaluate(context) && right.evaluate(context);
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/ArrayExpression.java b/src/expressionLanguage/extension/core/expression/ArrayExpression.java
deleted file mode 100644
index e2126d5..0000000
--- a/src/expressionLanguage/extension/core/expression/ArrayExpression.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-
-public class ArrayExpression implements Expression<List<?>> {
-
-    private final List<Expression<?>> values;
-
-    public ArrayExpression() {
-        this.values = Collections.emptyList();
-    }
-
-    public ArrayExpression(List<Expression<?>> values) {
-        if (values == null) {
-            this.values = Collections.emptyList();
-        } else {
-            this.values = values;
-        }
-    }
-
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    @Override
-    public List<?> evaluate(EvaluationContext context) {
-        List<Object> returnValues = new ArrayList<>(values.size());
-        values.stream()
-            .map((expr) -> expr == null ? null : expr.evaluate(context))
-            .forEach(returnValues::add);
-        return returnValues;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/BlockFunctionExpression.java b/src/expressionLanguage/extension/core/expression/BlockFunctionExpression.java
deleted file mode 100644
index 0fd41b6..0000000
--- a/src/expressionLanguage/extension/core/expression/BlockFunctionExpression.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.tree.ArgumentsNode;
-
-public class BlockFunctionExpression implements Expression<String> {
-
-    private final Expression<?> blockNameExpression;
-
-    public BlockFunctionExpression(ArgumentsNode args) {
-        this.blockNameExpression = args.getArgs().get(0).getValue();
-    }
-
-    @Override
-    public String evaluate(EvaluationContext context) {
-//        Writer writer = new StringWriter();
-        String blockName = (String) blockNameExpression.evaluate(context);
-        return blockName;
-//        try {
-//            self.block(writer, context, blockName, false);
-//        } catch (Exception e) {
-//            String msg = String.format("Could not render block [%s] at line %s in file %s.", blockName, this.getLineNumber(), self.getName());
-//            throw new Exception(msg);
-//        }
-//        return writer.toString();
-    }
-
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/ConcatenateExpression.java b/src/expressionLanguage/extension/core/expression/ConcatenateExpression.java
deleted file mode 100644
index e95d946..0000000
--- a/src/expressionLanguage/extension/core/expression/ConcatenateExpression.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-
-/**
- * Expression which implements the string concatenation.
- *
- */
-public class ConcatenateExpression extends BinaryExpression<Object> {
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-
-        Object left = getLeftExpression().evaluate(context);
-        Object right = getRightExpression().evaluate(context);
-        
-        StringBuilder result = new StringBuilder();
-        if (left != null) {
-            result.append(left.toString());
-        }
-        if (right != null) {
-            result.append(right.toString());
-        }
-
-        return result.toString();
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/ContainsExpression.java b/src/expressionLanguage/extension/core/expression/ContainsExpression.java
deleted file mode 100644
index 68a1196..0000000
--- a/src/expressionLanguage/extension/core/expression/ContainsExpression.java
+++ /dev/null
@@ -1,149 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import java.util.Collection;
-import java.util.Map;
-
-public class ContainsExpression extends BinaryExpression<Boolean> {
-
-    @Override
-    public Boolean evaluate(EvaluationContext context) {
-        Object leftValue = getLeftExpression().evaluate(context);
-
-        if (leftValue == null) {
-            return false;
-        }
-        Object rightValue = getRightExpression().evaluate(context);
-
-        if (leftValue instanceof Collection) {
-            if (rightValue instanceof Collection) {
-                return ((Collection) leftValue).containsAll((Collection) rightValue);
-            } else {
-                return ((Collection) leftValue).contains(rightValue);
-            }
-        } else if (leftValue instanceof Map) {
-            return ((Map) leftValue).containsKey(rightValue);
-        } else if (leftValue.getClass().isArray()) {
-            return arrayContains(leftValue, rightValue);
-        } else if (leftValue instanceof String) {
-            return String.valueOf(leftValue).contains(String.valueOf(rightValue));
-        } else {
-            throw new IllegalArgumentException(
-                    "Contains operator can only be used on Collections, Maps and arrays. Actual type was: "
-                            + leftValue.getClass().getName());
-        }
-    }
-
-    // FIXME is this right? does it make sense to support?
-    private static boolean arrayContains(Object input, Object value) {
-        if (input instanceof Object[]) {
-            return containsObject((Object[]) input, value);
-        } else if (input instanceof boolean[]) {
-            return containsBoolean((boolean[]) input, value);
-        } else if (input instanceof byte[]) {
-            return containsByte((byte[]) input, value);
-        } else if (input instanceof char[]) {
-            return containsChar((char[]) input, value);
-        } else if (input instanceof double[]) {
-            return containsDouble((double[]) input, value);
-        } else if (input instanceof float[]) {
-            return containsFloat((float[]) input, value);
-        } else if (input instanceof int[]) {
-            return containsInt((int[]) input, value);
-        } else if (input instanceof long[]) {
-            return containsLong((long[]) input, value);
-        } else {
-            return containsShort((short[]) input, value);
-        }
-    }
-
-    private static boolean containsObject(Object[] array, Object value) {
-        for (Object o : array) {
-            if (value == o || (value != null && value.equals(o)))
-                return true;
-        }
-        return false;
-    }
-
-    private static boolean containsBoolean(boolean[] array, Object value) {
-        if (!(value instanceof Boolean))
-            return false;
-        for (boolean b : array) {
-            if (b == ((Boolean) value))
-                return true;
-        }
-        return false;
-    }
-
-    private static boolean containsByte(byte[] array, Object value) {
-        if (!(value instanceof Byte))
-            return false;
-        for (byte b : array) {
-            if (b == ((Byte) value))
-                return true;
-        }
-        return false;
-    }
-
-    private static boolean containsChar(char[] array, Object value) {
-        if (!(value instanceof Character))
-            return false;
-        for (char c : array) {
-            if (c == ((Character) value))
-                return true;
-        }
-        return false;
-    }
-
-    private static boolean containsDouble(double[] array, Object value) {
-        if (!(value instanceof Double))
-            return false;
-        for (double d : array) {
-            if (d == ((Double) value))
-                return true;
-        }
-        return false;
-    }
-
-    private static boolean containsFloat(float[] array, Object value) {
-        if (!(value instanceof Float))
-            return false;
-        for (float f : array) {
-            if (f == ((Float) value))
-                return true;
-        }
-        return false;
-    }
-
-    private static boolean containsInt(int[] array, Object value) {
-        if (!(value instanceof Integer))
-            return false;
-        for (int i : array) {
-            if (i == ((Integer) value))
-                return true;
-        }
-        return false;
-    }
-
-    private static boolean containsLong(long[] array, Object value) {
-        if (!(value instanceof Long))
-            return false;
-        for (long l : array) {
-            if (l == ((Long) value))
-                return true;
-        }
-        return false;
-    }
-
-    private static boolean containsShort(short[] array, Object value) {
-        if (!(value instanceof Short))
-            return false;
-        for (short s : array) {
-            if (s == ((Short) value))
-                return true;
-        }
-        return false;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/ContextVariableExpression.java b/src/expressionLanguage/extension/core/expression/ContextVariableExpression.java
deleted file mode 100644
index f5dff4f..0000000
--- a/src/expressionLanguage/extension/core/expression/ContextVariableExpression.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-import expressionLanguage.scope.ScopeChain;
-
-public class ContextVariableExpression implements Expression<Object> {
-
-    protected final String name;
-
-    public ContextVariableExpression(String name) {
-        this.name = name;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        ScopeChain scopeChain = context.getScopeChain();
-        Object result = scopeChain.get(name);
-        if (result == null && context.isStrictVariables() && !scopeChain.containsKey(name)) {
-            String msg = String.format("Root attribute [%s] does not exist or can not be accessed and strict variables is set to true at line %s in file %s.", this.name);
-            throw new IllegalArgumentException(msg);
-        }
-        return result;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/DivideExpression.java b/src/expressionLanguage/extension/core/expression/DivideExpression.java
deleted file mode 100644
index 7656ecc..0000000
--- a/src/expressionLanguage/extension/core/expression/DivideExpression.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.operator.OperatorUtils;
-
-public class DivideExpression extends BinaryExpression<Object> {
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        return OperatorUtils.divide(getLeftExpression().evaluate(context),
-                getRightExpression().evaluate(context));
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/EqualsExpression.java b/src/expressionLanguage/extension/core/expression/EqualsExpression.java
deleted file mode 100644
index 225dcbd..0000000
--- a/src/expressionLanguage/extension/core/expression/EqualsExpression.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.operator.OperatorUtils;
-
-public class EqualsExpression extends BinaryExpression<Boolean> {
-
-    @Override
-    public Boolean evaluate(EvaluationContext context) {
-        return OperatorUtils.equals(getLeftExpression().evaluate(context),
-                getRightExpression().evaluate(context));
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/FilterExpression.java b/src/expressionLanguage/extension/core/expression/FilterExpression.java
deleted file mode 100644
index 0195ef0..0000000
--- a/src/expressionLanguage/extension/core/expression/FilterExpression.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.filter.Filter;
-import expressionLanguage.model.tree.ArgumentsNode;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Objects;
-
-public class FilterExpression extends BinaryExpression<Object> {
-
-    /**
-     * Save the filter instance on the first evaluation.
-     */
-    private Filter filter = null;
-
-    public FilterExpression() {
-        super();
-    }
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-
-        FilterInvocationExpression filterInvocation = (FilterInvocationExpression) getRightExpression();
-        ArgumentsNode args = filterInvocation.getArgs();
-        String filterName = filterInvocation.getFilterName();
-
-        if (this.filter == null) {
-            this.filter = context.getExtensionRegistry().getFilter(filterInvocation.getFilterName());
-        }
-
-        if (filter == null) {
-            String msg = String.format("Filter [%s] does not exist at line %s in file %s.", filterName);
-            throw new IllegalStateException(msg);
-        }
-
-//        Map<String, Object> namedArguments = args.getArgumentMap(context, filter);
-        Map<String, Object> namedArguments = new HashMap<>();
-
-        Object input = getLeftExpression().evaluate(context);
-
-        return filter.apply(Objects.toString(input), namedArguments);
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/FilterInvocationExpression.java b/src/expressionLanguage/extension/core/expression/FilterInvocationExpression.java
deleted file mode 100644
index 45685dc..0000000
--- a/src/expressionLanguage/extension/core/expression/FilterInvocationExpression.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.tree.ArgumentsNode;
-
-/**
- * The right hand side to the filter expression.
- *
- */
-public class FilterInvocationExpression implements Expression<Object> {
-
-    private final String filterName;
-
-    private final ArgumentsNode args;
-    
-    public FilterInvocationExpression(String filterName, ArgumentsNode args) {
-        this.filterName = filterName;
-        this.args = args;
-    }
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        // see FilterExpression.java
-        throw new UnsupportedOperationException();
-    }
-
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    public ArgumentsNode getArgs() {
-        return args;
-    }
-
-    public String getFilterName() {
-        return filterName;
-    }
-
-//    @Override
-//    public int getLineNumber() {
-//        return this.lineNumber;
-//    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/FunctionOrMacroInvocationExpression.java b/src/expressionLanguage/extension/core/expression/FunctionOrMacroInvocationExpression.java
deleted file mode 100644
index 0fba0a0..0000000
--- a/src/expressionLanguage/extension/core/expression/FunctionOrMacroInvocationExpression.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-import expressionLanguage.function.Function;
-import expressionLanguage.model.tree.ArgumentsNode;
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-
-public class  FunctionOrMacroInvocationExpression implements Expression<Object> {
-
-    private final String functionName;
-
-    private final ArgumentsNode args;
-
-    public FunctionOrMacroInvocationExpression(String functionName, ArgumentsNode arguments) {
-        this.functionName = functionName;
-        this.args = arguments;
-    }
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-//        return null;
-        Function function = context.getExtensionRegistry().getFunction(functionName);
-        if (function != null) {
-            return applyFunction(context, function, args);
-        }
-        return context.getHierarchy().get().macro(context, functionName, args, false);
-    }
-
-    private Object applyFunction(EvaluationContext context, Function function, ArgumentsNode args) {
-        List<Object> arguments = new ArrayList<>();
-
-        Collections.addAll(arguments, args);
-
-        Map<String, Object> namedArguments = args.getArgumentMap(context, function);
-        return function.evaluate(context, namedArguments);
-    }
-
-    public String getFunctionName() {
-        return functionName;
-    }
-
-    public ArgumentsNode getArguments() {
-        return args;
-    }
-
-//    @Override
-//    public int getLineNumber() {
-//        return this.lineNumber;
-//    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/GetAttributeExpression.java b/src/expressionLanguage/extension/core/expression/GetAttributeExpression.java
deleted file mode 100644
index ff530df..0000000
--- a/src/expressionLanguage/extension/core/expression/GetAttributeExpression.java
+++ /dev/null
@@ -1,376 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.tree.ArgumentsNode;
-import expressionLanguage.model.tree.ArgumentNode;
-import java.lang.reflect.*;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * Used to get an attribute from an object. It will look up attributes in the
- * following order: map entry, array item, list item, get method, is method, has
- * method, public method, public field.
- *
- */
-public class GetAttributeExpression implements Expression<Object> {
-
-    private final Expression<?> node;
-
-    private final Expression<?> attributeNameExpression;
-
-    private final ArgumentsNode args;
-
-    private final String filename;
-
-    /**
-     * Potentially cached on first evaluation.
-     */
-    private final ConcurrentHashMap<MemberCacheKey, Member> memberCache;
-
-    public GetAttributeExpression(Expression<?> node, Expression<?> attributeNameExpression, String filename) {
-        this(node, attributeNameExpression, null, filename);
-    }
-
-    public GetAttributeExpression(Expression<?> node, Expression<?> attributeNameExpression, ArgumentsNode args, String filename) {
-
-        this.node = node;
-        this.attributeNameExpression = attributeNameExpression;
-        this.args = args;
-        this.filename = filename;
-
-        /*
-         * I dont imagine that users will often give different types to the same
-         * template so we will give this cache a pretty small initial capacity.
-         */
-        this.memberCache = new ConcurrentHashMap<>(2, 0.9f, 1);
-    }
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        Object object = node.evaluate(context);
-        Object attributeNameValue = attributeNameExpression.evaluate(context);
-        String attributeName = String.valueOf(attributeNameValue);
-
-        Object result = null;
-
-        Object[] argumentValues = null;
-
-        Member member = object == null ? null : memberCache.get(new MemberCacheKey(object.getClass(), attributeName));
-
-        if (object != null && member == null) {
-
-            /*
-             * If, and only if, no arguments were provided does it make sense to
-             * check maps/arrays/lists
-             */
-            if (args == null) {
-
-                // first we check maps
-                if (object instanceof Map && ((Map<?, ?>) object).containsKey(attributeNameValue)) {
-                    return ((Map<?, ?>) object).get(attributeNameValue);
-                }
-
-                try {
-
-                    // then we check arrays
-                    if (object.getClass().isArray()) {
-                        int index = Integer.parseInt(attributeName);
-                        int length = Array.getLength(object);
-                        if (index < 0 || index >= length) {
-                            if (context.isStrictVariables()) {
-                                String msg = String.format("Index out of bounds while accessing array with strict variables on, on attribute %s in file %s.", attributeName, filename);
-                                throw new IndexOutOfBoundsException(msg);
-                            } else {
-                                return null;
-                            }
-                        }
-                        return Array.get(object, index);
-                    }
-
-                    // then lists
-                    if (object instanceof List) {
-
-                        @SuppressWarnings("unchecked")
-                        List<Object> list = (List<Object>) object;
-
-                        int index = Integer.parseInt(attributeName);
-                        int length = list.size();
-
-                        if (index < 0 || index >= length) {
-                            if (context.isStrictVariables()) {
-                                String msg = String.format("Index out of bounds while accessing array with strict variables on, on attribute %s in file %s.", attributeName, filename);
-                                throw new IndexOutOfBoundsException(msg);
-                            } else {
-                                return null;
-                            }
-                        }
-
-                        return list.get(index);
-                    }
-                } catch (NumberFormatException ex) {
-                    // do nothing
-                }
-
-            }
-
-            /*
-             * turn args into an array of types and an array of values in order
-             * to use them for our reflection calls
-             */
-            argumentValues = getArgumentValues(context);
-            Class<?>[] argumentTypes = new Class<?>[argumentValues.length];
-
-            for (int i = 0; i < argumentValues.length; i++) {
-                Object o = argumentValues[i];
-                if (o == null) {
-                    argumentTypes[i] = null;
-                } else {
-                    argumentTypes[i] = o.getClass();
-                }
-            }
-
-            member = reflect(object, attributeName, argumentTypes);
-            if (member != null) {
-                memberCache.put(new MemberCacheKey(object.getClass(), attributeName), member);
-            }
-
-        }
-
-        if (object != null && member != null) {
-            if (argumentValues == null) {
-                argumentValues = getArgumentValues(context);
-            }
-            result = invokeMember(object, member, argumentValues);
-        } else if (context.isStrictVariables()) {
-            if (object == null) {
-                if (node instanceof ContextVariableExpression) {
-                    final String rootPropertyName = ((ContextVariableExpression) node).getName();
-                    String msg = String.format("Root attribute [%s] does not exist or can not be accessed and strict variables is set to true at line %s in file %s.", rootPropertyName, this.filename);
-                    throw new IllegalStateException(msg);
-                }
-                
-                String msg = String.format("Attempt to get attribute of null object and strict variables is set to true at line %s in file %s.", attributeName, this.filename);
-                throw new NullPointerException(msg);
-
-            }
-            String msg = String.format("Attribute [%s] of [%s] does not exist or can not be accessed and strict variables is set to true at line %s in file %s.",attributeName, object.getClass().getName(), this.filename);
-            throw new IllegalStateException(msg);
-        }
-        return result;
-
-    }
-
-    /**
-     * Invoke the "Member" that was found via reflection.
-     *
-     * @param object
-     * @param member
-     * @param argumentValues
-     * @return
-     */
-    private Object invokeMember(Object object, Member member, Object[] argumentValues) {
-        Object result = null;
-        try {
-            if (member instanceof Method) {
-                result = ((Method) member).invoke(object, argumentValues);
-            } else if (member instanceof Field) {
-                result = ((Field) member).get(object);
-            }
-
-        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
-            throw new RuntimeException(e);
-        }
-        return result;
-    }
-
-    /**
-     * Fully evaluates the individual arguments.
-     *
-     * @param self
-     * @param context
-     * @return
-     */
-    private Object[] getArgumentValues(EvaluationContext context) {
-
-        Object[] argumentValues;
-
-        if (this.args == null) {
-            argumentValues = new Object[0];
-        } else {
-            List<ArgumentNode> args = this.args.getArgs();
-
-            argumentValues = new Object[args.size()];
-
-            int index = 0;
-            for (ArgumentNode arg : args) {
-                Object argumentValue = arg.getValue().evaluate(context);
-                argumentValues[index] = argumentValue;
-                index++;
-            }
-        }
-        return argumentValues;
-    }
-
-    /**
-     * Performs the actual reflection to obtain a "Member" from a class.
-     *
-     * @param object
-     * @param attributeName
-     * @param parameterTypes
-     * @return
-     */
-    private Member reflect(Object object, String attributeName, Class<?>[] parameterTypes) {
-
-        Class<?> clazz = object.getClass();
-
-        Member result = null;
-
-        // capitalize first letter of attribute for the following attempts
-        String attributeCapitalized = Character.toUpperCase(attributeName.charAt(0)) + attributeName.substring(1);
-
-        // check get method
-        result = findMethod(clazz, "get" + attributeCapitalized, parameterTypes);
-
-        // check is method
-        if (result == null) {
-            result = findMethod(clazz, "is" + attributeCapitalized, parameterTypes);
-        }
-
-        // check has method
-        if (result == null) {
-            result = findMethod(clazz, "has" + attributeCapitalized, parameterTypes);
-        }
-
-        // check if attribute is a public method
-        if (result == null) {
-            result = findMethod(clazz, attributeName, parameterTypes);
-        }
-
-        // public field
-        if (result == null) {
-            try {
-                result = clazz.getField(attributeName);
-            } catch (NoSuchFieldException | SecurityException e) {
-            }
-        }
-
-        if (result != null) {
-            ((AccessibleObject) result).setAccessible(true);
-        }
-
-        return result;
-    }
-
-    /**
-     * Finds an appropriate method by comparing if parameter types are
-     * compatible. This is more relaxed than class.getMethod.
-     *
-     * @param clazz
-     * @param name
-     * @param requiredTypes
-     * @return
-     */
-    private Method findMethod(Class<?> clazz, String name, Class<?>[] requiredTypes) {
-        Method result = null;
-
-        Method[] candidates = clazz.getMethods();
-
-        for (Method candidate : candidates) {
-            if (!candidate.getName().equalsIgnoreCase(name)) {
-                continue;
-            }
-
-            Class<?>[] types = candidate.getParameterTypes();
-
-            if (types.length != requiredTypes.length) {
-                continue;
-            }
-
-            boolean compatibleTypes = true;
-            for (int i = 0; i < types.length; i++) {
-                if (requiredTypes[i] != null && !widen(types[i]).isAssignableFrom(requiredTypes[i])) {
-                    compatibleTypes = false;
-                    break;
-                }
-            }
-
-            if (compatibleTypes) {
-                result = candidate;
-                break;
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Performs a widening conversion (primitive to boxed type)
-     *
-     * @param clazz
-     * @return
-     */
-    private Class<?> widen(Class<?> clazz) {
-        Class<?> result = clazz;
-        if (clazz == int.class) {
-            result = Integer.class;
-        } else if (clazz == long.class) {
-            result = Long.class;
-        } else if (clazz == double.class) {
-            result = Double.class;
-        } else if (clazz == float.class) {
-            result = Float.class;
-        } else if (clazz == short.class) {
-            result = Short.class;
-        } else if (clazz == byte.class) {
-            result = Byte.class;
-        } else if (clazz == boolean.class) {
-            result = Boolean.class;
-        }
-        return result;
-    }
-
-    private class MemberCacheKey {
-        private final Class<?> clazz;
-        private final String attributeName;
-
-        private MemberCacheKey(Class<?> clazz, String attributeName) {
-            this.clazz = clazz;
-            this.attributeName = attributeName;
-        }
-
-        @Override
-        public boolean equals(Object o) {
-            if (this == o) return true;
-            if (o == null || getClass() != o.getClass()) return false;
-
-            MemberCacheKey that = (MemberCacheKey) o;
-
-            if (!clazz.equals(that.clazz)) return false;
-            return attributeName.equals(that.attributeName);
-
-        }
-
-        @Override
-        public int hashCode() {
-            int result = clazz.hashCode();
-            result = 31 * result + attributeName.hashCode();
-            return result;
-        }
-    }
-
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    public Expression<?> getNode() {
-        return node;
-    }
-
-    public ArgumentsNode getArgumentsNode() {
-        return args;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/GreaterThanEqualsExpression.java b/src/expressionLanguage/extension/core/expression/GreaterThanEqualsExpression.java
deleted file mode 100644
index 9a2a4fd..0000000
--- a/src/expressionLanguage/extension/core/expression/GreaterThanEqualsExpression.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.operator.OperatorUtils;
-
-public class GreaterThanEqualsExpression extends BinaryExpression<Boolean> {
-
-    @Override
-    public Boolean evaluate(EvaluationContext context) {
-        return OperatorUtils.gte(getLeftExpression().evaluate(context),
-                getRightExpression().evaluate(context));
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/GreaterThanExpression.java b/src/expressionLanguage/extension/core/expression/GreaterThanExpression.java
deleted file mode 100644
index 3ee0207..0000000
--- a/src/expressionLanguage/extension/core/expression/GreaterThanExpression.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.operator.OperatorUtils;
-
-public class GreaterThanExpression extends BinaryExpression<Boolean> {
-
-    @Override
-    public Boolean evaluate(EvaluationContext context) {
-        return OperatorUtils.gt(getLeftExpression().evaluate(context),
-                getRightExpression().evaluate(context));
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/LessThanEqualsExpression.java b/src/expressionLanguage/extension/core/expression/LessThanEqualsExpression.java
deleted file mode 100644
index ad3d301..0000000
--- a/src/expressionLanguage/extension/core/expression/LessThanEqualsExpression.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.operator.OperatorUtils;
-
-public class LessThanEqualsExpression extends BinaryExpression<Boolean> {
-
-    @Override
-    public Boolean evaluate(EvaluationContext context) {
-        return OperatorUtils.lte(getLeftExpression().evaluate(context),
-                getRightExpression().evaluate(context));
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/LessThanExpression.java b/src/expressionLanguage/extension/core/expression/LessThanExpression.java
deleted file mode 100644
index 9321495..0000000
--- a/src/expressionLanguage/extension/core/expression/LessThanExpression.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.operator.OperatorUtils;
-
-public class LessThanExpression extends BinaryExpression<Boolean> {
-
-    @Override
-    public Boolean evaluate(EvaluationContext context) {
-        return OperatorUtils.lt(getLeftExpression().evaluate(context),
-                getRightExpression().evaluate(context));
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/LiteralBooleanExpression.java b/src/expressionLanguage/extension/core/expression/LiteralBooleanExpression.java
deleted file mode 100644
index 33e6687..0000000
--- a/src/expressionLanguage/extension/core/expression/LiteralBooleanExpression.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-
-public class LiteralBooleanExpression implements Expression<Boolean> {
-
-    private final Boolean value;
-
-    public LiteralBooleanExpression(Boolean value) {
-        this.value = value;
-    }
-
-    @Override
-    public Boolean evaluate(EvaluationContext context) {
-        return value;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/LiteralDoubleExpression.java b/src/expressionLanguage/extension/core/expression/LiteralDoubleExpression.java
deleted file mode 100644
index 3beb28b..0000000
--- a/src/expressionLanguage/extension/core/expression/LiteralDoubleExpression.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-
-public class LiteralDoubleExpression implements Expression<Double> {
-
-    private final Double value;
-
-    public LiteralDoubleExpression(Double value) {
-        this.value = value;
-    }
-    
-    @Override
-    public Double evaluate(EvaluationContext context) {
-        return value;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/LiteralLongExpression.java b/src/expressionLanguage/extension/core/expression/LiteralLongExpression.java
deleted file mode 100644
index 66eea9a..0000000
--- a/src/expressionLanguage/extension/core/expression/LiteralLongExpression.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-
-public class LiteralLongExpression implements Expression<Long> {
-
-    private final Long value;
-
-    public LiteralLongExpression(Long value) {
-        this.value = value;
-    }
-
-    @Override
-    public Long evaluate(EvaluationContext context) {
-        return value;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/LiteralNullExpression.java b/src/expressionLanguage/extension/core/expression/LiteralNullExpression.java
deleted file mode 100644
index 5e6e1f1..0000000
--- a/src/expressionLanguage/extension/core/expression/LiteralNullExpression.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-
-public class LiteralNullExpression implements Expression<Object> {
-
-    public LiteralNullExpression() {
-    }
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        return null;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/LiteralStringExpression.java b/src/expressionLanguage/extension/core/expression/LiteralStringExpression.java
deleted file mode 100644
index 9d65587..0000000
--- a/src/expressionLanguage/extension/core/expression/LiteralStringExpression.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-
-public class LiteralStringExpression implements Expression<String> {
-
-    private final String value;
-
-    public LiteralStringExpression(String value) {
-        this.value = value;
-    }
-
-    @Override
-    public String evaluate(EvaluationContext context) {
-        return value;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/MapExpression.java b/src/expressionLanguage/extension/core/expression/MapExpression.java
deleted file mode 100644
index 4aa66a8..0000000
--- a/src/expressionLanguage/extension/core/expression/MapExpression.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Map.Entry;
-
-public class MapExpression implements Expression<Map<?, ?>> {
-
-    // FIXME should keys be of any type?
-    private final Map<Expression<?>, Expression<?>> entries;
-
-    public MapExpression() {
-        this.entries = Collections.emptyMap();
-    }
-
-    public MapExpression(Map<Expression<?>, Expression<?>> entries) {
-        if (entries == null) {
-            this.entries = Collections.emptyMap();
-        } else {
-            this.entries = entries;
-        }
-    }
-
-    @Override
-    public Map<?, ?> evaluate(EvaluationContext context) {
-        Map<Object, Object> returnEntries = new HashMap<>(Long.valueOf(Math.round(Math.ceil(entries.size() / 0.75)))
-                .intValue());
-        entries.entrySet().stream().forEach((entry) -> {
-            Expression<?> keyExpr = entry.getKey();
-            Expression<?> valueExpr = entry.getValue();
-            Object key = keyExpr == null ? null : keyExpr.evaluate(context);
-            Object value = valueExpr == null ? null : valueExpr.evaluate(context);
-            returnEntries.put(key, value);
-        });
-        return returnEntries;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/ModulusExpression.java b/src/expressionLanguage/extension/core/expression/ModulusExpression.java
deleted file mode 100644
index 0952ef8..0000000
--- a/src/expressionLanguage/extension/core/expression/ModulusExpression.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.operator.OperatorUtils;
-
-public class ModulusExpression extends BinaryExpression<Object> {
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        return OperatorUtils.mod(getLeftExpression().evaluate(context),
-                getRightExpression().evaluate(context));
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/MultiplyExpression.java b/src/expressionLanguage/extension/core/expression/MultiplyExpression.java
deleted file mode 100644
index 435227c..0000000
--- a/src/expressionLanguage/extension/core/expression/MultiplyExpression.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.operator.OperatorUtils;
-
-public class MultiplyExpression extends BinaryExpression<Object> {
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        return OperatorUtils.multiply(getLeftExpression().evaluate(context),
-                getRightExpression().evaluate(context));
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/NegativeTestExpression.java b/src/expressionLanguage/extension/core/expression/NegativeTestExpression.java
deleted file mode 100644
index 5321004..0000000
--- a/src/expressionLanguage/extension/core/expression/NegativeTestExpression.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-
-public class NegativeTestExpression extends PositiveTestExpression {
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        return !((Boolean) super.evaluate(context));
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/NotEqualsExpression.java b/src/expressionLanguage/extension/core/expression/NotEqualsExpression.java
deleted file mode 100644
index 17598ed..0000000
--- a/src/expressionLanguage/extension/core/expression/NotEqualsExpression.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.operator.OperatorUtils;
-
-public class NotEqualsExpression extends BinaryExpression<Boolean> {
-
-    @Override
-    public Boolean evaluate(EvaluationContext context) {
-        return !OperatorUtils.equals(getLeftExpression().evaluate(context), getRightExpression().evaluate(context));
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/OrExpression.java b/src/expressionLanguage/extension/core/expression/OrExpression.java
deleted file mode 100644
index 61c9ccd..0000000
--- a/src/expressionLanguage/extension/core/expression/OrExpression.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.expression.Expression;
-
-public class OrExpression extends BinaryExpression<Boolean> {
-
-    @Override
-    public Boolean evaluate(EvaluationContext context) {
-        Expression<Boolean> left = (Expression<Boolean>) getLeftExpression();
-        Expression<Boolean> right = (Expression<Boolean>) getRightExpression();
-        return left.evaluate(context) || right.evaluate(context);
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/ParentFunctionExpression.java b/src/expressionLanguage/extension/core/expression/ParentFunctionExpression.java
deleted file mode 100644
index 93e855c..0000000
--- a/src/expressionLanguage/extension/core/expression/ParentFunctionExpression.java
+++ /dev/null
@@ -1,32 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.template.Hierarchy;
-import expressionLanguage.model.template.Template;
-
-public class ParentFunctionExpression implements Expression<Boolean> {
-
-    private final String blockName;
-
-    public ParentFunctionExpression(String blockName) {
-        this.blockName = blockName;
-    }
-
-    @Override
-    public Boolean evaluate(EvaluationContext context) {
-        Hierarchy hierarchy = context.getHierarchy();
-        if (hierarchy.getParent() == null) {
-            String msg = String.format("Can not use parent function if template does not extend another template");
-            throw new IllegalStateException(msg);
-        }
-        
-        Template parent = hierarchy.getParent();
-
-        hierarchy.ascend();
-        parent.block(context, blockName, true);
-        hierarchy.descend();
-        
-        return true;
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/PositiveTestExpression.java b/src/expressionLanguage/extension/core/expression/PositiveTestExpression.java
deleted file mode 100644
index 2707b12..0000000
--- a/src/expressionLanguage/extension/core/expression/PositiveTestExpression.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.expression.Expression;
-import expressionLanguage.test.Test;
-
-public class PositiveTestExpression extends BinaryExpression<Object> {
-
-    private Test cachedTest;
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-
-        Expression testInvocation = getRightExpression();
-
-        if (cachedTest == null) {
-            String testName = testInvocation.getClass().getName();
-
-            cachedTest = context.getExtensionRegistry().getTest(testName);
-
-            if (cachedTest == null) {
-                String msg = String.format("Test [%s] does not exist at line %s.", testName);
-                throw new IllegalStateException(msg);
-            }
-        }
-        
-        Test test = cachedTest;
-
-        Object input = getLeftExpression().evaluate(context);
-        
-        return test.apply(input);
-
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/RangeExpression.java b/src/expressionLanguage/extension/core/expression/RangeExpression.java
deleted file mode 100644
index b55328d..0000000
--- a/src/expressionLanguage/extension/core/expression/RangeExpression.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.function.RangeFunction;
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.tree.ArgumentsNode;
-import expressionLanguage.model.tree.ArgumentNode;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Expression which implements the range function.
- *
- */
-public class RangeExpression extends BinaryExpression<Object> {
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        List<ArgumentNode> positionalArgs = new ArrayList<>();
-        positionalArgs.add(new ArgumentNode(null, getLeftExpression()));
-        positionalArgs.add(new ArgumentNode(null, getRightExpression()));
-//
-        ArgumentsNode arguments = new ArgumentsNode(null, positionalArgs);
-        FunctionOrMacroInvocationExpression function = new FunctionOrMacroInvocationExpression(
-                RangeFunction.FUNCTION_NAME, arguments);
-
-        return function.evaluate(context);
-    }
-
-}
\ No newline at end of file
diff --git a/src/expressionLanguage/extension/core/expression/RenderableNodeExpression.java b/src/expressionLanguage/extension/core/expression/RenderableNodeExpression.java
deleted file mode 100644
index b867f41..0000000
--- a/src/expressionLanguage/extension/core/expression/RenderableNodeExpression.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.UnaryExpression;
-import expressionLanguage.model.tree.Node;
-
-/**
- * This class wraps a {@link RenderableNode} into an expression. This is used by
- * the filter TAG to apply a filter to large chunk of template which is
- * contained within a renderable node.
- *
- */
-public class RenderableNodeExpression extends UnaryExpression {
-
-    private final Node node;
-
-    public RenderableNodeExpression(Node node) {
-        this.node = node;
-    }
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-//        Writer writer = new StringWriter();
-//        try {
-//            node.render(self, writer, context);
-//        } catch (IOException e) {
-//            String msg = String.format("Error occurred while rendering node at line %s in file %s.", this.getLineNumber(), self.getName());
-//            throw new Exception(msg);
-//        }
-//        return writer.toString();
-        return node;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/SubtractExpression.java b/src/expressionLanguage/extension/core/expression/SubtractExpression.java
deleted file mode 100644
index c808114..0000000
--- a/src/expressionLanguage/extension/core/expression/SubtractExpression.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.BinaryExpression;
-import expressionLanguage.operator.OperatorUtils;
-
-public class SubtractExpression extends BinaryExpression<Object> {
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        return OperatorUtils.subtract(getLeftExpression().evaluate(context),
-                getRightExpression().evaluate(context));
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/TernaryExpression.java b/src/expressionLanguage/extension/core/expression/TernaryExpression.java
deleted file mode 100644
index e019f49..0000000
--- a/src/expressionLanguage/extension/core/expression/TernaryExpression.java
+++ /dev/null
@@ -1,53 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-
-public class TernaryExpression implements Expression<Object> {
-
-    private final Expression<Boolean> expression1;
-
-    private Expression<?> expression2;
-
-    private Expression<?> expression3;
-
-    public TernaryExpression(Expression<Boolean> expression1, Expression<?> expression2, Expression<?> expression3, String filename) {
-        this.expression1 = expression1;
-        this.expression2 = expression2;
-        this.expression3 = expression3;
-    }
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        if (expression1.evaluate(context) != null && expression1.evaluate(context)) {
-            return expression2.evaluate(context);
-        } else {
-            return expression3.evaluate(context);
-        }
-    }
-
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    public Expression<Boolean> getExpression1() {
-        return expression1;
-    }
-
-    public Expression<?> getExpression2() {
-        return expression2;
-    }
-
-    public Expression<?> getExpression3() {
-        return expression3;
-    }
-
-    public void setExpression3(Expression<?> expression3) {
-        this.expression3 = expression3;
-    }
-
-    public void setExpression2(Expression<?> expression2) {
-        this.expression2 = expression2;
-    }
-}
diff --git a/src/expressionLanguage/extension/core/expression/UnaryMinusExpression.java b/src/expressionLanguage/extension/core/expression/UnaryMinusExpression.java
deleted file mode 100644
index 2853c0b..0000000
--- a/src/expressionLanguage/extension/core/expression/UnaryMinusExpression.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.UnaryExpression;
-import expressionLanguage.operator.OperatorUtils;
-
-public class UnaryMinusExpression extends UnaryExpression {
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        return OperatorUtils.unaryMinus(getChildExpression().evaluate(context));
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/UnaryNotExpression.java b/src/expressionLanguage/extension/core/expression/UnaryNotExpression.java
deleted file mode 100644
index e9e3365..0000000
--- a/src/expressionLanguage/extension/core/expression/UnaryNotExpression.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.UnaryExpression;
-
-public class UnaryNotExpression extends UnaryExpression {
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        Boolean result = (Boolean) getChildExpression().evaluate(context);
-        return !result;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/expression/UnaryPlusExpression.java b/src/expressionLanguage/extension/core/expression/UnaryPlusExpression.java
deleted file mode 100644
index a14865c..0000000
--- a/src/expressionLanguage/extension/core/expression/UnaryPlusExpression.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package expressionLanguage.extension.core.expression;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.UnaryExpression;
-import expressionLanguage.operator.OperatorUtils;
-
-public class UnaryPlusExpression extends UnaryExpression {
-
-    @Override
-    public Object evaluate(EvaluationContext context) {
-        return OperatorUtils.unaryPlus(getChildExpression().evaluate(context));
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/AbbreviateFilter.java b/src/expressionLanguage/extension/core/filter/AbbreviateFilter.java
deleted file mode 100644
index 5e043f6..0000000
--- a/src/expressionLanguage/extension/core/filter/AbbreviateFilter.java
+++ /dev/null
@@ -1,50 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.filter.Filter;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-public class AbbreviateFilter implements Filter {
-
-    private final List<String> argumentNames = new ArrayList<>();
-
-    public AbbreviateFilter() {
-        argumentNames.add("length");
-    }
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return argumentNames;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-        String value = (String) input;
-        int maxWidth = ((Long) args.get("length")).intValue();
-
-        if(maxWidth < 0){
-            throw new RuntimeException("Invalid argument to abbreviate filter; must be greater than zero");
-        }
-
-        String ellipsis = "...";
-        int length = value.length();
-
-        if (length < maxWidth) {
-            return value;
-        }
-        if (length <= 3) {
-            return value;
-        }
-        if(maxWidth <= 3){
-            return value.substring(0, maxWidth);
-        }
-        return value.substring(0, Math.max(0, maxWidth - 3)) + ellipsis;
-    }
-
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/AbsFilter.java b/src/expressionLanguage/extension/core/filter/AbsFilter.java
deleted file mode 100644
index 112a5f1..0000000
--- a/src/expressionLanguage/extension/core/filter/AbsFilter.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.util.List;
-import java.util.Map;
-
-public class AbsFilter implements Filter {
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    @Override
-    public Number apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            throw new IllegalArgumentException("Can not pass null value to \"abs\" filter.");
-        }
-        if (input instanceof Long) {
-            return Math.abs((Long) input);
-        } else {
-            return Math.abs((Double) input);
-        }
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/CapitalizeFilter.java b/src/expressionLanguage/extension/core/filter/CapitalizeFilter.java
deleted file mode 100644
index 3291007..0000000
--- a/src/expressionLanguage/extension/core/filter/CapitalizeFilter.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-
-public class CapitalizeFilter implements Filter {
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-        String value = (String) input;
-
-        if (value.length() == 0) {
-            return value;
-        }
-
-        StringBuilder result = new StringBuilder();
-
-        char[] chars = value.toCharArray();
-        for (int i = 0; i < chars.length; i++) {
-            char c = chars[i];
-
-            if (Character.isWhitespace(c)) {
-                result.append(c);
-            } else {
-                result.append(Character.toTitleCase(c));
-                result.append(Arrays.copyOfRange(chars, i + 1, chars.length));
-                break;
-            }
-        }
-
-        return result.toString();
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/DateFilter.java b/src/expressionLanguage/extension/core/filter/DateFilter.java
deleted file mode 100644
index 9086892..0000000
--- a/src/expressionLanguage/extension/core/filter/DateFilter.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.filter.Filter;
-import java.text.DateFormat;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.*;
-
-public class DateFilter implements Filter {
-
-    private final List<String> argumentNames = new ArrayList<>();
-
-    public DateFilter() {
-        argumentNames.add("format");
-        argumentNames.add("existingFormat");
-    }
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return argumentNames;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-        Date date = null;
-
-        DateFormat existingFormat;
-        DateFormat intendedFormat;
-
-        EvaluationContext context = (EvaluationContext) args.get("_context");
-        Locale locale = context.getLocale();
-
-        intendedFormat = new SimpleDateFormat((String) args.get("format"), locale);
-
-        if (args.get("existingFormat") != null) {
-            existingFormat = new SimpleDateFormat((String) args.get("existingFormat"), locale);
-            try {
-                date = existingFormat.parse((String) input);
-            } catch (ParseException e) {
-                throw new RuntimeException("Could not parse date", e);
-            }
-        } else {
-            date = (Date) input;
-        }
-
-        return intendedFormat.format(date);
-    }
-}
diff --git a/src/expressionLanguage/extension/core/filter/DefaultFilter.java b/src/expressionLanguage/extension/core/filter/DefaultFilter.java
deleted file mode 100644
index 34c6ae7..0000000
--- a/src/expressionLanguage/extension/core/filter/DefaultFilter.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.extension.core.test.EmptyTest;
-import expressionLanguage.filter.Filter;
-import expressionLanguage.test.Test;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-public class DefaultFilter implements Filter {
-
-    private final List<String> argumentNames = new ArrayList<>();
-
-    public DefaultFilter() {
-        argumentNames.add("default");
-    }
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return argumentNames;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-
-        Object defaultObj = args.get("default");
-
-        Test emptyTest = new EmptyTest();
-        if (emptyTest.apply(input)) {
-            return defaultObj;
-        }
-        return input;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/FirstFilter.java b/src/expressionLanguage/extension/core/filter/FirstFilter.java
deleted file mode 100644
index 01b7546..0000000
--- a/src/expressionLanguage/extension/core/filter/FirstFilter.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.lang.reflect.Array;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Returns the first element of a collection
- * 
- */
-public class FirstFilter implements Filter {
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-        
-        if(input instanceof String){
-            String inputString = (String)input;
-            return inputString.charAt(0);
-        }
-
-        if(input.getClass().isArray()) {
-            int length = Array.getLength(input);
-            return length > 0 ? Array.get(input, 0) : null;
-        }
-        
-        Collection<?> inputCollection = (Collection<?>) input;
-        return inputCollection.iterator().next();
-    }
-}
diff --git a/src/expressionLanguage/extension/core/filter/JoinFilter.java b/src/expressionLanguage/extension/core/filter/JoinFilter.java
deleted file mode 100644
index 9105e0e..0000000
--- a/src/expressionLanguage/extension/core/filter/JoinFilter.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Concatenates all entries of a collection, optionally glued together with a
- * particular character such as a comma.
- * 
- */
-public class JoinFilter implements Filter {
-
-    private final List<String> argumentNames = new ArrayList<>();
-
-    public JoinFilter() {
-        argumentNames.add("separator");
-    }
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return argumentNames;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-
-        @SuppressWarnings("unchecked")
-        Collection<Object> inputCollection = (Collection<Object>) input;
-
-        StringBuilder builder = new StringBuilder();
-
-        String glue = null;
-        if (args.containsKey("separator")) {
-            glue = (String) args.get("separator");
-        }
-
-        boolean isFirst = true;
-        for (Object entry : inputCollection) {
-
-            if (!isFirst && glue != null) {
-                builder.append(glue);
-            }
-            builder.append(entry);
-
-            isFirst = false;
-        }
-        return builder.toString();
-    }
-}
diff --git a/src/expressionLanguage/extension/core/filter/LastFilter.java b/src/expressionLanguage/extension/core/filter/LastFilter.java
deleted file mode 100644
index f34bd62..0000000
--- a/src/expressionLanguage/extension/core/filter/LastFilter.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.lang.reflect.Array;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Returns the last element of a collection
- * 
- */
-public class LastFilter implements Filter {
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-
-        if(input instanceof String){
-            String inputString = (String)input;
-            return inputString.charAt(inputString.length() - 1);
-        }
-
-        if(input.getClass().isArray()) {
-            int length = Array.getLength(input);
-            return length > 0 ? Array.get(input, length - 1) : null;
-        }
-        
-        Collection<Object> inputCollection = (Collection<Object>) input;
-        Object result = null;
-        Iterator<Object> iterator = inputCollection.iterator();
-        while(iterator.hasNext()){
-            result = iterator.next();
-        }
-        return result;
-    }
-}
diff --git a/src/expressionLanguage/extension/core/filter/LengthFilter.java b/src/expressionLanguage/extension/core/filter/LengthFilter.java
deleted file mode 100644
index e65a756..0000000
--- a/src/expressionLanguage/extension/core/filter/LengthFilter.java
+++ /dev/null
@@ -1,52 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.lang.reflect.Array;
-import java.util.Collection;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-
-public class LengthFilter implements Filter {
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return 0;
-        }
-        if (input instanceof String) {
-            return ((String) input).length();
-        } else if (input instanceof Collection) {
-            return ((Collection<?>) input).size();
-        } else if (input.getClass().isArray()) {
-            return Array.getLength(input);
-        } else if (input instanceof Map) {
-            return ((Map<?, ?>) input).size();
-        } else if (input instanceof Iterable) {
-            Iterator<?> it = ((Iterable<?>) input).iterator();
-            int size = 0;
-            while (it.hasNext()) {
-                it.next();
-                size++;
-            }
-            return size;
-        } else if (input instanceof Iterator) {
-            Iterator<?> it = (Iterator<?>) input;
-            int size = 0;
-            while (it.hasNext()) {
-                it.next();
-                size++;
-            }
-            return size;
-        }
-        else {
-            return 0;
-        }
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/LowerFilter.java b/src/expressionLanguage/extension/core/filter/LowerFilter.java
deleted file mode 100644
index 1c07bd3..0000000
--- a/src/expressionLanguage/extension/core/filter/LowerFilter.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.util.List;
-import java.util.Map;
-
-public class LowerFilter implements Filter {
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-        return ((String)input).toLowerCase();
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/MergeFilter.java b/src/expressionLanguage/extension/core/filter/MergeFilter.java
deleted file mode 100644
index 19408d3..0000000
--- a/src/expressionLanguage/extension/core/filter/MergeFilter.java
+++ /dev/null
@@ -1,103 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.lang.reflect.Array;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-public class MergeFilter implements Filter {
-
-    public static final String FILTER_NAME = "merge";
-
-    private final List<String> argumentNames = new ArrayList<>();
-
-    public MergeFilter() {
-        argumentNames.add("items");
-    }
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return argumentNames;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        Object items = args.get("items");
-        if (input == null && items == null) {
-            throw new IllegalArgumentException("The two arguments to be merged are null");
-        } else if (input != null && items == null) {
-            return input;
-        } else if (items != null && input == null) {
-            return items;
-        }
-        // left hand side argument defines resulting type
-        if (input instanceof Map) {
-            return mergeAsMap((Map<?, ?>) input, items);
-        } else if (input instanceof List) {
-            return mergeAsList((List<?>) input, items);
-        } else if (input != null && input.getClass().isArray()) {
-            return mergeAsArray(input, items);
-        } else {
-            throw new IllegalArgumentException("The object being filtered is not a Map/List/Array");
-        }
-    }
-
-    private Object mergeAsMap(Map<?, ?> arg1, Object arg2) {
-        Map<?, ?> collection1 = arg1;
-        Map<Object, Object> output = null;
-        if (arg2 instanceof Map) {
-            Map<?, ?> collection2 = (Map<?, ?>) arg2;
-            output = new HashMap<>(collection1.size() + collection2.size() + 16);
-            output.putAll(collection1);
-            output.putAll(collection2);
-        } else if (arg2 instanceof List) {
-            List<?> collection2 = (List<?>) arg2;
-            output = new HashMap<>(collection1.size() + collection2.size() + 16);
-            output.putAll(collection1);
-            for (Object o : collection2) {
-                output.put(o, o);
-            }
-        } else {
-            throw new UnsupportedOperationException(
-                    "Currently, only Maps and Lists can be merged with a Map. Arg2: " + arg2.getClass().getName());
-        }
-        return output;
-    }
-
-    private Object mergeAsList(List<?> arg1, Object arg2) {
-        List<?> collection1 = arg1;
-        List<Object> output = null;
-        if (arg2 instanceof Map) {
-            Map<?, ?> collection2 = (Map<?, ?>) arg2;
-            output = new ArrayList<>(collection1.size() + collection2.size() + 16);
-            output.addAll(collection1);
-            output.addAll(collection2.entrySet());
-        } else if (arg2 instanceof List) {
-            List<?> collection2 = (List<?>) arg2;
-            output = new ArrayList<>(collection1.size() + collection2.size() + 16);
-            output.addAll(collection1);
-            output.addAll(collection2);
-        } else {
-            throw new UnsupportedOperationException(
-                    "Currently, only Maps and Lists can be merged with a List. Arg2: " + arg2.getClass().getName());
-        }
-        return output;
-    }
-
-    private Object mergeAsArray(Object arg1, Object arg2) {
-        Class<?> arg1Class = arg1.getClass().getComponentType();
-        Class<?> arg2Class = arg2.getClass().getComponentType();
-        if (!arg1Class.equals(arg2Class)) {
-            throw new UnsupportedOperationException(
-                    "Currently, only Arrays of the same component class can be merged. Arg1: " + arg1Class.getName()
-                            + ", Arg2: " + arg2Class.getName());
-        }
-        Object output = Array.newInstance(arg1Class, Array.getLength(arg1) + Array.getLength(arg2));
-        System.arraycopy(arg1, 0, output, 0, Array.getLength(arg1));
-        System.arraycopy(arg2, 0, output, Array.getLength(arg1), Array.getLength(arg2));
-        return output;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/NumberFormatFilter.java b/src/expressionLanguage/extension/core/filter/NumberFormatFilter.java
deleted file mode 100644
index add88a6..0000000
--- a/src/expressionLanguage/extension/core/filter/NumberFormatFilter.java
+++ /dev/null
@@ -1,46 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.filter.Filter;
-import java.text.DecimalFormat;
-import java.text.DecimalFormatSymbols;
-import java.text.Format;
-import java.text.NumberFormat;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Locale;
-import java.util.Map;
-
-public class NumberFormatFilter implements Filter {
-
-    private final List<String> argumentNames = new ArrayList<>();
-
-    public NumberFormatFilter() {
-        argumentNames.add("format");
-    }
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return argumentNames;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-        Number number = (Number) input;
-
-        EvaluationContext context = (EvaluationContext) args.get("_context");
-        Locale locale = context.getLocale();
-
-        if (args.get("format") != null) {
-            Format format = new DecimalFormat((String) args.get("format"), new DecimalFormatSymbols(locale));
-            return format.format(number);
-        } else {
-            NumberFormat numberFormat = NumberFormat.getInstance(locale);
-            return numberFormat.format(number);
-        }
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/ReplaceFilter.java b/src/expressionLanguage/extension/core/filter/ReplaceFilter.java
deleted file mode 100644
index 23a061f..0000000
--- a/src/expressionLanguage/extension/core/filter/ReplaceFilter.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.text.MessageFormat;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-import java.util.Map.Entry;
-
-/**
- * This class implements the 'replace' filter.
- */
-public class ReplaceFilter implements Filter {
-
-    public static final String FILTER_NAME = "replace";
-
-    private static final String ARGUMENT_NAME = "replace_pairs";
-
-    private final static List<String> ARGS = Collections.unmodifiableList(Arrays.asList(ARGUMENT_NAME));
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return ARGS;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        String data = input.toString();
-        if (args.get(ARGUMENT_NAME) == null) {
-            throw new IllegalArgumentException(MessageFormat.format("The argument ''{0}'' is required.", ARGUMENT_NAME));
-        }
-        Map<?, ?> replacePair = (Map<?, ?>) args.get(ARGUMENT_NAME);
-
-        for (Entry<?, ?> entry : replacePair.entrySet()) {
-           data = data.replace(entry.getKey().toString(), entry.getValue().toString());
-        }
-
-        return data;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/RsortFilter.java b/src/expressionLanguage/extension/core/filter/RsortFilter.java
deleted file mode 100644
index 7664704..0000000
--- a/src/expressionLanguage/extension/core/filter/RsortFilter.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Sort list items in the reverse order
- */
-public class RsortFilter implements Filter {
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    @Override
-    public List<Comparable> apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-        List<Comparable> collection = (List<Comparable>) input;
-        Collections.sort(collection, Collections.reverseOrder());
-        return collection;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/SliceFilter.java b/src/expressionLanguage/extension/core/filter/SliceFilter.java
deleted file mode 100644
index c36771a..0000000
--- a/src/expressionLanguage/extension/core/filter/SliceFilter.java
+++ /dev/null
@@ -1,114 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.lang.reflect.Array;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Map;
-
-public class SliceFilter implements Filter {
-
-    private final List<String> argumentNames = new ArrayList<>();
-
-    public SliceFilter() {
-        argumentNames.add("fromIndex");
-        argumentNames.add("toIndex");
-    }
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return argumentNames;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-
-        if (input == null) {
-            return null;
-        }
-
-        // argument parsing
-        Object argFrom = args.get("fromIndex");
-
-        if (argFrom == null) { // defaults to 0
-            argFrom = (long) 0;
-        } else if (!(argFrom instanceof Number)) {
-            String msg = String.format("Argument fromIndex must be a number. Actual type: %s", (argFrom == null ? "null" : argFrom.getClass().getName()));
-            throw new IllegalArgumentException(msg);
-        }
-        int from = ((Number) argFrom).intValue();
-        if (from < 0) {
-            throw new IllegalArgumentException("fromIndex must be greater than 0");
-        }
-
-        Object argTo = args.get("toIndex");
-
-        if (argTo == null) {
-            // defaults to input length
-            // argTo == null;
-        } else if (!(argTo instanceof Number)) {
-            String msg = String.format("Argument fromIndex must be a number. Actual type: %s", (argFrom == null ? "null" : argFrom.getClass().getName()));
-            throw new IllegalArgumentException(msg);
-        }
-
-        int length;
-        if (input instanceof List) {
-            length = ((List<?>) input).size();
-        } else if (input.getClass().isArray()) {
-            length = Array.getLength(input);
-        } else if (input instanceof String) {
-            length = ((String) input).length();
-        } else {
-            throw new IllegalArgumentException("Slice filter can only be applied to String, List and array inputs. Actual type was: "
-                            + input.getClass().getName());
-        }
-        int to;
-
-        if (argTo != null) {
-            to = ((Number) argTo).intValue();
-            if (to > length)
-                throw new IllegalArgumentException("toIndex must be smaller than input size: " + length);
-            else if (from >= to)
-                throw new IllegalArgumentException("toIndex must be greater than fromIndex");
-        } else {
-            to = length;
-        }
-
-        // slice input
-        if (input instanceof List) {
-            List<?> value = (List<?>) input;
-            // FIXME maybe sublist() is not the best option due to its
-            // implementation?
-            return value.subList(from, to);
-        } else if (input.getClass().isArray()) {
-            return sliceArray(input, from, to);
-        } else {
-            String value = (String) input;
-            return value.substring(from, to);
-        }
-    }
-
-    private static Object sliceArray(Object input, int from, int to) {
-        if (input instanceof Object[]) {
-            return Arrays.copyOfRange((Object[]) input, from, to);
-        } else if (input instanceof boolean[]) {
-            return Arrays.copyOfRange((boolean[]) input, from, to);
-        } else if (input instanceof byte[]) {
-            return Arrays.copyOfRange((byte[]) input, from, to);
-        } else if (input instanceof char[]) {
-            return Arrays.copyOfRange((char[]) input, from, to);
-        } else if (input instanceof double[]) {
-            return Arrays.copyOfRange((double[]) input, from, to);
-        } else if (input instanceof float[]) {
-            return Arrays.copyOfRange((float[]) input, from, to);
-        } else if (input instanceof int[]) {
-            return Arrays.copyOfRange((int[]) input, from, to);
-        } else if (input instanceof long[]) {
-            return Arrays.copyOfRange((long[]) input, from, to);
-        } else {
-            return Arrays.copyOfRange((short[]) input, from, to);
-        }
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/SortFilter.java b/src/expressionLanguage/extension/core/filter/SortFilter.java
deleted file mode 100644
index 984524c..0000000
--- a/src/expressionLanguage/extension/core/filter/SortFilter.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.util.Collections;
-import java.util.List;
-import java.util.Map;
-
-public class SortFilter implements Filter {
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    @Override
-    public List<Comparable> apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-        List<Comparable> collection = (List<Comparable>) input;
-        Collections.sort(collection);
-        return collection;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/TitleFilter.java b/src/expressionLanguage/extension/core/filter/TitleFilter.java
deleted file mode 100644
index 4988cb6..0000000
--- a/src/expressionLanguage/extension/core/filter/TitleFilter.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.util.List;
-import java.util.Map;
-
-public class TitleFilter implements Filter {
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-        String value = (String) input;
-
-        if (value.length() == 0) {
-            return value;
-        }
-
-        StringBuilder result = new StringBuilder();
-
-        boolean capitalizeNextCharacter = true;
-
-        for (char c : value.toCharArray()) {
-            if (Character.isWhitespace(c)) {
-                capitalizeNextCharacter = true;
-            } else if (capitalizeNextCharacter) {
-                c = Character.toTitleCase(c);
-                capitalizeNextCharacter = false;
-            }
-            result.append(c);
-        }
-
-        return result.toString();
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/TrimFilter.java b/src/expressionLanguage/extension/core/filter/TrimFilter.java
deleted file mode 100644
index b091044..0000000
--- a/src/expressionLanguage/extension/core/filter/TrimFilter.java
+++ /dev/null
@@ -1,23 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.util.List;
-import java.util.Map;
-
-public class TrimFilter implements Filter {
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-        String str = (String) input;
-        return str.trim();
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/UpperFilter.java b/src/expressionLanguage/extension/core/filter/UpperFilter.java
deleted file mode 100644
index 7d0c1e3..0000000
--- a/src/expressionLanguage/extension/core/filter/UpperFilter.java
+++ /dev/null
@@ -1,22 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.util.List;
-import java.util.Map;
-
-public class UpperFilter implements Filter {
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-        return ((String)input).toUpperCase();
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/filter/UrlEncoderFilter.java b/src/expressionLanguage/extension/core/filter/UrlEncoderFilter.java
deleted file mode 100644
index 642f202..0000000
--- a/src/expressionLanguage/extension/core/filter/UrlEncoderFilter.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package expressionLanguage.extension.core.filter;
-
-import expressionLanguage.filter.Filter;
-import java.io.UnsupportedEncodingException;
-import java.net.URLEncoder;
-import java.util.List;
-import java.util.Map;
-
-public class UrlEncoderFilter implements Filter {
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    public Object apply(Object input, Map<String, Object> args) {
-        if (input == null) {
-            return null;
-        }
-        String arg = (String) input;
-        try {
-            arg = URLEncoder.encode(arg, "UTF-8");
-        } catch (UnsupportedEncodingException e) {
-        }
-        return arg;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/function/MaxFunction.java b/src/expressionLanguage/extension/core/function/MaxFunction.java
deleted file mode 100644
index af029bc..0000000
--- a/src/expressionLanguage/extension/core/function/MaxFunction.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package expressionLanguage.extension.core.function;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.function.Function;
-import expressionLanguage.operator.OperatorUtils;
-import java.util.List;
-import java.util.Map;
-
-public class MaxFunction implements Function {
-
-    @Override
-    public String getName() {
-        return "max";
-    }
-
-    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    @Override
-    public Object evaluate(EvaluationContext context, Map<String, Object> args) {
-        Object min = null;
-
-        int i = 0;
-
-        while (args.containsKey(String.valueOf(i))) {
-
-            Object candidate = args.get(String.valueOf(i));
-            i++;
-
-            if (min == null) {
-                min = candidate;
-                continue;
-            }
-            if (OperatorUtils.gt(candidate, min)) {
-                min = candidate;
-            }
-
-        }
-        return min;
-
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/function/MinFunction.java b/src/expressionLanguage/extension/core/function/MinFunction.java
deleted file mode 100644
index 40a3c82..0000000
--- a/src/expressionLanguage/extension/core/function/MinFunction.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package expressionLanguage.extension.core.function;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.function.Function;
-import expressionLanguage.operator.OperatorUtils;
-import java.util.List;
-import java.util.Map;
-
-public class MinFunction implements Function {
-
-    @Override
-    public String getName() {
-        return "min";
-    }
-
-    @Override
-    public List<String> getArgumentNames() {
-        return null;
-    }
-
-    @Override
-    public Object evaluate(EvaluationContext context, Map<String, Object> args) {
-        Object min = null;
-
-        int i = 0;
-
-        while (args.containsKey(String.valueOf(i))) {
-
-            Object candidate = args.get(String.valueOf(i));
-            i++;
-
-            if (min == null) {
-                min = candidate;
-                continue;
-            }
-            if (OperatorUtils.lt(candidate, min)) {
-                min = candidate;
-            }
-        }
-        return min;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/function/RangeFunction.java b/src/expressionLanguage/extension/core/function/RangeFunction.java
deleted file mode 100644
index a7de3a1..0000000
--- a/src/expressionLanguage/extension/core/function/RangeFunction.java
+++ /dev/null
@@ -1,105 +0,0 @@
-package expressionLanguage.extension.core.function;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.function.Function;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Range function to iterate over long or a string with a length of 1.
- */
-public class RangeFunction implements Function {
-    
-    public static final String FUNCTION_NAME = "range";
-    private static final String PARAM_END = "end";
-    private static final String PARAM_INCREMENT = "increment";
-    private static final String PARAM_START = "start";
-    
-    private final List<String> argumentNames = new ArrayList<>();
-
-    public RangeFunction() {
-        this.argumentNames.add(PARAM_START);
-        this.argumentNames.add(PARAM_END);
-        this.argumentNames.add(PARAM_INCREMENT);
-    }
-    
-    @Override
-    public String getName() {
-        return FUNCTION_NAME;
-    }
-
-    @Override
-    public Object evaluate(EvaluationContext context, Map<String, Object> args) {
-        Object start = args.get(PARAM_START);
-        Object end = args.get(PARAM_END);
-        Object increment = (Object) args.get(PARAM_INCREMENT);
-        if (increment == null) {
-            increment = 1L;
-        }
-        else if (!(increment instanceof Number)) {
-            throw new IllegalArgumentException("The increment of the range function must be a number " + increment);
-        }
-        
-        Long incrementNum = ((Number) increment).longValue();
-
-        List<Object> results = new ArrayList<>();
-        // Iterating over Number
-        if (start instanceof Number && end instanceof Number) {
-            Long startNum = ((Number) start).longValue();
-            Long endNum = ((Number) end).longValue();
-
-            if (incrementNum > 0) {
-                for (Long i = startNum; i <= endNum; i += incrementNum) {
-                    results.add(i);
-                }
-            }
-            else if (incrementNum < 0) {
-                for (Long i = startNum; i >= endNum; i += incrementNum) {
-                    results.add(i);
-                }
-            }
-            else {
-                throw new IllegalArgumentException("The increment of the range function must be different than 0");
-            }
-        }
-        // Iterating over character
-        else if (start instanceof String && end instanceof String) {
-            String startStr = (String) start;
-            String endStr = (String) end;
-            if (startStr.length() != 1 || endStr.length() != 1) {
-                throw new IllegalArgumentException("Arguments of range function must be of type Number or String with "
-                        + "a length of 1");
-            }
-
-            char startChar = startStr.charAt(0);
-            char endChar = endStr.charAt(0);
-
-            if (incrementNum > 0) {
-                for (int i = startChar; i <= endChar; i += incrementNum) {
-                    results.add((char) i);
-                }
-            }
-            else if (incrementNum < 0) {
-                for (int i = startChar; i >= endChar; i += incrementNum) {
-                    results.add((char) i);
-                }
-            }
-            else {
-                throw new IllegalArgumentException("The increment of the range function must be different than 0");
-            }
-        }
-        else {
-            throw new IllegalArgumentException("Arguments of range function must be of type Number or String with a "
-                    + "length of 1");
-        }
-
-        return results;
-    }
-
-    @Override
-    public List<String> getArgumentNames() {
-        return this.argumentNames;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/test/DefinedTest.java b/src/expressionLanguage/extension/core/test/DefinedTest.java
deleted file mode 100644
index a9ce3b7..0000000
--- a/src/expressionLanguage/extension/core/test/DefinedTest.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package expressionLanguage.extension.core.test;
-
-/**
- * Implementation for the test function 'defined'.
- *
- * <p>
- * Inversion of 'null' test function to provide better compatibility with the
- * original twig version and JTwig.
- *
- */
-public class DefinedTest extends NullTest {
-
-    @Override
-    public boolean apply(Object input) {
-        return !super.apply(input);
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/test/EmptyTest.java b/src/expressionLanguage/extension/core/test/EmptyTest.java
deleted file mode 100644
index 6eecb6c..0000000
--- a/src/expressionLanguage/extension/core/test/EmptyTest.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package expressionLanguage.extension.core.test;
-
-import expressionLanguage.test.Test;
-import java.util.Collection;
-import java.util.Map;
-
-public class EmptyTest implements Test {
-
-    @Override
-    public boolean apply(Object input) {
-        boolean isEmpty = input == null;
-
-        if (!isEmpty && input instanceof String) {
-            String value = (String) input;
-            isEmpty = "".equals(value.trim());
-        }
-
-        if (!isEmpty && input instanceof Collection) {
-            isEmpty = ((Collection<?>) input).isEmpty();
-        }
-
-        if (!isEmpty && input instanceof Map) {
-            isEmpty = ((Map<?, ?>) input).isEmpty();
-        }
-
-        return isEmpty;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/test/EvenTest.java b/src/expressionLanguage/extension/core/test/EvenTest.java
deleted file mode 100644
index d87aa10..0000000
--- a/src/expressionLanguage/extension/core/test/EvenTest.java
+++ /dev/null
@@ -1,19 +0,0 @@
-package expressionLanguage.extension.core.test;
-
-import expressionLanguage.test.Test;
-
-public class EvenTest implements Test {
-
-    @Override
-    public boolean apply(Object input) {
-        if (input == null) {
-            throw new IllegalArgumentException("Can not pass null value to \"even\" test.");
-        }
-
-        if (input instanceof Integer) {
-            return ((Integer) input) % 2 == 0;
-        } else {
-            return ((Long) input) % 2 == 0;
-        }
-    }
-}
diff --git a/src/expressionLanguage/extension/core/test/IterableTest.java b/src/expressionLanguage/extension/core/test/IterableTest.java
deleted file mode 100644
index c2bff47..0000000
--- a/src/expressionLanguage/extension/core/test/IterableTest.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package expressionLanguage.extension.core.test;
-
-import expressionLanguage.test.Test;
-
-public class IterableTest implements Test {
-
-    @Override
-    public boolean apply(Object input) {
-        return input instanceof Iterable;
-    }
-}
diff --git a/src/expressionLanguage/extension/core/test/MapTest.java b/src/expressionLanguage/extension/core/test/MapTest.java
deleted file mode 100644
index e37118b..0000000
--- a/src/expressionLanguage/extension/core/test/MapTest.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package expressionLanguage.extension.core.test;
-
-import expressionLanguage.test.Test;
-import java.util.Map;
-
-public class MapTest implements Test {
-
-    @Override
-    public boolean apply(Object input) {
-        return input instanceof Map;
-    }
-
-}
diff --git a/src/expressionLanguage/extension/core/test/NullTest.java b/src/expressionLanguage/extension/core/test/NullTest.java
deleted file mode 100644
index f61f614..0000000
--- a/src/expressionLanguage/extension/core/test/NullTest.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package expressionLanguage.extension.core.test;
-
-import expressionLanguage.test.Test;
-
-public class NullTest implements Test {
-
-    @Override
-    public boolean apply(Object input) {
-        return input == null;
-    }
-}
diff --git a/src/expressionLanguage/extension/core/test/OddTest.java b/src/expressionLanguage/extension/core/test/OddTest.java
deleted file mode 100644
index 3797fd7..0000000
--- a/src/expressionLanguage/extension/core/test/OddTest.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package expressionLanguage.extension.core.test;
-
-import expressionLanguage.test.Test;
-
-public class OddTest implements Test {
-
-    @Override
-    public boolean apply(Object input) {
-        if (input == null) {
-            throw new IllegalArgumentException("Can not pass null value to \"odd\" test.");
-        }
-        EvenTest evenTest = new EvenTest();
-        return !evenTest.apply(input);
-    }
-}
diff --git a/src/expressionLanguage/extension/core/token/AutoEscapeTokenParser.java b/src/expressionLanguage/extension/core/token/AutoEscapeTokenParser.java
deleted file mode 100644
index d2c0416..0000000
--- a/src/expressionLanguage/extension/core/token/AutoEscapeTokenParser.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package expressionLanguage.extension.core.token;
-
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.tree.AutoEscapeNode;
-import expressionLanguage.model.tree.BodyNode;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import expressionLanguage.token.parser.TokenParser;
-import expressionLanguage.token.parser.TokenStreamParser;
-import java.util.function.Predicate;
-
-public class AutoEscapeTokenParser implements TokenParser {
-
-    @Override
-    public String getTag() {
-        return "autoescape";
-    }
-    
-    @Override
-    public Node parse(Token token, TokenStreamParser parser) {
-        TokenStream stream = parser.getStream();
-        Position position = token.getPosition();
-
-        String strategy = null;
-        boolean active = true;
-
-        // skip over the 'autoescape' token
-        stream.next();
-
-        // did user specify active boolean?
-        if (stream.current().isA(Type.NAME)) {
-            active = Boolean.parseBoolean(stream.current().getValue());
-            stream.next();
-        }
-
-        // did user specify a strategy?
-        if (stream.current().isA(Type.STRING)) {
-            strategy = stream.current().getValue();
-            stream.next();
-        }
-
-        stream.expect(Type.EXECUTE_END);
-
-        // now we parse the block body
-        BodyNode body = parser.subparse((Token token1) -> token1.isA(Type.NAME, "endautoescape"));
-
-        // skip the 'endautoescape' token
-        stream.next();
-
-        stream.expect(Type.EXECUTE_END);
-
-        return new AutoEscapeNode(position, body, active, strategy);
-    }
-
-
-}
diff --git a/src/expressionLanguage/extension/core/token/BlockTokenParser.java b/src/expressionLanguage/extension/core/token/BlockTokenParser.java
deleted file mode 100644
index 7c975bd..0000000
--- a/src/expressionLanguage/extension/core/token/BlockTokenParser.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package expressionLanguage.extension.core.token;
-
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.tree.BlockNode;
-import expressionLanguage.model.tree.BodyNode;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.token.parser.Parser;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import expressionLanguage.token.parser.TokenParser;
-import expressionLanguage.token.parser.TokenStreamParser;
-
-public class BlockTokenParser implements TokenParser {
-
-    @Override
-    public Node parse(Token token, TokenStreamParser parser) {
-        TokenStream stream = parser.getStream();
-        Position position = token.getPosition();
-
-        // skip over the 'block' token to the name token
-        Token blockName = stream.next();
-
-        // expect a name or string for the new block
-        if (!blockName.isA(Type.NAME) && !blockName.isA(Type.STRING)) {
-
-            // we already know an error has occurred but let's just call the
-            // typical "expect" method so that we know a proper error
-            // message is given to user
-            stream.expect(Type.NAME);
-        }
-
-        // get the name of the new block
-        String name = blockName.getValue();
-
-        // skip over name
-        stream.next();
-
-        stream.expect(Type.EXECUTE_END);
-
-        parser.pushBlockStack(name);
-
-        // now we parse the block body
-        BodyNode blockBody = parser.subparse((Token token1) -> token1.isA(Type.NAME, "endblock"));
-        parser.popBlockStack();
-
-        // skip the 'endblock' token
-        stream.next();
-
-        // check if user included block name in endblock
-        Token current = stream.current();
-        if (current.isA(Type.NAME, name) || current.isA(Type.STRING, name)) {
-            stream.next();
-        }
-
-        stream.expect(Type.EXECUTE_END);
-        return new BlockNode(position, name, blockBody);
-    }
-
-    @Override
-    public String getTag() {
-        return "block";
-    }
-}
diff --git a/src/expressionLanguage/extension/core/token/ExtendsTokenParser.java b/src/expressionLanguage/extension/core/token/ExtendsTokenParser.java
deleted file mode 100644
index 51c0231..0000000
--- a/src/expressionLanguage/extension/core/token/ExtendsTokenParser.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package expressionLanguage.extension.core.token;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.tree.ExtendsNode;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.token.parser.Parser;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import expressionLanguage.token.parser.TokenParser;
-import expressionLanguage.token.parser.TokenStreamParser;
-
-public class ExtendsTokenParser implements TokenParser {
-
-    @Override
-    public Node parse(Token token, TokenStreamParser parser) {
-        TokenStream stream = parser.getStream();
-        Position position = token.getPosition();
-
-        // skip the 'extends' token
-        stream.next();
-
-        Expression<?> parentTemplateExpression = parser.getExpressionParser().parseExpression();
-
-        stream.expect(Type.EXECUTE_END);
-        return new ExtendsNode(position, parentTemplateExpression);
-    }
-
-    @Override
-    public String getTag() {
-        return "extends";
-    }
-}
diff --git a/src/expressionLanguage/extension/core/token/FilterTokenParser.java b/src/expressionLanguage/extension/core/token/FilterTokenParser.java
deleted file mode 100644
index 7a5f468..0000000
--- a/src/expressionLanguage/extension/core/token/FilterTokenParser.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package expressionLanguage.extension.core.token;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.extension.core.expression.FilterExpression;
-import expressionLanguage.extension.core.expression.RenderableNodeExpression;
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.tree.BodyNode;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.model.tree.PrintNode;
-import expressionLanguage.token.parser.Parser;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import expressionLanguage.token.parser.TokenParser;
-import expressionLanguage.token.parser.TokenStreamParser;
-import java.util.ArrayList;
-import java.util.List;
-
-/**
- * Parses the "filter" tag. It has nothing to do with implementing normal
- * filters.
- */
-public class FilterTokenParser implements TokenParser {
-
-    @Override
-    public Node parse(Token token, TokenStreamParser parser) {
-        TokenStream stream = parser.getStream();
-        Position position = token.getPosition();
-
-        // skip the 'filter' token
-        stream.next();
-
-        List<Expression<?>> filterInvocationExpressions = new ArrayList<>();
-
-        filterInvocationExpressions.add(parser.getExpressionParser().parseFilterInvocationExpression());
-
-        while(stream.current().isA(Type.OPERATOR, "|")){
-            // skip the '|' token
-            stream.next();
-            filterInvocationExpressions.add(parser.getExpressionParser().parseFilterInvocationExpression());
-        }
-
-        stream.expect(Type.EXECUTE_END);
-
-        BodyNode body = parser.subparse((Token subToken) -> subToken.isA(Type.NAME, "endfilter"));
-
-        stream.next();
-        stream.expect(Type.EXECUTE_END);
-
-        Expression<?> lastExpression = new RenderableNodeExpression(body);
-
-        for(Expression<?> filterInvocationExpression : filterInvocationExpressions){
-
-            FilterExpression filterExpression = new FilterExpression();
-            filterExpression.setRightExpression(filterInvocationExpression);
-            filterExpression.setLeftExpression(lastExpression);
-
-            lastExpression = filterExpression;
-        }
-
-        return new PrintNode(position, lastExpression);
-    }
-
-//    private StoppingCondition endFilter = (Token token) -> token.test(Token.Type.NAME, "endfilter");
-
-    @Override
-    public String getTag() {
-        return "filter";
-    }
-}
diff --git a/src/expressionLanguage/extension/core/token/FlushTokenParser.java b/src/expressionLanguage/extension/core/token/FlushTokenParser.java
deleted file mode 100644
index fa26c55..0000000
--- a/src/expressionLanguage/extension/core/token/FlushTokenParser.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package expressionLanguage.extension.core.token;
-
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.tree.FlushNode;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.token.parser.Parser;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import expressionLanguage.token.parser.TokenParser;
-import expressionLanguage.token.parser.TokenStreamParser;
-
-public class FlushTokenParser implements TokenParser {
-
-    @Override
-    public Node parse(Token token, TokenStreamParser parser) {
-
-        TokenStream stream = parser.getStream();
-        Position position = token.getPosition();
-
-        // skip over the 'flush' token
-        stream.next();
-
-        stream.expect(Type.EXECUTE_END);
-
-        return new FlushNode(position);
-    }
-
-    @Override
-    public String getTag() {
-        return "flush";
-    }
-}
diff --git a/src/expressionLanguage/extension/core/token/ForTokenParser.java b/src/expressionLanguage/extension/core/token/ForTokenParser.java
deleted file mode 100644
index 999dffb..0000000
--- a/src/expressionLanguage/extension/core/token/ForTokenParser.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package expressionLanguage.extension.core.token;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.tree.BodyNode;
-import expressionLanguage.model.tree.ForNode;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.token.parser.Parser;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import expressionLanguage.token.parser.TokenParser;
-import expressionLanguage.token.parser.TokenStreamParser;
-
-public class ForTokenParser implements TokenParser {
-
-    @Override
-    public Node parse(Token token, TokenStreamParser parser) {
-        TokenStream stream = parser.getStream();
-        Position position = token.getPosition();
-
-        // skip the 'for' token
-        stream.next();
-
-        // get the iteration variable
-        String iterationVariable = parser.getExpressionParser().parseNewVariableName();
-
-        stream.expect(Type.NAME, "in");
-
-        // get the iterable variable
-        Expression<?> iterable = parser.getExpressionParser().parseExpression();
-
-        stream.expect(Type.EXECUTE_END);
-
-        BodyNode body = parser.subparse((Token subToken) -> subToken.isA(Type.NAME, "else", "endfor"));
-
-        BodyNode elseBody = null;
-
-        if (stream.current().isA(Type.NAME, "else")) {
-            // skip the 'else' token
-            stream.next();
-            stream.expect(Type.EXECUTE_END);
-            elseBody = parser.subparse((Token subToken) -> subToken.isA(Type.NAME, "endfor"));
-        }
-
-        // skip the 'endfor' token
-        stream.next();
-
-        stream.expect(Type.EXECUTE_END);
-
-        return new ForNode(position, iterationVariable, iterable, body, elseBody);
-    }
-    
-    @Override
-    public String getTag() {
-        return "for";
-    }
-}
diff --git a/src/expressionLanguage/extension/core/token/IfTokenParser.java b/src/expressionLanguage/extension/core/token/IfTokenParser.java
deleted file mode 100644
index 8154d8b..0000000
--- a/src/expressionLanguage/extension/core/token/IfTokenParser.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package expressionLanguage.extension.core.token;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.tree.BodyNode;
-import expressionLanguage.model.tree.IfNode;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.token.parser.Parser;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import expressionLanguage.token.parser.TokenParser;
-import expressionLanguage.token.parser.TokenStreamParser;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.function.Predicate;
-import javafx.util.Pair;
-
-public class IfTokenParser implements TokenParser {
-    
-    private final Predicate<Token> decideIfFork = (Token token) -> token.isA(Type.NAME, "elseif", "else", "endif");
-
-    private final Predicate<Token> decideIfEnd = (Token token) -> token.isA(Type.NAME, "endif");
-
-    @Override
-    public Node parse(Token token, TokenStreamParser parser) {
-        TokenStream stream = parser.getStream();
-        Position position = token.getPosition();
-
-        // skip the 'if' token
-        stream.next();
-
-        List<Pair<Expression<?>, BodyNode>> conditionsWithBodies = new ArrayList<>();
-
-        Expression<?> expression = parser.getExpressionParser().parseExpression();
-
-        stream.expect(Type.EXECUTE_END);
-
-        BodyNode body = parser.subparse(decideIfFork);
-
-        conditionsWithBodies.add(new Pair<>(expression, body));
-
-        BodyNode elseBody = null;
-        boolean end = false;
-        while (!end) {
-            switch (stream.current().getValue()) {
-            case "else":
-                stream.next();
-                stream.expect(Type.EXECUTE_END);
-                elseBody = parser.subparse(decideIfEnd);
-                break;
-
-            case "elseif":
-                stream.next();
-                expression = parser.getExpressionParser().parseExpression();
-                stream.expect(Type.EXECUTE_END);
-                body = parser.subparse(decideIfFork);
-                conditionsWithBodies.add(new Pair<>(expression, body));
-                break;
-
-            case "endif":
-                stream.next();
-                end = true;
-                break;
-            default:
-                String msg = String.format("Unexpected end of template. Pebble was looking for the following tags \"else\", \"elseif\", or \"endif\" at line %s in file %s.", stream.current().getPosition(), stream.getFilename());
-                throw new IllegalStateException(msg);
-            }
-        }
-
-        stream.expect(Type.EXECUTE_END);
-        return new IfNode(position, conditionsWithBodies, elseBody);
-    }
-
-    @Override
-    public String getTag() {
-        return "if";
-    }
-}
diff --git a/src/expressionLanguage/extension/core/token/ImportTokenParser.java b/src/expressionLanguage/extension/core/token/ImportTokenParser.java
deleted file mode 100644
index 4ee8222..0000000
--- a/src/expressionLanguage/extension/core/token/ImportTokenParser.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package expressionLanguage.extension.core.token;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.tree.ImportNode;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.token.parser.Parser;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import expressionLanguage.token.parser.TokenParser;
-import expressionLanguage.token.parser.TokenStreamParser;
-
-public class ImportTokenParser implements TokenParser {
-
-    @Override
-    public Node parse(Token token, TokenStreamParser parser) {
-
-        TokenStream stream = parser.getStream();
-        Position position = token.getPosition();
-
-        // skip over the 'import' token
-        stream.next();
-
-        Expression<?> importExpression = parser.getExpressionParser().parseExpression();
-
-        stream.expect(Type.EXECUTE_END);
-
-        return new ImportNode(position, importExpression);
-    }
-
-    @Override
-    public String getTag() {
-        return "import";
-    }
-}
diff --git a/src/expressionLanguage/extension/core/token/IncludeTokenParser.java b/src/expressionLanguage/extension/core/token/IncludeTokenParser.java
deleted file mode 100644
index a85ec3d..0000000
--- a/src/expressionLanguage/extension/core/token/IncludeTokenParser.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package expressionLanguage.extension.core.token;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.extension.core.expression.MapExpression;
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.tree.IncludeNode;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import expressionLanguage.token.parser.TokenParser;
-import expressionLanguage.token.parser.TokenStreamParser;
-
-public class IncludeTokenParser implements TokenParser {
-
-    @Override
-    public Node parse(Token token, TokenStreamParser parser) {
-
-        TokenStream stream = parser.getStream();
-        Position position = token.getPosition();
-
-        // skip over the 'include' token
-        stream.next();
-
-        Expression<?> includeExpression = parser.getExpressionParser().parseExpression();
-
-        Token current = stream.current();
-        MapExpression mapExpression = null;
-
-        // We check if there is an optional 'with' parameter on the include tag.
-        if (current.getType().equals(Type.NAME) && current.getValue().equals("with")) {
-
-            // Skip over 'with'
-            stream.next();
-
-            Expression<?> parsedExpression = parser.getExpressionParser().parseExpression();
-
-            if (parsedExpression instanceof MapExpression) {
-                mapExpression = (MapExpression) parsedExpression;
-            } else {
-                String msg = String.format("Unexpected expression '%1s' at line %s in file %s.", parsedExpression .getClass().getCanonicalName(), token.getPosition(), stream.getFilename());
-                throw new IllegalStateException(msg);
-            }
-
-        }
-
-        stream.expect(Type.EXECUTE_END);
-
-        return new IncludeNode(position, includeExpression, mapExpression);
-    }
-
-    @Override
-    public String getTag() {
-        return "include";
-    }
-}
diff --git a/src/expressionLanguage/extension/core/token/MacroTokenParser.java b/src/expressionLanguage/extension/core/token/MacroTokenParser.java
deleted file mode 100644
index 1403512..0000000
--- a/src/expressionLanguage/extension/core/token/MacroTokenParser.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package expressionLanguage.extension.core.token;
-
-import expressionLanguage.model.tree.ArgumentsNode;
-import expressionLanguage.model.tree.BodyNode;
-import expressionLanguage.model.tree.MacroNode;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import expressionLanguage.token.parser.TokenParser;
-import expressionLanguage.token.parser.TokenStreamParser;
-import java.util.function.Predicate;
-
-public class MacroTokenParser implements TokenParser {
-
-    private final Predicate<Token> decideMacroEnd = (Token token) -> token.isA(Type.NAME, "endmacro");
-
-    @Override
-    public Node parse(Token token, TokenStreamParser parser) {
-
-        TokenStream stream = parser.getStream();
-
-        // skip over the 'macro' token
-        stream.next();
-
-        String macroName = stream.expect(Type.NAME).getValue();
-
-        ArgumentsNode args = parser.getExpressionParser().parseArguments(true);
-
-        stream.expect(Type.EXECUTE_END);
-
-        // parse the body
-        BodyNode body = parser.subparse(decideMacroEnd);
-
-        // skip the 'endmacro' token
-        stream.next();
-
-        stream.expect(Type.EXECUTE_END);
-
-        return new MacroNode(stream.current().getPosition(), macroName, args, body);
-    }
-
-    @Override
-    public String getTag() {
-        return "macro";
-    }
-}
diff --git a/src/expressionLanguage/extension/core/token/ParallelTokenParser.java b/src/expressionLanguage/extension/core/token/ParallelTokenParser.java
deleted file mode 100644
index 2bdbecb..0000000
--- a/src/expressionLanguage/extension/core/token/ParallelTokenParser.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package expressionLanguage.extension.core.token;
-
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.tree.BodyNode;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.model.tree.ParallelNode;
-import expressionLanguage.token.parser.Parser;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import expressionLanguage.token.parser.TokenParser;
-import expressionLanguage.token.parser.TokenStreamParser;
-import java.util.function.Predicate;
-
-public class ParallelTokenParser implements TokenParser {
-
-    private final Predicate<Token> decideParallelEnd = (Token token) -> token.isA(Type.NAME, "endparallel");
-
-    @Override
-    public Node parse(Token token, TokenStreamParser parser) {
-        TokenStream stream = parser.getStream();
-        Position position = token.getPosition();
-
-        // skip the 'parallel' token
-        stream.next();
-
-        stream.expect(Type.EXECUTE_END);
-
-        BodyNode body = parser.subparse(decideParallelEnd);
-
-        // skip the 'endparallel' token
-        stream.next();
-
-        stream.expect(Type.EXECUTE_END);
-        return new ParallelNode(position, body);
-    }
-
-    @Override
-    public String getTag() {
-        return "parallel";
-    }
-}
diff --git a/src/expressionLanguage/extension/core/token/SetTokenParser.java b/src/expressionLanguage/extension/core/token/SetTokenParser.java
deleted file mode 100644
index 7e1de22..0000000
--- a/src/expressionLanguage/extension/core/token/SetTokenParser.java
+++ /dev/null
@@ -1,39 +0,0 @@
-package expressionLanguage.extension.core.token;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.model.tree.SetNode;
-import expressionLanguage.token.parser.Parser;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import expressionLanguage.token.parser.TokenParser;
-import expressionLanguage.token.parser.TokenStreamParser;
-
-public class SetTokenParser implements TokenParser {
-
-    @Override
-    public Node parse(Token token, TokenStreamParser parser) {
-        TokenStream stream = parser.getStream();
-        Position position = token.getPosition();
-
-        // skip the 'set' token
-        stream.next();
-
-        String name = parser.getExpressionParser().parseNewVariableName();
-
-        stream.expect(Type.PUNCTUATION, "=");
-
-        Expression<?> value = parser.getExpressionParser().parseExpression();
-
-        stream.expect(Type.EXECUTE_END);
-
-        return new SetNode(position, name, value);
-    }
-
-    @Override
-    public String getTag() {
-        return "set";
-    }
-}
diff --git a/src/expressionLanguage/extension/core/token/VerbatimTokenParser.java b/src/expressionLanguage/extension/core/token/VerbatimTokenParser.java
deleted file mode 100644
index dee928d..0000000
--- a/src/expressionLanguage/extension/core/token/VerbatimTokenParser.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package expressionLanguage.extension.core.token;
-
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.parser.TokenParser;
-import expressionLanguage.token.parser.TokenStreamParser;
-
-/**
- * This is just a dummy class to point developers into the right direction; the
- * verbatim tag had to be implemented directly into the lexer.
- *
- */
-public class VerbatimTokenParser implements TokenParser {
-
-    @Override
-    public Node parse(Token token, TokenStreamParser parser) {
-        throw new UnsupportedOperationException();
-    }
-
-    @Override
-    public String getTag() {
-        return "verbatim";
-    }
-}
diff --git a/src/expressionLanguage/filter/DefaultFilter.java b/src/expressionLanguage/filter/DefaultFilter.java
deleted file mode 100644
index 5f9b989..0000000
--- a/src/expressionLanguage/filter/DefaultFilter.java
+++ /dev/null
@@ -1,48 +0,0 @@
-package expressionLanguage.filter;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.extension.core.test.EmptyTest;
-import expressionLanguage.test.Test;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-
-public class DefaultFilter implements Filter {
-
-    private final List<String> argumentNames = new ArrayList<>();
-
-    public DefaultFilter() {
-        argumentNames.add("default");
-    }
-    
-//    @Override
-    public String getName() {
-        return "default";
-    }
-
-//    @Override
-    public Object evaluate(EvaluationContext context, Map<String, Object> args) {
-        return null;
-    }
-    
-
-//    @Override
-    public List<String> getArgumentNames() {
-        return argumentNames;
-    }
-
-    @Override
-    public Object apply(Object input, Map<String, Object> args) {
-        return filter(input, args.get("default"));
-    }
-    
-    public Object filter(Object input, Object orElse) {
-        if (new EmptyTest().apply(input)) {
-            return orElse;
-        }
-        
-        return input;
-    }
-
-}
diff --git a/src/expressionLanguage/filter/Filter.java b/src/expressionLanguage/filter/Filter.java
deleted file mode 100644
index 243989b..0000000
--- a/src/expressionLanguage/filter/Filter.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package expressionLanguage.filter;
-
-import java.util.Map;
-
-public interface Filter {
-    
-    Object apply(Object input, Map<String, Object> args);
-}
diff --git a/src/expressionLanguage/function/Function.java b/src/expressionLanguage/function/Function.java
deleted file mode 100644
index d2f7569..0000000
--- a/src/expressionLanguage/function/Function.java
+++ /dev/null
@@ -1,60 +0,0 @@
-package expressionLanguage.function;
-
-import expressionLanguage.EvaluationContext;
-import java.util.List;
-import java.util.Map;
-import java.util.function.BiFunction;
-
-public interface Function {
-    
-    String getName();
-    List<String> getArgumentNames();
-    Object evaluate(EvaluationContext context, Map<String, Object> args);
-    
-    public static FunctionBuilder builder() {
-        return new FunctionBuilder();
-    }
-    
-    public static class FunctionBuilder {
-        
-        private String name;
-        
-        private BiFunction<EvaluationContext, Map<String, Object>, String> runnable;
-        
-        private List<String> argumentsNames;
-        
-        public FunctionBuilder named(String name) {
-            this.name = name;
-            return this;
-        }
-        
-        public FunctionBuilder with(String argName) {
-            this.argumentsNames.add(argName);
-            return this;
-        }
-        
-        public FunctionBuilder evaluation(BiFunction<EvaluationContext, Map<String, Object>, String> runnable) {
-            this.runnable = runnable;
-            return this;
-        }
-        
-        public Function build() {
-            return new Function() {
-                @Override
-                public String getName() {
-                    return name;
-                }
-                
-                @Override
-                public String evaluate(EvaluationContext context, Map<String, Object> args) {
-                    return runnable.apply(context, args);
-                }
-
-                @Override
-                public List<String> getArgumentNames() {
-                   return argumentsNames;
-                }
-            };
-        }
-    }
-}
diff --git a/src/expressionLanguage/function/RangeFunction.java b/src/expressionLanguage/function/RangeFunction.java
deleted file mode 100644
index cc84bc3..0000000
--- a/src/expressionLanguage/function/RangeFunction.java
+++ /dev/null
@@ -1,104 +0,0 @@
-package expressionLanguage.function;
-
-import expressionLanguage.EvaluationContext;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Range function to iterate over long or a string with a length of 1.
- *
- */
-public class RangeFunction implements Function {
-    
-    public static final String FUNCTION_NAME = "range";
-    private static final String PARAM_END = "end";
-    private static final String PARAM_INCREMENT = "increment";
-    private static final String PARAM_START = "start";
-    
-    private final List<String> argumentNames = new ArrayList<>();
-
-    public RangeFunction() {
-        this.argumentNames.add(PARAM_START);
-        this.argumentNames.add(PARAM_END);
-        this.argumentNames.add(PARAM_INCREMENT);
-    }
-
-    @Override
-    public String getName() {
-        return FUNCTION_NAME;
-    }
-
-    @Override
-    public String evaluate(EvaluationContext context, Map<String, Object> args) {
-        Object start = args.get(PARAM_START);
-        Object end = args.get(PARAM_END);
-        Object increment = (Object) args.get(PARAM_INCREMENT);
-        if (increment == null) {
-            increment = 1L;
-        }
-        else if (!(increment instanceof Number)) {
-            throw new IllegalArgumentException("The increment of the range function must be a number " + increment);
-        }
-        
-        Long incrementNum = ((Number) increment).longValue();
-
-        List<Object> results = new ArrayList<>();
-        // Iterating over Number
-        if (start instanceof Number && end instanceof Number) {
-            Long startNum = ((Number) start).longValue();
-            Long endNum = ((Number) end).longValue();
-
-            if (incrementNum > 0) {
-                for (Long i = startNum; i <= endNum; i += incrementNum) {
-                    results.add(i);
-                }
-            }
-            else if (incrementNum < 0) {
-                for (Long i = startNum; i >= endNum; i += incrementNum) {
-                    results.add(i);
-                }
-            }
-            else {
-                throw new IllegalArgumentException("The increment of the range function must be different than 0");
-            }
-        }
-        // Iterating over character
-        else if (start instanceof String && end instanceof String) {
-            String startStr = (String) start;
-            String endStr = (String) end;
-            if (startStr.length() != 1 || endStr.length() != 1) {
-                throw new IllegalArgumentException("Arguments of range function must be of type Number or String with "
-                        + "a length of 1");
-            }
-
-            char startChar = startStr.charAt(0);
-            char endChar = endStr.charAt(0);
-
-            if (incrementNum > 0) {
-                for (int i = startChar; i <= endChar; i += incrementNum) {
-                    results.add((char) i);
-                }
-            }
-            else if (incrementNum < 0) {
-                for (int i = startChar; i >= endChar; i += incrementNum) {
-                    results.add((char) i);
-                }
-            }
-            else {
-                throw new IllegalArgumentException("The increment of the range function must be different than 0");
-            }
-        }
-        else {
-            throw new IllegalArgumentException("Arguments of range function must be of type Number or String with a "
-                    + "length of 1");
-        }
-
-        return results.toString();
-    }
-
-    @Override
-    public List<String> getArgumentNames() {
-        return this.argumentNames;
-    }
-}
diff --git a/src/expressionLanguage/lexer/Lexer.java b/src/expressionLanguage/lexer/Lexer.java
deleted file mode 100644
index 7251c1b..0000000
--- a/src/expressionLanguage/lexer/Lexer.java
+++ /dev/null
@@ -1,515 +0,0 @@
-package expressionLanguage.lexer;
-
-import com.marvin.component.util.StringUtils;
-import expressionLanguage.model.position.Source;
-import expressionLanguage.operator.Operator;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.Map;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import static java.util.regex.Pattern.compile;
-import javafx.util.Pair;
-
-public class Lexer {
-
-    private static final Pattern PATTERN_NAME = compile("^[a-zA-Z_][a-zA-Z0-9_]*");
-
-    private static final Pattern PATTERN_NUMBER = compile("^[0-9]+(\\.[0-9]+)?");
-
-    // the negative lookbehind assertion is used to ignore escaped quotation marks
-    private static final Pattern PATTERN_STRING = compile("((\").*?(?<!\\\\)(\"))|((').*?(?<!\\\\)('))", Pattern.DOTALL);
-
-    private static final String PUNCTUATION = "()[]{}?:.,|=";
-
-    protected Syntax syntax;
-
-    protected Source source;
-
-    protected ArrayList<Token> tokens;
-
-    protected Pattern regexOperators;
-
-    private LinkedList<Pair<String, Integer>> brackets;
-    
-    private boolean trimLeadingWhitespaceFromNextData = false;
-
-    /**
-     * The state of the lexer is important so that we know what to expect next
-     * and to help discover errors in the template (ex. unclosed comments).
-     */
-    private State state;
-
-    private LinkedList<State> states;
-
-    private enum State {
-        DATA, EXECUTE, PRINT, COMMENT
-    }
-
-
-    public Lexer() {
-        
-    }
-    
-    public TokenStream tokenize(Source source) {
-        this.tokens = new ArrayList();
-        this.source = source;
-        
-        return doTokenize();
-    }
-
-    public TokenStream doTokenize() {
-
-        this.brackets = new LinkedList<>();
-
-        this.states = new LinkedList<>();
-        this.state = State.DATA;
-        /*
-         * loop through the entire source and apply different lexing methods
-         * depending on what kind of state we are in at the time.
-         *
-         * This will always start on lexData();
-         */
-        while (this.source.length() > 0) {
-            switch (this.state) {
-                case DATA:
-                    lexData();
-                    break;
-                case EXECUTE:
-                    lexExecute();
-                    break;
-                case PRINT:
-                    lexPrint();
-                    break;
-                case COMMENT:
-                    lexComment();
-                    break;
-                default:
-                    break;
-            }
-
-        }
-
-        // end of file token
-        pushToken(Type.EOF);
-
-        // make sure that all brackets have been closed, else throw an error
-        if (!this.brackets.isEmpty()) {
-            String msg = String.format("Unclosed \"%s\" at .", brackets.pop().getKey(), source.getPosition());
-            throw new IllegalStateException(msg);
-        }
-
-        return new TokenStream(tokens, source.getName());
-    }
-
-    private void lexData() {
-
-        Matcher matcher = this.syntax.getRegexStartDelimiters().matcher(source);
-        boolean match = matcher.find();
-
-        String text;
-        String startDelimiterToken = null;
-
-        if (!match) {
-
-            text = source.toString();
-            source.advance(source.length());
-
-        } else {
-
-            text = source.substring(matcher.start());
-            startDelimiterToken = source.substring(matcher.start(), matcher.end());
-            source.advance(matcher.end());
-        }
-        
-        if (trimLeadingWhitespaceFromNextData) {
-            text = StringUtils.trimLeadingWhitespace(text);
-            trimLeadingWhitespaceFromNextData = false;
-        }
-        
-        Token textToken = pushToken(Type.TEXT, text);
-
-        if (match) {
-
-            checkForLeadingWhitespaceTrim(textToken);
-
-            if (this.syntax.getCommentOpen().equals(startDelimiterToken)) {
-                pushState(State.COMMENT);
-            } else if (this.syntax.getPrintOpen().equals(startDelimiterToken)) {
-
-                pushToken(Type.PRINT_START, this.syntax.getPrintOpen());
-                pushState(State.PRINT);
-
-            } else if ((this.syntax.getExecuteOpen().equals(startDelimiterToken))) {
-                pushToken(Type.EXECUTE_START, this.syntax.getExecuteOpen());
-                pushState(State.EXECUTE);
-            }
-        }
-
-    }
-
-    private void lexExecute() {
-
-        // check for the trailing whitespace trim character
-        checkForTrailingWhitespaceTrim();
-
-        Matcher matcher = this.syntax.getRegexExecuteClose().matcher(source);
-
-        // check if we are at the execute closing delimiter
-        if (matcher.lookingAt() && brackets.isEmpty()) {
-            pushToken(Type.EXECUTE_END, this.syntax.getExecuteClose());
-            source.advance(matcher.end());
-            popState();
-        } else {
-            lexExpression();
-        }
-
-    }
-
-    private void lexPrint() {
-
-        // check for the trailing whitespace trim character
-        checkForTrailingWhitespaceTrim();
-        Matcher matcher = this.syntax.getRegexPrintClose().matcher(source);
-
-        // check if we are at the print closing delimiter
-        if (matcher.lookingAt() && brackets.isEmpty()) {
-            pushToken(Type.PRINT_END, this.syntax.getPrintClose());
-            source.advance(matcher.end());
-            popState();
-        } else {
-            lexExpression();
-        }
-
-    }
-
-    private void lexExpression() {
-        String token;
-
-        // whitespace
-        source.advanceThroughWhitespace();
-
-        Matcher matcher;
-
-        /*
-         * Matcher matcher = REGEX_WHITESPACE.matcher(source); if
-         * (matcher.lookingAt()) { source.advance(matcher.end()); }
-         */
-        // operators
-        if (regexOperators != null) {
-            matcher = regexOperators.matcher(source);
-            if (matcher.lookingAt()) {
-                token = source.substring(matcher.end());
-                pushToken(Type.OPERATOR, token);
-                source.advance(matcher.end());
-                return;
-            }
-        }
-
-        // names
-        matcher = PATTERN_NAME.matcher(source);
-        if (matcher.lookingAt()) {
-            token = source.substring(matcher.end());
-            pushToken(Type.NAME, token);
-            source.advance(matcher.end());
-            return;
-        }
-
-        // numbers
-        matcher = PATTERN_NUMBER.matcher(source);
-        if (matcher.lookingAt()) {
-            token = source.substring(matcher.end());
-            pushToken(Type.NUMBER, token);
-            source.advance(matcher.end());
-            return;
-        }
-
-        // punctuation
-        if (PUNCTUATION.indexOf(source.charAt(0)) >= 0) {
-            String character = String.valueOf(source.charAt(0));
-
-            // opening bracket
-            if ("([{".contains(character)) {
-                brackets.push(new Pair<>(character, source.getLineNumber()));
-            } // closing bracket
-            else if (")]}".contains(character)) {
-                if (brackets.isEmpty()) {
-                    String msg = String.format("Unexpected \"" + character + "\" at %s", source.getPosition());
-                    throw new IllegalStateException(msg);
-                } else {
-                    HashMap<String, String> validPairs = new HashMap<>();
-                    validPairs.put("(", ")");
-                    validPairs.put("[", "]");
-                    validPairs.put("{", "}");
-                    String lastBracket = brackets.pop().getKey();
-                    String expected = validPairs.get(lastBracket);
-                    if (!expected.equals(character)) {
-                        String msg = String.format("Unclosed \"" + expected + "\" at %s", source.getPosition());
-                        throw new IllegalStateException(msg);
-                    }
-                }
-            }
-
-            pushToken(Type.PUNCTUATION, character);
-            source.advance(1);
-            return;
-        }
-
-        // strings
-        matcher = PATTERN_STRING.matcher(source);
-        if (matcher.lookingAt()) {
-            token = source.substring(matcher.end());
-
-            source.advance(matcher.end());
-
-            char quotationType = token.charAt(0);
-
-            // remove first and last quotation marks
-            token = token.substring(1, token.length() - 1);
-
-            // remove backslashes used to escape inner quotation marks
-            if (quotationType == '\'') {
-                token = token.replaceAll("\\\\(')", "$1");
-            } else if (quotationType == '"') {
-                token = token.replaceAll("\\\\(\")", "$1");
-            }
-
-            pushToken(Type.STRING, token);
-            return;
-        }
-
-        String msg = String.format("Unexpected character [%s], at %s.", source.charAt(0), source.getPosition());
-        // we should have found something and returned by this point
-        throw new IllegalStateException(msg);
-    }
-
-    private void lexComment() {
-
-        // all we need to do is find the end of the comment.
-        Matcher matcher = this.syntax.getRegexCommentClose().matcher(source);
-
-        boolean match = matcher.find(0);
-
-        if (!match) {
-            String msg = String.format("Unclosed comment at line %s, in file %s.", source.getLineNumber(), source.getName());
-            throw new IllegalStateException(msg);
-        }
-
-        /*
-         * check if the commented ended with the whitespace trim character by
-         * reversing the comment and performing a regular forward regex search.
-         */
-        String comment = source.substring(matcher.start());
-        String reversedComment = new StringBuilder(comment).reverse().toString();
-        Matcher whitespaceTrimMatcher = this.syntax.getRegexLeadingWhitespaceTrim().matcher(reversedComment);
-
-        if (whitespaceTrimMatcher.lookingAt()) {
-            this.trimLeadingWhitespaceFromNextData = true;
-        }
-
-        // move cursor to end of comment (and closing delimiter)
-        source.advance(matcher.end());
-        popState();
-    }
-
-    private void checkForTrailingWhitespaceTrim() {
-        Matcher whitespaceTrimMatcher = this.syntax.getRegexTrailingWhitespaceTrim().matcher(source);
-        
-        if(whitespaceTrimMatcher.lookingAt()) {
-            this.trimLeadingWhitespaceFromNextData = true;
-        }
-    }
-
-    private void checkForLeadingWhitespaceTrim(Token leadingToken) {
-
-        Matcher whitespaceTrimMatcher = this.syntax.getRegexLeadingWhitespaceTrim().matcher(source);
-
-        if (whitespaceTrimMatcher.lookingAt()) {
-            if (leadingToken != null) {
-                leadingToken.setValue(StringUtils.trimLeadingWhitespace(leadingToken.getValue()));
-            }
-            source.advance(whitespaceTrimMatcher.end());
-        }
-    }
-
-    private Token pushToken(Type type) {
-        return pushToken(type, null);
-    }
-
-    /**
-     * Create a Token of a certain type and value and push it into the list of
-     * tokens that we are maintaining. `
-     *
-     * @param type The type of token we are creating
-     * @param value The value of the new token
-     */
-    private Token pushToken(Type type, String value) {
-
-        // ignore empty text tokens
-        if (type.equals(Type.TEXT) && (value == null || "".equals(value))) {
-            return null;
-        }
-//source.getName(), source.getLineNumber(), 0
-        Token result = new Token(type, value, this.source.getPosition());
-
-        this.tokens.add(result);
-
-        return result;
-    }
-
-//    /**
-//     * Retrieves the operators (both unary and binary) from the PebbleEngine and
-//     * then dynamically creates one giant regular expression to detect for the
-//     * existence of one of these operators.
-//     *
-//     * @return Pattern The regular expression used to find an operator
-//     */
-//    private void buildOperatorRegex() {
-//
-//        List<String> operators = new ArrayList<>();
-//
-//        if (unaryOperators != null) {
-//            unaryOperators.keySet().stream().forEach(operators::add);
-//        }
-//
-//        if (binaryOperators != null) {
-//            binaryOperators.keySet().stream().forEach(operators::add);
-//        }
-//
-//        if (!operators.isEmpty()) {
-//            StringBuilder regex = new StringBuilder("^");
-//
-//            boolean isFirst = true;
-//
-//            for (String operator : operators) {
-//                if (isFirst) {
-//                    isFirst = false;
-//                } else {
-//                    regex.append("|");
-//                }
-//                regex.append(Pattern.quote(operator));
-//
-//                char nextChar = operator.charAt(operator.length() - 1);
-//                if (Character.isLetter(nextChar) || Character.getType(nextChar) == Character.LETTER_NUMBER) {
-//                    regex.append("(?![a-zA-Z])");
-//                }
-//            }
-//
-//            this.regexOperators = Pattern.compile(regex.toString());
-//        }
-//
-//    }
-
-    /**
-     * Pushes the current state onto the stack and then updates the current
-     * state to the new state.
-     *
-     * @param state The new state to use as the current state
-     */
-    private void pushState(State state) {
-        this.states.push(this.state);
-        this.state = state;
-    }
-
-    /**
-     * Pop state from the stack
-     */
-    private void popState() {
-        this.state = this.states.pop();
-    }
-
-    public Syntax getSyntax() {
-        return syntax;
-    }
-
-    public void setSyntax(Syntax syntax) {
-        this.syntax = syntax;
-    }
-
-    public Source getSource() {
-        return source;
-    }
-
-    public void setSource(Source source) {
-        this.source = source;
-    }
-
-    public ArrayList<Token> getTokens() {
-        return tokens;
-    }
-
-    public void setRegexOperators(Pattern regexOperators) {
-        this.regexOperators = regexOperators;
-    }
-
-    public void setTrimLeadingWhitespaceFromNextData(boolean trimLeadingWhitespaceFromNextData) {
-        this.trimLeadingWhitespaceFromNextData = trimLeadingWhitespaceFromNextData;
-    }
-    
-    public static LexerBuilder builder() {
-        return new LexerBuilder();
-    }
-    
-    public static class LexerBuilder {
-        
-        protected Syntax syntax;
-
-        protected Map<String, Operator> operators;
-
-        private boolean trimLeadingWhitespaceFromNextData = false;
-        
-        public LexerBuilder syntax(Syntax syntax) {
-            this.syntax = syntax;
-            return this;
-        }
-        
-        public LexerBuilder operator(String symbol, Operator operator) {
-            if (this.operators == null) {
-                this.operators = new HashMap<>();
-            }
-            
-            this.operators.put(symbol, operator);
-            return this;
-        }
-        
-        public LexerBuilder operators(Map<String, Operator> operators) {
-            if (this.operators == null) {
-                this.operators = new HashMap<>();
-            }
-            
-            this.operators.putAll(operators);
-            return this;
-        }
-        
-        public LexerBuilder trim(boolean trim) {
-            this.trimLeadingWhitespaceFromNextData = trim;
-            return this;
-        }
-        
-        
-        public Lexer build() {
-            Lexer lexer = new Lexer();
-            
-            lexer.setSyntax(syntax);
-            lexer.setTrimLeadingWhitespaceFromNextData(trimLeadingWhitespaceFromNextData);
-            
-            if (this.operators != null && !this.operators.isEmpty()) {
-                String regex = this.operators.keySet().stream().reduce("^", (a, symbol) -> {
-                    char nextChar = symbol.charAt(symbol.length() - 1);
-                    return a.concat(a.contentEquals("^") ? "" : "|")
-                            .concat(Pattern.quote(symbol))
-                            .concat(Character.isLetter(nextChar) || Character.getType(nextChar) == Character.LETTER_NUMBER ? "(?![a-zA-Z])" : "");
-                });
-
-                lexer.setRegexOperators(Pattern.compile(regex));
-            }
-            
-            return lexer;
-        }
-        
-    }
-}
diff --git a/src/expressionLanguage/lexer/Syntax.java b/src/expressionLanguage/lexer/Syntax.java
deleted file mode 100644
index d58cbfd..0000000
--- a/src/expressionLanguage/lexer/Syntax.java
+++ /dev/null
@@ -1,245 +0,0 @@
-package expressionLanguage.lexer;
-
-import java.util.regex.Pattern;
-
-import static java.util.regex.Pattern.compile;
-import static java.util.regex.Pattern.quote;
-
-public class Syntax {
-
-    private static final String POSSIBLE_NEW_LINE = "(\r\n|\n\r|\r|\n|\u0085|\u2028|\u2029)?";
-    
-    private String commentOpen;
-
-    private String commentClose;
-
-    private String executeOpen;
-
-    private String executeClose;
-
-    private String printOpen;
-
-    private String printClose;
-
-    private String wsTrim;
-
-    private Pattern regexPrintClose;
-
-    private Pattern regexExecuteClose;
-
-    private Pattern regexCommentClose;
-
-    private Pattern regexStartDelimiters;
-
-    private Pattern regexLeadingWhitespaceTrim;
-
-    private Pattern regexTrailingWhitespaceTrim;
-    
-    protected Pattern regexOperators;
-
-    public Pattern getRegexPrintClose() {
-        if (this.regexPrintClose == null) {
-            this.regexPrintClose = compile(
-                    "^\\s*" + quote(wsTrim) + 
-                    "?" + quote(printClose) + 
-                    POSSIBLE_NEW_LINE);
-        }
-        return regexPrintClose;
-    }
-
-    public Pattern getRegexExecuteClose() {
-        if (this.regexExecuteClose == null) {
-            this.regexExecuteClose = compile(
-                    "^\\s*" + quote(wsTrim) + 
-                    "?" + quote(executeClose) + 
-                    POSSIBLE_NEW_LINE);
-        }
-        return regexExecuteClose;
-    }
-
-    public Pattern getRegexCommentClose() {
-        if (this.regexCommentClose == null) {
-            this.regexCommentClose = compile(
-                quote(commentClose) + 
-                POSSIBLE_NEW_LINE);
-        }
-        return regexCommentClose;
-    }
-
-    public Pattern getRegexStartDelimiters() {
-        if (regexStartDelimiters == null) {
-             this.regexStartDelimiters = compile(
-                    quote(printOpen) + "|" + 
-                    quote(executeOpen) + "|" + 
-                    quote(commentOpen));
-        }
-        return regexStartDelimiters;
-    }
-
-    public Pattern getRegexLeadingWhitespaceTrim() {
-        if (regexLeadingWhitespaceTrim == null) {
-            this.regexLeadingWhitespaceTrim = compile(quote(wsTrim) + "\\s+");
-        }
-        return regexLeadingWhitespaceTrim;
-    }
-
-    public Pattern getRegexTrailingWhitespaceTrim() {
-        if (regexTrailingWhitespaceTrim == null) {
-            this.regexTrailingWhitespaceTrim = compile(
-                    "^\\s*" + quote(wsTrim) + 
-                    "(" + quote(printClose) + 
-                        "|" + quote(executeClose) + 
-                        "|" + quote(commentClose) + 
-                    ")");
-        }
-        return regexTrailingWhitespaceTrim;
-    }
-
-    public String getCommentOpen() {
-        return commentOpen;
-    }
-
-    public void setCommentOpen(String commentOpen) {
-        this.commentOpen = commentOpen;
-    }
-
-    public String getCommentClose() {
-        return commentClose;
-    }
-
-    public void setCommentClose(String commentClose) {
-        this.commentClose = commentClose;
-    }
-
-    public String getExecuteOpen() {
-        return executeOpen;
-    }
-
-    public void setExecuteOpen(String executeOpen) {
-        this.executeOpen = executeOpen;
-    }
-
-    public String getExecuteClose() {
-        return executeClose;
-    }
-
-    public void setExecuteClose(String executeClose) {
-        this.executeClose = executeClose;
-    }
-
-    public String getPrintOpen() {
-        return printOpen;
-    }
-
-    public void setPrintOpen(String printOpen) {
-        this.printOpen = printOpen;
-    }
-
-    public String getPrintClose() {
-        return printClose;
-    }
-
-    public void setPrintClose(String printClose) {
-        this.printClose = printClose;
-    }
-
-    public String getWsTrim() {
-        return wsTrim;
-    }
-
-    public void setWsTrim(String wsTrim) {
-        this.wsTrim = wsTrim;
-    }
-
-    public static SyntaxBuilder builder() {
-        return new SyntaxBuilder();
-    }
-
-    public static class SyntaxBuilder {
-
-        private String commentOpen;
-
-        private String commentClose;
-
-        private String executeOpen;
-
-        private String executeClose;
-
-        private String printOpen;
-
-        private String printClose;
-
-        private String wsTrim;
-
-        public SyntaxBuilder comment(String open, String close) {
-            this.commentOpen = open;
-            this.commentClose = close;
-            return this;
-        }
-
-        public SyntaxBuilder commentOpen(String commentOpen) {
-            this.commentOpen = commentOpen;
-            return this;
-        }
-
-        public SyntaxBuilder commentClose(String commentClose) {
-            this.commentClose = commentClose;
-            return this;
-        }
-
-        public SyntaxBuilder execute(String open, String close) {
-            this.executeOpen = open;
-            this.executeClose = close;
-            return this;
-        }
-
-        public SyntaxBuilder executeOpen(String executeOpen) {
-            this.executeOpen = executeOpen;
-            return this;
-        }
-
-        public SyntaxBuilder executeClose(String executeClose) {
-            this.executeClose = executeClose;
-            return this;
-        }
-
-        public SyntaxBuilder print(String open, String close) {
-            this.printOpen = open;
-            this.printClose = close;
-            return this;
-        }
-        
-        public SyntaxBuilder printClose(String printClose) {
-            this.printClose = printClose;
-            return this;
-        }
-
-        public SyntaxBuilder printOpen(String printOpen) {
-            this.printOpen = printOpen;
-            return this;
-        }
-
-        public SyntaxBuilder wsTrim(String wsTrim) {
-            this.wsTrim = wsTrim;
-            return this;
-        }
-
-        public Syntax build() {
-            Syntax syntax = new Syntax();
-
-            syntax.setCommentClose(commentClose);
-            syntax.setCommentOpen(commentOpen);
-
-            syntax.setExecuteClose(executeClose);
-            syntax.setExecuteOpen(executeOpen);
-
-            syntax.setPrintClose(printClose);
-            syntax.setPrintOpen(printOpen);
-
-            syntax.setWsTrim(wsTrim);
-
-            return syntax;
-        }
-    }
-
-}
diff --git a/src/expressionLanguage/model/position/Position.java b/src/expressionLanguage/model/position/Position.java
deleted file mode 100644
index d8c591b..0000000
--- a/src/expressionLanguage/model/position/Position.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package expressionLanguage.model.position;
-
-public class Position {
-    
-    private final String name;
-    private final int line;
-    private final int column;
-
-    public Position(String name, int line, int column) {
-        this.name = name;
-        this.line = line;
-        this.column = column;
-    }
-
-    public int getLine() {
-        return line;
-    }
-
-    public int getColumn() {
-        return column;
-    }
-
-    @Override
-    public String toString() {
-        return String.format("%s (Line: %d, Column: %d)", name, line, column);
-    }
-}
diff --git a/src/expressionLanguage/model/position/Source.java b/src/expressionLanguage/model/position/Source.java
deleted file mode 100644
index ed27ed7..0000000
--- a/src/expressionLanguage/model/position/Source.java
+++ /dev/null
@@ -1,210 +0,0 @@
-package expressionLanguage.model.position;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.util.Arrays;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-public class Source implements CharSequence {
-
-    private final String name;
-
-    /**
-     * The characters found within the template.
-     */
-    private final char[] source;
-
-    /**
-     * Number of characters stored in source array remaining to be tokenized
-     */
-    private int size = 0;
-
-    /**
-     * Default capacity
-     */
-    private static final int DEFAULT_CAPACITY = 1024;
-
-    /**
-     * An index of the first character for the remaining un-tokenized source.
-     */
-    private int offset = 0;
-
-    /**
-     * Tracking the line number that we are currently tokenizing.
-     */
-    private int lineNumber = 1;
-    private int columnNumber = 1;
-
-    public Source(String name, char[] source, int size) {
-        this.name = name;
-        this.source = source;
-        this.size = size;
-    }
-
-    /**
-     * Moves the start index a certain amount. While traversing this amount we
-     * will count how many newlines have been encountered.
-     *
-     * @param amount Amount of characters to advance by
-     */
-    public void advance(int amount) {
-
-        int index = 0;
-        while (index < amount) {
-            int sizeOfNewline = advanceThroughNewline(index);
-
-            if (sizeOfNewline > 0) {
-                index += sizeOfNewline;
-            } else {
-                index++;
-            }
-        }
-
-        this.size -= amount;
-        this.offset += amount;
-    }
-
-    public void advanceThroughWhitespace() {
-        int index = 0;
-
-        while (Character.isWhitespace(charAt(index))) {
-            int sizeOfNewline = advanceThroughNewline(index);
-
-            if (sizeOfNewline > 0) {
-                index += sizeOfNewline;
-            } else {
-                index++;
-            }
-        }
-
-        this.size -= index;
-        this.offset += index;
-    }
-
-    /**
-     * Advances through possible newline character and returns how many
-     * characters were used to represent the newline (windows uses two
-     * characters to represent one newline).
-     *
-     * @param index The index of the potential newline character
-     * @return
-     */
-    private int advanceThroughNewline(int index) {
-        char character = this.charAt(index);
-        int numOfCharacters = 0;
-
-        // windows newline
-        if ('\r' == character && '\n' == charAt(index + 1)) {
-
-            this.lineNumber++;
-            numOfCharacters = 2;
-
-            // various other newline characters
-        } else if ('\n' == character || '\r' == character 
-                || '\u0085' == character || '\u2028' == character
-                || '\u2029' == character) {
-
-            this.lineNumber++;
-            numOfCharacters = 1;
-        }
-        this.columnNumber++;
-        return numOfCharacters;
-    }
-
-    public String substring(int start, int end) {
-        return new String(Arrays.copyOfRange(source, this.offset + start, this.offset + end));
-    }
-
-    public String substring(int end) {
-        return new String(Arrays.copyOfRange(source, offset, offset + end));
-    }
-
-    @Override
-    public int length() {
-        return size;
-    }
-
-    @Override
-    public char charAt(int index) {
-        return source[offset + index];
-    }
-
-    @Override
-    public CharSequence subSequence(int start, int end) {
-        return new String(Arrays.copyOfRange(source, this.offset + start, this.offset + end));
-    }
-
-    @Override
-    public String toString() {
-        return new String(Arrays.copyOfRange(source, offset, offset + size));
-    }
-    
-    
-    public Position getPosition() {
-        return new Position(getName(), lineNumber, columnNumber);
-    }
-
-    public int getLineNumber() {
-        return lineNumber;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public static SourceBuilder builder(String name) {
-        return new SourceBuilder(name);
-    }
-
-    public static class SourceBuilder {
-
-        private final String name;
-        private char[] source = new char[DEFAULT_CAPACITY];
-        private int size = 0;
-
-        public SourceBuilder(String name) {
-            this.name = name;
-        }
-
-        public SourceBuilder read(Reader reader) {
-            try {
-                char[] buffer = new char[1024 * 4];
-                int amountJustRead = 0;
-                while ((amountJustRead = reader.read(buffer)) != -1) {
-                    ensureCapacity(size + amountJustRead);
-                    append(buffer, amountJustRead);
-                }
-                reader.close();
-            } catch (IOException ex) {
-                Logger.getLogger(Source.class.getName()).log(Level.SEVERE, null, ex);
-            }
-            return this;
-        }
-
-        public SourceBuilder append(char[] characters, int amount) {
-            for (int i = 0; i < amount; ++i) {
-                this.source[size + i] = characters[i];
-            }
-            size += amount;
-            return this;
-        }
-
-        public Source build() {
-            return new Source(this.name, this.source, this.size);
-        }
-
-        private void ensureCapacity(int minCapacity) {
-            if (source.length - minCapacity < 0) {
-                grow(minCapacity);
-            }
-        }
-
-        private void grow(int minCapacity) {
-            int oldCapacity = source.length;
-            int newCapacity = Math.max(oldCapacity << 1, minCapacity);
-
-            this.source = Arrays.copyOf(source, newCapacity);
-        }
-    }
-}
diff --git a/src/expressionLanguage/model/template/Block.java b/src/expressionLanguage/model/template/Block.java
deleted file mode 100644
index 837ca64..0000000
--- a/src/expressionLanguage/model/template/Block.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package expressionLanguage.model.template;
-
-import expressionLanguage.EvaluationContext;
-
-public interface Block {
-
-    String getName();
-
-    void evaluate(Template self, EvaluationContext context);
-}
diff --git a/src/expressionLanguage/model/template/Hierarchy.java b/src/expressionLanguage/model/template/Hierarchy.java
deleted file mode 100644
index d9465e7..0000000
--- a/src/expressionLanguage/model/template/Hierarchy.java
+++ /dev/null
@@ -1,85 +0,0 @@
-package expressionLanguage.model.template;
-
-import java.util.ArrayList;
-
-/**
- * A data structure that represents the entire inheritance hierarchy
- * of the current template and tracks which level in the hierarchy
- * we are currently evaluating.
- */
-public class Hierarchy {
-
-    /**
-     * A list of all the templates in this hierarchy. A template at index i is the child
-     * to the template at index i+1.
-     */
-    private final ArrayList<Template> hierarchy = new ArrayList<>();
-
-    /**
-     * Index of the template currently being evaluated.
-     */
-    private int current = 0;
-
-    /**
-     * Constructs an inheritance chain with one known template.
-     *
-     * @param current The current node
-     */
-    public Hierarchy(Template current) {
-        hierarchy.add(current);
-    }
-
-    /**
-     * Adds a known ancestor onto the inheritance chain, does not
-     * increment which template is the "current" template being evaluated.
-     *
-     * @param ancestor The ancestor template
-     */
-    public void pushAncestor(Template ancestor) {
-        hierarchy.add(ancestor);
-    }
-
-    /**
-     * Signifies that the parent template in the hierarchy is now being evaluated so it should
-     * be considered the "current" template.
-     */
-    public void ascend() {
-        current++;
-    }
-
-    /**
-     * Signifies that the child template in the hierarchy is now being evaluated so i t
-     * should be considered the "current" template.
-     */
-    public void descend() {
-        current--;
-    }
-
-    /**
-     * Returns the child of the template currently being evaluated or null if there is no child.
-     *
-     * @return The child template if exists or null
-     */
-    public Template getChild() {
-        if (current == 0) {
-            return null;
-        }
-        return hierarchy.get(current - 1);
-    }
-
-    /**
-     * Returns the parent of the template currently being evaluated or null if there is no parent.
-     *
-     * @return The parent template if exists or null
-     */
-    public Template getParent() {
-        if (current == hierarchy.size() - 1) {
-            return null;
-        }
-        return hierarchy.get(current + 1);
-    }
-    
-    public Template get() {
-        return hierarchy.get(current);
-    }
-}
diff --git a/src/expressionLanguage/model/template/Template.java b/src/expressionLanguage/model/template/Template.java
deleted file mode 100644
index 578a6a0..0000000
--- a/src/expressionLanguage/model/template/Template.java
+++ /dev/null
@@ -1,203 +0,0 @@
-package expressionLanguage.model.template;
-
-import expressionLanguage.Engine;
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.function.Function;
-import expressionLanguage.model.tree.ArgumentsNode;
-import expressionLanguage.model.tree.RootNode;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * The actual implementation of a Template
- */
-public class Template {
-
-    /**
-     * A template has to store a reference to the main engine so that it can
-     * compile other templates when using the "import" or "include" tags.
-     * <p>
-     * It will also retrieve some stateful information such as the default locale
-     * when necessary. Luckily, the engine is immutable so this should be thread safe.
-     */
-    private final Engine engine;
-
-    /**
-     * Blocks defined inside this template.
-     */
-    private final Map<String, Block> blocks = new HashMap<>();
-
-    /**
-     * Macros defined inside this template.
-     */
-    private final Map<String, Function> macros = new HashMap<>();
-
-    /**
-     * The root node of the AST to be rendered.
-     */
-    private final RootNode rootNode;
-
-    /**
-     * Name of template. Used to help with debugging.
-     */
-    private final String name;
-
-    /**
-     * Constructor
-     *
-     * @param engine The engine used to construct this template
-     * @param root   The root not to evaluate
-     * @param name   The name of the template
-     */
-    public Template(Engine engine, RootNode root, String name) {
-        this.engine = engine;
-        this.rootNode = root;
-        this.name = name;
-    }
-    
-    /**
-     * Registers a block.
-     *
-     * @param block The block
-     */
-    public void registerBlock(Block block) {
-        blocks.put(block.getName(), block);
-    }
-
-    /**
-     * Registers a macro
-     *
-     * @param macro The macro
-     */
-    public void registerMacro(Function macro) {
-        if (macros.containsKey(macro.getName())) {
-            String msg = String.format("More than one macro can not share the same name: %s", macro.getName());
-            throw new IllegalStateException(msg);
-        }
-        this.macros.put(macro.getName(), macro);
-    }
-
-    public void setParent(EvaluationContext context, String parentName) throws Exception {
-        context.getHierarchy().pushAncestor(engine.load(parentName));
-    }
-    
-    /**
-     * A typical block declaration will use this method which evaluates the
-     * block using the regular user-provided writer.
-     *
-     * @param blockName       The name of the block
-     * @param context         The evaluation context
-     * @param ignoreOverriden Whether or not to ignore overriden blocks
-     */
-    public void block(EvaluationContext context, String blockName, boolean ignoreOverriden) {
-
-        Hierarchy hierarchy = context.getHierarchy();
-        Template childTemplate = hierarchy.getChild();
-
-        // check child
-        if (!ignoreOverriden && childTemplate != null) {
-            hierarchy.descend();
-            childTemplate.block(context, blockName, false);
-            hierarchy.ascend();
-
-            // check this template
-        } else if (blocks.containsKey(blockName)) {
-            Block block = blocks.get(blockName);
-            block.evaluate(this, context);
-
-            // delegate to parent
-        } else {
-            if (hierarchy.getParent() != null) {
-                Template parent = hierarchy.getParent();
-                hierarchy.ascend();
-                parent.block(context, blockName, true);
-                hierarchy.descend();
-            }
-        }
-
-    }
-    
-    /**
-     * Invokes a macro
-     *
-     * @param context         The evaluation context
-     * @param macroName       The name of the macro
-     * @param args            The arguments
-     * @param ignoreOverriden Whether or not to ignore macro definitions in child template
-     * @return The results of the macro invocation
-     */
-    public String macro(EvaluationContext context, String macroName, ArgumentsNode args, boolean ignoreOverriden) {
-        String result = null;
-        boolean found = false;
-
-        Template childTemplate = context.getHierarchy().getChild();
-
-        // check child template first
-        if (!ignoreOverriden && childTemplate != null) {
-            found = true;
-            context.getHierarchy().descend();
-            result = childTemplate.macro(context, macroName, args, false);
-            context.getHierarchy().ascend();
-
-            // check current template
-        } else if (hasMacro(macroName)) {
-            found = true;
-            Function macro = macros.get(macroName);
-
-            Map<String, Object> namedArguments = args.getArgumentMap(context, macro);
-            result = (String) macro.evaluate(context, namedArguments);
-        }
-
-        // check imported templates
-        if (!found) {
-            for (Template template : context.getImported()) {
-                if (template.hasMacro(macroName)) {
-                    found = true;
-                    result = template.macro(context, macroName, args, false);
-                }
-            }
-        }
-
-        // delegate to parent template
-        if (!found) {
-            if (context.getHierarchy().getParent() != null) {
-                Template parent = context.getHierarchy().getParent();
-                context.getHierarchy().ascend();
-                result = parent.macro(context, macroName, args, true);
-                context.getHierarchy().descend();
-            } else {
-                String msg = String.format("Function or Macro [%s] does not exist.", macroName);
-                throw new IllegalStateException(msg);
-            }
-        }
-
-        return result;
-    }
-
-    /**
-     * Checks if a macro exists
-     *
-     * @param macroName The name of the macro
-     * @return Whether or not the macro exists
-     */
-    public boolean hasMacro(String macroName) {
-        return macros.containsKey(macroName);
-    }
-    /**
-     * Returns the template name
-     *
-     * @return The name of the template
-     */
-    public String getName() {
-        return name;
-    }
-
-    public RootNode getRootNode() {
-        return rootNode;
-    }
-    
-    @Override
-    public String toString() {
-        return "Template{" + "engine=" + engine + ", blocks=" + blocks + ", macros=" + macros + ", rootNode=" + rootNode + ", name=" + name + '}';
-    }
-}
diff --git a/src/expressionLanguage/model/tree/ArgumentNode.java b/src/expressionLanguage/model/tree/ArgumentNode.java
deleted file mode 100644
index 3fead46..0000000
--- a/src/expressionLanguage/model/tree/ArgumentNode.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-
-public class ArgumentNode extends Node {
-
-    private String name;
-    private final Expression<?> value;
-
-    public ArgumentNode(Position position, Expression<?> value) {
-        super(position);
-        this.value = value;
-    }
-    
-    public ArgumentNode(Position position, Expression<?> value, String name) {
-        this(position, value);
-        this.name = name;
-    }
-
-    public Expression<?> getValue() {
-        return value;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-}
diff --git a/src/expressionLanguage/model/tree/ArgumentsNode.java b/src/expressionLanguage/model/tree/ArgumentsNode.java
deleted file mode 100644
index 12a499b..0000000
--- a/src/expressionLanguage/model/tree/ArgumentsNode.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.function.Function;
-import expressionLanguage.model.position.Position;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-public class ArgumentsNode extends Node {
-
-    private final List<ArgumentNode> args;
-
-    public ArgumentsNode(Position position, List<ArgumentNode> args) {
-        super(position);
-        this.args = args;
-    }
-
-    public List<ArgumentNode> getArgs() {
-        return args;
-    }
-
-    /**
-     * Using hints from the filter/function/test/macro it will convert an
-     * ArgumentMap (which holds both positional and named arguments) into a
-     * regular Map that the filter/function/test/macro is expecting.
-     *
-     * @param context
-     *            The evaluation context
-     * @param invocableWithNamedArguments
-     *            The named arguments object
-     * @return Returns a map representaion of the arguments
-     */
-    public Map<String, Object> getArgumentMap(EvaluationContext context, Function invocableWithNamedArguments) {
-        Map<String, Object> result = new HashMap<>();
-        List<String> argumentNames = invocableWithNamedArguments.getArgumentNames();
-
-        if (argumentNames == null) {
-
-            /* Some functions such as min and max use un-named varags */
-            if (args != null && !args.isEmpty()) {
-                for (int i = 0; i < args.size(); i++) {
-                    result.put(String.valueOf(i), args.get(i).getValue().evaluate(context));
-                }
-            }
-        } else {
-
-            if (args != null) {
-                int nameIndex = 0;
-
-                for (ArgumentNode arg : args) {
-                    if (argumentNames.size() <= nameIndex) {
-                        String msg = String.format("The argument at position %s is not allowed. Only %s argument(s) are allowed at line %s in file %s.", nameIndex + 1, argumentNames.size());
-                        throw new IllegalArgumentException(msg);
-                    }
-
-                    result.put(argumentNames.get(nameIndex), arg.getValue().evaluate(context));
-                    nameIndex++;
-                }
-            }
-
-            if (args != null) {
-                for (ArgumentNode arg : args) {
-                    // check if user used an incorrect name
-                    if (!argumentNames.contains(arg.getName())) {
-                        String msg = String.format("The following named argument does not exist: %s at line %s in file %s", arg.getName());
-                        throw new IllegalArgumentException(msg);
-                    }
-                    Object value = arg.getValue() == null ? null : arg.getValue().evaluate(context);
-                    result.put(arg.getName(), value);
-                }
-            }
-        }
-
-        result.put("_context", context);
-
-        return result;
-    }
-
-}
diff --git a/src/expressionLanguage/model/tree/AutoEscapeNode.java b/src/expressionLanguage/model/tree/AutoEscapeNode.java
deleted file mode 100644
index 83a9d49..0000000
--- a/src/expressionLanguage/model/tree/AutoEscapeNode.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.model.position.Position;
-
-public class AutoEscapeNode extends Node {
-
-    private final BodyNode body;
-
-    private final String strategy;
-
-    private final boolean active;
-
-    public AutoEscapeNode(Position position, BodyNode body, boolean active, String strategy) {
-        super(position);
-        this.body = body;
-        this.strategy = strategy;
-        this.active = active;
-    }
-
-//    @Override
-//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
-//        body.render(self, writer, context);
-//    }
-
-//    @Override
-//    public void visit(NodeVisitor visitor) {
-//        visitor.accept(this);
-//    }
-
-    public BodyNode getBody() {
-        return body;
-    }
-
-    public String getStrategy() {
-        return strategy;
-    }
-
-    public boolean isActive() {
-        return active;
-    }
-
-}
diff --git a/src/expressionLanguage/model/tree/BlockNode.java b/src/expressionLanguage/model/tree/BlockNode.java
deleted file mode 100644
index 5a07565..0000000
--- a/src/expressionLanguage/model/tree/BlockNode.java
+++ /dev/null
@@ -1,58 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.template.Block;
-import expressionLanguage.model.template.Template;
-import java.io.IOException;
-
-public class BlockNode extends Node {
-
-    private final BodyNode body;
-
-    private String name;
-
-    public BlockNode(Position position, String name) {
-        this(position, name, null);
-    }
-
-    public BlockNode(Position position, String name, BodyNode body) {
-        super(position);
-        this.body = body;
-        this.name = name;
-    }
-
-//    @Override
-//    public void render(final Template self, Writer writer, EvaluationContext context) throws Exception {
-//        self.block(writer, context, name, false);
-//    }
-//
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    public Block getBlock() {
-        return new Block() {
-
-            @Override
-            public String getName() {
-                return name;
-            }
-
-            @Override
-            public void evaluate(Template self, EvaluationContext context) {
-//                body.render(self, writer, context);
-            }
-        };
-    }
-
-    public BodyNode getBody() {
-        return body;
-    }
-
-    public String getName() {
-        return name;
-    }
-    
-}
diff --git a/src/expressionLanguage/model/tree/BodyNode.java b/src/expressionLanguage/model/tree/BodyNode.java
deleted file mode 100644
index f3e532d..0000000
--- a/src/expressionLanguage/model/tree/BodyNode.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.visitor.NodeVisitor;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.function.Consumer;
-
-public class BodyNode extends Node {
-
-    private final List<Node> children;
-
-    private static final List<Class<? extends Node>> nodesToRenderInChild = new ArrayList<>();
-
-    static {
-        nodesToRenderInChild.add(SetNode.class);
-        nodesToRenderInChild.add(ImportNode.class);
-    }
-
-    /**
-     * When a template extends a parent template there are very few nodes in the
-     * child that should actually get rendered such as set and import. All
-     * others should be ignored.
-     */
-    private boolean onlyRenderInheritanceSafeNodes = false;
-
-    public BodyNode(Position position, List<Node> children) {
-        super(position);
-        this.children = children;
-    }
-
-//    @Override
-//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
-//        for (RenderableNode child : children) {
-//            if (onlyRenderInheritanceSafeNodes && context.getHierarchy().getParent() != null) {
-//                if (!nodesToRenderInChild.contains(child.getClass())) {
-//                    continue;
-//                }
-//            }
-//            child.render(self, writer, context);
-//        }
-//    }
-
-    @Override
-    public void accept(NodeVisitor visitor) {
-        super.accept(visitor);
-        
-        this.children.forEach((node) -> node.accept(visitor));
-    }
-
-    public List<Node> getChildren() {
-        return children;
-    }
-
-    public boolean isOnlyRenderInheritanceSafeNodes() {
-        return onlyRenderInheritanceSafeNodes;
-    }
-
-    public void setOnlyRenderInheritanceSafeNodes(boolean onlyRenderInheritanceSafeNodes) {
-        this.onlyRenderInheritanceSafeNodes = onlyRenderInheritanceSafeNodes;
-    }
-
-}
diff --git a/src/expressionLanguage/model/tree/ExtendsNode.java b/src/expressionLanguage/model/tree/ExtendsNode.java
deleted file mode 100644
index fdc60bb..0000000
--- a/src/expressionLanguage/model/tree/ExtendsNode.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-
-public class ExtendsNode extends Node {
-
-    Expression<?> parentExpression;
-
-    public ExtendsNode(Position position, Expression<?> parentExpression) {
-        super(position);
-        this.parentExpression = parentExpression;
-    }
-
-//    @Override
-//    public void render(final Template self, Writer writer, final EvaluationContext context) throws Exception {
-//        self.setParent(context, (String) parentExpression.evaluate(self, context));
-//    }
-//
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    public Expression<?> getParentExpression() {
-        return parentExpression;
-    }
-}
diff --git a/src/expressionLanguage/model/tree/FlushNode.java b/src/expressionLanguage/model/tree/FlushNode.java
deleted file mode 100644
index a5ac70a..0000000
--- a/src/expressionLanguage/model/tree/FlushNode.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.model.position.Position;
-
-public class FlushNode extends Node {
-
-    public FlushNode(Position position) {
-        super(position);
-    }
-
-//    @Override
-//    public void render(Template self, Writer writer, EvaluationContext context) throws IOException {
-//        writer.flush();
-//    }
-//
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-}
diff --git a/src/expressionLanguage/model/tree/ForNode.java b/src/expressionLanguage/model/tree/ForNode.java
deleted file mode 100644
index d54f9cf..0000000
--- a/src/expressionLanguage/model/tree/ForNode.java
+++ /dev/null
@@ -1,214 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.visitor.NodeVisitor;
-import java.lang.reflect.Array;
-import java.util.*;
-
-/**
- * Represents a "for" loop within the template.
- *
- */
-public class ForNode extends Node {
-
-    private final String variableName;
-
-    private final Expression<?> iterableExpression;
-
-    private final BodyNode body;
-
-    private final BodyNode elseBody;
-
-    public ForNode(Position position, String variableName, Expression<?> iterableExpression, BodyNode body, BodyNode elseBody) {
-        super(position);
-        this.variableName = variableName;
-        this.iterableExpression = iterableExpression;
-        this.body = body;
-        this.elseBody = elseBody;
-    }
-
-    @Override
-    public void accept(NodeVisitor visitor) {
-        super.accept(visitor);
-//        Object iterableEvaluation = iterableExpression.evaluate(self, context);
-//        Iterable<?> iterable;
-//
-    }
-    
-//    @Override
-//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
-//        Object iterableEvaluation = iterableExpression.evaluate(self, context);
-//        Iterable<?> iterable;
-//
-//        if (iterableEvaluation == null) {
-//            return;
-//        }
-//
-//        iterable = toIterable(iterableEvaluation);
-//
-//        if (iterable == null) {
-//            String msg = String.format("Not an iterable object. Value = [%s] at line %s in file %s.", iterableEvaluation, getLineNumber(), self.getName());
-//            throw new Exception(msg);
-//        }
-//
-//        Iterator<?> iterator = iterable.iterator();
-//
-//        boolean newScope = false;
-//
-//        if (iterator.hasNext()) {
-//
-//            ScopeChain scopeChain = context.getScopeChain();
-//
-//            /*
-//             * Only if there is a variable name conflict between one of the
-//             * variables added by the for loop construct and an existing
-//             * variable do we push another scope, otherwise we reuse the current
-//             * scope for performance purposes.
-//             */
-//            if (scopeChain.currentScopeContainsVariable("loop") || scopeChain
-//                    .currentScopeContainsVariable(variableName)) {
-//                scopeChain.pushScope();
-//                newScope = true;
-//            }
-//
-//            int length = getIteratorSize(iterableEvaluation);
-//            int index = 0;
-//
-//            Map<String, Object> loop = new HashMap<>();
-//
-//            boolean usingExecutorService = context.getExecutorService() != null;
-//
-//            while (iterator.hasNext()) {
-//
-//                /*
-//                 * If the user is using an executor service (i.e. parallel node), we
-//                 * must create a new map with every iteration instead of
-//                 * re-using the same one; it's imperative that each thread would
-//                 * get it's own distinct copy of the context.
-//                 */
-//                if (index == 0 || usingExecutorService) {
-//                    loop.put("first", index == 0);
-//                    loop.put("last", index == length - 1);
-//                    loop.put("length", length);
-//                }else{
-//
-//                    // second iteration
-//                    if(index == 1){
-//                        loop.put("first", false);
-//                    }
-//
-//                    // last iteration
-//                    if(index == length - 1){
-//                        loop.put("last", true);
-//                    }
-//                }
-//
-//                loop.put("revindex", length - index - 1);
-//                loop.put("index", index++);
-//
-//                scopeChain.put("loop", loop);
-//
-//                scopeChain.put(variableName, iterator.next());
-//                body.render(self, writer, context);
-//            }
-//
-//            if (newScope) {
-//                scopeChain.popScope();
-//            }
-//
-//        } else if (elseBody != null) {
-//            elseBody.render(self, writer, context);
-//        }
-//
-//    }
-//
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    public String getIterationVariable() {
-        return variableName;
-    }
-
-    public Expression<?> getIterable() {
-        return iterableExpression;
-    }
-
-    public BodyNode getBody() {
-        return body;
-    }
-
-    public BodyNode getElseBody() {
-        return elseBody;
-    }
-
-    @SuppressWarnings({ "unchecked", "rawtypes" })
-    private Iterable<Object> toIterable(final Object obj) {
-
-        Iterable<Object> result = null;
-
-        if (obj instanceof Iterable<?>) {
-
-            result = (Iterable<Object>) obj;
-
-        } else if (obj instanceof Map) {
-
-            // raw type
-            result = ((Map) obj).entrySet();
-
-        } else if (obj.getClass().isArray()) {
-
-            if (Array.getLength(obj) == 0) {
-                return new ArrayList<>(0);
-            }
-
-            result = () -> new Iterator<Object>() {
-                
-                private int index = 0;
-                
-                private final int length = Array.getLength(obj);
-                
-                @Override
-                public boolean hasNext() {
-                    return index < length;
-                }
-                
-                @Override
-                public Object next() {
-                    return Array.get(obj, index++);
-                }
-                
-                @Override
-                public void remove() {
-                    throw new UnsupportedOperationException();
-                }
-            };
-        }
-
-        return result;
-    }
-
-    private int getIteratorSize(Object iterable) {
-        if (iterable == null) {
-            return 0;
-        }
-        if (iterable instanceof Collection) {
-            return ((Collection<?>) iterable).size();
-        } else if (iterable instanceof Map) {
-            return ((Map<?, ?>) iterable).size();
-        } else if (iterable.getClass().isArray()) {
-            return Array.getLength(iterable);
-        }
-
-        // assumed to be of type Iterator
-        Iterator<?> it = ((Iterable<?>) iterable).iterator();
-        int size = 0;
-        while (it.hasNext()) {
-            size++;
-            it.next();
-        }
-        return size;
-    }
-}
diff --git a/src/expressionLanguage/model/tree/FunctionOrMacroNameNode.java b/src/expressionLanguage/model/tree/FunctionOrMacroNameNode.java
deleted file mode 100644
index d9a53c9..0000000
--- a/src/expressionLanguage/model/tree/FunctionOrMacroNameNode.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-
-public class FunctionOrMacroNameNode extends Node implements Expression<String> {
-
-    private final String name;
-
-    public FunctionOrMacroNameNode(Position position, String name) {
-        super(position);
-        this.name = name;
-    }
-
-    @Override
-    public String evaluate(EvaluationContext context) {
-        throw new UnsupportedOperationException();
-    }
-//
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    public String getName() {
-        return name;
-    }
-
-//    @Override
-//    public int getLineNumber() {
-//        return this.lineNumber;
-//    }
-
-}
diff --git a/src/expressionLanguage/model/tree/IfNode.java b/src/expressionLanguage/model/tree/IfNode.java
deleted file mode 100644
index 678be4b..0000000
--- a/src/expressionLanguage/model/tree/IfNode.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-import java.util.List;
-import javafx.util.Pair;
-
-public class IfNode extends Node {
-
-    private final List<Pair<Expression<?>, BodyNode>> conditionsWithBodies;
-
-    private final BodyNode elseBody;
-
-    public IfNode(Position position, List<Pair<Expression<?>, BodyNode>> conditionsWithBodies) {
-        this(position, conditionsWithBodies, null);
-    }
-
-    public IfNode(Position position, List<Pair<Expression<?>, BodyNode>> conditionsWithBodies, BodyNode elseBody) {
-        super(position);
-        this.conditionsWithBodies = conditionsWithBodies;
-        this.elseBody = elseBody;
-    }
-
-//    @Override
-//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
-//
-//        boolean satisfied = false;
-//        for (Pair<Expression<?>, BodyNode> ifStatement : conditionsWithBodies) {
-//
-//            Expression<?> conditionalExpression = ifStatement.getKey();
-//
-//            try {
-//
-//                Object result = conditionalExpression.evaluate(self, context);
-//
-//                if (result != null) {
-//                    try {
-//                        satisfied = (Boolean) result;
-//                    } catch (ClassCastException ex) {
-//                        String msg = String.format("Expected a Boolean in \"if\" statement at line %s in file %s.", getLineNumber(), self.getName());
-//                        throw new Exception(msg);
-//                    }
-//                }
-//
-//            } catch (RuntimeException ex) {
-//                String msg = String.format("Wrong operand(s) type in conditional expression at line %s in file %s.", getLineNumber(), self.getName());
-//                throw new Exception(msg);
-//            }
-//
-//            if (satisfied) {
-//                ifStatement.getValue().render(self, writer, context);
-//                break;
-//            }
-//        }
-//
-//        if (!satisfied && elseBody != null) {
-//            elseBody.render(self, writer, context);
-//        }
-//    }
-
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    public List<Pair<Expression<?>, BodyNode>> getConditionsWithBodies() {
-        return conditionsWithBodies;
-    }
-
-    public BodyNode getElseBody() {
-        return elseBody;
-    }
-
-}
diff --git a/src/expressionLanguage/model/tree/ImportNode.java b/src/expressionLanguage/model/tree/ImportNode.java
deleted file mode 100644
index 2c58364..0000000
--- a/src/expressionLanguage/model/tree/ImportNode.java
+++ /dev/null
@@ -1,29 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-
-public class ImportNode extends Node {
-
-    private final Expression<?> importExpression;
-
-    public ImportNode(Position position, Expression<?> importExpression) {
-        super(position);
-        this.importExpression = importExpression;
-    }
-
-//    @Override
-//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
-//        self.importTemplate(context, (String) importExpression.evaluate(self, context));
-//    }
-//
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    public Expression<?> getImportExpression() {
-        return importExpression;
-    }
-
-}
diff --git a/src/expressionLanguage/model/tree/IncludeNode.java b/src/expressionLanguage/model/tree/IncludeNode.java
deleted file mode 100644
index f520afb..0000000
--- a/src/expressionLanguage/model/tree/IncludeNode.java
+++ /dev/null
@@ -1,44 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.extension.core.expression.MapExpression;
-import expressionLanguage.model.position.Position;
-
-public class IncludeNode extends Node {
-
-    private final Expression<?> includeExpression;
-
-    private final MapExpression mapExpression;
-
-    public IncludeNode(Position position, Expression<?> includeExpression, MapExpression mapExpression) {
-        super(position);
-        this.includeExpression = includeExpression;
-        this.mapExpression = mapExpression;
-    }
-
-//    @Override
-//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
-//        String templateName = (String) includeExpression.evaluate(self, context);
-//
-//        Map<?, ?> map = Collections.emptyMap();
-//        if (this.mapExpression != null) {
-//            map = this.mapExpression.evaluate(self, context);
-//        }
-//
-//        if (templateName == null) {
-//            String msg = String.format("The template name in an include tag evaluated to NULL. If the template name is static, make sure to wrap it in quotes. template [%s] at line %s in file %s.", templateName, getLineNumber(), self.getName());
-//            throw new Exception(msg);
-//        }
-//        self.includeTemplate(writer, context, templateName, map);
-//    }
-//
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    public Expression<?> getIncludeExpression() {
-        return includeExpression;
-    }
-
-}
diff --git a/src/expressionLanguage/model/tree/MacroNode.java b/src/expressionLanguage/model/tree/MacroNode.java
deleted file mode 100644
index b866bc4..0000000
--- a/src/expressionLanguage/model/tree/MacroNode.java
+++ /dev/null
@@ -1,120 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.EvaluationContext;
-import expressionLanguage.expression.Expression;
-import expressionLanguage.function.Function;
-import expressionLanguage.model.position.Position;
-import expressionLanguage.scope.ScopeChain;
-import java.util.Map;
-
-public class MacroNode extends Node {
-
-    private final String name;
-
-    private final ArgumentsNode args;
-
-    private final BodyNode body;
-
-    public MacroNode(Position position, String name, ArgumentsNode args, BodyNode body) {
-        super(position);
-        this.name = name;
-        this.args = args;
-        this.body = body;
-    }
-
-//    @Override
-//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
-//        // do nothing
-//    }
-//
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    public Function getMacro() {
-        return Function.builder()
-                .named(name)
-                .evaluation((EvaluationContext context, Map<String, Object> macroArgs) -> {
-                    ScopeChain scopeChain = context.getScopeChain();
-                    scopeChain.pushLocalScope();
-                    getArgs().getArgs().stream().forEach((arg) -> {
-                        Expression<?> valueExpression = arg.getValue();
-                        if (valueExpression == null) {
-                            scopeChain.put(arg.getName(), null);
-                        } else {
-                            scopeChain.put(arg.getName(), valueExpression.evaluate(context));
-                        }
-                    });
-                    
-                    // scope for user provided arguments
-                    scopeChain.pushScope(macroArgs);
-
-//                    getBody().render(self, writer, context);
-
-                    scopeChain.popScope(); // user arguments
-                    scopeChain.popScope(); // default arguments
-
-                    return "";
-                })
-                .build();
-                
-//                new Macro() {
-//
-//            @Override
-//            public List<String> getArgumentNames() {
-//                List<String> names = new ArrayList<>();
-//                getArgs().getNamedArgs().stream().forEach((arg) -> {
-//                    names.add(arg.getName());
-//                });
-//                return names;
-//            }
-//
-//            @Override
-//            public String getName() {
-//                return name;
-//            }
-//
-//            @Override
-//            public String call(EvaluationContext context, Map<String, Object> macroArgs) throws Exception {
-//                Writer writer = new StringWriter();
-//                ScopeChain scopeChain = context.getScopeChain();
-//
-//                // scope for default arguments
-//                scopeChain.pushLocalScope();
-//                for (NamedArgumentNode arg : getArgs().getNamedArgs()) {
-//                    Expression<?> valueExpression = arg.getValueExpression();
-//                    if (valueExpression == null) {
-//                        scopeChain.put(arg.getName(), null);
-//                    } else {
-//                        scopeChain.put(arg.getName(), arg.getValueExpression().evaluate(context));
-//                    }
-//                }
-//
-//                // scope for user provided arguments
-//                scopeChain.pushScope(macroArgs);
-//                
-////                getBody().render(self, writer, context);
-//
-//                scopeChain.popScope(); // user arguments
-//                scopeChain.popScope(); // default arguments
-//
-//                return writer.toString();
-//            }
-
-//        };
-    }
-
-    public BodyNode getBody() {
-        return body;
-    }
-
-    public ArgumentsNode getArgs() {
-        return args;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-}
diff --git a/src/expressionLanguage/model/tree/NamedArgumentNode.java b/src/expressionLanguage/model/tree/NamedArgumentNode.java
deleted file mode 100644
index 08afe95..0000000
--- a/src/expressionLanguage/model/tree/NamedArgumentNode.java
+++ /dev/null
@@ -1,26 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-
-public class NamedArgumentNode extends Node {
-
-    private final Expression<?> value;
-
-    private final String name;
-
-    public NamedArgumentNode(Position position, String name, Expression<?> value) {
-        super(position);
-        this.name = name;
-        this.value = value;
-    }
-
-    public Expression<?> getValueExpression() {
-        return value;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-}
diff --git a/src/expressionLanguage/model/tree/Node.java b/src/expressionLanguage/model/tree/Node.java
deleted file mode 100644
index d9e3ec9..0000000
--- a/src/expressionLanguage/model/tree/Node.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.visitor.NodeVisitor;
-
-public abstract class Node {
-
-    private final Position position;
-
-    protected Node(Position position) {
-        this.position = position;
-    }
-
-    public Position getPosition() {
-        return position;
-    }
-
-    public void accept(NodeVisitor visitor) {
-        visitor.visit(this);
-    }
-}
diff --git a/src/expressionLanguage/model/tree/ParallelNode.java b/src/expressionLanguage/model/tree/ParallelNode.java
deleted file mode 100644
index 40fa030..0000000
--- a/src/expressionLanguage/model/tree/ParallelNode.java
+++ /dev/null
@@ -1,72 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.model.position.Position;
-import java.util.logging.Logger;
-
-public class ParallelNode extends Node {
-
-    private static final Logger LOGGER = Logger.getLogger(ParallelNode.class.getName());
-
-    private final BodyNode body;
-
-    /**
-     * If the user is using the parallel tag but doesn't provide an
-     * ExecutorService we will warn them that this tag will essentially be
-     * ignored but it's important that we only warn them once because this tag
-     * may show up in a loop.
-     */
-    private boolean hasWarnedAboutNonExistingExecutorService = false;
-
-    public ParallelNode(Position position, BodyNode body) {
-        super(position);
-        this.body = body;
-    }
-
-//    @Override
-//    public void render(final Template self, Writer writer, final EvaluationContext context) throws Exception {
-//
-//        ExecutorService es = context.getExecutorService();
-//
-//        if (es == null) {
-//
-//            if (!hasWarnedAboutNonExistingExecutorService) {
-//                LOGGER.info(String.format(
-//                        "The parallel tag was used [%s:%d] but no ExecutorService was provided. The parallel tag will be ignored "
-//                                + "and it's contents will be rendered in sequence with the rest of the template.",
-//                        self.getName(), getLineNumber()));
-//                hasWarnedAboutNonExistingExecutorService = true;
-//            }
-//
-//            /*
-//             * If user did not provide an ExecutorService, we simply ignore the
-//             * parallel tag and render it's contents like we normally would.
-//             */
-//            body.render(self, writer, context);
-//            
-//        } else {
-//
-//            final EvaluationContext contextCopy = context.threadSafeCopy(self);
-//
-//            final StringWriter newStringWriter = new StringWriter();
-//            final Writer newFutureWriter = new FutureWriter(newStringWriter);
-//
-//            Future<String> future = es.submit(() -> {
-//                body.render(self, newFutureWriter, contextCopy);
-//                newFutureWriter.flush();
-//                newFutureWriter.close();
-//                return newStringWriter.toString();
-//            });
-//            
-//            ((FutureWriter) writer).enqueue(future);
-//        }
-//    }
-//
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    public BodyNode getBody() {
-        return body;
-    }
-}
diff --git a/src/expressionLanguage/model/tree/PrintNode.java b/src/expressionLanguage/model/tree/PrintNode.java
deleted file mode 100644
index 77b04b8..0000000
--- a/src/expressionLanguage/model/tree/PrintNode.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-
-public class PrintNode extends Node {
-
-    private Expression<?> expression;
-
-    public PrintNode(Position position, Expression<?> expression) {
-        super(position);
-        this.expression = expression;
-    }
-
-//    @Override
-//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
-//        Object var = expression.evaluate(self, context);
-//        if (var != null) {
-//            writer.write(ObjectUtils.nullSafeToString(var));
-//        }
-//    }
-
-    public Expression<?> getExpression() {
-        return expression;
-    }
-
-    public void setExpression(Expression<?> expression) {
-        this.expression = expression;
-    }
-
-}
diff --git a/src/expressionLanguage/model/tree/RootNode.java b/src/expressionLanguage/model/tree/RootNode.java
deleted file mode 100644
index 68b334b..0000000
--- a/src/expressionLanguage/model/tree/RootNode.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.model.position.Position;
-import expressionLanguage.model.visitor.NodeVisitor;
-
-public class RootNode extends Node {
-
-    private final BodyNode body;
-
-    public RootNode(Position position, BodyNode body) {
-        super(position);
-        this.body = body;
-    }
-
-//    @Override
-//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
-//        body.setOnlyRenderInheritanceSafeNodes(true);
-//        body.render(self, writer, context);
-//    }
-//
-    @Override
-    public void accept(NodeVisitor visitor) {
-        super.accept(visitor);
-        
-        if (getBody() != null) {
-            getBody().accept(visitor);
-        }
-    }
-
-    public BodyNode getBody() {
-        return body;
-    }
-}
diff --git a/src/expressionLanguage/model/tree/SetNode.java b/src/expressionLanguage/model/tree/SetNode.java
deleted file mode 100644
index b8d6f20..0000000
--- a/src/expressionLanguage/model/tree/SetNode.java
+++ /dev/null
@@ -1,31 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.model.position.Position;
-
-public class SetNode extends Node {
-
-    private final String name;
-
-    private final Expression<?> value;
-
-    public SetNode(Position position, String name, Expression<?> value) {
-        super(position);
-        this.name = name;
-        this.value = value;
-    }
-
-//    @Override
-//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
-//        context.getScopeChain().put(name, value.evaluate(self, context));
-//    }
-
-    public Expression<?> getValue() {
-        return value;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-}
diff --git a/src/expressionLanguage/model/tree/TestInvocationExpressionNode.java b/src/expressionLanguage/model/tree/TestInvocationExpressionNode.java
deleted file mode 100644
index fa2a4d1..0000000
--- a/src/expressionLanguage/model/tree/TestInvocationExpressionNode.java
+++ /dev/null
@@ -1,28 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.model.position.Position;
-
-/**
- * The right hand side to the test expression.
- */
-public class TestInvocationExpressionNode extends Node {
-
-    private final String testName;
-
-    private final ArgumentsNode args;
-
-    public TestInvocationExpressionNode(Position position, String testName, ArgumentsNode args) {
-        super(position);
-        this.testName = testName;
-        this.args = args;
-    }
-
-    public ArgumentsNode getArgs() {
-        return args;
-    }
-
-    public String getTestName() {
-        return testName;
-    }
-
-}
diff --git a/src/expressionLanguage/model/tree/TextNode.java b/src/expressionLanguage/model/tree/TextNode.java
deleted file mode 100644
index e88c92c..0000000
--- a/src/expressionLanguage/model/tree/TextNode.java
+++ /dev/null
@@ -1,38 +0,0 @@
-package expressionLanguage.model.tree;
-
-import expressionLanguage.model.position.Position;
-
-/**
- * Represents static text in a template.
- */
-public class TextNode extends Node {
-
-    /**
-     * Most Writers will convert strings to char[] so we might as well store it
-     * as a char[] to begin with; small performance optimization.
-     */
-    private final char[] data;
-
-    public TextNode(Position position, String text) {
-        super(position);
-
-        int length = text.length();
-        this.data = new char[text.length()];
-        text.getChars(0, length, this.data, 0);
-    }
-
-//    @Override
-//    public void render(Template self, Writer writer, EvaluationContext context) throws IOException {
-//        writer.write(data);
-//    }
-//
-//    @Override
-//    public void accept(NodeVisitor visitor) {
-//        visitor.visit(this);
-//    }
-
-    public char[] getData() {
-        return data;
-    }
-
-}
diff --git a/src/expressionLanguage/model/visitor/BlockRegistrantVisitor.java b/src/expressionLanguage/model/visitor/BlockRegistrantVisitor.java
deleted file mode 100644
index 70cfe6a..0000000
--- a/src/expressionLanguage/model/visitor/BlockRegistrantVisitor.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package expressionLanguage.model.visitor;
-
-import expressionLanguage.model.template.Template;
-import expressionLanguage.model.tree.BlockNode;
-import expressionLanguage.model.tree.Node;
-
-public class BlockRegistrantVisitor implements NodeVisitor {
-        
-    private Template template;
-    
-    public BlockRegistrantVisitor(Template template) {
-        this.template = template;
-    }
-
-    @Override
-    public void visit(Node node) {
-        if (!(node instanceof BlockNode)) {
-            return;
-        }
-        
-        this.template.registerBlock(((BlockNode) node).getBlock());
-    }
-
-}
diff --git a/src/expressionLanguage/model/visitor/MacroRegistrantVisitor.java b/src/expressionLanguage/model/visitor/MacroRegistrantVisitor.java
deleted file mode 100644
index 972b80d..0000000
--- a/src/expressionLanguage/model/visitor/MacroRegistrantVisitor.java
+++ /dev/null
@@ -1,24 +0,0 @@
-package expressionLanguage.model.visitor;
-
-import expressionLanguage.function.Function;
-import expressionLanguage.model.template.Template;
-import expressionLanguage.model.tree.MacroNode;
-import expressionLanguage.model.tree.Node;
-
-public class MacroRegistrantVisitor implements NodeVisitor {
-        
-    private Template template;
-    
-    public MacroRegistrantVisitor(Template template) {
-        this.template = template;
-    }
-
-    @Override
-    public void visit(Node node) {
-        if (!(node instanceof MacroNode)) {
-            return;
-        }
-        Function.builder().build();
-        this.template.registerMacro(((MacroNode) node).getMacro());
-    }
-}
diff --git a/src/expressionLanguage/model/visitor/NodeVisitor.java b/src/expressionLanguage/model/visitor/NodeVisitor.java
deleted file mode 100644
index e081b0c..0000000
--- a/src/expressionLanguage/model/visitor/NodeVisitor.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package expressionLanguage.model.visitor;
-
-import expressionLanguage.model.tree.Node;
-
-@FunctionalInterface
-public interface NodeVisitor {
-    
-    void visit(Node node);
-}
diff --git a/src/expressionLanguage/operator/Associativity.java b/src/expressionLanguage/operator/Associativity.java
deleted file mode 100644
index 9f4c7a5..0000000
--- a/src/expressionLanguage/operator/Associativity.java
+++ /dev/null
@@ -1,6 +0,0 @@
-package expressionLanguage.operator;
-
-public enum Associativity {
-    RIGHT,
-    LEFT
-}
diff --git a/src/expressionLanguage/operator/BinaryOperator.java b/src/expressionLanguage/operator/BinaryOperator.java
deleted file mode 100644
index 1a078d8..0000000
--- a/src/expressionLanguage/operator/BinaryOperator.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package expressionLanguage.operator;
-
-import expressionLanguage.expression.BinaryExpression;
-
-public class BinaryOperator extends Operator {
-    
-    protected Associativity associativity;
-
-    public BinaryOperator(int precedence, Class<? extends BinaryExpression<?>> nodeClass, Associativity associativity) {
-        super(precedence, nodeClass);
-        this.associativity = associativity;
-    }
-    
-    public Associativity getAssociativity() {
-        return associativity;
-    }
-}
diff --git a/src/expressionLanguage/operator/Operator.java b/src/expressionLanguage/operator/Operator.java
deleted file mode 100644
index 249dbf3..0000000
--- a/src/expressionLanguage/operator/Operator.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package expressionLanguage.operator;
-
-import expressionLanguage.expression.Expression;
-
-public abstract class Operator {
-    
-//    protected String symbol;
-    
-    protected int precedence;
-    protected Class<? extends Expression<?>> expression;
-
-    public Operator(int precedence, Class<? extends Expression<?>> expression) {
-        this.precedence = precedence;
-        this.expression = expression;
-    }
-    
-//    public Operator(String symbol, Class<? extends Expression<?>> expression) {
-//        this.symbol = symbol;
-//        this.expression = expression;
-//    }
-    
-//    public String getSymbol(){
-//        return this.symbol;
-//    }
-
-    public Class<? extends Expression<?>> getExpression() {
-        return expression;
-    }
-    
-    public int getPrecedence(){
-        return this.precedence;
-    }
-}
diff --git a/src/expressionLanguage/operator/OperatorUtils.java b/src/expressionLanguage/operator/OperatorUtils.java
deleted file mode 100644
index b6c8608..0000000
--- a/src/expressionLanguage/operator/OperatorUtils.java
+++ /dev/null
@@ -1,288 +0,0 @@
-package expressionLanguage.operator;
-
-import java.math.BigDecimal;
-import java.math.MathContext;
-import java.util.Collection;
-import java.util.List;
-
-/**
- *
- * This class acts as a sort of wrapper around Java's built in operators. This
- * is necessary because Pebble treats all user provided variables as Objects
- * even if they were originally primitives.
- * <p>
- * It's important that this class mimics the natural type conversion that Java
- * will apply when performing operators. This can be found in section 5.6.2 of
- * the Java 7 spec, under Binary Numeric Promotion.
- *
- */
-public class OperatorUtils {
-
-    private enum Operation {
-        ADD, SUBTRACT, MULTIPLICATION, DIVISION, MODULUS
-    }
-
-    private enum Comparison {
-        GREATER_THAN, GREATER_THAN_EQUALS, LESS_THAN, LESS_THAN_EQUALS, EQUALS
-    }
-
-    public static Object add(Object op1, Object op2) {
-        if (op1 instanceof String || op2 instanceof String) {
-            return concatenateStrings(String.valueOf(op1), String.valueOf(op2));
-        } else if (op1 instanceof List) {
-            return addToList((List<?>) op1, op2);
-        }
-        return wideningConversionBinaryOperation(op1, op2, Operation.ADD);
-    }
-
-    public static Object subtract(Object op1, Object op2) {
-        if (op1 instanceof List) {
-            return subtractFromList((List<?>) op1, op2);
-        }
-        return wideningConversionBinaryOperation(op1, op2, Operation.SUBTRACT);
-    }
-
-    public static Object multiply(Object op1, Object op2) {
-        return wideningConversionBinaryOperation(op1, op2, Operation.MULTIPLICATION);
-    }
-
-    public static Object divide(Object op1, Object op2) {
-        return wideningConversionBinaryOperation(op1, op2, Operation.DIVISION);
-    }
-
-    public static Object mod(Object op1, Object op2) {
-        return wideningConversionBinaryOperation(op1, op2, Operation.MODULUS);
-    }
-
-    public static boolean equals(Object op1, Object op2) {
-        if (op1 != null && op1 instanceof Number && op2 != null && op2 instanceof Number) {
-            return wideningConversionBinaryComparison(op1, op2, Comparison.EQUALS);
-        } else if (op1 != null && op1 instanceof Enum<?> && op2 != null && op2 instanceof String) {
-            return compareEnum((Enum<?>) op1, (String) op2);
-        } else if (op2 != null && op2 instanceof Enum<?> && op1 != null && op1 instanceof String) {
-            return compareEnum((Enum<?>) op2, (String) op1);
-        } else {
-            return ((op1 == op2) || ((op1 != null) && op1.equals(op2)));
-        }
-    }
-
-    private static <T extends Enum<T>> boolean compareEnum(Enum<T> enumVariable, String compareToString) {
-        return enumVariable.name().equals(compareToString);
-    }
-
-    public static boolean gt(Object op1, Object op2) {
-        return wideningConversionBinaryComparison(op1, op2, Comparison.GREATER_THAN);
-    }
-
-    public static boolean gte(Object op1, Object op2) {
-        return wideningConversionBinaryComparison(op1, op2, Comparison.GREATER_THAN_EQUALS);
-    }
-
-    public static boolean lt(Object op1, Object op2) {
-        return wideningConversionBinaryComparison(op1, op2, Comparison.LESS_THAN);
-    }
-
-    public static boolean lte(Object op1, Object op2) {
-        return wideningConversionBinaryComparison(op1, op2, Comparison.LESS_THAN_EQUALS);
-    }
-
-    public static Object unaryPlus(Object op1) {
-        return multiply(1, op1);
-    }
-
-    public static Object unaryMinus(Object op1) {
-        return multiply(-1, op1);
-    }
-
-    private static Object concatenateStrings(String op1, String op2) {
-        return op1 + op2;
-    }
-
-    /**
-     * This is not a documented feature but we are leaving this in for now. I'm
-     * unsure if there is demand for this feature.
-     *
-     * @param op1
-     * @param op2
-     * @return
-     */
-    @Deprecated
-    @SuppressWarnings({ "unchecked", "rawtypes" })
-    private static Object addToList(List<?> op1, Object op2) {
-        if (op2 instanceof Collection) {
-            op1.addAll((Collection) op2);
-        } else {
-            ((List<Object>) op1).add(op2);
-        }
-        return op1;
-    }
-
-    /**
-     * This is not a documented feature but we are leaving this in for now. I'm
-     * unsure if there is demand for this feature.
-     *
-     * @param op1
-     * @param op2
-     * @return
-     */
-    @Deprecated
-    @SuppressWarnings({ "unchecked", "rawtypes" })
-    private static Object subtractFromList(List<?> op1, Object op2) {
-        if (op2 instanceof Collection) {
-            op1.removeAll((Collection) op2);
-        } else {
-            op1.remove(op2);
-        }
-        return op1;
-    }
-
-    private static Object wideningConversionBinaryOperation(Object op1, Object op2, Operation operation) {
-
-        if (!(op1 instanceof Number) || !(op2 instanceof Number)) {
-            throw new RuntimeException(
-                    String.format("invalid operands for mathematical operation [%s]", operation.toString()));
-        }
-
-        Number num1 = (Number) op1;
-        Number num2 = (Number) op2;
-
-        if (num1 instanceof BigDecimal || num2 instanceof BigDecimal) {
-            return bigDecimalOperation(BigDecimal.valueOf(num1.doubleValue()), BigDecimal.valueOf(num2.doubleValue()),
-                    operation);
-        }
-
-        if (num1 instanceof Double || num2 instanceof Double) {
-            return doubleOperation(num1.doubleValue(), num2.doubleValue(), operation);
-        }
-
-        if (num1 instanceof Float || num2 instanceof Float) {
-            return floatOperation(num1.floatValue(), num2.floatValue(), operation);
-        }
-
-        if (num1 instanceof Long || num2 instanceof Long) {
-            return longOperation(num1.longValue(), num2.longValue(), operation);
-        }
-
-        return integerOperation(num1.intValue(), num2.intValue(), operation);
-    }
-
-    private static boolean wideningConversionBinaryComparison(Object op1, Object op2, Comparison comparison) {
-        if (op1 == null || op2 == null) {
-            return false;
-        }
-
-        Number num1;
-        Number num2;
-        try {
-            num1 = (Number) op1;
-            num2 = (Number) op2;
-        } catch (ClassCastException ex) {
-            throw new RuntimeException(
-                    String.format("invalid operands for mathematical comparison [%s]", comparison.toString()));
-        }
-
-        return doubleComparison(num1.doubleValue(), num2.doubleValue(), comparison);
-    }
-
-    private static double doubleOperation(double op1, double op2, Operation operation) {
-        switch (operation) {
-        case ADD:
-            return op1 + op2;
-        case SUBTRACT:
-            return op1 - op2;
-        case MULTIPLICATION:
-            return op1 * op2;
-        case DIVISION:
-            return op1 / op2;
-        case MODULUS:
-            return op1 % op2;
-        default:
-            throw new RuntimeException("Bug in OperatorUtils in pebble library");
-        }
-    }
-
-    private static boolean doubleComparison(double op1, double op2, Comparison comparison) {
-        switch (comparison) {
-        case GREATER_THAN:
-            return op1 > op2;
-        case GREATER_THAN_EQUALS:
-            return op1 >= op2;
-        case LESS_THAN:
-            return op1 < op2;
-        case LESS_THAN_EQUALS:
-            return op1 <= op2;
-        case EQUALS:
-            return op1 == op2;
-        default:
-            throw new RuntimeException("Bug in OperatorUtils in pebble library");
-        }
-    }
-
-    private static BigDecimal bigDecimalOperation(BigDecimal op1, BigDecimal op2, Operation operation) {
-        switch (operation) {
-        case ADD:
-            return op1.add(op2);
-        case SUBTRACT:
-            return op1.subtract(op2);
-        case MULTIPLICATION:
-            return op1.multiply(op2, MathContext.DECIMAL128);
-        case DIVISION:
-            return op1.divide(op2, MathContext.DECIMAL128);
-        case MODULUS:
-            return op1.remainder(op2, MathContext.DECIMAL128);
-        default:
-            throw new RuntimeException("Bug in OperatorUtils in pebble library");
-        }
-    }
-
-    private static Float floatOperation(Float op1, Float op2, Operation operation) {
-        switch (operation) {
-        case ADD:
-            return op1 + op2;
-        case SUBTRACT:
-            return op1 - op2;
-        case MULTIPLICATION:
-            return op1 * op2;
-        case DIVISION:
-            return op1 / op2;
-        case MODULUS:
-            return op1 % op2;
-        default:
-            throw new RuntimeException("Bug in OperatorUtils in pebble library");
-        }
-    }
-
-    private static long longOperation(long op1, long op2, Operation operation) {
-        switch (operation) {
-        case ADD:
-            return op1 + op2;
-        case SUBTRACT:
-            return op1 - op2;
-        case MULTIPLICATION:
-            return op1 * op2;
-        case DIVISION:
-            return op1 / op2;
-        case MODULUS:
-            return op1 % op2;
-        default:
-            throw new RuntimeException("Bug in OperatorUtils in pebble library");
-        }
-    }
-
-    private static long integerOperation(int op1, int op2, Operation operation) {
-        switch (operation) {
-        case ADD:
-            return op1 + op2;
-        case SUBTRACT:
-            return op1 - op2;
-        case MULTIPLICATION:
-            return op1 * op2;
-        case DIVISION:
-            return op1 / op2;
-        case MODULUS:
-            return op1 % op2;
-        default:
-            throw new RuntimeException("Bug in OperatorUtils in pebble library");
-        }
-    }
-} 
diff --git a/src/expressionLanguage/operator/UnaryOperator.java b/src/expressionLanguage/operator/UnaryOperator.java
deleted file mode 100644
index f74ff44..0000000
--- a/src/expressionLanguage/operator/UnaryOperator.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package expressionLanguage.operator;
-
-import expressionLanguage.expression.UnaryExpression;
-
-public class UnaryOperator extends Operator {
-    
-    public UnaryOperator(int precedence, Class<? extends UnaryExpression> nodeClass) {
-        super(precedence, nodeClass);
-    }
-}
diff --git a/src/expressionLanguage/scope/Scope.java b/src/expressionLanguage/scope/Scope.java
deleted file mode 100644
index a8e24a1..0000000
--- a/src/expressionLanguage/scope/Scope.java
+++ /dev/null
@@ -1,97 +0,0 @@
-package expressionLanguage.scope;
-
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * A scope is a map of variables. A "local" scope ensures that
- * the search for a particular variable will end at this scope
- * whether or not it was found.
- *
- */
-public class Scope {
-
-    /**
-     * A "local" scope ensures that
-     * the search for a particular variable will end at this scope
-     * whether or not it was found.
-     */
-    private final boolean isLocal;
-
-    /**
-     * The map of variables known at this scope
-     */
-    private final Map<String, Object> backingMap;
-
-    /**
-     * Constructor
-     *
-     * @param backingMap The backing map of variables
-     * @param isLocal    Whether this scope is local or not
-     */
-    public Scope(Map<String, Object> backingMap, boolean isLocal) {
-        this.backingMap = backingMap == null ? new HashMap<>() : backingMap;
-        this.isLocal = isLocal;
-    }
-
-    /**
-     * Creates a shallow copy of the Scope.
-     * <p>
-     * This is used for the parallel tag  because every new thread should have a
-     * "snapshot" of the scopes, i.e. one thread should not affect rendering output of another.
-     * <p>
-     * It will construct a new collection but
-     * it will contain references to all of the original variables therefore it is not
-     * a deep copy. This is why it is import for the user to use thread-safe variables
-     * when using the parallel tag.
-     *
-     * @return A copy of the scope
-     */
-    public Scope shallowCopy() {
-
-        Map<String, Object> backingMapCopy = new HashMap<>();
-        backingMapCopy.putAll(backingMap);
-
-        return new Scope(backingMapCopy, isLocal);
-    }
-
-    /**
-     * Returns whether or not this scope is "local".
-     *
-     * @return boolean stating whether this scope is local or not.
-     */
-    public boolean isLocal() {
-        return isLocal;
-    }
-
-    /**
-     * Adds a variable to this scope
-     *
-     * @param key   The name of the variable
-     * @param value The value of the variable
-     */
-    public void put(String key, Object value) {
-        backingMap.put(key, value);
-    }
-
-    /**
-     * Retrieves the variable at this scope
-     *
-     * @param key The name of the variable
-     * @return The value of the variable
-     */
-    public Object get(String key) {
-        return backingMap.get(key);
-    }
-
-    /**
-     * Checks if this scope contains a variable of a certain name.
-     *
-     * @param key The name of the variable
-     * @return boolean stating whether or not the backing map of this scope contains that variable
-     */
-    public boolean containsKey(String key) {
-        return backingMap.containsKey(key);
-    }
-
-}
diff --git a/src/expressionLanguage/scope/ScopeChain.java b/src/expressionLanguage/scope/ScopeChain.java
deleted file mode 100644
index 200a7ad..0000000
--- a/src/expressionLanguage/scope/ScopeChain.java
+++ /dev/null
@@ -1,190 +0,0 @@
-package expressionLanguage.scope;
-
-import java.util.HashMap;
-import java.util.Iterator;
-import java.util.LinkedList;
-import java.util.Map;
-
-/**
- * A stack data structure used to represent the scope of variables that are currently accessible. 
- * Pushing a new scope will allow the template to add variables with names of pre-existing variables 
- * without overriding the originals; 
- * to access the original variables you would pop the scope again.
- */
-public class ScopeChain {
-
-    /**
-     * The stack of scopes
-     */
-    private final LinkedList<Scope> stack = new LinkedList<>();
-
-    /**
-     * Constructs an empty scope chain without any known scopes.
-     */
-    public ScopeChain() {
-    }
-
-    /**
-     * Constructs a new scope chain with one known scope.
-     *
-     * @param map The map of variables used to initialize a scope.
-     */
-    public ScopeChain(Map<String, Object> map) {
-        Scope scope = new Scope(new HashMap<>(map), false);
-        stack.push(scope);
-    }
-
-    /**
-     * Creates a deep copy of the ScopeChain. This is used for the parallel tag
-     * because every new thread should have a "snapshot" of the scopes, i.e. if
-     * one thread adds a new object to a scope, it should not be available to
-     * the other threads.
-     * <p>
-     * This will construct a new scope chain and new scopes but it will continue
-     * to have references to the original user-provided variables. This is why
-     * it is important for the user to only provide thread-safe variables
-     * when using the "parallel" tag.
-     *
-     * @return A copy of the scope chain
-     */
-    public ScopeChain deepCopy() {
-        ScopeChain copy = new ScopeChain();
-
-        stack.stream().forEach((originalScope) -> {
-            copy.stack.add(originalScope.shallowCopy());
-        });
-        
-        return copy;
-    }
-
-    /**
-     * Adds an empty non-local scope to the scope chain
-     */
-    public void pushScope() {
-        pushScope(new HashMap<>());
-    }
-
-    /**
-     * Adds a new non-local scope to the scope chain
-     *
-     * @param map The known variables of this scope.
-     */
-    public void pushScope(Map<String, Object> map) {
-        Scope scope = new Scope(map, false);
-        stack.push(scope);
-    }
-
-    /**
-     * Adds a new local scope to the scope chain
-     */
-    public void pushLocalScope() {
-        Scope scope = new Scope(new HashMap<>(), true);
-        stack.push(scope);
-    }
-
-    /**
-     * Pops the most recent scope from the scope chain.
-     */
-    public void popScope() {
-        stack.pop();
-    }
-
-    /**
-     * Adds a variable to the current scope.
-     *
-     * @param key   The name of the variable
-     * @param value The value of the variable
-     */
-    public void put(String key, Object value) {
-        stack.peek().put(key, value);
-    }
-
-    /**
-     * Retrieves a variable from the scope chain, starting at the current
-     * scope and working it's way up all visible scopes.
-     *
-     * @param key The name of the variable
-     * @return The value of the variable
-     */
-    public Object get(String key) {
-        Object result;
-
-        /*
-         * The majority of time, the requested variable will be in the first
-         * scope so we do a quick lookup in that scope before attempting to
-         * create an iterator, etc. This is solely for performance.
-         */
-        Scope scope = stack.getFirst();
-        result = scope.get(key);
-
-        if (result == null) {
-
-            Iterator<Scope> iterator = stack.iterator();
-
-            // account for the first lookup we did
-            iterator.next();
-
-            while (result == null && iterator.hasNext()) {
-                scope = iterator.next();
-
-                result = scope.get(key);
-                if (scope.isLocal()) {
-                    break;
-                }
-            }
-        }
-
-        return result;
-    }
-
-    /**
-     * This method checks if the given {@code key} does exists within the scope
-     * chain.
-     *
-     * @param key the for which the the check should be executed for.
-     * @return {@code true} when the key does exists or {@code false} when the
-     * given key does not exists.
-     */
-    public boolean containsKey(String key) {
-
-        /*
-         * The majority of time, the requested variable will be in the first
-         * scope so we do a quick lookup in that scope before attempting to
-         * create an iterator, etc. This is solely for performance.
-         */
-        Scope scope = stack.getFirst();
-        if (scope.containsKey(key)) {
-            return true;
-        }
-
-        Iterator<Scope> iterator = stack.iterator();
-
-        // account for the first lookup we did
-        iterator.next();
-
-        while (iterator.hasNext()) {
-            scope = iterator.next();
-
-            if (scope.containsKey(key)) {
-                return true;
-            }
-            if (scope.isLocal()) {
-                break;
-            }
-        }
-
-        return false;
-    }
-
-    /**
-     * Checks if the current scope contains a variable without
-     * then looking up the scope chain.
-     *
-     * @param variableName The name of the variable
-     * @return Whether or not the variable exists in the current scope
-     */
-    public boolean currentScopeContainsVariable(String variableName) {
-        return stack.getFirst().containsKey(variableName);
-    }
-
-}
diff --git a/src/expressionLanguage/test/Test.java b/src/expressionLanguage/test/Test.java
deleted file mode 100644
index 6ecff3f..0000000
--- a/src/expressionLanguage/test/Test.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package expressionLanguage.test;
-
-@FunctionalInterface
-public interface Test {
-
-    boolean apply(Object input);
-}
diff --git a/src/expressionLanguage/token/Token.java b/src/expressionLanguage/token/Token.java
deleted file mode 100644
index fafc481..0000000
--- a/src/expressionLanguage/token/Token.java
+++ /dev/null
@@ -1,66 +0,0 @@
-package expressionLanguage.token;
-
-import expressionLanguage.model.position.Position;
-import java.util.Arrays;
-
-public class Token {
-    
-    private String value;
-
-    private Type type;
-
-    private Position position;
-    
-    public Token(Type type, String value, Position position) {
-        this.type = type;
-        this.value = value;
-        this.position = position;
-    }
-    
-    public boolean isA(Type type) {
-        return this.type.equals(type);
-    }
-
-    public boolean isA(Type type, String... values) {
-        boolean test = true;
-        
-        if (values.length > 0) {
-            test = Arrays.asList(values).contains(this.value);
-        }
-        
-        return test && isA(type);
-    }
-
-    public String getValue() {
-        return value;
-    }
-
-    public void setValue(String value) {
-        this.value = value;
-    }
-
-    public Type getType() {
-        return type;
-    }
-
-    public void setType(Type type) {
-        this.type = type;
-    }
-
-    public Position getPosition() {
-        return position;
-    }
-
-    public void setPosition(Position position) {
-        this.position = position;
-    }
-    
-    public boolean isEOF() {
-        return Type.EOF.equals(getType());
-    }
-
-    @Override
-    public String toString() {
-        return "Token[" + this.getType() + "](" + this.getValue() + ")";
-    }
-}
diff --git a/src/expressionLanguage/token/TokenStream.java b/src/expressionLanguage/token/TokenStream.java
deleted file mode 100644
index 24c693a..0000000
--- a/src/expressionLanguage/token/TokenStream.java
+++ /dev/null
@@ -1,114 +0,0 @@
-package expressionLanguage.token;
-
-import java.util.ArrayList;
-import java.util.Collection;
-
-public class TokenStream {
-
-    private final ArrayList<Token> tokens = new ArrayList<>();
-    private final String filename;
-    private int current;
-
-    /**
-     * Constructor for a Token Stream
-     *
-     * @param tokens A collection of tokens
-     * @param name The filename of the template that these tokens came from
-     */
-    public TokenStream(Collection<Token> tokens, String name) {
-        this.tokens.addAll(tokens);
-        this.current = 0;
-        this.filename = name;
-    }
-
-    /**
-     * Consumes and returns the next token in the stream.
-     *
-     * @return The next token
-     */
-    public Token next() {
-        return tokens.get(++current);
-    }
-
-    /**
-     * Checks the current token to see if it matches the provided type. If it
-     * doesn't match this will throw a SyntaxException. This will consume a
-     * token.
-     *
-     * @param type The type of token that we expect
-     * @return Token The current token
-     */
-    public Token expect(Type type) {
-        return expect(type, null);
-    }
-
-    /**
-     * Checks the current token to see if it matches the provided type. If it
-     * doesn't match this will throw a SyntaxException. This will consume a
-     * token.
-     *
-     * @param type The type of token that we expect
-     * @param value The expected value of the token
-     * @return Token The current token
-     */
-    public Token expect(Type type, String value) {
-        Token token = tokens.get(current);
-
-        boolean success = token.isA(type, value);
-
-        if (!success) {
-            String message = String.format("Unexpected token of value \"%s\" and type %s, expected token of type %s",
-                    token.getValue(), token.getType().toString(), type);
-            throw new IllegalStateException(message);
-        }
-        this.next();
-        return token;
-    }
-
-    /**
-     * Returns the next token in the stream without consuming it.
-     *
-     * @return The next token
-     */
-    public Token peek() {
-        return peek(1);
-    }
-
-    /**
-     * Returns a future token in the stream without consuming any.
-     *
-     * @param number How many tokens to lookahead
-     * @return The token we are peeking at
-     */
-    public Token peek(int number) {
-        return this.tokens.get(this.current + number);
-    }
-
-
-    @Override
-    public String toString() {
-        return tokens.toString();
-    }
-
-    /**
-     * Looks at the current token. Does not consume the token.
-     *
-     * @return Token The current token
-     */
-    public Token current() {
-        return this.tokens.get(current);
-    }
-
-    public String getFilename() {
-        return filename;
-    }
-
-    /**
-     * used for testing purposes
-     *
-     * @return List of tokens
-     */
-    public ArrayList<Token> getTokens() {
-        return tokens;
-    }
-}
diff --git a/src/expressionLanguage/token/Type.java b/src/expressionLanguage/token/Type.java
deleted file mode 100644
index 11604cb..0000000
--- a/src/expressionLanguage/token/Type.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package expressionLanguage.token;
-
-public enum Type {
-    EOF, 
-    TEXT, 
-    EXECUTE_START, 
-    EXECUTE_END, 
-    PRINT_START, 
-    PRINT_END, 
-    NAME, 
-    NUMBER, 
-    STRING, 
-    OPERATOR, 
-    PUNCTUATION;
-}
diff --git a/src/expressionLanguage/token/parser/Parser.java b/src/expressionLanguage/token/parser/Parser.java
deleted file mode 100644
index 4f8e353..0000000
--- a/src/expressionLanguage/token/parser/Parser.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package expressionLanguage.token.parser;
-
-@FunctionalInterface
-public interface Parser<I, R> {
-
-    R parse(I stream);
-}
diff --git a/src/expressionLanguage/token/parser/TokenParser.java b/src/expressionLanguage/token/parser/TokenParser.java
deleted file mode 100644
index 0472a84..0000000
--- a/src/expressionLanguage/token/parser/TokenParser.java
+++ /dev/null
@@ -1,77 +0,0 @@
-package expressionLanguage.token.parser;
-
-import expressionLanguage.model.tree.BodyNode;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.function.Predicate;
-
-/**
- * A TokenParser is responsible for converting a stream of Tokens into a Node. A
- * TokenParser often has to temporarily delegate responsibility.
- */
-public interface TokenParser extends Parser<TokenStream, Node> {
-
-    /**
-     * The "tag" is used to determine when to use a particular instance of a
-     * TokenParser. For example, the TokenParser that handles the "block" tag
-     * would return "block" with this method.
-     *
-     * @return The tag used to define this TokenParser.
-     */
-    default String getTag() {
-        return this.getClass().getSimpleName().replace("TokenParser", "").toLowerCase();
-    }
-    
-    @Override
-    default Node parse(TokenStream stream) {
-        return parse(stream, Token::isEOF);
-    }
-
-    public default Node parse(TokenStream stream, Predicate<Token> stop) {
-        Token current = stream.current();
-        List<Node> children = new ArrayList<>();
-        while (!stop.test(current)) {
-            children.add(parse(stream));
-        }
-        return new BodyNode(current.getPosition(), children);
-    }
-    
-    /**
-     * The TokenParser is responsible to convert all the necessary tokens into
-     * appropriate Nodes. It can access tokens using parser.getTokenStream().
-     *
-     * The tag may be self contained like the "extends" tag or it may have a
-     * start and end point with content in the middle like the "block" tag. If
-     * it contains content in the middle, it can use
-     * parser.subparse(stopCondition) to parse the middle content at which point
-     * responsibility comes back to the TokenParser to parse the end point.
-     *
-     * It is the responsibility of the TokenParser to ensure that when it is
-     * complete, the "current" token of the primary Parser's TokenStream is
-     * pointing to the NEXT token. USUALLY this means the last statement in this
-     * parse method, immediately prior to the return statement, is the following
-     * which will consume one token:
-     *
-     * stream.expect(Token.Type.EXECUTE_END);
-     *
-     * Here are two relatively simple examples of how TokenParsers are
-     * implemented:
-     *
-     * - self contained: com.mitchellbosecke.pebble.tokenParser.SetTokenParser -
-     * middle content: com.mitchellbosecke.pebble.tokenParser.BlockTokenParser
-     *
-     * @param token
-     *            The token to parse
-     * @param parser
-     *            the parser which should be used to parse the token
-     * @return A node representation of the token
-     */
-    default Node parse(Token token, TokenStreamParser parser) {
-        TokenStream stream = parser.getStream();
-        return parse(stream);
-    }
-
-}
diff --git a/src/expressionLanguage/token/parser/TokenStreamParser.java b/src/expressionLanguage/token/parser/TokenStreamParser.java
deleted file mode 100644
index 41b22b7..0000000
--- a/src/expressionLanguage/token/parser/TokenStreamParser.java
+++ /dev/null
@@ -1,201 +0,0 @@
-package expressionLanguage.token.parser;
-
-import expressionLanguage.expression.Expression;
-import expressionLanguage.expression.parser.ExpressionParser;
-import expressionLanguage.model.tree.BodyNode;
-import expressionLanguage.model.tree.Node;
-import expressionLanguage.model.tree.PrintNode;
-import expressionLanguage.model.tree.RootNode;
-import expressionLanguage.model.tree.TextNode;
-import expressionLanguage.operator.Operator;
-import expressionLanguage.token.Token;
-import expressionLanguage.token.TokenStream;
-import expressionLanguage.token.Type;
-import java.util.ArrayList;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.function.Predicate;
-
-public class TokenStreamParser implements Parser<TokenStream, RootNode> {
-
-    /**
-     * operators
-     */
-    private final Map<String, Operator> operators;
-
-    /**
-     * Token parsers
-     */
-    private final Map<String, TokenParser> tokenParsers;
-
-    /**
-     * An expression parser.
-     */
-    private ExpressionParser expressionParser;
-
-    /**
-     * The TokenStream that we are converting into an Abstract Syntax Tree.
-     */
-    private TokenStream stream;
-
-    /**
-     * TokenParser objects provided by the extensions. Used to keep track of the
-     * name of the block that we are currently inside of. This is purely just
-     * for the parent() function.
-     */
-    private LinkedList<String> blockStack;
-
-    /**
-     * Constructor
-     *
-     * @param operators A map of operators
-     * @param tokenParsers A map of token parsers
-     */
-    public TokenStreamParser(Map<String, Operator> operators, Map<String, TokenParser> tokenParsers) {
-        this.operators = operators;
-        this.tokenParsers = tokenParsers;
-    }
-
-    @Override
-    public RootNode parse(TokenStream stream) {
-
-        // expression parser
-        this.expressionParser = new ExpressionParser(this, this.operators);
-
-        this.stream = stream;
-        this.blockStack = new LinkedList<>();
-        
-        BodyNode body = subparse(Token::isEOF);
-
-//        stop != null && stop.test(stream)
-        RootNode root = new RootNode(stream.current().getPosition(), body);
-        return root;
-    }
-
-    /**
-     * The main method for the parser. This method does the work of converting a
-     * TokenStream into a Node
-     *
-     * @param stop A stopping condition provided by a token parser
-     * @return Node The root node of the generated Abstract Syntax Tree
-     */
-    public BodyNode subparse(Predicate<Token> stop) {
-        // these nodes will be the children of the root node
-        List<Node> nodes = new ArrayList<>();
-
-        Token token = stream.current();
-        while (!token.isEOF()) {
-
-            switch (token.getType()) {
-                case TEXT:
-
-                    /*
-                 * The current token is a text token. Not much to do here other
-                 * than convert it to a text Node.
-                     */
-                    token = stream.current();
-                    nodes.add(new TextNode(token.getPosition(), token.getValue()));
-                    stream.next();
-                    break;
-
-                case PRINT_START:
-
-                    /*
-                 * We are entering a print delimited region at this point. These
-                 * regions will contain some sort of expression so let's pass
-                 * control to our expression parser.
-                     */
-                    // go to the next token because the current one is just the
-                    // opening delimiter
-                    token = stream.next();
-
-                    Expression<?> expression = this.expressionParser.parseExpression();
-                    nodes.add(new PrintNode(token.getPosition(), expression));
-
-                    // we expect to see a print closing delimiter
-                    stream.expect(Type.PRINT_END);
-
-                    break;
-
-                case EXECUTE_START:
-
-                    // go to the next token because the current one is just the
-                    // opening delimiter
-                    stream.next();
-
-                    token = stream.current();
-
-                    /*
-                    * We expect a name token at the beginning of every block.
-                    *
-                    * We do not use stream.expect() because it consumes the current
-                    * token. The current token may be needed by a token parser
-                    * which has provided a stopping condition. Ex. the 'if' token
-                    * parser may need to check if the current token is either
-                    * 'endif' or 'else' and act accordingly, thus we should not
-                    * consume it.
-                     */
-                    if (!Type.NAME.equals(token.getType())) {
-                        String msg = String.format("A block must start with a tag name at line %s in file %s.", token.getPosition(), stream.getFilename());
-                        throw new IllegalStateException(msg);
-                    }
-
-                    // If this method was executed using a TokenParser and
-                    // that parser provided a stopping condition (ex. checking
-                    // for the 'endif' token) let's check for that condition
-                    // now.
-                    if (stop != null && stop.test(token)) {
-                        return new BodyNode(token.getPosition(), nodes);
-                    }
-
-                    // find an appropriate parser for this name
-                    TokenParser tokenParser = tokenParsers.get(token.getValue());
-
-                    if (tokenParser == null) {
-                        String msg = String.format("Unexpected tag name \"%s\" at %s", token.getValue(), token.getPosition());
-                        throw new IllegalStateException(msg);
-                    }
-
-                    Node node = tokenParser.parse(token, this);
-
-                    // node might be null (ex. "extend" token parser)
-                    if (node != null) {
-                        nodes.add(node);
-                    }
-
-                    break;
-
-                default:
-                    String msg = String.format("Parser ended in undefined state.", stream.current().getPosition());
-                    throw new IllegalStateException(msg);
-            }
-        }
-        return new BodyNode(stream.current().getPosition(), nodes);
-    }
-
-    public TokenStream getStream() {
-        return stream;
-    }
-
-    public void setStream(TokenStream stream) {
-        this.stream = stream;
-    }
-
-    public ExpressionParser getExpressionParser() {
-        return this.expressionParser;
-    }
-
-    public String peekBlockStack() {
-        return blockStack.peek();
-    }
-
-    public String popBlockStack() {
-        return blockStack.pop();
-    }
-
-    public void pushBlockStack(String blockName) {
-        blockStack.push(blockName);
-    }
-
-}
diff --git a/src/extractor/Extractor.java b/src/extractor/Extractor.java
deleted file mode 100644
index 48d3391..0000000
--- a/src/extractor/Extractor.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package extractor;
-
-@FunctionalInterface
-public interface Extractor<T, R> {
-    
-    R extract(T spec);
-}
diff --git a/src/main/java/component/MarkupBuilder.java b/src/main/java/component/MarkupBuilder.java
new file mode 100644
index 0000000..de3b1aa
--- /dev/null
+++ b/src/main/java/component/MarkupBuilder.java
@@ -0,0 +1,33 @@
+package component;
+
+
+
+import component.node.builder.NodeBuilder;
+import java.util.function.Supplier;
+
+public abstract class MarkupBuilder extends NodeBuilder {
+
+    boolean rootElement = false;
+
+    public MarkupBuilder() {
+        super();
+    }
+
+    protected String spacer(int len){
+       StringBuilder b = new StringBuilder();
+        for (int i = 0; i < len; i++) {
+             b.append('\t');
+        }
+        return b.toString();
+    }
+
+    public MarkupBuilder element(String name) {
+        this.child(name);
+        return this;
+    }
+
+    public MarkupBuilder content(String name) {
+        this.child(name);
+        return this;
+    }
+}
diff --git a/src/main/java/component/Test.java b/src/main/java/component/Test.java
new file mode 100644
index 0000000..52583c4
--- /dev/null
+++ b/src/main/java/component/Test.java
@@ -0,0 +1,141 @@
+package component;
+
+
+
+import component.node.builder.NodeBuilder;
+import component.node.Node;
+import component.builder.Builder;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+
+public class Test {
+    
+    public static void main(String[] args) {
+        
+        String input = "FLORIAN\n" +
+                        "Help Me!\n" +
+                        "Date:16/11/2017\n" +
+                        "Time:15:40:23\n" +
+                        "Speed:0Km/h\n" +
+                        "Altitude:189.0m\n" +
+                        "Bat:78%\n" +
+                        "maps.google.com/maps?g=43.301228,-0.371803";
+//        (?<msg>Help Me\\Q!\\E$)(?<date>\\QDate:\\E[0-9]{2}/[0-9]{2}/[0-9]{4}$)(?<autre>.+)$
+        String regex = "^(?<contract>\\w+$)";
+        Pattern pattern = Pattern.compile(regex, Pattern.MULTILINE);
+        Matcher matcher = pattern.matcher(input);
+        
+        System.out.println("Matcher stats");
+        System.out.print("Matches : ");
+        System.out.println(matcher.matches());
+        System.out.print("Loking at : ");
+        System.out.println(matcher.lookingAt());
+        System.out.print("Group count : ");
+        System.out.println(matcher.groupCount());
+        System.out.println();
+        
+        if (matcher.lookingAt()) {
+            
+        }
+        
+        while (matcher.find()) {
+            System.out.println("contract="+matcher.group("contract"));
+            System.out.println("msg="+matcher.group("msg"));
+            System.out.println("date="+matcher.group("date"));
+            System.out.println("autre="+matcher.group("autre"));
+            System.out.println("result="+matcher.group("result"));
+            System.out.println(matcher.groupCount());
+        }
+
+//        
+//        Node node = Builder.of(Node::new).consume(
+//            n -> n.attr("info", "Informations")
+//        ).consume((n) -> {
+//            System.out.append("visiting");
+//        }).build();
+//        
+//        node = NodeBuilder.root()
+//                .info("Root informations")
+//                .attribute("attribute", 17)
+//                .array("child - 1")
+//                    .info("child - 1 informations")
+//                    .array("child - 1 - 2")
+//                        .info("child - 1 - 2 informations")
+//                    .end()
+//                .end()
+//                .bool("boolean")
+//                    .info("Information")
+//                    .defaultTrue()
+//                .end()
+//                .array("child - 2")
+//                    .info("child - 2 informations")
+//                .end()
+//                .build();
+//        
+//        System.out.append("" + node);
+//        
+//        new TreeNodeBuilder()
+//                .root("root")
+//                    .info("Root informations")
+//                    .attribute("attribute", 17)
+//                .child("child")
+//                    .info("child informations")
+//                .end()
+//                .bool("boolean")
+//                    .info("Information")
+//                    .defaultTrue()
+//                .end()
+//                .array("root")
+//                    .info("root informations")
+//                    .child();
+
+//        Builder.of(Node::new)
+//            .before((product, builder) -> {
+//                System.out.println(Builder.BEFORE);
+//                System.out.println(product);
+//            })
+//            .with((product) -> {
+//                System.out.println(Builder.WITH);
+//                product.child(new Node("1", "1", "1"));
+//                System.out.println(product);
+//            })
+//            .with((product) -> {
+//                System.out.println(Builder.WITH);
+//                product.child(new Node("2", "2", "2"));
+//                System.out.println(product);
+//            })
+//            .after((product, builder) -> {
+//                System.out.println(Builder.AFTER);
+//                System.out.println(product);
+//            })
+//            .build();
+//            .child(new Node())
+//            .visit((node) -> System.out.println(node));
+
+//            new NodeBuilder().info(info)
+//                    .child("services")
+                    
+                
+//        Node.builder()
+//                .child(new Node())
+//                .visit((node) -> System.out.println(node));
+
+//            .arrayNode("router")
+//                .info("router configuration")
+//                .scalarNode("resource")
+//                    .info("Resource path")
+//                    .required()
+//                .end()
+//            .end()
+                    
+//          Configruation.builder().root()
+//                .array("parameters")
+//                    .info("")
+//                    .scalar("resource")
+//                        .info("Resource path")
+//                        .required()
+//                    .end()
+//                .end();
+    }
+}
diff --git a/src/main/java/component/builder/Builder.java b/src/main/java/component/builder/Builder.java
new file mode 100644
index 0000000..0c1525c
--- /dev/null
+++ b/src/main/java/component/builder/Builder.java
@@ -0,0 +1,42 @@
+package component.builder;
+
+import java.util.function.Consumer;
+import java.util.function.Function;
+import java.util.function.Supplier;
+
+public class Builder<P> implements BuilderInterface<P> {
+    
+    protected P product;
+
+    public Builder(P product) {
+        this.product = product;
+    }
+    
+    public static <P> BuilderInterface<P> of(Class<P> clazz) throws Exception {
+        return of(clazz.newInstance());
+    }
+    
+    public static <P> BuilderInterface<P> of(Supplier<P> supplier) {
+        return of(supplier.get());
+    }
+    
+    public static <P> BuilderInterface<P> of(P product) {
+        return new Builder(product);
+    }
+
+    @Override
+    public P build(Function<P, P> build) {
+        return build.apply(product);
+    }
+    
+    @Override
+    public BuilderInterface consume(Consumer<P> visitor) {
+        visitor.accept(product);
+        return this;
+    }
+
+    public P getProduct() {
+        return product;
+    }
+
+}
diff --git a/src/main/java/component/builder/BuilderInterface.java b/src/main/java/component/builder/BuilderInterface.java
new file mode 100644
index 0000000..f60802e
--- /dev/null
+++ b/src/main/java/component/builder/BuilderInterface.java
@@ -0,0 +1,16 @@
+package component.builder;
+
+import java.util.function.Consumer;
+import java.util.function.Function;
+
+public interface BuilderInterface<P> {
+
+    default P build() {
+        return build(Function.identity());
+    };
+    public P build(Function<P, P> build);
+    
+//    public P getProduct();
+    public BuilderInterface<P> consume(Consumer<P> visitor);
+    
+}
diff --git a/src/main/java/component/builder/ConditionalBuilder.java b/src/main/java/component/builder/ConditionalBuilder.java
new file mode 100644
index 0000000..579d8ca
--- /dev/null
+++ b/src/main/java/component/builder/ConditionalBuilder.java
@@ -0,0 +1,36 @@
+package component.builder;
+
+import component.builder.Builder;
+import java.util.function.BooleanSupplier;
+import java.util.function.Consumer;
+
+public abstract class ConditionalBuilder<T> extends Builder<T> {
+    
+    private boolean ifCond = Boolean.TRUE;
+
+    public ConditionalBuilder(T product) {
+        super(product);
+    }
+
+//    public ConditionalBuilder(T product) {
+//        super(product);
+//    }
+
+//    @Override
+//    protected Builder<T> with(Consumer<T> setter) {
+//        if (!ifCond) {
+//           super.with(setter);
+//        }
+//        return this;
+//    }
+    
+    public Builder<T> require(BooleanSupplier condition) {
+        this.ifCond = condition.getAsBoolean();
+        return this;
+    }
+
+    public Builder<T> endRequire() {
+        this.ifCond = true;
+        return this;
+    }
+}
diff --git a/src/main/java/component/builder/StepInterface.java b/src/main/java/component/builder/StepInterface.java
new file mode 100644
index 0000000..b5899b5
--- /dev/null
+++ b/src/main/java/component/builder/StepInterface.java
@@ -0,0 +1,12 @@
+package component.builder;
+
+import component.builder.BuilderInterface;
+import java.util.function.BiConsumer;
+
+@FunctionalInterface
+public interface StepInterface<P> extends BiConsumer<P, BuilderInterface<P>> {
+
+    @Override
+    public void accept(P product, BuilderInterface<P> builder);
+    
+}
diff --git a/src/main/java/component/builder/SteppedBuilder.java b/src/main/java/component/builder/SteppedBuilder.java
new file mode 100644
index 0000000..8618241
--- /dev/null
+++ b/src/main/java/component/builder/SteppedBuilder.java
@@ -0,0 +1,74 @@
+package component.builder;
+
+import component.builder.BuilderInterface;
+import component.builder.Builder;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Consumer;
+
+public class SteppedBuilder<P> extends Builder<P> {
+    
+    public final static String AFTER       = "AFTER";
+    public final static String BEFORE      = "BEFORE";
+    public final static String WITH        = "WITH";
+    public final static String VISIT        = "VISIT";
+    
+    protected Map<String, List<StepInterface<P>>> steps;
+
+    public SteppedBuilder(P product) {
+        super(product);
+    }
+
+    public BuilderInterface<P> step(String event, StepInterface<P> step) {
+        this.steps.computeIfAbsent(event, (e) -> new ArrayList<>()).add(step);
+        return this;
+    }
+    
+    public P build() {
+        getSteps().stream().forEach((step) -> {
+            step.accept(product, this);
+        });
+        
+        return product;
+    }
+    
+    protected List<StepInterface<P>> getSteps(String step) {
+        return this.steps.computeIfAbsent(step, (a) -> new ArrayList<>());
+    }
+    
+    protected List<StepInterface<P>> getSteps() {
+        return Arrays.asList(
+                getSteps(BEFORE), 
+                getSteps(WITH), 
+                getSteps(AFTER), 
+                getSteps(VISIT)).stream()
+                .collect(ArrayList::new, List::addAll, List::addAll);
+    }
+    
+//    public BuilderInterface<P> step(String event, StepInterface<P> step);
+//    public BuilderInterface<P> with(Consumer<P> setter);
+//    public BuilderInterface<P> after(StepInterface<P> step);
+//    public BuilderInterface<P> before(StepInterface<P> step);
+    
+    public BuilderInterface<P> with(Consumer<P> setter) {
+        step(WITH, (P product, BuilderInterface<P> builder) -> {
+            setter.accept(product);
+        });
+//        setter.accept(product);
+        return this;
+    }
+    
+    public BuilderInterface<P> before(StepInterface step) {
+        return step(BEFORE, step);
+    }
+    
+    public BuilderInterface<P> after(StepInterface step) {
+        return step(AFTER, step);
+    }
+    
+    public BuilderInterface<P> visit(StepInterface step) {
+        return step(VISIT, step);
+    }
+}
diff --git a/src/main/java/component/configuration/Configuration.java b/src/main/java/component/configuration/Configuration.java
new file mode 100644
index 0000000..8a779dc
--- /dev/null
+++ b/src/main/java/component/configuration/Configuration.java
@@ -0,0 +1,9 @@
+package component.configuration;
+
+import component.node.builder.NodeBuilder;
+
+public class Configuration {
+    public static NodeBuilder builder() {
+        return new NodeBuilder();
+    }
+}
diff --git a/src/main/java/component/configuration/ConfigurationBuilder.java b/src/main/java/component/configuration/ConfigurationBuilder.java
new file mode 100644
index 0000000..aeb9ddd
--- /dev/null
+++ b/src/main/java/component/configuration/ConfigurationBuilder.java
@@ -0,0 +1,5 @@
+package component.configuration;
+
+public class ConfigurationBuilder {
+    
+}
diff --git a/src/main/java/component/converter/Converter.java b/src/main/java/component/converter/Converter.java
new file mode 100644
index 0000000..36b012c
--- /dev/null
+++ b/src/main/java/component/converter/Converter.java
@@ -0,0 +1,26 @@
+package component.converter;
+
+import java.util.Collections;
+import java.util.List;
+
+@FunctionalInterface
+public interface Converter<I, O> {
+    
+    O convert(I value);
+    
+    default O convert(I value, Object type) {
+        if (support(type)) {
+            return convert(value);
+        }
+        
+        return null;
+    }
+    
+    default List<Object> getTypes(){
+        return Collections.EMPTY_LIST;
+    };
+
+    default boolean support(Object type) {
+        return getTypes().contains(type);
+    }
+}
diff --git a/src/main/java/component/converter/ConverterDelegate.java b/src/main/java/component/converter/ConverterDelegate.java
new file mode 100644
index 0000000..060de5f
--- /dev/null
+++ b/src/main/java/component/converter/ConverterDelegate.java
@@ -0,0 +1,27 @@
+package component.converter;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+
+public class ConverterDelegate<I, O> {
+    
+    List<Converter<I, O>> converters;
+
+    public ConverterDelegate() {
+        this.converters = new ArrayList<>();
+    }
+
+    public O convert(I value, Object type) {
+        Optional<Converter<I, O>> first = this.converters.stream().filter((Converter<I, O> converter)->{
+            return converter.support(type);
+        }).findFirst();
+        
+        if (first.isPresent()) {
+            return first.get().convert(value, type);
+        }
+        
+        return null;      
+    }
+    
+}
diff --git a/src/main/java/component/converter/ConverterResolver.java b/src/main/java/component/converter/ConverterResolver.java
new file mode 100644
index 0000000..efa9f39
--- /dev/null
+++ b/src/main/java/component/converter/ConverterResolver.java
@@ -0,0 +1,49 @@
+package component.converter;
+
+import component.converter.support.*;
+import java.util.Arrays;
+import java.util.Optional;
+
+public class ConverterResolver {
+
+    Converter[] converters;
+
+    public ConverterResolver() {
+        this.converters = new Converter[]{
+            new BigDecimalConverter(),
+            new BooleanConverter(),
+            new ByteConverter(),
+            new CharacterConverter(),
+            new DoubleConverter(),
+            new FloatConverter(),
+            new IdentityConverter(),
+            new IntegerConverter(),
+            new LongConverter(),
+            new ObjectConverter(),
+            new ShortConverter(),
+            new SqlDateConverter(),
+            new SqlTimestampConverter(),
+            new StringConverter()
+        };
+    }
+    
+    public boolean support(Object toConvert) {
+        return Arrays.stream(this.converters).anyMatch((Converter converter)->{
+            return converter.getTypes().contains(toConvert);
+        });
+    }
+    
+    public Converter resolve(Object toConvert) {
+        Optional<Converter> converter = Arrays.stream(this.converters)
+                .filter((Converter c) -> {
+            return c.getTypes().contains(toConvert);
+        }).findFirst();
+        
+        if (!converter.isPresent()) {
+            return null;
+        }
+        
+        return converter.get();
+    }
+    
+}
diff --git a/src/main/java/component/converter/support/BigDecimalConverter.java b/src/main/java/component/converter/support/BigDecimalConverter.java
new file mode 100644
index 0000000..92ffb27
--- /dev/null
+++ b/src/main/java/component/converter/support/BigDecimalConverter.java
@@ -0,0 +1,36 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.math.BigDecimal;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Convert to a {@link BigDecimal} by parsing the value as a string
+ */
+public class BigDecimalConverter implements Converter<Object, BigDecimal> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(BigDecimal.class, BigDecimal.class.getName());
+    }
+
+    @Override
+    public BigDecimal convert(Object value) {
+        if (value == null) {
+            return null;
+        }
+        
+        if (value instanceof BigDecimal) {
+            return (BigDecimal) value;
+        } else {
+            String v = value.toString();
+            if (v.trim().length() != 0) {
+                return new BigDecimal(v);
+            }
+        }
+        
+        return null;
+    }
+
+}
diff --git a/src/main/java/component/converter/support/BooleanConverter.java b/src/main/java/component/converter/support/BooleanConverter.java
new file mode 100644
index 0000000..abb03c5
--- /dev/null
+++ b/src/main/java/component/converter/support/BooleanConverter.java
@@ -0,0 +1,37 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Convert to a boolean by parsing the value as a string
+ */
+public class BooleanConverter implements Converter<Object, Boolean> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(Boolean.class,
+            Boolean.TYPE,
+            Boolean.class.getName());
+    }
+
+    @Override
+    public Boolean convert(Object value) {
+        
+        if (value == null) {
+            return null;
+        }
+        
+        if(value instanceof Boolean) {
+            return (Boolean) value;
+        } else {
+            String v = value.toString();
+            if (v.trim().length() != 0) {
+                return Boolean.parseBoolean(v);
+            }
+        }
+        
+        return null;
+    }
+}
diff --git a/src/main/java/component/converter/support/ByteConverter.java b/src/main/java/component/converter/support/ByteConverter.java
new file mode 100644
index 0000000..15cc2c8
--- /dev/null
+++ b/src/main/java/component/converter/support/ByteConverter.java
@@ -0,0 +1,36 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Convert to a byte by parsing the value as a string
+ */
+public class ByteConverter implements Converter<Object, Byte> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(Byte.class,
+            Byte.TYPE,
+            Byte.class.getName());
+    }
+
+    @Override
+    public Byte convert(Object value) {
+        if (value == null) {
+            return null;
+        }
+
+        if (value instanceof Byte) {
+            return (Byte) value;
+        } else {
+            String v = value.toString();
+            if (v.trim().length() != 0) {
+                return Byte.parseByte(v);
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/component/converter/support/CharacterConverter.java b/src/main/java/component/converter/support/CharacterConverter.java
new file mode 100644
index 0000000..e770506
--- /dev/null
+++ b/src/main/java/component/converter/support/CharacterConverter.java
@@ -0,0 +1,37 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Convert to a character by parsing the first character of the value as a
+ * string
+ *
+ */
+public class CharacterConverter implements Converter<Object, Character> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(
+            Character.class,
+            Character.TYPE,
+            Character.class.getName()
+        );
+    }
+
+    @Override
+    public Character convert(Object value) {
+        if (value == null) {
+            return null;
+        }
+        if (value instanceof Character) {
+            return (Character) value;
+        }
+        String v = value.toString();
+        if (v.trim().length() == 0) {
+            return null;
+        }
+        return v.charAt(0);
+    }
+}
diff --git a/src/main/java/component/converter/support/DoubleConverter.java b/src/main/java/component/converter/support/DoubleConverter.java
new file mode 100644
index 0000000..baea161
--- /dev/null
+++ b/src/main/java/component/converter/support/DoubleConverter.java
@@ -0,0 +1,38 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Convert to a double by parsing the value as a string
+ *
+ */
+public class DoubleConverter implements Converter<Object, Double> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(
+            Double.class,
+            Double.TYPE,
+            Double.class.getName()
+        );
+    }
+
+    @Override
+    public Double convert(Object value) {
+        if (value == null) {
+            return null;
+        }
+        
+        if (value instanceof Double) {
+            return (Double) value;
+        } else {
+            String v = value.toString();
+            if (v.trim().length() != 0) {
+                return Double.parseDouble(v);
+            }
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/component/converter/support/FloatConverter.java b/src/main/java/component/converter/support/FloatConverter.java
new file mode 100644
index 0000000..e33de2f
--- /dev/null
+++ b/src/main/java/component/converter/support/FloatConverter.java
@@ -0,0 +1,40 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Convert to a float by parsing the value as a string
+ *
+ */
+public class FloatConverter implements Converter<Object, Float> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(
+            Float.class,
+            Float.TYPE,
+            Float.class.getName()
+        );
+    }
+
+    @Override
+    public Float convert(Object value) {
+        
+        if (value == null) {
+            return null;
+        }
+        
+        if (value instanceof Float) {
+            return (Float) value;
+        } else {
+            String v = value.toString();
+            if (v.trim().length() != 0) {
+                return Float.parseFloat(v);
+            }
+        }
+        
+        return null;
+    }
+}
diff --git a/src/main/java/component/converter/support/IdentityConverter.java b/src/main/java/component/converter/support/IdentityConverter.java
new file mode 100644
index 0000000..4336618
--- /dev/null
+++ b/src/main/java/component/converter/support/IdentityConverter.java
@@ -0,0 +1,22 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Returns the value as-is (no conversion)
+ *
+ */
+public class IdentityConverter implements Converter<Object, Object> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList();
+    }
+
+    @Override
+    public Object convert(Object value) {
+        return value;
+    }
+}
diff --git a/src/main/java/component/converter/support/IntegerConverter.java b/src/main/java/component/converter/support/IntegerConverter.java
new file mode 100644
index 0000000..4a0432f
--- /dev/null
+++ b/src/main/java/component/converter/support/IntegerConverter.java
@@ -0,0 +1,40 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Convert to an integer by parsing the value as a string
+ *
+ */
+public class IntegerConverter implements Converter<Object, Integer> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(
+            Integer.class,
+            Integer.TYPE,
+            Integer.class.getName()
+        );
+    }
+
+    @Override
+    public Integer convert(Object value) {
+        
+        if (value == null) {
+            return null;
+        }
+        
+        if (value instanceof Integer) {
+            return (Integer) value;
+        } else {
+            String v = value.toString();
+            if (v.trim().length() != 0) {
+                return Integer.parseInt(v);
+            }
+        }
+        
+        return null;
+    }
+}
diff --git a/src/main/java/component/converter/support/LongConverter.java b/src/main/java/component/converter/support/LongConverter.java
new file mode 100644
index 0000000..b0c2fc3
--- /dev/null
+++ b/src/main/java/component/converter/support/LongConverter.java
@@ -0,0 +1,40 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Convert to a long by parsing the value as a string
+ *
+ */
+public class LongConverter implements Converter<Object, Long> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(
+            Long.class,
+            Long.TYPE,
+            Long.class.getName()
+        );
+    }
+
+    @Override
+    public Long convert(Object value) {
+
+        if (value == null) {
+            return null;
+        }
+
+        if (value instanceof Long) {
+            return (Long) value;
+        } else {
+            String v = value.toString();
+            if (v.trim().length() != 0) {
+                return Long.parseLong(v);
+            }
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/component/converter/support/ObjectConverter.java b/src/main/java/component/converter/support/ObjectConverter.java
new file mode 100644
index 0000000..8d6db88
--- /dev/null
+++ b/src/main/java/component/converter/support/ObjectConverter.java
@@ -0,0 +1,63 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.io.ByteArrayInputStream;
+import java.io.IOException;
+import java.io.ObjectInputStream;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Converts a byte array to an object via deserialization, or returns the value
+ * as-is
+ *
+ */
+public class ObjectConverter implements Converter<Object, Object> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(
+            Object.class,
+            Object.class.getName()
+        );
+    }
+
+    @Override
+    public Object convert(Object value) {
+        if (value == null) {
+            return null;
+        }
+        if (value.getClass().isArray()) {
+            // This is a byte array; presume we can convert it to an object
+            if (value.getClass().getComponentType() == Byte.TYPE) {
+                ByteArrayInputStream bis
+                        = new ByteArrayInputStream((byte[]) value);
+                ObjectInputStream ois = null;
+                try {
+                    ois = new ObjectInputStream(bis);
+                    value = ois.readObject();
+                } catch (IOException | ClassNotFoundException e) {
+                    throw new IllegalArgumentException(
+                            "Could not deserialize object", e);
+                } finally {
+                    try {
+                        if (ois != null) {
+                            ois.close();
+                        }
+                    } catch (IOException e) {
+                        // Ignore
+                    }
+                    try {
+                        if (bis != null) {
+                            bis.close();
+                        }
+                    } catch (IOException e) {
+                        // Ignore
+                    }
+                }
+            }
+        }
+
+        return value;
+    }
+}
diff --git a/src/main/java/component/converter/support/ShortConverter.java b/src/main/java/component/converter/support/ShortConverter.java
new file mode 100644
index 0000000..72e2e21
--- /dev/null
+++ b/src/main/java/component/converter/support/ShortConverter.java
@@ -0,0 +1,39 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Convert to a short by parsing the value as a string
+ *
+ */
+public class ShortConverter implements Converter<Object, Short> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(
+            Short.class,
+            Short.TYPE,
+            Short.class.getName()
+        );
+    }
+
+    @Override
+    public Short convert(Object value) {
+        
+        if (value == null) {
+            return null;
+        }
+        
+        if (value instanceof Short) {
+            return (Short) value;
+        } else {
+            String v = value.toString();
+            if (v.trim().length() != 0) {
+                return Short.parseShort(v);
+            }
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/component/converter/support/SqlDateConverter.java b/src/main/java/component/converter/support/SqlDateConverter.java
new file mode 100644
index 0000000..c907f6f
--- /dev/null
+++ b/src/main/java/component/converter/support/SqlDateConverter.java
@@ -0,0 +1,41 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.sql.Date;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Convert to a {@link SqlDate} by parsing a value as a string of form
+ * <code>yyyy-[m]m-[d]d</code>.
+ *
+ * @see	java.sql.Date#valueOf(String)
+ */
+public class SqlDateConverter implements Converter<Object, Date> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(
+            java.sql.Date.class,
+            java.sql.Date.class.getName()
+        );
+    }
+
+    @Override
+    public Date convert(Object value) {
+        if (value == null) {
+            return null;
+        }
+        
+        if (value instanceof Date) {
+            return (Date) value;
+        } else {
+            String v = value.toString();
+            if (v.trim().length() != 0) {
+                return Date.valueOf(v);
+            }
+        }
+        
+        return null;
+    }
+}
diff --git a/src/main/java/component/converter/support/SqlTimeConverter.java b/src/main/java/component/converter/support/SqlTimeConverter.java
new file mode 100644
index 0000000..69ad921
--- /dev/null
+++ b/src/main/java/component/converter/support/SqlTimeConverter.java
@@ -0,0 +1,39 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.sql.Time;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Convert to a {@link SqlTime} by parsing a value as a string of form
+ * <code>hh:mm:ss</code>.
+ *
+ * @see	java.sql.Date#valueOf(String)
+ */
+public class SqlTimeConverter implements Converter<Object, Time> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(
+            Time.class,
+            Time.class.getName()
+        );
+    }
+
+    @Override
+    public Time convert(Object value) {
+        if (value == null) {
+            return null;
+        }
+        if (value instanceof Time) {
+            return (Time) value;
+        } else {
+            String v = value.toString();
+            if (v.trim().length() != 0) {
+                return Time.valueOf(v);
+            }
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/component/converter/support/SqlTimestampConverter.java b/src/main/java/component/converter/support/SqlTimestampConverter.java
new file mode 100644
index 0000000..83925bc
--- /dev/null
+++ b/src/main/java/component/converter/support/SqlTimestampConverter.java
@@ -0,0 +1,39 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.sql.Timestamp;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Convert to a {@link SqlTimestamp} by parsing a value as a string of form
+ * <code>yyyy-[m]m-[d]d hh:mm:ss[.f...]</code>.
+ *
+ * @see	java.sql.Date#valueOf(String)
+ */
+public class SqlTimestampConverter implements Converter<Object, Timestamp> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(
+            Timestamp.class,
+            Timestamp.class.getName()
+        );
+    }
+
+    @Override
+    public Timestamp convert(Object value) {
+        if (value == null) {
+            return null;
+        }
+        if (value instanceof Timestamp) {
+            return (Timestamp) value;
+        } else {
+            String v = value.toString();
+            if (v.trim().length() == 0) {
+                return Timestamp.valueOf(v);
+            }
+        }
+        return null;
+    }
+}
diff --git a/src/main/java/component/converter/support/StringConverter.java b/src/main/java/component/converter/support/StringConverter.java
new file mode 100644
index 0000000..cad9dfe
--- /dev/null
+++ b/src/main/java/component/converter/support/StringConverter.java
@@ -0,0 +1,47 @@
+package component.converter.support;
+
+import component.converter.Converter;
+import java.util.Arrays;
+import java.util.List;
+
+/**
+ * Converts the value to a string. If the value is a byte or char array, it is
+ * converted to a string via {@link toString()}.
+ *
+ */
+public class StringConverter implements Converter<Object, String> {
+
+    @Override
+    public List<Object> getTypes() {
+        return Arrays.asList(
+            String.class,
+            String.class.getName(),
+            "string",
+            "String"
+        );
+    }
+
+    @Override
+    public String convert(Object value) {
+        if (value == null) {
+            return null;
+        }
+
+        if (value.getClass().isArray()) {
+            // This is a byte array; we can convert it to a string
+            if (value.getClass().getComponentType() == Byte.TYPE) {
+                return new String((byte[]) value);
+            }
+            
+            if (value.getClass().getComponentType() == Character.TYPE) {
+                return new String((char[]) value);
+            }
+        } else if (!(value instanceof String)) {
+            return value.toString();
+        } else {
+            return (String) value;
+        }
+
+        return null;
+    }
+}
diff --git a/src/main/java/component/environment/Environment.java b/src/main/java/component/environment/Environment.java
new file mode 100644
index 0000000..0dea7be
--- /dev/null
+++ b/src/main/java/component/environment/Environment.java
@@ -0,0 +1,5 @@
+package component.environment;
+
+public class Environment {
+    
+}
diff --git a/src/main/java/component/event/Event.java b/src/main/java/component/event/Event.java
new file mode 100644
index 0000000..4a447e2
--- /dev/null
+++ b/src/main/java/component/event/Event.java
@@ -0,0 +1,41 @@
+package component.event;
+
+import component.event.dispatcher.Dispatcher;
+import java.util.UUID;
+
+public class Event {
+
+    private long id;
+    private boolean propagationStopped = false;
+    private Dispatcher dispatcher;
+
+    public Event() {
+        super();
+        this.id = UUID.randomUUID().getMostSignificantBits();
+    }
+
+    public long getId() {
+        return id;
+    }
+
+    public void setId(long id) {
+        this.id = id;
+    }
+
+    public Dispatcher getDispatcher() {
+        return dispatcher;
+    }
+
+    public void setDispatcher(Dispatcher dispatcher) {
+        this.dispatcher = dispatcher;
+    }
+
+    public boolean isPropagationStopped() {
+        return propagationStopped;
+    }
+
+    public void stopEventPropagation() {
+        this.propagationStopped = true;
+    }
+
+}
diff --git a/src/main/java/component/event/dispatcher/Dispatcher.java b/src/main/java/component/event/dispatcher/Dispatcher.java
new file mode 100644
index 0000000..d0db042
--- /dev/null
+++ b/src/main/java/component/event/dispatcher/Dispatcher.java
@@ -0,0 +1,169 @@
+package component.event.dispatcher;
+
+import component.event.Event;
+import component.event.handler.Handler;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+
+import java.util.function.Predicate;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public abstract class Dispatcher<E extends Event> implements DispatcherInterface<E> {
+
+    protected final Logger logger = Logger.getLogger(getClass().getName());
+
+    private Map<String, Map<Integer, Handler<E>>> handlers;
+    
+    private Predicate<E> stopCondition;
+
+    public Dispatcher() {}
+    
+    public Dispatcher(Map<String, Map<Integer, Handler<E>>> handlers) {
+        this.handlers = handlers;
+    }
+    
+    public Dispatcher(Predicate<E> stopCondition) {
+        this.stopCondition = stopCondition;
+    }
+
+    public Dispatcher(Map<String, Map<Integer, Handler<E>>> handlers, Predicate<E> stopCondition) {
+        this.handlers = handlers;
+        this.stopCondition = stopCondition;
+    }
+    
+    public Map<String, Map<Integer, Handler<E>>> getHandlers() {
+        if(this.handlers == null) {
+            this.handlers = new HashMap<>();
+        }
+        
+        return this.handlers;
+    }
+    
+    public Map<Integer, Handler<E>> getHandlers(String name) {
+        return getHandlers().computeIfAbsent(name, (handlers) -> new HashMap<>());
+    }
+    
+    public Handler<E> getHandler(String name, Integer priority) {
+        return getHandlers(name).get(priority);
+    }
+    
+    public boolean hasStopCondition(){
+        return this.stopCondition != null;
+    }
+
+    public <T extends E> Dispatcher<T> of(Class<T> clazz) {
+        return (Dispatcher<T>) this;
+    }
+    
+    @Override
+    public DispatcherInterface<E> register(String name, Integer priority, Handler<E> handler) {
+        
+        if (getHandler(name, priority) != null) {
+            priority = Integer.MAX_VALUE;
+        }
+        
+        getHandlers(name).put(priority, handler);
+        return this;
+    }
+    
+    @Override
+    public DispatcherInterface<E> dispatch(String name, E event) throws Exception {
+        if(!getHandlers().containsKey(name)) {
+            this.logger.log(Level.FINE, "No handlers for {}", name);
+            return this;
+        }
+        
+        String msg = String.format("%s is dispatching an event : %s ", this.getClass().getName(), name);
+        this.logger.finest(msg);
+        
+        Collection<Handler<E>> values = getHandlers(name).values();
+        
+        for (Handler<E> handler : values) {
+            if(hasStopCondition() && this.stopCondition.test(event)) {
+                break;
+            }
+            
+            handler.handle(event);
+        }
+        
+        return this;
+    }
+    
+//    private Handler<E> getLowestPriority(String name) {
+//        
+//        getHandlers().get(name).entrySet()
+//    }
+    
+    
+//    @Override
+//    public void addSubscriber(SubscriberInterface<E> sub) {
+//        if (Objects.isNull(sub)) {
+//            return;
+//        }
+//        
+//        getSubscribers().add(sub);
+//        this.logger.finest(String.format("Subscriber %s has been added to %s.", sub.getClass().getName(), this.getClass().getName()));
+//    }
+    
+//    @Override
+//    public void removeSubscriber(SubscriberInterface<E> subscriber) {
+//        if (getSubscribers().isEmpty() || !getSubscribers().contains(subscriber)) {
+//            return;
+//        }
+//
+//        getSubscribers().remove(subscriber);
+//        this.logger.finest(String.format("Subscriber %s has been removed from %s.", subscriber.getClass().getName(), this.getClass().getName()));
+//    }
+
+    
+//    @Override
+//    public void register(String name, Map<Integer, Handler<E>> handler) {
+//        if (Objects.isNull(handler)) {
+//            return;
+//        }
+//
+//        getHandlers().put(name, handler);
+//        this.logger.finest(String.format("Subscriber %s has been added to %s.", handler.getClass().getName(), this.getClass().getName()));
+//    }
+    
+//        getHandlers().containsKey(msg)
+
+//        for (Handler<E> handler : handlers.values()) {
+//            if(hasStopCondition() || this.stopCondition.test(event)) {
+//                break;
+//            }
+//            handler.handle(event);
+//        }
+        
+//        List<SubscriberInterface<E>> subscribers = getSubscribers().stream()
+//            .filter(Objects::nonNull)
+//            .collect(Collectors.toList());
+//        
+//        for (SubscriberInterface<E> subscriber : subscribers) {
+//            Map<String, Handler<E>> handlers = subscriber.getHandlers();
+//            
+//            for (Handler<E> handler : handlers.values()) {
+//                if(hasStopCondition() || this.stopCondition.test(event)) {
+//                    break;
+//                }
+//                handler.handle(event);
+//            }
+//        }
+        
+//        getSubscribers().stream()
+//            .filter(subscriber -> subscriber != null)
+//            .forEach((SubscriberInterface<T> subscriber) -> {
+//                subscriber.getSubscribedEvents().entrySet().stream()
+//                    .filter(entry -> name.equals(entry.getKey()))
+//                    .map(entry -> entry.getValue())
+//                    .forEach(listener -> {
+//                        if(!hasStopCondition() || !this.stopCondition.test(event)) {
+//                            listener.consume(event);
+//                        }
+//                    });
+//            });
+//    }
+    
+}
diff --git a/src/main/java/component/event/dispatcher/DispatcherInterface.java b/src/main/java/component/event/dispatcher/DispatcherInterface.java
new file mode 100644
index 0000000..c78892e
--- /dev/null
+++ b/src/main/java/component/event/dispatcher/DispatcherInterface.java
@@ -0,0 +1,26 @@
+package component.event.dispatcher;
+
+import component.event.Event;
+import component.event.handler.Handler;
+import java.util.Map;
+
+public interface DispatcherInterface<E extends Event> {
+    
+    <T extends E> Dispatcher<T> of(Class<T> clazz);
+    DispatcherInterface<E> dispatch(String name, E event) throws Exception;
+    DispatcherInterface<E> register(String name, Integer priority, Handler<E> handler);
+    
+    default DispatcherInterface<E> register(String name, Handler<E> handler) {
+        register(name, 1, handler);
+        return this;
+    }
+    
+    default DispatcherInterface<E> register(String name, Map<Integer, Handler<E>> handlers) {
+        if (handlers == null || handlers.isEmpty()) {
+            return this;
+        }
+        
+        handlers.forEach((priority, handler) -> register(name, priority, handler));
+        return this;
+    }
+}
diff --git a/src/main/java/component/event/dispatcher/EventDispatcher.java b/src/main/java/component/event/dispatcher/EventDispatcher.java
new file mode 100644
index 0000000..848a6eb
--- /dev/null
+++ b/src/main/java/component/event/dispatcher/EventDispatcher.java
@@ -0,0 +1,96 @@
+package component.event.dispatcher;
+
+import component.event.Event;
+import component.event.handler.Handler;
+import component.event.subscriber.Subscriber;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Predicate;
+
+public class EventDispatcher extends Dispatcher<Event> {
+
+    public EventDispatcher() {
+        super();
+    }
+    
+    public EventDispatcher(Predicate<Event> stopCondition) {
+        super(stopCondition);
+    }
+
+    @Override
+    public DispatcherInterface<Event> dispatch(final String name, Event event) throws Exception {
+        if (event == null) {
+            event = this.create();
+            this.logger.info(String.format("%s has created an event.", this.getClass().getName()));
+        }
+
+        event.setDispatcher(this);
+        
+        return super.dispatch(name, event);
+    }
+
+    public Event create() {
+        return new Event();
+    }
+    
+    public static EventDispatcherBuilder builder() {
+        return new EventDispatcherBuilder();
+    }
+    
+    public static class EventDispatcherBuilder {
+        
+        private Predicate<Event> stop;
+        
+        private Collection<Subscriber<Event>> subscribers = new ArrayList<>();
+        
+        private Map<String, Map<Integer, Handler<Event>>> handlers;
+    
+        public EventDispatcherBuilder willStopWhen(Predicate<Event> stop) {
+            this.stop = stop;
+            return this;
+        }
+        
+        public EventDispatcherBuilder subscribe(Subscriber<Event> subscriber) {
+            this.subscribers.add(subscriber);
+            return this;
+        }
+        
+        public EventDispatcherBuilder register(String name, Integer priority, Handler<Event> handler) {
+            if (getHandler(name, priority) != null) {
+                priority = Integer.MAX_VALUE;
+            }
+
+            getHandlers(name).put(priority, handler);
+            return this;
+        }
+        
+        public EventDispatcher build() {
+            EventDispatcher dispatcher = new EventDispatcher(this.stop);
+            
+            this.subscribers.forEach((subscriber) -> {
+                subscriber.subscribe(dispatcher);
+            });
+            
+            return dispatcher;
+        }
+        
+        public Map<String, Map<Integer, Handler<Event>>> getHandlers() {
+            if(this.handlers == null) {
+                this.handlers = new HashMap<>();
+            }
+
+            return this.handlers;
+        }
+
+        public Map<Integer, Handler<Event>> getHandlers(String name) {
+            return getHandlers().computeIfAbsent(name, (handlers) -> new HashMap<>());
+        }
+
+        public Handler getHandler(String name, Integer priority) {
+            return getHandlers(name).get(priority);
+        }
+    }
+
+}
diff --git a/src/main/java/component/event/handler/Handler.java b/src/main/java/component/event/handler/Handler.java
new file mode 100644
index 0000000..f83f4c9
--- /dev/null
+++ b/src/main/java/component/event/handler/Handler.java
@@ -0,0 +1,9 @@
+package component.event.handler;
+
+import component.event.Event;
+
+@FunctionalInterface
+public interface Handler<E extends Event> {
+    
+    void handle(E event);
+}
diff --git a/src/main/java/component/event/subscriber/Subscriber.java b/src/main/java/component/event/subscriber/Subscriber.java
new file mode 100644
index 0000000..96c3f80
--- /dev/null
+++ b/src/main/java/component/event/subscriber/Subscriber.java
@@ -0,0 +1,11 @@
+package component.event.subscriber;
+
+import component.event.Event;
+import component.event.dispatcher.DispatcherInterface;
+
+@FunctionalInterface
+public interface Subscriber<E extends Event> {
+
+    void subscribe(DispatcherInterface<E> dispatcher);
+
+}
diff --git a/src/main/java/component/event_old/Event.java b/src/main/java/component/event_old/Event.java
new file mode 100644
index 0000000..bbf6b5a
--- /dev/null
+++ b/src/main/java/component/event_old/Event.java
@@ -0,0 +1,41 @@
+package component.event_old;
+
+import component.event_old.dispatcher.Dispatcher;
+import java.util.UUID;
+
+public class Event {
+
+    private long id;
+    private boolean propagationStopped = false;
+    private Dispatcher dispatcher;
+
+    public Event() {
+        super();
+        this.id = UUID.randomUUID().getMostSignificantBits();
+    }
+
+    public long getId() {
+        return id;
+    }
+
+    public void setId(long id) {
+        this.id = id;
+    }
+
+    public Dispatcher getDispatcher() {
+        return dispatcher;
+    }
+
+    public void setDispatcher(Dispatcher dispatcher) {
+        this.dispatcher = dispatcher;
+    }
+
+    public boolean isPropagationStopped() {
+        return propagationStopped;
+    }
+
+    public void stopEventPropagation() {
+        this.propagationStopped = true;
+    }
+
+}
diff --git a/src/main/java/component/event_old/EventConsumer.java b/src/main/java/component/event_old/EventConsumer.java
new file mode 100644
index 0000000..a075a1f
--- /dev/null
+++ b/src/main/java/component/event_old/EventConsumer.java
@@ -0,0 +1,7 @@
+package component.event_old;
+
+@FunctionalInterface
+public interface EventConsumer<T> {
+    
+    void consume(T event) throws Exception;
+}
diff --git a/src/main/java/component/event_old/EventDispatcher.java b/src/main/java/component/event_old/EventDispatcher.java
new file mode 100644
index 0000000..e228ec9
--- /dev/null
+++ b/src/main/java/component/event_old/EventDispatcher.java
@@ -0,0 +1,27 @@
+package component.event_old;
+
+import component.event_old.dispatcher.Dispatcher;
+
+public class EventDispatcher extends Dispatcher<Event> {
+
+    public EventDispatcher() {
+        super(event -> event.isPropagationStopped());
+    }
+
+    @Override
+    public void dispatch(final String name, Event event) throws Exception {
+        if (event == null) {
+            event = this.create();
+            this.logger.info(String.format("%s has created an event.", this.getClass().getName()));
+        }
+
+        event.setDispatcher(this);
+        
+        super.dispatch(name, event);
+    }
+
+    @Override
+    public Event create() {
+        return new Event();
+    }
+}
diff --git a/src/main/java/component/event_old/EventSubscriber.java b/src/main/java/component/event_old/EventSubscriber.java
new file mode 100644
index 0000000..1fa8567
--- /dev/null
+++ b/src/main/java/component/event_old/EventSubscriber.java
@@ -0,0 +1,14 @@
+package component.event_old;
+
+import component.event_old.subscriber.SubscriberInterface;
+import java.util.Map;
+import java.util.logging.Logger;
+
+public abstract class EventSubscriber<T extends Event> implements SubscriberInterface<T> {
+
+    protected final Logger logger = Logger.getLogger(getClass().getName());
+    
+    @Override
+    public abstract Map<String, EventConsumer<T>> getSubscribedEvents();
+
+}
diff --git a/src/main/java/component/event_old/dispatcher/Dispatcher.java b/src/main/java/component/event_old/dispatcher/Dispatcher.java
new file mode 100644
index 0000000..618d10d
--- /dev/null
+++ b/src/main/java/component/event_old/dispatcher/Dispatcher.java
@@ -0,0 +1,104 @@
+package component.event_old.dispatcher;
+
+import component.event_old.Event;
+import component.event_old.EventConsumer;
+import java.util.List;
+import java.util.ArrayList;
+
+import component.event_old.subscriber.SubscriberInterface;
+import java.util.Map;
+import java.util.Objects;
+import java.util.function.Predicate;
+import java.util.logging.Logger;
+import java.util.stream.Collectors;
+
+public abstract class Dispatcher<T extends Event> implements DispatcherInterface<T> {
+
+    protected final Logger logger = Logger.getLogger(getClass().getName());
+
+    private List<SubscriberInterface<T>> subscribers;
+    
+    private Predicate<T> stopCondition;
+
+    public Dispatcher() {}
+    
+    public Dispatcher(List<SubscriberInterface<T>> subscribers) {
+        this.subscribers = subscribers;
+    }
+    
+    public Dispatcher(Predicate<T> stopCondition) {
+        this.stopCondition = stopCondition;
+    }
+    
+    public Dispatcher(List<SubscriberInterface<T>> subscribers, Predicate<T> stopCondition) {
+        this.subscribers = subscribers;
+        this.stopCondition = stopCondition;
+    }
+
+    public List<SubscriberInterface<T>> getSubscribers() {
+        if(this.subscribers == null) {
+            this.subscribers = new ArrayList<>();
+        }
+        
+        return this.subscribers;
+    }
+    
+    public boolean hasStopCondition(){
+        return this.stopCondition != null;
+    }
+    
+    @Override
+    public void addSubscriber(SubscriberInterface<T> sub) {
+        if (Objects.isNull(sub)) {
+            return;
+        }
+        
+        getSubscribers().add(sub);
+        this.logger.finest(String.format("Subscriber %s has been added to %s.", sub.getClass().getName(), this.getClass().getName()));
+    }
+    
+    @Override
+    public void removeSubscriber(SubscriberInterface<T> subscriber) {
+        if (getSubscribers().isEmpty() || !getSubscribers().contains(subscriber)) {
+            return;
+        }
+
+        getSubscribers().remove(subscriber);
+        this.logger.finest(String.format("Subscriber %s has been removed from %s.", subscriber.getClass().getName(), this.getClass().getName()));
+    }
+
+    @Override
+    public void dispatch(String name, T event) throws Exception {
+        String msg = String.format("%s is dispatching an event : %s ", this.getClass().getName(), name);
+        this.logger.finest(msg);
+        
+        List<SubscriberInterface<T>> subscribers = getSubscribers().stream()
+            .filter(Objects::nonNull)
+            .collect(Collectors.toList());
+        
+        for (SubscriberInterface<T> subscriber : subscribers) {
+            
+            Map<String, EventConsumer<T>> subscribedEvents = subscriber.getSubscribedEvents();
+            
+            for (EventConsumer<T> consumer : subscribedEvents.values()) {
+                if(!hasStopCondition() || !this.stopCondition.test(event)) {
+                    consumer.consume(event);
+                }
+            }
+        }
+        
+//        getSubscribers().stream()
+//            .filter(subscriber -> subscriber != null)
+//            .forEach((SubscriberInterface<T> subscriber) -> {
+//                subscriber.getSubscribedEvents().entrySet().stream()
+//                    .filter(entry -> name.equals(entry.getKey()))
+//                    .map(entry -> entry.getValue())
+//                    .forEach(listener -> {
+//                        if(!hasStopCondition() || !this.stopCondition.test(event)) {
+//                            listener.consume(event);
+//                        }
+//                    });
+//            });
+    }
+    
+}
diff --git a/src/main/java/component/event_old/dispatcher/DispatcherInterface.java b/src/main/java/component/event_old/dispatcher/DispatcherInterface.java
new file mode 100644
index 0000000..0dd4067
--- /dev/null
+++ b/src/main/java/component/event_old/dispatcher/DispatcherInterface.java
@@ -0,0 +1,15 @@
+package component.event_old.dispatcher;
+
+import component.event_old.subscriber.SubscriberInterface;
+
+public interface DispatcherInterface<T> {
+
+    T create();
+    
+    void dispatch(String name, T event) throws Exception;
+
+    void addSubscriber(SubscriberInterface<T> sub);
+    
+    void removeSubscriber(SubscriberInterface<T> sub);
+
+}
diff --git a/src/main/java/component/event_old/subscriber/Subscriber.java b/src/main/java/component/event_old/subscriber/Subscriber.java
new file mode 100644
index 0000000..dd0871a
--- /dev/null
+++ b/src/main/java/component/event_old/subscriber/Subscriber.java
@@ -0,0 +1,11 @@
+package component.event_old.subscriber;
+
+import component.event_old.EventConsumer;
+import java.util.Map;
+
+public abstract class Subscriber<T> implements SubscriberInterface<T> {
+
+    @Override
+    public abstract Map<String, EventConsumer<T>> getSubscribedEvents();
+    
+}
diff --git a/src/main/java/component/event_old/subscriber/SubscriberInterface.java b/src/main/java/component/event_old/subscriber/SubscriberInterface.java
new file mode 100644
index 0000000..7724884
--- /dev/null
+++ b/src/main/java/component/event_old/subscriber/SubscriberInterface.java
@@ -0,0 +1,10 @@
+package component.event_old.subscriber;
+
+import component.event_old.EventConsumer;
+import java.util.Map;
+
+public interface SubscriberInterface<T> {
+    
+    Map<String, EventConsumer<T>> getSubscribedEvents();
+    
+}
diff --git a/src/main/java/component/expressionLanguage/Engine.java b/src/main/java/component/expressionLanguage/Engine.java
new file mode 100644
index 0000000..f802eff
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/Engine.java
@@ -0,0 +1,225 @@
+package component.expressionLanguage;
+
+import component.expressionLanguage.extension.ExtensionRegistry;
+import component.expressionLanguage.lexer.Lexer;
+import component.expressionLanguage.model.position.Source;
+import component.expressionLanguage.model.template.Template;
+import component.expressionLanguage.model.tree.RootNode;
+import component.expressionLanguage.model.visitor.BlockRegistrantVisitor;
+import component.expressionLanguage.model.visitor.MacroRegistrantVisitor;
+import component.expressionLanguage.token.parser.Parser;
+import component.expressionLanguage.scope.ScopeChain;
+import component.expressionLanguage.token.TokenStream;
+import component.resource.ResourceService;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.concurrent.ExecutorService;
+import java.util.function.Predicate;
+import java.util.stream.Stream;
+
+/**
+ * The main class used for compiling templates. The PebbleEngine is responsible
+ * for delegating responsibility to the lexer, parser, compiler, and template
+ * cache.
+ */
+public class Engine {
+
+    private final ResourceService resourceService;
+
+    private final Lexer lexer;
+
+    private final Parser<TokenStream, RootNode> parser;
+
+    private final boolean strictVariables;
+
+    private final ExtensionRegistry extensionRegistry;
+
+    private final Locale defaultLocale;
+
+    private final ExecutorService executorService;
+
+    public Engine(ResourceService resourceService,
+            Lexer lexer,
+            Parser parser,
+            ExtensionRegistry extensionRegistry,
+            boolean strictVariables,
+            Locale defaultLocale,
+            ExecutorService executorService) {
+
+        this.resourceService = resourceService;
+        this.lexer = lexer;
+        this.parser = parser;
+        this.extensionRegistry = extensionRegistry;
+        this.strictVariables = strictVariables;
+        this.defaultLocale = defaultLocale;
+        this.executorService = executorService;
+    }
+
+    /**
+     * Loads, parses, and compiles a template into an instance of PebbleTemplate
+     * and returns this instance.
+     *
+     * @param name The name of the template
+     * @return Template The compiled version of the template
+     * @throws Exception Thrown if an error occurs while parsing the template.
+     */
+    public Template load(final String name) throws Exception {
+
+        /*
+         * template name will be null if user uses the extends tag with an
+         * expression that evaluates to null
+         */
+        if (name == null) {
+            return null;
+        }
+
+        InputStream stream = this.resourceService.load(name);
+        Reader reader = new InputStreamReader(stream);
+        Source source = Source.builder(name).read(reader).build();
+        TokenStream tokenStream = this.lexer.tokenize(source);
+        RootNode root = this.parser.parse(tokenStream);
+
+//        final Engine self = this;
+        Template instance = new Template(this, root, name);
+
+        evaluate(instance);
+
+        return instance;
+    }
+
+    public void evaluate(Template root) throws Exception {
+        EvaluationContext context = initContext(root, null);
+        evaluate(root, context);
+    }
+
+    public void evaluate(Template root, Locale locale) throws Exception {
+        EvaluationContext context = initContext(root, locale);
+        evaluate(root, context);
+    }
+
+    public void evaluate(Template root, Map<String, Object> map) throws Exception {
+        EvaluationContext context = initContext(root, null);
+        context.getScopeChain().pushScope(map);
+        evaluate(root, context);
+    }
+
+    public void evaluate(Template root, Map<String, Object> map, Locale locale) throws Exception {
+        EvaluationContext context = initContext(root, locale);
+        context.getScopeChain().pushScope(map);
+        evaluate(root, context);
+    }
+
+    /**
+     * This is the authoritative evaluate method. It will evaluate the template
+     * starting at the root node.
+     *
+     * @param writer The writer used to write the final output of the template
+     * @param context The evaluation context
+     * @throws Exception Thrown from the writer object
+     */
+    private void evaluate(Template root, EvaluationContext context) throws Exception {
+
+//        root.accept((node) -> {
+//            System.out.println("Node : ");
+//            System.out.println(Objects.toString(node));
+//        });
+//        System.out.println(root);
+        // Eval logic HERE 
+//        template.
+//        rootNode.render(this, context);
+
+        Stream.concat(
+            Stream.of(new BlockRegistrantVisitor(root), new MacroRegistrantVisitor(root)), 
+            this.extensionRegistry.getVisitors().stream()
+        ).forEach(root.getRootNode()::accept);
+
+        /*
+         * If the current template has a parent then we know the current template
+         * was only used to evaluate a very small subset of tags such as "set" and "import".
+         * We now evaluate the parent template as to evaluate all of the actual content.
+         * When evaluating the parent template, it will check the child template for overridden blocks.
+         */
+        if (context.getHierarchy().getParent() != null) {
+            Template parent = context.getHierarchy().getParent();
+            context.getHierarchy().ascend();
+            evaluate(parent, context);
+        }
+    }
+
+    /**
+     * Initializes the evaluation context with settings from the engine.
+     *
+     * @param locale The desired locale
+     * @return The evaluation context
+     */
+    private EvaluationContext initContext(Template root, Locale locale) {
+        locale = locale == null ? getDefaultLocale() : locale;
+
+        // globals
+        Map<String, Object> globals = new HashMap<>();
+        globals.put("locale", locale);
+        globals.put("template", root);
+        ScopeChain scopeChain = new ScopeChain(globals);
+
+        // global vars provided from extensions
+        scopeChain.pushScope(getExtensionRegistry().getGlobalVariables());
+
+        EvaluationContext context = new EvaluationContext(root,
+                isStrictVariables(), locale,
+                getExtensionRegistry(), getExecutorService(),
+                new ArrayList<>(), scopeChain, null);
+        return context;
+    }
+
+    /**
+     * Returns the resourceService
+     *
+     * @return The resourceService
+     */
+    public ResourceService getResourceService() {
+        return resourceService;
+    }
+
+    /**
+     * Returns the strict variables setting
+     *
+     * @return The strict variables setting
+     */
+    public boolean isStrictVariables() {
+        return strictVariables;
+    }
+
+    /**
+     * Returns the default locale
+     *
+     * @return The default locale
+     */
+    public Locale getDefaultLocale() {
+        return defaultLocale;
+    }
+
+    /**
+     * Returns the executor service
+     *
+     * @return The executor service
+     */
+    public ExecutorService getExecutorService() {
+        return executorService;
+    }
+
+    /**
+     * Returns the extension registry.
+     *
+     * @return The extension registry
+     */
+    public ExtensionRegistry getExtensionRegistry() {
+        return extensionRegistry;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/EvaluationContext.java b/src/main/java/component/expressionLanguage/EvaluationContext.java
new file mode 100644
index 0000000..7ad34a1
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/EvaluationContext.java
@@ -0,0 +1,183 @@
+package component.expressionLanguage;
+
+import component.expressionLanguage.model.template.Hierarchy;
+import component.expressionLanguage.extension.ExtensionRegistry;
+import component.expressionLanguage.model.template.Template;
+import component.expressionLanguage.scope.ScopeChain;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.concurrent.ExecutorService;
+
+/**
+ * An evaluation context will store all stateful data that is necessary for the
+ * evaluation of a template. Passing the entire state around will assist with
+ * thread safety.
+ *
+ */
+public class EvaluationContext {
+
+    private final boolean strictVariables;
+
+    /**
+     * A template will look to it's parent and children for overridden macros
+     * and other features; this inheritance chain will help the template keep
+     * track of where in the inheritance chain it currently is.
+     */
+    private final Hierarchy hierarchy;
+
+    /**
+     * A scope is a set of visible variables. A trivial template will only have
+     * one scope. New scopes are added with for loops and macros for example.
+     * <p>
+     * Most scopes will have a link to their parent scope which allow an
+     * evaluation to look up the scope chain for variables. A macro is an
+     * exception to this as it only has access to it's local variables.
+     */
+    private final ScopeChain scopeChain;
+
+    /**
+     * The locale of this template.
+     */
+    private final Locale locale;
+
+    /**
+     * All the available filters/tests/functions for this template.
+     */
+    private final ExtensionRegistry extensionRegistry;
+
+    /**
+     * The user-provided ExecutorService (can be null).
+     */
+    private final ExecutorService executorService;
+
+    /**
+     * The imported templates are used to look up macros.
+     */
+    private final List<Template> imported;
+    
+    /**
+     * Constructor used to provide all final variables.
+     *
+     * @param self The template implementation
+     * @param strictVariables Whether strict variables is to be used
+     * @param locale The locale of the template
+     * @param extensionRegistry The extension registry
+     * @param executorService The optional executor service
+     * @param imported
+     * @param scopeChain The scope chain
+     * @param hierarchy The inheritance chain
+     */
+    public EvaluationContext(Template self, boolean strictVariables, Locale locale,
+            ExtensionRegistry extensionRegistry,
+            ExecutorService executorService, List<Template> imported, ScopeChain scopeChain,
+            Hierarchy hierarchy) {
+
+        if (hierarchy == null) {
+            hierarchy = new Hierarchy(self);
+        }
+
+        this.strictVariables = strictVariables;
+        this.locale = locale;
+        this.extensionRegistry = extensionRegistry;
+        this.executorService = executorService;
+        this.imported = imported;
+        this.scopeChain = scopeChain;
+        this.hierarchy = hierarchy;
+    }
+
+    /**
+     * Makes an exact copy of the evaluation context EXCEPT for the inheritance
+     * chain. This is necessary for the "include" tag.
+     *
+     * @param self The template implementation
+     * @return A copy of the evaluation context
+     */
+    public EvaluationContext shallowCopyWithoutInheritanceChain(Template self) {
+        EvaluationContext result = new EvaluationContext(self, strictVariables, locale, extensionRegistry, executorService, imported, scopeChain, null);
+        return result;
+    }
+
+    /**
+     * Makes a "snapshot" of the evaluation context. The scopeChain object will
+     * be a deep copy and the imported templates will be a new list. This is
+     * used for the "parallel" tag.
+     *
+     * @param self The template implementation
+     * @return A copy of the evaluation context
+     */
+    public EvaluationContext threadSafeCopy(Template self) {
+        EvaluationContext result = new EvaluationContext(self, strictVariables, locale, extensionRegistry, executorService, new ArrayList<>(imported), scopeChain.deepCopy(), hierarchy);
+        return result;
+    }
+
+    /**
+     * Returns whether or not this template is being evaluated in "strict
+     * templates" mode
+     *
+     * @return Whether or not this template is being evaluated in "strict
+     * tempaltes" mode.
+     */
+    public boolean isStrictVariables() {
+        return strictVariables;
+    }
+
+    /**
+     * Returns the locale
+     *
+     * @return The current locale
+     */
+    public Locale getLocale() {
+        return locale;
+    }
+
+    /**
+     * Returns the extension registry used to access all of the
+     * tests/filters/functions
+     *
+     * @return The extension registry
+     */
+    public ExtensionRegistry getExtensionRegistry() {
+        return extensionRegistry;
+    }
+
+    /**
+     * Returns the executor service if exists or null
+     *
+     * @return The executor service if exists, or null
+     */
+    public ExecutorService getExecutorService() {
+        return executorService;
+    }
+
+    /**
+     * Returns a list of imported Templates.
+     *
+     * @return A list of imported Templates.
+     */
+    public List<Template> getImported() {
+        return this.imported;
+    }
+    
+    /**
+     * Returns the scope chain data structure that allows variables to be
+     * added/removed from the current scope and retrieved from the nearest
+     * visible scopes.
+     *
+     * @return The scope chain.
+     */
+    public ScopeChain getScopeChain() {
+        return scopeChain;
+    }
+
+    /**
+     * Returns the data structure representing the entire hierarchy of the
+     * template currently being evaluated.
+     *
+     * @return The inheritance chain
+     */
+    public Hierarchy getHierarchy() {
+        return hierarchy;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/expression/BinaryExpression.java b/src/main/java/component/expressionLanguage/expression/BinaryExpression.java
new file mode 100644
index 0000000..7dd3f6d
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/expression/BinaryExpression.java
@@ -0,0 +1,24 @@
+package component.expressionLanguage.expression;
+
+public abstract class BinaryExpression<T> implements Expression<T> {
+
+    private Expression<?> leftExpression;
+
+    private Expression<?> rightExpression;
+
+    public void setLeftExpression(Expression<?> left) {
+        this.leftExpression = left;
+    }
+
+    public void setRightExpression(Expression<?> right) {
+        this.rightExpression = right;
+    }
+
+    public Expression<?> getLeftExpression() {
+        return leftExpression;
+    }
+
+    public Expression<?> getRightExpression() {
+        return rightExpression;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/expression/Expression.java b/src/main/java/component/expressionLanguage/expression/Expression.java
new file mode 100644
index 0000000..65fc4d9
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/expression/Expression.java
@@ -0,0 +1,9 @@
+package component.expressionLanguage.expression;
+
+import component.expressionLanguage.EvaluationContext;
+
+@FunctionalInterface
+public interface Expression<T> {
+
+    T evaluate(EvaluationContext context);
+}
diff --git a/src/main/java/component/expressionLanguage/expression/UnaryExpression.java b/src/main/java/component/expressionLanguage/expression/UnaryExpression.java
new file mode 100644
index 0000000..7df0de1
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/expression/UnaryExpression.java
@@ -0,0 +1,14 @@
+package component.expressionLanguage.expression;
+
+public abstract class UnaryExpression implements Expression<Object> {
+
+    private Expression<?> childExpression;
+
+    public Expression<?> getChildExpression() {
+        return childExpression;
+    }
+
+    public void setChildExpression(Expression<?> childExpression) {
+        this.childExpression = childExpression;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/expression/parser/ExpressionParser.java b/src/main/java/component/expressionLanguage/expression/parser/ExpressionParser.java
new file mode 100644
index 0000000..54f30ae
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/expression/parser/ExpressionParser.java
@@ -0,0 +1,569 @@
+package component.expressionLanguage.expression.parser;
+
+import component.expressionLanguage.expression.*;
+import component.expressionLanguage.extension.core.expression.*;
+import component.expressionLanguage.model.tree.*;
+import component.expressionLanguage.operator.*;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import jdk.nashorn.internal.runtime.ParserException;
+
+/**
+ * Parses expressions.
+ */
+public class ExpressionParser {
+
+    private static final Set<String> RESERVED_KEYWORDS = new HashSet<>(Arrays.asList("true", "false", "null", "none"));
+
+    private final TokenStreamParser parser;
+
+    private TokenStream stream;
+
+    private final Map<String, Operator> operators;
+
+    /**
+     * Constructor
+     *
+     * @param parser A reference to the main parser
+     * @param operators All the operators
+     */
+    public ExpressionParser(TokenStreamParser parser, Map<String, Operator> operators) {
+        this.parser = parser;
+        this.operators = operators;
+    }
+
+    /**
+     * The public entry point for parsing an expression.
+     *
+     * @return NodeExpression the expression that has been parsed.
+     */
+    public Expression<?> parseExpression() {
+        return parseExpression(0);
+    }
+
+    /**
+     * A private entry point for parsing an expression. This method takes in the
+     * precedence required to operate a "precedence climbing" parsing algorithm.
+     * It is a recursive method.
+     *
+     * @see http://en.wikipedia.org/wiki/Operator-precedence_parser
+     *
+     * @return The NodeExpression representing the parsed expression.
+     * @throws ParserException Thrown if a parsing error occurs.
+     */
+    private Expression<?> parseExpression(int minPrecedence) {
+
+        this.stream = parser.getStream();
+        Token token = stream.current();
+        Expression<?> expression = null;
+
+        /*
+         * The first check is to see if the expression begins with a unary
+         * operator, or an opening bracket, or neither.
+         */
+        if (isUnary(token)) {
+            Operator operator = this.operators.get(token.getValue());
+            stream.next();
+            expression = parseExpression(operator.getPrecedence());
+
+            UnaryExpression unaryExpression = null;
+            Class<? extends Expression<?>> operatorExpression = operator.getExpression();
+            try {
+                unaryExpression = (UnaryExpression) operatorExpression.newInstance();
+//                unaryExpression.setLineNumber(stream.current().getLineNumber());
+            } catch (InstantiationException | IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
+            unaryExpression.setChildExpression(expression);
+
+            expression = unaryExpression;
+
+        } else if (token.isA(Type.PUNCTUATION, "(")) {
+
+            stream.next();
+            expression = parseExpression();
+            stream.expect(Type.PUNCTUATION, ")");
+            expression = parsePostfixExpression(expression);
+
+        }  else if (token.isA(Type.PUNCTUATION, "[")) { // array definition syntax
+
+            // preserve [ token for array parsing
+            expression = parseArrayDefinitionExpression();
+            // don't expect ], because it has been already expected
+            // currently, postfix expressions are not supported for arrays
+            // expression = parsePostfixExpression(expression);
+        }  else if (token.isA(Type.PUNCTUATION, "{")) { // map definition syntax
+
+            // preserve { token for map parsing
+            expression = parseMapDefinitionExpression();
+            // don't expect }, because it has been already expected
+            // currently, postfix expressions are not supported for maps
+            // expression = parsePostfixExpression(expression);
+
+        } else {
+            /*
+             * starts with neither. Let's parse out the first expression that we
+             * can find. There may be one, there may be many (separated by
+             * binary operators); right now we are just looking for the first.
+             */
+            expression = subparseExpression();
+        }
+
+        /*
+         * If, after parsing the first expression we encounter a binary operator
+         * then we know we have another expression on the other side of the
+         * operator that requires parsing. Otherwise we're done.
+         */
+        token = stream.current();
+        while (isBinary(token) && operators.get(token.getValue()).getPrecedence() >= minPrecedence) {
+
+            // find out which operator we are dealing with and then skip over it
+            Operator operator = operators.get(token.getValue());
+            stream.next();
+
+            Expression<?> expressionRight = null;
+
+            // the right hand expression of the FILTER operator is handled in a
+            // unique way
+            if (FilterExpression.class.equals(operator.getExpression())) {
+                expressionRight = parseFilterInvocationExpression();
+            }  else if (PositiveTestExpression.class.equals(operator.getExpression())
+                    || NegativeTestExpression.class.equals(operator.getExpression())) {
+                // the right hand expression of TEST operators is handled in a
+                // unique way
+//                expressionRight = parseTestInvocationExpression();
+            } else {
+                /*
+                 * parse the expression on the right hand side of the operator
+                 * while maintaining proper associativity and precedence
+                 */
+//                Associativity.LEFT.equals(operator.getAssociativity()) ? operator.getPrecedence() + 1 : operator.getPrecedence();
+                expressionRight = parseExpression(operator.getPrecedence());
+            }
+
+            /*
+             * we have to wrap the left and right side expressions into one
+             * final expression. The operator provides us with the type of
+             * expression we are creating.
+             */
+            BinaryExpression<?> finalExpression = null;
+            Class<? extends Expression<?>> operatorExpression = operator.getExpression();
+            try {
+                finalExpression = (BinaryExpression<?>) operatorExpression.newInstance();
+//                finalExpression.setLineNumber(stream.current().getPosition());
+            } catch (InstantiationException | IllegalAccessException e) {
+                String msg = String.format("Error instantiating operator node [%s] at %s.", operatorExpression.getName(), token.getPosition());
+                throw new IllegalStateException(msg);
+            }
+
+            finalExpression.setLeftExpression(expression);
+            finalExpression.setRightExpression(expressionRight);
+
+            expression = finalExpression;
+
+            token = stream.current();
+        }
+
+        if (minPrecedence == 0) {
+            return parseTernaryExpression(expression);
+        }
+
+        return expression;
+    }
+
+    /**
+     * Checks if a token is a unary operator.
+     *
+     * @param token The token that we are checking
+     * @return boolean Whether the token is a unary operator or not
+     */
+    private boolean isUnary(Token token) {
+        return token.isA(Type.OPERATOR) && this.operators.containsKey(token.getValue()) && (this.operators.get(token.getValue()) instanceof UnaryOperator);
+    }
+
+    /**
+     * Checks if a token is a binary operator.
+     *
+     * @param token The token that we are checking
+     * @return boolean Whether the token is a binary operator or not
+     */
+    private boolean isBinary(Token token) {
+        return token.isA(Type.OPERATOR) && this.operators.containsKey(token.getValue()) && (this.operators.get(token.getValue()) instanceof BinaryOperator);
+    }
+
+    /**
+     * Finds and returns the next "simple" expression; an expression of which
+     * can be found on either side of a binary operator but does not contain a
+     * binary operator. Ex. "var.field", "true", "12", etc.
+     *
+     * @return NodeExpression The expression that it found.
+     * @throws Exception Thrown if a parsing error occurs.
+     */
+    private Expression<?> subparseExpression() {
+        final Token token = stream.current();
+        Expression<?> node = null;
+
+        switch (token.getType()) {
+
+            case NAME:
+                switch (token.getValue()) {
+
+                    // a constant?
+                    case "true":
+                    case "TRUE":
+                        node = new LiteralBooleanExpression(true);
+                        break;
+                    case "false":
+                    case "FALSE":
+                        node = new LiteralBooleanExpression(false);
+                        break;
+                    case "none":
+                    case "NONE":
+                    case "null":
+                    case "NULL":
+                        node = new LiteralNullExpression();
+                        break;
+
+                    default:
+
+                        // name of a function?
+                        if (stream.peek().isA(Type.PUNCTUATION, "(")) {
+                            node = new FunctionOrMacroNameNode(stream.peek().getPosition(), token.getValue());
+                        } // variable name
+                        else {
+                            node = new ContextVariableExpression(token.getValue());
+                        }
+                        break;
+                }
+                break;
+
+            case NUMBER:
+                final String numberValue = token.getValue();
+                if (numberValue.contains(".")) {
+                    node = new LiteralDoubleExpression(Double.valueOf(numberValue));
+                } else {
+                    node = new LiteralLongExpression(Long.valueOf(numberValue));
+                }
+
+                break;
+
+            case STRING:
+                node = new LiteralStringExpression(token.getValue());
+                break;
+
+            // not found, syntax error
+            default:
+                String msg = String.format("Unexpected token \"%s\" of value \"%s\" at line %s in file %s.", token.getType()
+                        .toString(), token.getValue(), token.getPosition(), stream.getFilename());
+                throw new IllegalStateException(msg);
+        }
+
+        // there may or may not be more to this expression - let's keep looking
+        stream.next();
+        return parsePostfixExpression(node);
+    }
+
+    private Expression<?> parseTernaryExpression(Expression<?> expression) {
+        // if the next token isn't a ?, we're not dealing with a ternary expression
+        if (!stream.current().isA(Type.PUNCTUATION, "?")) {
+            return expression;
+        }
+
+        stream.next();
+        Expression<?> expression2 = parseExpression();
+        stream.expect(Type.PUNCTUATION, ":");
+        Expression<?> expression3 = parseExpression();
+
+        expression = new TernaryExpression((Expression<Boolean>) expression, expression2, expression3, stream.getFilename());
+        return expression;
+    }
+
+    /**
+     * Determines if there is more to the provided expression than we originally
+     * thought. We will look for the filter operator or perhaps we are getting
+     * an attribute from a variable (ex. var.attribute or var['attribute'] or
+     * var.attribute(bar)).
+     *
+     * @param node The expression that we have already discovered
+     * @return Either the original expression that was passed in or a slightly
+     * modified version of it, depending on what was discovered.
+     */
+    private Expression<?> parsePostfixExpression(Expression<?> node) {
+        Token current;
+        while (true) {
+            current = stream.current();
+
+            if (current.isA(Type.PUNCTUATION, ".") || current.isA(Type.PUNCTUATION, "[")) {
+
+                // a period represents getting an attribute from a variable or
+                // calling a method
+                node = parseBeanAttributeExpression(node);
+
+            } else if (current.isA(Type.PUNCTUATION, "(")) {
+
+                // function call
+                node = parseFunctionOrMacroInvocation(node);
+
+            } else {
+                break;
+            }
+        }
+        return node;
+    }
+
+    private Expression<?> parseFunctionOrMacroInvocation(Expression<?> node) {
+        String functionName = ((FunctionOrMacroNameNode) node).getName();
+        ArgumentsNode args = parseArguments();
+
+        /*
+         * The following core functions have their own Nodes and are rendered in
+         * unique ways for the sake of performance.
+         */
+        switch (functionName) {
+            case "parent":
+                return new ParentFunctionExpression(parser.peekBlockStack());
+            case "block":
+                return new BlockFunctionExpression(args);
+        }
+
+        return new FunctionOrMacroInvocationExpression(functionName, args);
+    }
+
+    public FilterInvocationExpression parseFilterInvocationExpression() {
+        TokenStream stream = parser.getStream();
+        Token filterToken = stream.expect(Type.NAME);
+
+        ArgumentsNode args = null;
+        if (stream.current().isA(Type.PUNCTUATION, "(")) {
+            args = this.parseArguments();
+        } else {
+//            args = new ArgumentsNode(filterToken.getPosition(), null, null);
+        }
+
+        return new FilterInvocationExpression(filterToken.getValue(), args);
+    }
+
+//    private Expression<?> parseTestInvocationExpression() {
+//        TokenStream stream = parser.getStream();
+//        Position position = stream.current().getPosition();
+//
+//        Token testToken = stream.expect(Type.NAME);
+//
+//        ArgumentsNode args = null;
+//        if (stream.current().isA(Type.PUNCTUATION, "(")) {
+//            args = this.parseArguments();
+//        } else {
+////            args = new ArgumentsNode(testToken.getPosition(), null, null);
+//        }
+//
+////        return new TestInvocationExpression(position, testToken.getValue(), args);
+//        return new TestInvocationExpression(position, testToken.getValue());
+//    }
+
+    /**
+     * A bean attribute expression can either be an expression getting an
+     * attribute from a variable in the context, or calling a method from a
+     * variable.
+     *
+     * Ex. foo.bar or foo['bar'] or foo.bar('baz')
+     *
+     * @param node The expression parsed so far
+     * @return NodeExpression The parsed subscript expression
+     */
+    private Expression<?> parseBeanAttributeExpression(Expression<?> node) {
+        TokenStream stream = parser.getStream();
+
+        if (stream.current().isA(Type.PUNCTUATION, ".")) {
+
+            // skip over the '.' token
+            stream.next();
+
+            Token token = stream.expect(Type.NAME);
+
+            ArgumentsNode args = null;
+            if (stream.current().isA(Type.PUNCTUATION, "(")) {
+                args = this.parseArguments();
+//                if (!args.getNamedArgs().isEmpty()) {
+//                    String msg = String.format("Can not use named arguments when calling a bean method at line %s in file %s.", stream.current().getPosition(), stream.getFilename());
+//                    throw new IllegalStateException(msg);
+//                }
+            }
+
+            node = new GetAttributeExpression(node, new LiteralStringExpression(token.getValue()), args,
+                    stream.getFilename());
+
+        } else if (stream.current().isA(Type.PUNCTUATION, "[")) {
+            // skip over opening '[' bracket
+            stream.next();
+
+            node = new GetAttributeExpression(node, parseExpression(), stream.getFilename());
+
+            // move past the closing ']' bracket
+            stream.expect(Type.PUNCTUATION, "]");
+        }
+
+        return node;
+    }
+
+    public ArgumentsNode parseArguments() {
+        return parseArguments(false);
+    }
+
+    public ArgumentsNode parseArguments(boolean isMacroDefinition) {
+
+        List<ArgumentNode> positionalArgs = new ArrayList<>();
+        List<NamedArgumentNode> namedArgs = new ArrayList<>();
+        this.stream = this.parser.getStream();
+
+        stream.expect(Type.PUNCTUATION, "(");
+
+        while (!stream.current().isA(Type.PUNCTUATION, ")")) {
+
+            String argumentName = null;
+            Expression<?> argumentValue = null;
+
+            if (!namedArgs.isEmpty() || !positionalArgs.isEmpty()) {
+                stream.expect(Type.PUNCTUATION, ",");
+            }
+
+            /*
+             * Most arguments consist of VALUES with optional NAMES but in the
+             * case of a macro definition the user is specifying NAMES with
+             * optional VALUES. Therefore the logic changes slightly.
+             */
+            if (isMacroDefinition) {
+                argumentName = parseNewVariableName();
+                if (stream.current().isA(Type.PUNCTUATION, "=")) {
+                    stream.expect(Type.PUNCTUATION, "=");
+                    argumentValue = parseExpression();
+                }
+            } else {
+                if (stream.peek().isA(Type.PUNCTUATION, "=")) {
+                    argumentName = parseNewVariableName();
+                    stream.expect(Type.PUNCTUATION, "=");
+                }
+                argumentValue = parseExpression();
+            }
+
+            if (argumentName == null) {
+                if (!namedArgs.isEmpty()) {
+                    String msg = String.format("Positional arguments must be declared before any named arguments at line %s in file %s.", stream.current()
+                            .getPosition(), stream.getFilename());
+                    throw new IllegalArgumentException(msg);
+                }
+                positionalArgs.add(new ArgumentNode(stream.current()
+                            .getPosition(), argumentValue));
+            } else {
+                namedArgs.add(new NamedArgumentNode(stream.current()
+                            .getPosition(), argumentName, argumentValue));
+            }
+
+        }
+
+        stream.expect(Type.PUNCTUATION, ")");
+
+//        return new ArgumentsNode(stream.current()
+//                            .getPosition(), positionalArgs, namedArgs);
+        return new ArgumentsNode(stream.current()
+                            .getPosition(), positionalArgs);
+    }
+
+    /**
+     * Parses a new variable that will need to be initialized in the Java code.
+     *
+     * This is used for the set tag, the for loop, and in named arguments.
+     *
+     * @return A variable name
+     */
+    public String parseNewVariableName() {
+
+        // set the stream because this function may be called externally (for
+        // and set token parsers)
+        this.stream = this.parser.getStream();
+        Token token = stream.current();
+        token.isA(Type.NAME);
+
+        if (RESERVED_KEYWORDS.contains(token.getValue())) {
+            String msg = String.format("Can not assign a value to %s at line %s in file %s.", token.getValue(), token.getPosition(), stream.getFilename());
+            throw new IllegalAccessError(msg);
+        }
+
+        stream.next();
+        return token.getValue();
+    }
+
+    private Expression<?> parseArrayDefinitionExpression() {
+        TokenStream stream = parser.getStream();
+
+        // expect the opening bracket and check for an empty array
+        stream.expect(Type.PUNCTUATION, "[");
+        if (stream.current().isA(Type.PUNCTUATION, "]")) {
+            stream.next();
+            return new ArrayExpression();
+        }
+
+        // there's at least one expression in the array
+        List<Expression<?>> elements = new ArrayList<>();
+        while (true) {
+            Expression<?> expr = parseExpression();
+            elements.add(expr);
+            if (stream.current().isA(Type.PUNCTUATION, "]")) {
+                // this seems to be the end of the array
+                break;
+            }
+            // expect the comma separator, until we either find a closing
+            // bracket or fail the expect
+            stream.expect(Type.PUNCTUATION, ",");
+        }
+
+        // expect the closing bracket
+        stream.expect(Type.PUNCTUATION, "]");
+
+        return new ArrayExpression(elements);
+    }
+
+    private Expression<?> parseMapDefinitionExpression() {
+        TokenStream stream = parser.getStream();
+
+        // expect the opening brace and check for an empty map
+        stream.expect(Type.PUNCTUATION, "{");
+        if (stream.current().isA(Type.PUNCTUATION, "}")) {
+            stream.next();
+            return new MapExpression();
+        }
+
+        // there's at least one expression in the map
+        Map<Expression<?>, Expression<?>> elements = new HashMap<>();
+        while (true) {
+            // key : value
+            Expression<?> keyExpr = parseExpression();
+            stream.expect(Type.PUNCTUATION, ":");
+            Expression<?> valueExpr = parseExpression();
+            elements.put(keyExpr, valueExpr);
+            if (stream.current().isA(Type.PUNCTUATION, "}")) {
+                // this seems to be the end of the map
+                break;
+            }
+            // expect the comma separator, until we either find a closing brace
+            // or fail the expect
+            stream.expect(Type.PUNCTUATION, ",");
+        }
+
+        // expect the closing brace
+        stream.expect(Type.PUNCTUATION, "}");
+
+        return new MapExpression(elements);
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/Extension.java b/src/main/java/component/expressionLanguage/extension/Extension.java
new file mode 100644
index 0000000..6b9b735
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/Extension.java
@@ -0,0 +1,74 @@
+package component.expressionLanguage.extension;
+
+import component.expressionLanguage.filter.Filter;
+import component.expressionLanguage.function.Function;
+import component.expressionLanguage.model.visitor.NodeVisitor;
+import component.expressionLanguage.operator.Operator;
+import component.expressionLanguage.test.Test;
+import component.expressionLanguage.token.parser.TokenParser;
+import java.util.List;
+import java.util.Map;
+
+public interface Extension {
+
+    /**
+     * Use this method to provide custom filters.
+     *
+     * @return A list of filters. It is okay to return null.
+     */
+    default Map<String, Filter> getFilters() {
+        return null;
+    }
+
+    /**
+     * Use this method to provide custom tests.
+     *
+     * @return A list of tests. It is okay to return null.
+     */
+    default Map<String, Test> getTests(){
+        return null;
+    }
+
+    /**
+     * Use this method to provide custom functions.
+     *
+     * @return A list of functions. It is okay to return null.
+     */
+    default Map<String, Function> getFunctions(){
+        return null;
+    }
+
+    /**
+     * Use this method to provide custom tags.
+     *
+     * A TokenParser is used to parse a stream of tokens into Nodes which are
+     * then responsible for compiling themselves into Java.
+     *
+     * @return A list of TokenParsers. It is okay to return null.
+     */
+    default Map<String, TokenParser> getTokenParsers(){
+        return null;
+    }
+
+    default Map<String, Operator> getOperators(){
+        return null;
+    }
+
+    /**
+     * Use this method to provide variables available to all templates
+     *
+     * @return Map of global variables available to all templates
+     */
+    default Map<String, Object> getGlobalVariables(){
+        return null;
+    }
+
+    /**
+     * Node visitors will travel the AST tree during the compilation phase.
+     *
+     * @return a list of node visitors
+     */
+    default List<NodeVisitor> getVisitors(){
+        return null;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/ExtensionRegistry.java b/src/main/java/component/expressionLanguage/extension/ExtensionRegistry.java
new file mode 100644
index 0000000..4ac867b
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/ExtensionRegistry.java
@@ -0,0 +1,169 @@
+package component.expressionLanguage.extension;
+
+import component.expressionLanguage.filter.Filter;
+import component.expressionLanguage.function.Function;
+import component.expressionLanguage.model.visitor.NodeVisitor;
+import component.expressionLanguage.operator.Operator;
+import component.expressionLanguage.test.Test;
+import component.expressionLanguage.token.parser.TokenParser;
+import java.util.*;
+
+/**
+ * Storage for the extensions and the components retrieved from the various
+ * extensions.
+ */
+public class ExtensionRegistry {
+
+    /**
+     * Extensions
+     */
+    private final Collection<Extension> extensions = new ArrayList();
+    
+    /**
+     * Operators used during the lexing phase.
+     */
+    private Map<String, Operator> operators;
+
+    /**
+     * Token parsers used during the parsing phase.
+     */
+    private Map<String, TokenParser> tokenParsers = new HashMap<>();
+
+    /**
+     * Visitors available during the parsing phase.
+     */
+    private final List<NodeVisitor> visitors = new ArrayList<>();
+
+    /**
+     * Filters used during the evaluation phase.
+     */
+    private final Map<String, Filter> filters = new HashMap<>();
+
+    /**
+     * Tests used during the evaluation phase.
+     */
+    private final Map<String, Test> tests = new HashMap<>();
+
+    /**
+     * Functions used during the evaluation phase.
+     */
+    private final Map<String, Function> functions = new HashMap<>();
+
+    /**
+     * Global variables available during the evaluation phase.
+     */
+    private final Map<String, Object> globalVariables = new HashMap<>();
+    
+    public ExtensionRegistry() {
+    }
+    
+    public ExtensionRegistry(Collection<Extension> extensions) {
+        addExtensions(extensions);
+    }
+    
+    private void addExtensions(Collection<Extension> extensions) {
+        extensions.forEach(this::addExtension);
+    }
+    
+    private void addExtension(Extension extension) {
+        
+        // filters
+        Map<String, Filter> efilters = extension.getFilters();
+        if (efilters != null) {
+            this.filters.putAll(efilters);
+        }
+        // tests
+        Map<String, Test> etests = extension.getTests();
+        if (etests != null) {
+            this.tests.putAll(etests);
+        }
+        // tests
+        Map<String, Function> efunctions = extension.getFunctions();
+        if (efunctions != null) {
+            this.functions.putAll(efunctions);
+        }
+        // global variables
+        Map<String, Object> eglobalVariables = extension.getGlobalVariables();
+        if (eglobalVariables != null) {
+            this.globalVariables.putAll(eglobalVariables);
+        }
+        
+        List<NodeVisitor> visitors = extension.getVisitors();
+        
+        if (visitors != null) {
+            this.visitors.addAll(visitors);
+        }
+        
+        this.extensions.add(extension);
+    }
+
+    public Filter getFilter(String name) {
+        return this.filters.get(name);
+    }
+
+    public Test getTest(String name) {
+        return this.tests.get(name);
+    }
+
+    public Function getFunction(String name) {
+        return this.functions.get(name);
+    }
+
+    public Map<String, Operator> getOperators() {
+        if (this.operators == null) {
+            this.operators = new HashMap<>();
+        }
+
+        this.extensions.stream()
+                .map((extension) -> extension.getOperators())
+                .forEach(this.operators::putAll);
+
+        return operators;
+    }
+
+    public List<NodeVisitor> getVisitors() {
+        return this.visitors;
+    }
+
+    public Map<String, Object> getGlobalVariables() {
+        return this.globalVariables;
+    }
+
+    public Map<String, TokenParser> getTokenParsers() {
+        if (this.tokenParsers == null) {
+            this.tokenParsers = new HashMap<>();
+        }
+
+        this.extensions.stream()
+                .map((extension) -> extension.getTokenParsers())
+                .forEach(this.tokenParsers::putAll);
+
+        return tokenParsers;
+    }
+    
+    public static ExtensionRegistryBuilder builder() {
+        return new ExtensionRegistryBuilder();
+    }
+    
+    public static class ExtensionRegistryBuilder {
+        
+        private Collection<Extension> extensions = new ArrayList<>();
+        
+        public ExtensionRegistryBuilder with(Extension extension) {
+            this.extensions.add(extension);
+            return this;
+        }
+        
+        public ExtensionRegistryBuilder and(Extension extension) {
+            return with(extension);
+        }
+        
+        public ExtensionRegistry build() {
+            ExtensionRegistry registry = new ExtensionRegistry();
+            
+            registry.addExtensions(extensions);
+            
+            return registry;
+        }
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/CoreExtension.java b/src/main/java/component/expressionLanguage/extension/core/CoreExtension.java
new file mode 100644
index 0000000..f66fba5
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/CoreExtension.java
@@ -0,0 +1,155 @@
+package component.expressionLanguage.extension.core;
+
+import component.expressionLanguage.extension.core.test.IterableTest;
+import component.expressionLanguage.extension.core.function.RangeFunction;
+import component.expressionLanguage.extension.core.function.MinFunction;
+import component.expressionLanguage.extension.core.function.MaxFunction;
+import component.expressionLanguage.extension.Extension;
+import component.expressionLanguage.extension.core.expression.*;
+import component.expressionLanguage.extension.core.filter.*;
+import component.expressionLanguage.extension.core.token.*;
+import component.expressionLanguage.filter.Filter;
+import component.expressionLanguage.function.Function;
+import component.expressionLanguage.model.visitor.NodeVisitor;
+import component.expressionLanguage.operator.Associativity;
+import component.expressionLanguage.operator.BinaryOperator;
+import component.expressionLanguage.operator.Operator;
+import component.expressionLanguage.operator.UnaryOperator;
+import component.expressionLanguage.test.Test;
+import component.expressionLanguage.token.parser.TokenParser;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+public class CoreExtension implements Extension {
+
+    @Override
+    public Map<String, TokenParser> getTokenParsers() {
+        ArrayList<TokenParser> parsers = new ArrayList<>();
+        parsers.add(new BlockTokenParser());
+        parsers.add(new ExtendsTokenParser());
+        parsers.add(new FilterTokenParser());
+        parsers.add(new FlushTokenParser());
+        parsers.add(new ForTokenParser());
+        parsers.add(new IfTokenParser());
+        parsers.add(new ImportTokenParser());
+        parsers.add(new IncludeTokenParser());
+        parsers.add(new MacroTokenParser());
+        parsers.add(new ParallelTokenParser());
+        parsers.add(new SetTokenParser());
+        return parsers.stream().collect(Collectors.toMap(TokenParser::getTag, a -> a));
+    }
+
+//    @Override
+    public Map<String, UnaryOperator> getUnaryOperators() {
+        Map<String, UnaryOperator> operators = new HashMap<>();
+        operators.put("not", new UnaryOperator(5, UnaryNotExpression.class));
+        operators.put("+", new UnaryOperator(500, UnaryPlusExpression.class));
+        operators.put("-", new UnaryOperator(500, UnaryMinusExpression.class));
+        return operators;
+    }
+
+//    @Override
+    public Map<String, BinaryOperator> getBinaryOperators() {
+        Map<String, BinaryOperator> operators = new HashMap<>();
+        operators.put("or", new BinaryOperator(10, OrExpression.class, Associativity.LEFT));
+        operators.put("and", new BinaryOperator(15, AndExpression.class, Associativity.LEFT));
+        operators.put("is", new BinaryOperator(20, PositiveTestExpression.class, Associativity.LEFT));
+        operators.put("is not", new BinaryOperator(20, NegativeTestExpression.class, Associativity.LEFT));
+        operators.put("contains", new BinaryOperator(20, ContainsExpression.class, Associativity.LEFT));
+        operators.put("==", new BinaryOperator(30, EqualsExpression.class, Associativity.LEFT));
+        operators.put("equals", new BinaryOperator(30, EqualsExpression.class, Associativity.LEFT));
+        operators.put("!=", new BinaryOperator(30, NotEqualsExpression.class, Associativity.LEFT));
+        operators.put(">", new BinaryOperator(30, GreaterThanExpression.class, Associativity.LEFT));
+        operators.put("<", new BinaryOperator(30, LessThanExpression.class, Associativity.LEFT));
+        operators.put(">=", new BinaryOperator(30, GreaterThanEqualsExpression.class, Associativity.LEFT));
+        operators.put("<=", new BinaryOperator(30, LessThanEqualsExpression.class, Associativity.LEFT));
+        operators.put("+", new BinaryOperator(40, AddExpression.class, Associativity.LEFT));
+        operators.put("-", new BinaryOperator(40, SubtractExpression.class, Associativity.LEFT));
+        operators.put("*", new BinaryOperator(60, MultiplyExpression.class, Associativity.LEFT));
+        operators.put("/", new BinaryOperator(60, DivideExpression.class, Associativity.LEFT));
+        operators.put("%", new BinaryOperator(60, ModulusExpression.class, Associativity.LEFT));
+        operators.put("|", new BinaryOperator(100, FilterExpression.class, Associativity.LEFT));
+        operators.put("~", new BinaryOperator(110, ConcatenateExpression.class, Associativity.LEFT));
+        operators.put("..", new BinaryOperator(120, RangeExpression.class, Associativity.LEFT));
+
+        return operators;
+    }
+    
+    @Override
+    public Map<String, Operator> getOperators() {
+        Map<String, Operator> operators = new HashMap<>();
+        
+        operators.putAll(getUnaryOperators());
+        operators.putAll(getBinaryOperators());
+        
+        return operators;
+    }
+
+    @Override
+    public Map<String, Filter> getFilters() {
+        Map<String, Filter> filters = new HashMap<>();
+        filters.put("abbreviate", new AbbreviateFilter());
+        filters.put("abs", new AbsFilter());
+        filters.put("capitalize", new CapitalizeFilter());
+        filters.put("date", new DateFilter());
+        filters.put("default", new DefaultFilter());
+        filters.put("first", new FirstFilter());
+        filters.put("join", new JoinFilter());
+        filters.put("last", new LastFilter());
+        filters.put("lower", new LowerFilter());
+        filters.put("numberformat", new NumberFormatFilter());
+        filters.put("slice", new SliceFilter());
+        filters.put("sort", new SortFilter());
+        filters.put("rsort", new RsortFilter());
+        filters.put("title", new TitleFilter());
+        filters.put("trim", new TrimFilter());
+        filters.put("upper", new UpperFilter());
+        filters.put("urlencode", new UrlEncoderFilter());
+        filters.put("length", new LengthFilter());
+        filters.put(ReplaceFilter.FILTER_NAME, new ReplaceFilter());
+        filters.put(MergeFilter.FILTER_NAME, new MergeFilter());
+        return filters;
+    }
+
+    @Override
+    public Map<String, Test> getTests() {
+        Map<String, Test> tests = new HashMap<>();
+//        tests.put("empty", new EmptyTest());
+//        tests.put("even", new EvenTest());
+        tests.put("iterable", new IterableTest());
+//        tests.put("map", new MapTest());
+//        tests.put("null", new NullTest());
+//        tests.put("odd", new OddTest());
+//        tests.put("defined", new DefinedTest());
+        return tests;
+    }
+
+    @Override
+    public Map<String, Function> getFunctions() {
+        Map<String, Function> functions = new HashMap<>();
+
+        /*
+         * For efficiency purposes, some core functions are individually parsed
+         * by our expression parser and compiled in their own unique way. This
+         * includes the block and parent functions.
+         */
+
+        functions.put("max", new MaxFunction());
+        functions.put("min", new MinFunction());
+        functions.put(RangeFunction.FUNCTION_NAME, new RangeFunction());
+        return functions;
+    }
+
+    @Override
+    public List<NodeVisitor> getVisitors() {
+        List<NodeVisitor> visitors = new ArrayList<>();
+        visitors.add((node) -> {
+            System.out.println(node);
+        });
+        return visitors;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/AddExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/AddExpression.java
new file mode 100644
index 0000000..dac8d52
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/AddExpression.java
@@ -0,0 +1,13 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.operator.OperatorUtils;
+
+public class AddExpression extends BinaryExpression<Object> {
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        return OperatorUtils.add(getLeftExpression().evaluate(context), getRightExpression().evaluate(context));
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/AndExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/AndExpression.java
new file mode 100644
index 0000000..ffcb6a2
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/AndExpression.java
@@ -0,0 +1,15 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.expression.Expression;
+
+public class AndExpression extends BinaryExpression<Boolean> {
+
+    @Override
+    public Boolean evaluate(EvaluationContext context) {
+        Expression<Boolean> left = (Expression<Boolean>) getLeftExpression();
+        Expression<Boolean> right = (Expression<Boolean>) getRightExpression();
+        return left.evaluate(context) && right.evaluate(context);
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/ArrayExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/ArrayExpression.java
new file mode 100644
index 0000000..97fbc34
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/ArrayExpression.java
@@ -0,0 +1,39 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class ArrayExpression implements Expression<List<?>> {
+
+    private final List<Expression<?>> values;
+
+    public ArrayExpression() {
+        this.values = Collections.emptyList();
+    }
+
+    public ArrayExpression(List<Expression<?>> values) {
+        if (values == null) {
+            this.values = Collections.emptyList();
+        } else {
+            this.values = values;
+        }
+    }
+
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    @Override
+    public List<?> evaluate(EvaluationContext context) {
+        List<Object> returnValues = new ArrayList<>(values.size());
+        values.stream()
+            .map((expr) -> expr == null ? null : expr.evaluate(context))
+            .forEach(returnValues::add);
+        return returnValues;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/BlockFunctionExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/BlockFunctionExpression.java
new file mode 100644
index 0000000..d897656
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/BlockFunctionExpression.java
@@ -0,0 +1,34 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.tree.ArgumentsNode;
+
+public class BlockFunctionExpression implements Expression<String> {
+
+    private final Expression<?> blockNameExpression;
+
+    public BlockFunctionExpression(ArgumentsNode args) {
+        this.blockNameExpression = args.getArgs().get(0).getValue();
+    }
+
+    @Override
+    public String evaluate(EvaluationContext context) {
+//        Writer writer = new StringWriter();
+        String blockName = (String) blockNameExpression.evaluate(context);
+        return blockName;
+//        try {
+//            self.block(writer, context, blockName, false);
+//        } catch (Exception e) {
+//            String msg = String.format("Could not render block [%s] at line %s in file %s.", blockName, this.getLineNumber(), self.getName());
+//            throw new Exception(msg);
+//        }
+//        return writer.toString();
+    }
+
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/ConcatenateExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/ConcatenateExpression.java
new file mode 100644
index 0000000..e6a1212
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/ConcatenateExpression.java
@@ -0,0 +1,29 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+
+/**
+ * Expression which implements the string concatenation.
+ *
+ */
+public class ConcatenateExpression extends BinaryExpression<Object> {
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+
+        Object left = getLeftExpression().evaluate(context);
+        Object right = getRightExpression().evaluate(context);
+        
+        StringBuilder result = new StringBuilder();
+        if (left != null) {
+            result.append(left.toString());
+        }
+        if (right != null) {
+            result.append(right.toString());
+        }
+
+        return result.toString();
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/ContainsExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/ContainsExpression.java
new file mode 100644
index 0000000..5542037
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/ContainsExpression.java
@@ -0,0 +1,149 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import java.util.Collection;
+import java.util.Map;
+
+public class ContainsExpression extends BinaryExpression<Boolean> {
+
+    @Override
+    public Boolean evaluate(EvaluationContext context) {
+        Object leftValue = getLeftExpression().evaluate(context);
+
+        if (leftValue == null) {
+            return false;
+        }
+        Object rightValue = getRightExpression().evaluate(context);
+
+        if (leftValue instanceof Collection) {
+            if (rightValue instanceof Collection) {
+                return ((Collection) leftValue).containsAll((Collection) rightValue);
+            } else {
+                return ((Collection) leftValue).contains(rightValue);
+            }
+        } else if (leftValue instanceof Map) {
+            return ((Map) leftValue).containsKey(rightValue);
+        } else if (leftValue.getClass().isArray()) {
+            return arrayContains(leftValue, rightValue);
+        } else if (leftValue instanceof String) {
+            return String.valueOf(leftValue).contains(String.valueOf(rightValue));
+        } else {
+            throw new IllegalArgumentException(
+                    "Contains operator can only be used on Collections, Maps and arrays. Actual type was: "
+                            + leftValue.getClass().getName());
+        }
+    }
+
+    // FIXME is this right? does it make sense to support?
+    private static boolean arrayContains(Object input, Object value) {
+        if (input instanceof Object[]) {
+            return containsObject((Object[]) input, value);
+        } else if (input instanceof boolean[]) {
+            return containsBoolean((boolean[]) input, value);
+        } else if (input instanceof byte[]) {
+            return containsByte((byte[]) input, value);
+        } else if (input instanceof char[]) {
+            return containsChar((char[]) input, value);
+        } else if (input instanceof double[]) {
+            return containsDouble((double[]) input, value);
+        } else if (input instanceof float[]) {
+            return containsFloat((float[]) input, value);
+        } else if (input instanceof int[]) {
+            return containsInt((int[]) input, value);
+        } else if (input instanceof long[]) {
+            return containsLong((long[]) input, value);
+        } else {
+            return containsShort((short[]) input, value);
+        }
+    }
+
+    private static boolean containsObject(Object[] array, Object value) {
+        for (Object o : array) {
+            if (value == o || (value != null && value.equals(o)))
+                return true;
+        }
+        return false;
+    }
+
+    private static boolean containsBoolean(boolean[] array, Object value) {
+        if (!(value instanceof Boolean))
+            return false;
+        for (boolean b : array) {
+            if (b == ((Boolean) value))
+                return true;
+        }
+        return false;
+    }
+
+    private static boolean containsByte(byte[] array, Object value) {
+        if (!(value instanceof Byte))
+            return false;
+        for (byte b : array) {
+            if (b == ((Byte) value))
+                return true;
+        }
+        return false;
+    }
+
+    private static boolean containsChar(char[] array, Object value) {
+        if (!(value instanceof Character))
+            return false;
+        for (char c : array) {
+            if (c == ((Character) value))
+                return true;
+        }
+        return false;
+    }
+
+    private static boolean containsDouble(double[] array, Object value) {
+        if (!(value instanceof Double))
+            return false;
+        for (double d : array) {
+            if (d == ((Double) value))
+                return true;
+        }
+        return false;
+    }
+
+    private static boolean containsFloat(float[] array, Object value) {
+        if (!(value instanceof Float))
+            return false;
+        for (float f : array) {
+            if (f == ((Float) value))
+                return true;
+        }
+        return false;
+    }
+
+    private static boolean containsInt(int[] array, Object value) {
+        if (!(value instanceof Integer))
+            return false;
+        for (int i : array) {
+            if (i == ((Integer) value))
+                return true;
+        }
+        return false;
+    }
+
+    private static boolean containsLong(long[] array, Object value) {
+        if (!(value instanceof Long))
+            return false;
+        for (long l : array) {
+            if (l == ((Long) value))
+                return true;
+        }
+        return false;
+    }
+
+    private static boolean containsShort(short[] array, Object value) {
+        if (!(value instanceof Short))
+            return false;
+        for (short s : array) {
+            if (s == ((Short) value))
+                return true;
+        }
+        return false;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/ContextVariableExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/ContextVariableExpression.java
new file mode 100644
index 0000000..bdc8273
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/ContextVariableExpression.java
@@ -0,0 +1,30 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.scope.ScopeChain;
+
+public class ContextVariableExpression implements Expression<Object> {
+
+    protected final String name;
+
+    public ContextVariableExpression(String name) {
+        this.name = name;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        ScopeChain scopeChain = context.getScopeChain();
+        Object result = scopeChain.get(name);
+        if (result == null && context.isStrictVariables() && !scopeChain.containsKey(name)) {
+            String msg = String.format("Root attribute [%s] does not exist or can not be accessed and strict variables is set to true at line %s in file %s.", this.name);
+            throw new IllegalArgumentException(msg);
+        }
+        return result;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/DivideExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/DivideExpression.java
new file mode 100644
index 0000000..3420b90
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/DivideExpression.java
@@ -0,0 +1,14 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.operator.OperatorUtils;
+
+public class DivideExpression extends BinaryExpression<Object> {
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        return OperatorUtils.divide(getLeftExpression().evaluate(context),
+                getRightExpression().evaluate(context));
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/EqualsExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/EqualsExpression.java
new file mode 100644
index 0000000..8b3e321
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/EqualsExpression.java
@@ -0,0 +1,14 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.operator.OperatorUtils;
+
+public class EqualsExpression extends BinaryExpression<Boolean> {
+
+    @Override
+    public Boolean evaluate(EvaluationContext context) {
+        return OperatorUtils.equals(getLeftExpression().evaluate(context),
+                getRightExpression().evaluate(context));
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/FilterExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/FilterExpression.java
new file mode 100644
index 0000000..b811433
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/FilterExpression.java
@@ -0,0 +1,45 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.filter.Filter;
+import component.expressionLanguage.model.tree.ArgumentsNode;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+
+public class FilterExpression extends BinaryExpression<Object> {
+
+    /**
+     * Save the filter instance on the first evaluation.
+     */
+    private Filter filter = null;
+
+    public FilterExpression() {
+        super();
+    }
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+
+        FilterInvocationExpression filterInvocation = (FilterInvocationExpression) getRightExpression();
+        ArgumentsNode args = filterInvocation.getArgs();
+        String filterName = filterInvocation.getFilterName();
+
+        if (this.filter == null) {
+            this.filter = context.getExtensionRegistry().getFilter(filterInvocation.getFilterName());
+        }
+
+        if (filter == null) {
+            String msg = String.format("Filter [%s] does not exist at line %s in file %s.", filterName);
+            throw new IllegalStateException(msg);
+        }
+
+//        Map<String, Object> namedArguments = args.getArgumentMap(context, filter);
+        Map<String, Object> namedArguments = new HashMap<>();
+
+        Object input = getLeftExpression().evaluate(context);
+
+        return filter.apply(Objects.toString(input), namedArguments);
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/FilterInvocationExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/FilterInvocationExpression.java
new file mode 100644
index 0000000..31d4117
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/FilterInvocationExpression.java
@@ -0,0 +1,46 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.tree.ArgumentsNode;
+
+/**
+ * The right hand side to the filter expression.
+ *
+ */
+public class FilterInvocationExpression implements Expression<Object> {
+
+    private final String filterName;
+
+    private final ArgumentsNode args;
+    
+    public FilterInvocationExpression(String filterName, ArgumentsNode args) {
+        this.filterName = filterName;
+        this.args = args;
+    }
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        // see FilterExpression.java
+        throw new UnsupportedOperationException();
+    }
+
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    public ArgumentsNode getArgs() {
+        return args;
+    }
+
+    public String getFilterName() {
+        return filterName;
+    }
+
+//    @Override
+//    public int getLineNumber() {
+//        return this.lineNumber;
+//    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/FunctionOrMacroInvocationExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/FunctionOrMacroInvocationExpression.java
new file mode 100644
index 0000000..82e41d4
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/FunctionOrMacroInvocationExpression.java
@@ -0,0 +1,55 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.function.Function;
+import component.expressionLanguage.model.tree.ArgumentsNode;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
+public class  FunctionOrMacroInvocationExpression implements Expression<Object> {
+
+    private final String functionName;
+
+    private final ArgumentsNode args;
+
+    public FunctionOrMacroInvocationExpression(String functionName, ArgumentsNode arguments) {
+        this.functionName = functionName;
+        this.args = arguments;
+    }
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+//        return null;
+        Function function = context.getExtensionRegistry().getFunction(functionName);
+        if (function != null) {
+            return applyFunction(context, function, args);
+        }
+        return context.getHierarchy().get().macro(context, functionName, args, false);
+    }
+
+    private Object applyFunction(EvaluationContext context, Function function, ArgumentsNode args) {
+        List<Object> arguments = new ArrayList<>();
+
+        Collections.addAll(arguments, args);
+
+        Map<String, Object> namedArguments = args.getArgumentMap(context, function);
+        return function.evaluate(context, namedArguments);
+    }
+
+    public String getFunctionName() {
+        return functionName;
+    }
+
+    public ArgumentsNode getArguments() {
+        return args;
+    }
+
+//    @Override
+//    public int getLineNumber() {
+//        return this.lineNumber;
+//    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/GetAttributeExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/GetAttributeExpression.java
new file mode 100644
index 0000000..1486eda
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/GetAttributeExpression.java
@@ -0,0 +1,376 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.tree.ArgumentsNode;
+import component.expressionLanguage.model.tree.ArgumentNode;
+import java.lang.reflect.*;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Used to get an attribute from an object. It will look up attributes in the
+ * following order: map entry, array item, list item, get method, is method, has
+ * method, public method, public field.
+ *
+ */
+public class GetAttributeExpression implements Expression<Object> {
+
+    private final Expression<?> node;
+
+    private final Expression<?> attributeNameExpression;
+
+    private final ArgumentsNode args;
+
+    private final String filename;
+
+    /**
+     * Potentially cached on first evaluation.
+     */
+    private final ConcurrentHashMap<MemberCacheKey, Member> memberCache;
+
+    public GetAttributeExpression(Expression<?> node, Expression<?> attributeNameExpression, String filename) {
+        this(node, attributeNameExpression, null, filename);
+    }
+
+    public GetAttributeExpression(Expression<?> node, Expression<?> attributeNameExpression, ArgumentsNode args, String filename) {
+
+        this.node = node;
+        this.attributeNameExpression = attributeNameExpression;
+        this.args = args;
+        this.filename = filename;
+
+        /*
+         * I dont imagine that users will often give different types to the same
+         * template so we will give this cache a pretty small initial capacity.
+         */
+        this.memberCache = new ConcurrentHashMap<>(2, 0.9f, 1);
+    }
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        Object object = node.evaluate(context);
+        Object attributeNameValue = attributeNameExpression.evaluate(context);
+        String attributeName = String.valueOf(attributeNameValue);
+
+        Object result = null;
+
+        Object[] argumentValues = null;
+
+        Member member = object == null ? null : memberCache.get(new MemberCacheKey(object.getClass(), attributeName));
+
+        if (object != null && member == null) {
+
+            /*
+             * If, and only if, no arguments were provided does it make sense to
+             * check maps/arrays/lists
+             */
+            if (args == null) {
+
+                // first we check maps
+                if (object instanceof Map && ((Map<?, ?>) object).containsKey(attributeNameValue)) {
+                    return ((Map<?, ?>) object).get(attributeNameValue);
+                }
+
+                try {
+
+                    // then we check arrays
+                    if (object.getClass().isArray()) {
+                        int index = Integer.parseInt(attributeName);
+                        int length = Array.getLength(object);
+                        if (index < 0 || index >= length) {
+                            if (context.isStrictVariables()) {
+                                String msg = String.format("Index out of bounds while accessing array with strict variables on, on attribute %s in file %s.", attributeName, filename);
+                                throw new IndexOutOfBoundsException(msg);
+                            } else {
+                                return null;
+                            }
+                        }
+                        return Array.get(object, index);
+                    }
+
+                    // then lists
+                    if (object instanceof List) {
+
+                        @SuppressWarnings("unchecked")
+                        List<Object> list = (List<Object>) object;
+
+                        int index = Integer.parseInt(attributeName);
+                        int length = list.size();
+
+                        if (index < 0 || index >= length) {
+                            if (context.isStrictVariables()) {
+                                String msg = String.format("Index out of bounds while accessing array with strict variables on, on attribute %s in file %s.", attributeName, filename);
+                                throw new IndexOutOfBoundsException(msg);
+                            } else {
+                                return null;
+                            }
+                        }
+
+                        return list.get(index);
+                    }
+                } catch (NumberFormatException ex) {
+                    // do nothing
+                }
+
+            }
+
+            /*
+             * turn args into an array of types and an array of values in order
+             * to use them for our reflection calls
+             */
+            argumentValues = getArgumentValues(context);
+            Class<?>[] argumentTypes = new Class<?>[argumentValues.length];
+
+            for (int i = 0; i < argumentValues.length; i++) {
+                Object o = argumentValues[i];
+                if (o == null) {
+                    argumentTypes[i] = null;
+                } else {
+                    argumentTypes[i] = o.getClass();
+                }
+            }
+
+            member = reflect(object, attributeName, argumentTypes);
+            if (member != null) {
+                memberCache.put(new MemberCacheKey(object.getClass(), attributeName), member);
+            }
+
+        }
+
+        if (object != null && member != null) {
+            if (argumentValues == null) {
+                argumentValues = getArgumentValues(context);
+            }
+            result = invokeMember(object, member, argumentValues);
+        } else if (context.isStrictVariables()) {
+            if (object == null) {
+                if (node instanceof ContextVariableExpression) {
+                    final String rootPropertyName = ((ContextVariableExpression) node).getName();
+                    String msg = String.format("Root attribute [%s] does not exist or can not be accessed and strict variables is set to true at line %s in file %s.", rootPropertyName, this.filename);
+                    throw new IllegalStateException(msg);
+                }
+                
+                String msg = String.format("Attempt to get attribute of null object and strict variables is set to true at line %s in file %s.", attributeName, this.filename);
+                throw new NullPointerException(msg);
+
+            }
+            String msg = String.format("Attribute [%s] of [%s] does not exist or can not be accessed and strict variables is set to true at line %s in file %s.",attributeName, object.getClass().getName(), this.filename);
+            throw new IllegalStateException(msg);
+        }
+        return result;
+
+    }
+
+    /**
+     * Invoke the "Member" that was found via reflection.
+     *
+     * @param object
+     * @param member
+     * @param argumentValues
+     * @return
+     */
+    private Object invokeMember(Object object, Member member, Object[] argumentValues) {
+        Object result = null;
+        try {
+            if (member instanceof Method) {
+                result = ((Method) member).invoke(object, argumentValues);
+            } else if (member instanceof Field) {
+                result = ((Field) member).get(object);
+            }
+
+        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
+            throw new RuntimeException(e);
+        }
+        return result;
+    }
+
+    /**
+     * Fully evaluates the individual arguments.
+     *
+     * @param self
+     * @param context
+     * @return
+     */
+    private Object[] getArgumentValues(EvaluationContext context) {
+
+        Object[] argumentValues;
+
+        if (this.args == null) {
+            argumentValues = new Object[0];
+        } else {
+            List<ArgumentNode> args = this.args.getArgs();
+
+            argumentValues = new Object[args.size()];
+
+            int index = 0;
+            for (ArgumentNode arg : args) {
+                Object argumentValue = arg.getValue().evaluate(context);
+                argumentValues[index] = argumentValue;
+                index++;
+            }
+        }
+        return argumentValues;
+    }
+
+    /**
+     * Performs the actual reflection to obtain a "Member" from a class.
+     *
+     * @param object
+     * @param attributeName
+     * @param parameterTypes
+     * @return
+     */
+    private Member reflect(Object object, String attributeName, Class<?>[] parameterTypes) {
+
+        Class<?> clazz = object.getClass();
+
+        Member result = null;
+
+        // capitalize first letter of attribute for the following attempts
+        String attributeCapitalized = Character.toUpperCase(attributeName.charAt(0)) + attributeName.substring(1);
+
+        // check get method
+        result = findMethod(clazz, "get" + attributeCapitalized, parameterTypes);
+
+        // check is method
+        if (result == null) {
+            result = findMethod(clazz, "is" + attributeCapitalized, parameterTypes);
+        }
+
+        // check has method
+        if (result == null) {
+            result = findMethod(clazz, "has" + attributeCapitalized, parameterTypes);
+        }
+
+        // check if attribute is a public method
+        if (result == null) {
+            result = findMethod(clazz, attributeName, parameterTypes);
+        }
+
+        // public field
+        if (result == null) {
+            try {
+                result = clazz.getField(attributeName);
+            } catch (NoSuchFieldException | SecurityException e) {
+            }
+        }
+
+        if (result != null) {
+            ((AccessibleObject) result).setAccessible(true);
+        }
+
+        return result;
+    }
+
+    /**
+     * Finds an appropriate method by comparing if parameter types are
+     * compatible. This is more relaxed than class.getMethod.
+     *
+     * @param clazz
+     * @param name
+     * @param requiredTypes
+     * @return
+     */
+    private Method findMethod(Class<?> clazz, String name, Class<?>[] requiredTypes) {
+        Method result = null;
+
+        Method[] candidates = clazz.getMethods();
+
+        for (Method candidate : candidates) {
+            if (!candidate.getName().equalsIgnoreCase(name)) {
+                continue;
+            }
+
+            Class<?>[] types = candidate.getParameterTypes();
+
+            if (types.length != requiredTypes.length) {
+                continue;
+            }
+
+            boolean compatibleTypes = true;
+            for (int i = 0; i < types.length; i++) {
+                if (requiredTypes[i] != null && !widen(types[i]).isAssignableFrom(requiredTypes[i])) {
+                    compatibleTypes = false;
+                    break;
+                }
+            }
+
+            if (compatibleTypes) {
+                result = candidate;
+                break;
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Performs a widening conversion (primitive to boxed type)
+     *
+     * @param clazz
+     * @return
+     */
+    private Class<?> widen(Class<?> clazz) {
+        Class<?> result = clazz;
+        if (clazz == int.class) {
+            result = Integer.class;
+        } else if (clazz == long.class) {
+            result = Long.class;
+        } else if (clazz == double.class) {
+            result = Double.class;
+        } else if (clazz == float.class) {
+            result = Float.class;
+        } else if (clazz == short.class) {
+            result = Short.class;
+        } else if (clazz == byte.class) {
+            result = Byte.class;
+        } else if (clazz == boolean.class) {
+            result = Boolean.class;
+        }
+        return result;
+    }
+
+    private class MemberCacheKey {
+        private final Class<?> clazz;
+        private final String attributeName;
+
+        private MemberCacheKey(Class<?> clazz, String attributeName) {
+            this.clazz = clazz;
+            this.attributeName = attributeName;
+        }
+
+        @Override
+        public boolean equals(Object o) {
+            if (this == o) return true;
+            if (o == null || getClass() != o.getClass()) return false;
+
+            MemberCacheKey that = (MemberCacheKey) o;
+
+            if (!clazz.equals(that.clazz)) return false;
+            return attributeName.equals(that.attributeName);
+
+        }
+
+        @Override
+        public int hashCode() {
+            int result = clazz.hashCode();
+            result = 31 * result + attributeName.hashCode();
+            return result;
+        }
+    }
+
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    public Expression<?> getNode() {
+        return node;
+    }
+
+    public ArgumentsNode getArgumentsNode() {
+        return args;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/GreaterThanEqualsExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/GreaterThanEqualsExpression.java
new file mode 100644
index 0000000..7dadc72
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/GreaterThanEqualsExpression.java
@@ -0,0 +1,14 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.operator.OperatorUtils;
+
+public class GreaterThanEqualsExpression extends BinaryExpression<Boolean> {
+
+    @Override
+    public Boolean evaluate(EvaluationContext context) {
+        return OperatorUtils.gte(getLeftExpression().evaluate(context),
+                getRightExpression().evaluate(context));
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/GreaterThanExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/GreaterThanExpression.java
new file mode 100644
index 0000000..02038b8
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/GreaterThanExpression.java
@@ -0,0 +1,14 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.operator.OperatorUtils;
+
+public class GreaterThanExpression extends BinaryExpression<Boolean> {
+
+    @Override
+    public Boolean evaluate(EvaluationContext context) {
+        return OperatorUtils.gt(getLeftExpression().evaluate(context),
+                getRightExpression().evaluate(context));
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/LessThanEqualsExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/LessThanEqualsExpression.java
new file mode 100644
index 0000000..810543d
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/LessThanEqualsExpression.java
@@ -0,0 +1,14 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.operator.OperatorUtils;
+
+public class LessThanEqualsExpression extends BinaryExpression<Boolean> {
+
+    @Override
+    public Boolean evaluate(EvaluationContext context) {
+        return OperatorUtils.lte(getLeftExpression().evaluate(context),
+                getRightExpression().evaluate(context));
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/LessThanExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/LessThanExpression.java
new file mode 100644
index 0000000..a61b636
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/LessThanExpression.java
@@ -0,0 +1,14 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.operator.OperatorUtils;
+
+public class LessThanExpression extends BinaryExpression<Boolean> {
+
+    @Override
+    public Boolean evaluate(EvaluationContext context) {
+        return OperatorUtils.lt(getLeftExpression().evaluate(context),
+                getRightExpression().evaluate(context));
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/LiteralBooleanExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/LiteralBooleanExpression.java
new file mode 100644
index 0000000..140ac1d
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/LiteralBooleanExpression.java
@@ -0,0 +1,19 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+
+public class LiteralBooleanExpression implements Expression<Boolean> {
+
+    private final Boolean value;
+
+    public LiteralBooleanExpression(Boolean value) {
+        this.value = value;
+    }
+
+    @Override
+    public Boolean evaluate(EvaluationContext context) {
+        return value;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/LiteralDoubleExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/LiteralDoubleExpression.java
new file mode 100644
index 0000000..cd1d828
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/LiteralDoubleExpression.java
@@ -0,0 +1,19 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+
+public class LiteralDoubleExpression implements Expression<Double> {
+
+    private final Double value;
+
+    public LiteralDoubleExpression(Double value) {
+        this.value = value;
+    }
+    
+    @Override
+    public Double evaluate(EvaluationContext context) {
+        return value;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/LiteralLongExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/LiteralLongExpression.java
new file mode 100644
index 0000000..de95035
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/LiteralLongExpression.java
@@ -0,0 +1,19 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+
+public class LiteralLongExpression implements Expression<Long> {
+
+    private final Long value;
+
+    public LiteralLongExpression(Long value) {
+        this.value = value;
+    }
+
+    @Override
+    public Long evaluate(EvaluationContext context) {
+        return value;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/LiteralNullExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/LiteralNullExpression.java
new file mode 100644
index 0000000..ef772c1
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/LiteralNullExpression.java
@@ -0,0 +1,16 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+
+public class LiteralNullExpression implements Expression<Object> {
+
+    public LiteralNullExpression() {
+    }
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        return null;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/LiteralStringExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/LiteralStringExpression.java
new file mode 100644
index 0000000..1550bf8
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/LiteralStringExpression.java
@@ -0,0 +1,19 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+
+public class LiteralStringExpression implements Expression<String> {
+
+    private final String value;
+
+    public LiteralStringExpression(String value) {
+        this.value = value;
+    }
+
+    @Override
+    public String evaluate(EvaluationContext context) {
+        return value;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/MapExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/MapExpression.java
new file mode 100644
index 0000000..c7a3024
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/MapExpression.java
@@ -0,0 +1,41 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Map.Entry;
+
+public class MapExpression implements Expression<Map<?, ?>> {
+
+    // FIXME should keys be of any type?
+    private final Map<Expression<?>, Expression<?>> entries;
+
+    public MapExpression() {
+        this.entries = Collections.emptyMap();
+    }
+
+    public MapExpression(Map<Expression<?>, Expression<?>> entries) {
+        if (entries == null) {
+            this.entries = Collections.emptyMap();
+        } else {
+            this.entries = entries;
+        }
+    }
+
+    @Override
+    public Map<?, ?> evaluate(EvaluationContext context) {
+        Map<Object, Object> returnEntries = new HashMap<>(Long.valueOf(Math.round(Math.ceil(entries.size() / 0.75)))
+                .intValue());
+        entries.entrySet().stream().forEach((entry) -> {
+            Expression<?> keyExpr = entry.getKey();
+            Expression<?> valueExpr = entry.getValue();
+            Object key = keyExpr == null ? null : keyExpr.evaluate(context);
+            Object value = valueExpr == null ? null : valueExpr.evaluate(context);
+            returnEntries.put(key, value);
+        });
+        return returnEntries;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/ModulusExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/ModulusExpression.java
new file mode 100644
index 0000000..9ca8a21
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/ModulusExpression.java
@@ -0,0 +1,14 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.operator.OperatorUtils;
+
+public class ModulusExpression extends BinaryExpression<Object> {
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        return OperatorUtils.mod(getLeftExpression().evaluate(context),
+                getRightExpression().evaluate(context));
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/MultiplyExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/MultiplyExpression.java
new file mode 100644
index 0000000..9c81d31
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/MultiplyExpression.java
@@ -0,0 +1,14 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.operator.OperatorUtils;
+
+public class MultiplyExpression extends BinaryExpression<Object> {
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        return OperatorUtils.multiply(getLeftExpression().evaluate(context),
+                getRightExpression().evaluate(context));
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/NegativeTestExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/NegativeTestExpression.java
new file mode 100644
index 0000000..285ff40
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/NegativeTestExpression.java
@@ -0,0 +1,11 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+
+public class NegativeTestExpression extends PositiveTestExpression {
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        return !((Boolean) super.evaluate(context));
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/NotEqualsExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/NotEqualsExpression.java
new file mode 100644
index 0000000..3672e1e
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/NotEqualsExpression.java
@@ -0,0 +1,13 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.operator.OperatorUtils;
+
+public class NotEqualsExpression extends BinaryExpression<Boolean> {
+
+    @Override
+    public Boolean evaluate(EvaluationContext context) {
+        return !OperatorUtils.equals(getLeftExpression().evaluate(context), getRightExpression().evaluate(context));
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/OrExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/OrExpression.java
new file mode 100644
index 0000000..6d21ad7
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/OrExpression.java
@@ -0,0 +1,15 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.expression.Expression;
+
+public class OrExpression extends BinaryExpression<Boolean> {
+
+    @Override
+    public Boolean evaluate(EvaluationContext context) {
+        Expression<Boolean> left = (Expression<Boolean>) getLeftExpression();
+        Expression<Boolean> right = (Expression<Boolean>) getRightExpression();
+        return left.evaluate(context) || right.evaluate(context);
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/ParentFunctionExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/ParentFunctionExpression.java
new file mode 100644
index 0000000..0f1ac65
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/ParentFunctionExpression.java
@@ -0,0 +1,32 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.template.Hierarchy;
+import component.expressionLanguage.model.template.Template;
+
+public class ParentFunctionExpression implements Expression<Boolean> {
+
+    private final String blockName;
+
+    public ParentFunctionExpression(String blockName) {
+        this.blockName = blockName;
+    }
+
+    @Override
+    public Boolean evaluate(EvaluationContext context) {
+        Hierarchy hierarchy = context.getHierarchy();
+        if (hierarchy.getParent() == null) {
+            String msg = String.format("Can not use parent function if template does not extend another template");
+            throw new IllegalStateException(msg);
+        }
+        
+        Template parent = hierarchy.getParent();
+
+        hierarchy.ascend();
+        parent.block(context, blockName, true);
+        hierarchy.descend();
+        
+        return true;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/PositiveTestExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/PositiveTestExpression.java
new file mode 100644
index 0000000..ccc7404
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/PositiveTestExpression.java
@@ -0,0 +1,35 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.test.Test;
+
+public class PositiveTestExpression extends BinaryExpression<Object> {
+
+    private Test cachedTest;
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+
+        Expression testInvocation = getRightExpression();
+
+        if (cachedTest == null) {
+            String testName = testInvocation.getClass().getName();
+
+            cachedTest = context.getExtensionRegistry().getTest(testName);
+
+            if (cachedTest == null) {
+                String msg = String.format("Test [%s] does not exist at line %s.", testName);
+                throw new IllegalStateException(msg);
+            }
+        }
+        
+        Test test = cachedTest;
+
+        Object input = getLeftExpression().evaluate(context);
+        
+        return test.apply(input);
+
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/RangeExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/RangeExpression.java
new file mode 100644
index 0000000..63e5189
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/RangeExpression.java
@@ -0,0 +1,31 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.function.RangeFunction;
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.tree.ArgumentsNode;
+import component.expressionLanguage.model.tree.ArgumentNode;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Expression which implements the range function.
+ *
+ */
+public class RangeExpression extends BinaryExpression<Object> {
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        List<ArgumentNode> positionalArgs = new ArrayList<>();
+        positionalArgs.add(new ArgumentNode(null, getLeftExpression()));
+        positionalArgs.add(new ArgumentNode(null, getRightExpression()));
+//
+        ArgumentsNode arguments = new ArgumentsNode(null, positionalArgs);
+        FunctionOrMacroInvocationExpression function = new FunctionOrMacroInvocationExpression(
+                RangeFunction.FUNCTION_NAME, arguments);
+
+        return function.evaluate(context);
+    }
+
+}
\ No newline at end of file
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/RenderableNodeExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/RenderableNodeExpression.java
new file mode 100644
index 0000000..386a5d5
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/RenderableNodeExpression.java
@@ -0,0 +1,34 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.UnaryExpression;
+import component.expressionLanguage.model.tree.Node;
+
+/**
+ * This class wraps a {@link RenderableNode} into an expression. This is used by
+ * the filter TAG to apply a filter to large chunk of template which is
+ * contained within a renderable node.
+ *
+ */
+public class RenderableNodeExpression extends UnaryExpression {
+
+    private final Node node;
+
+    public RenderableNodeExpression(Node node) {
+        this.node = node;
+    }
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+//        Writer writer = new StringWriter();
+//        try {
+//            node.render(self, writer, context);
+//        } catch (IOException e) {
+//            String msg = String.format("Error occurred while rendering node at line %s in file %s.", this.getLineNumber(), self.getName());
+//            throw new Exception(msg);
+//        }
+//        return writer.toString();
+        return node;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/SubtractExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/SubtractExpression.java
new file mode 100644
index 0000000..250d321
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/SubtractExpression.java
@@ -0,0 +1,14 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.BinaryExpression;
+import component.expressionLanguage.operator.OperatorUtils;
+
+public class SubtractExpression extends BinaryExpression<Object> {
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        return OperatorUtils.subtract(getLeftExpression().evaluate(context),
+                getRightExpression().evaluate(context));
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/TernaryExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/TernaryExpression.java
new file mode 100644
index 0000000..416fedf
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/TernaryExpression.java
@@ -0,0 +1,53 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+
+public class TernaryExpression implements Expression<Object> {
+
+    private final Expression<Boolean> expression1;
+
+    private Expression<?> expression2;
+
+    private Expression<?> expression3;
+
+    public TernaryExpression(Expression<Boolean> expression1, Expression<?> expression2, Expression<?> expression3, String filename) {
+        this.expression1 = expression1;
+        this.expression2 = expression2;
+        this.expression3 = expression3;
+    }
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        if (expression1.evaluate(context) != null && expression1.evaluate(context)) {
+            return expression2.evaluate(context);
+        } else {
+            return expression3.evaluate(context);
+        }
+    }
+
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    public Expression<Boolean> getExpression1() {
+        return expression1;
+    }
+
+    public Expression<?> getExpression2() {
+        return expression2;
+    }
+
+    public Expression<?> getExpression3() {
+        return expression3;
+    }
+
+    public void setExpression3(Expression<?> expression3) {
+        this.expression3 = expression3;
+    }
+
+    public void setExpression2(Expression<?> expression2) {
+        this.expression2 = expression2;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/UnaryMinusExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/UnaryMinusExpression.java
new file mode 100644
index 0000000..0f5accb
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/UnaryMinusExpression.java
@@ -0,0 +1,14 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.UnaryExpression;
+import component.expressionLanguage.operator.OperatorUtils;
+
+public class UnaryMinusExpression extends UnaryExpression {
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        return OperatorUtils.unaryMinus(getChildExpression().evaluate(context));
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/UnaryNotExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/UnaryNotExpression.java
new file mode 100644
index 0000000..3ed8679
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/UnaryNotExpression.java
@@ -0,0 +1,14 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.UnaryExpression;
+
+public class UnaryNotExpression extends UnaryExpression {
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        Boolean result = (Boolean) getChildExpression().evaluate(context);
+        return !result;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/expression/UnaryPlusExpression.java b/src/main/java/component/expressionLanguage/extension/core/expression/UnaryPlusExpression.java
new file mode 100644
index 0000000..583fd86
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/expression/UnaryPlusExpression.java
@@ -0,0 +1,14 @@
+package component.expressionLanguage.extension.core.expression;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.UnaryExpression;
+import component.expressionLanguage.operator.OperatorUtils;
+
+public class UnaryPlusExpression extends UnaryExpression {
+
+    @Override
+    public Object evaluate(EvaluationContext context) {
+        return OperatorUtils.unaryPlus(getChildExpression().evaluate(context));
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/AbbreviateFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/AbbreviateFilter.java
new file mode 100644
index 0000000..0db06b1
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/AbbreviateFilter.java
@@ -0,0 +1,50 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.filter.Filter;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+public class AbbreviateFilter implements Filter {
+
+    private final List<String> argumentNames = new ArrayList<>();
+
+    public AbbreviateFilter() {
+        argumentNames.add("length");
+    }
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return argumentNames;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+        String value = (String) input;
+        int maxWidth = ((Long) args.get("length")).intValue();
+
+        if(maxWidth < 0){
+            throw new RuntimeException("Invalid argument to abbreviate filter; must be greater than zero");
+        }
+
+        String ellipsis = "...";
+        int length = value.length();
+
+        if (length < maxWidth) {
+            return value;
+        }
+        if (length <= 3) {
+            return value;
+        }
+        if(maxWidth <= 3){
+            return value.substring(0, maxWidth);
+        }
+        return value.substring(0, Math.max(0, maxWidth - 3)) + ellipsis;
+    }
+
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/AbsFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/AbsFilter.java
new file mode 100644
index 0000000..c5abaf4
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/AbsFilter.java
@@ -0,0 +1,26 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.util.List;
+import java.util.Map;
+
+public class AbsFilter implements Filter {
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    @Override
+    public Number apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            throw new IllegalArgumentException("Can not pass null value to \"abs\" filter.");
+        }
+        if (input instanceof Long) {
+            return Math.abs((Long) input);
+        } else {
+            return Math.abs((Double) input);
+        }
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/CapitalizeFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/CapitalizeFilter.java
new file mode 100644
index 0000000..dfce317
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/CapitalizeFilter.java
@@ -0,0 +1,45 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+
+public class CapitalizeFilter implements Filter {
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+        String value = (String) input;
+
+        if (value.length() == 0) {
+            return value;
+        }
+
+        StringBuilder result = new StringBuilder();
+
+        char[] chars = value.toCharArray();
+        for (int i = 0; i < chars.length; i++) {
+            char c = chars[i];
+
+            if (Character.isWhitespace(c)) {
+                result.append(c);
+            } else {
+                result.append(Character.toTitleCase(c));
+                result.append(Arrays.copyOfRange(chars, i + 1, chars.length));
+                break;
+            }
+        }
+
+        return result.toString();
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/DateFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/DateFilter.java
new file mode 100644
index 0000000..348aaa1
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/DateFilter.java
@@ -0,0 +1,52 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.filter.Filter;
+import java.text.DateFormat;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.*;
+
+public class DateFilter implements Filter {
+
+    private final List<String> argumentNames = new ArrayList<>();
+
+    public DateFilter() {
+        argumentNames.add("format");
+        argumentNames.add("existingFormat");
+    }
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return argumentNames;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+        Date date = null;
+
+        DateFormat existingFormat;
+        DateFormat intendedFormat;
+
+        EvaluationContext context = (EvaluationContext) args.get("_context");
+        Locale locale = context.getLocale();
+
+        intendedFormat = new SimpleDateFormat((String) args.get("format"), locale);
+
+        if (args.get("existingFormat") != null) {
+            existingFormat = new SimpleDateFormat((String) args.get("existingFormat"), locale);
+            try {
+                date = existingFormat.parse((String) input);
+            } catch (ParseException e) {
+                throw new RuntimeException("Could not parse date", e);
+            }
+        } else {
+            date = (Date) input;
+        }
+
+        return intendedFormat.format(date);
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/DefaultFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/DefaultFilter.java
new file mode 100644
index 0000000..e0b571d
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/DefaultFilter.java
@@ -0,0 +1,36 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.extension.core.test.EmptyTest;
+import component.expressionLanguage.filter.Filter;
+import component.expressionLanguage.test.Test;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class DefaultFilter implements Filter {
+
+    private final List<String> argumentNames = new ArrayList<>();
+
+    public DefaultFilter() {
+        argumentNames.add("default");
+    }
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return argumentNames;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+
+        Object defaultObj = args.get("default");
+
+        Test emptyTest = new EmptyTest();
+        if (emptyTest.apply(input)) {
+            return defaultObj;
+        }
+        return input;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/FirstFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/FirstFilter.java
new file mode 100644
index 0000000..c776219
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/FirstFilter.java
@@ -0,0 +1,39 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.lang.reflect.Array;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Returns the first element of a collection
+ * 
+ */
+public class FirstFilter implements Filter {
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+        
+        if(input instanceof String){
+            String inputString = (String)input;
+            return inputString.charAt(0);
+        }
+
+        if(input.getClass().isArray()) {
+            int length = Array.getLength(input);
+            return length > 0 ? Array.get(input, 0) : null;
+        }
+        
+        Collection<?> inputCollection = (Collection<?>) input;
+        return inputCollection.iterator().next();
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/JoinFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/JoinFilter.java
new file mode 100644
index 0000000..2b87ad8
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/JoinFilter.java
@@ -0,0 +1,55 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Concatenates all entries of a collection, optionally glued together with a
+ * particular character such as a comma.
+ * 
+ */
+public class JoinFilter implements Filter {
+
+    private final List<String> argumentNames = new ArrayList<>();
+
+    public JoinFilter() {
+        argumentNames.add("separator");
+    }
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return argumentNames;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+
+        @SuppressWarnings("unchecked")
+        Collection<Object> inputCollection = (Collection<Object>) input;
+
+        StringBuilder builder = new StringBuilder();
+
+        String glue = null;
+        if (args.containsKey("separator")) {
+            glue = (String) args.get("separator");
+        }
+
+        boolean isFirst = true;
+        for (Object entry : inputCollection) {
+
+            if (!isFirst && glue != null) {
+                builder.append(glue);
+            }
+            builder.append(entry);
+
+            isFirst = false;
+        }
+        return builder.toString();
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/LastFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/LastFilter.java
new file mode 100644
index 0000000..ca80b7d
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/LastFilter.java
@@ -0,0 +1,45 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.lang.reflect.Array;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Returns the last element of a collection
+ * 
+ */
+public class LastFilter implements Filter {
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+
+        if(input instanceof String){
+            String inputString = (String)input;
+            return inputString.charAt(inputString.length() - 1);
+        }
+
+        if(input.getClass().isArray()) {
+            int length = Array.getLength(input);
+            return length > 0 ? Array.get(input, length - 1) : null;
+        }
+        
+        Collection<Object> inputCollection = (Collection<Object>) input;
+        Object result = null;
+        Iterator<Object> iterator = inputCollection.iterator();
+        while(iterator.hasNext()){
+            result = iterator.next();
+        }
+        return result;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/LengthFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/LengthFilter.java
new file mode 100644
index 0000000..d68edb4
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/LengthFilter.java
@@ -0,0 +1,52 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.lang.reflect.Array;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+
+public class LengthFilter implements Filter {
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return 0;
+        }
+        if (input instanceof String) {
+            return ((String) input).length();
+        } else if (input instanceof Collection) {
+            return ((Collection<?>) input).size();
+        } else if (input.getClass().isArray()) {
+            return Array.getLength(input);
+        } else if (input instanceof Map) {
+            return ((Map<?, ?>) input).size();
+        } else if (input instanceof Iterable) {
+            Iterator<?> it = ((Iterable<?>) input).iterator();
+            int size = 0;
+            while (it.hasNext()) {
+                it.next();
+                size++;
+            }
+            return size;
+        } else if (input instanceof Iterator) {
+            Iterator<?> it = (Iterator<?>) input;
+            int size = 0;
+            while (it.hasNext()) {
+                it.next();
+                size++;
+            }
+            return size;
+        }
+        else {
+            return 0;
+        }
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/LowerFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/LowerFilter.java
new file mode 100644
index 0000000..91790fb
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/LowerFilter.java
@@ -0,0 +1,22 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.util.List;
+import java.util.Map;
+
+public class LowerFilter implements Filter {
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+        return ((String)input).toLowerCase();
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/MergeFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/MergeFilter.java
new file mode 100644
index 0000000..e34f02a
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/MergeFilter.java
@@ -0,0 +1,103 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.lang.reflect.Array;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class MergeFilter implements Filter {
+
+    public static final String FILTER_NAME = "merge";
+
+    private final List<String> argumentNames = new ArrayList<>();
+
+    public MergeFilter() {
+        argumentNames.add("items");
+    }
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return argumentNames;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        Object items = args.get("items");
+        if (input == null && items == null) {
+            throw new IllegalArgumentException("The two arguments to be merged are null");
+        } else if (input != null && items == null) {
+            return input;
+        } else if (items != null && input == null) {
+            return items;
+        }
+        // left hand side argument defines resulting type
+        if (input instanceof Map) {
+            return mergeAsMap((Map<?, ?>) input, items);
+        } else if (input instanceof List) {
+            return mergeAsList((List<?>) input, items);
+        } else if (input != null && input.getClass().isArray()) {
+            return mergeAsArray(input, items);
+        } else {
+            throw new IllegalArgumentException("The object being filtered is not a Map/List/Array");
+        }
+    }
+
+    private Object mergeAsMap(Map<?, ?> arg1, Object arg2) {
+        Map<?, ?> collection1 = arg1;
+        Map<Object, Object> output = null;
+        if (arg2 instanceof Map) {
+            Map<?, ?> collection2 = (Map<?, ?>) arg2;
+            output = new HashMap<>(collection1.size() + collection2.size() + 16);
+            output.putAll(collection1);
+            output.putAll(collection2);
+        } else if (arg2 instanceof List) {
+            List<?> collection2 = (List<?>) arg2;
+            output = new HashMap<>(collection1.size() + collection2.size() + 16);
+            output.putAll(collection1);
+            for (Object o : collection2) {
+                output.put(o, o);
+            }
+        } else {
+            throw new UnsupportedOperationException(
+                    "Currently, only Maps and Lists can be merged with a Map. Arg2: " + arg2.getClass().getName());
+        }
+        return output;
+    }
+
+    private Object mergeAsList(List<?> arg1, Object arg2) {
+        List<?> collection1 = arg1;
+        List<Object> output = null;
+        if (arg2 instanceof Map) {
+            Map<?, ?> collection2 = (Map<?, ?>) arg2;
+            output = new ArrayList<>(collection1.size() + collection2.size() + 16);
+            output.addAll(collection1);
+            output.addAll(collection2.entrySet());
+        } else if (arg2 instanceof List) {
+            List<?> collection2 = (List<?>) arg2;
+            output = new ArrayList<>(collection1.size() + collection2.size() + 16);
+            output.addAll(collection1);
+            output.addAll(collection2);
+        } else {
+            throw new UnsupportedOperationException(
+                    "Currently, only Maps and Lists can be merged with a List. Arg2: " + arg2.getClass().getName());
+        }
+        return output;
+    }
+
+    private Object mergeAsArray(Object arg1, Object arg2) {
+        Class<?> arg1Class = arg1.getClass().getComponentType();
+        Class<?> arg2Class = arg2.getClass().getComponentType();
+        if (!arg1Class.equals(arg2Class)) {
+            throw new UnsupportedOperationException(
+                    "Currently, only Arrays of the same component class can be merged. Arg1: " + arg1Class.getName()
+                            + ", Arg2: " + arg2Class.getName());
+        }
+        Object output = Array.newInstance(arg1Class, Array.getLength(arg1) + Array.getLength(arg2));
+        System.arraycopy(arg1, 0, output, 0, Array.getLength(arg1));
+        System.arraycopy(arg2, 0, output, Array.getLength(arg1), Array.getLength(arg2));
+        return output;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/NumberFormatFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/NumberFormatFilter.java
new file mode 100644
index 0000000..6941c7f
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/NumberFormatFilter.java
@@ -0,0 +1,46 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.filter.Filter;
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.text.Format;
+import java.text.NumberFormat;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+
+public class NumberFormatFilter implements Filter {
+
+    private final List<String> argumentNames = new ArrayList<>();
+
+    public NumberFormatFilter() {
+        argumentNames.add("format");
+    }
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return argumentNames;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+        Number number = (Number) input;
+
+        EvaluationContext context = (EvaluationContext) args.get("_context");
+        Locale locale = context.getLocale();
+
+        if (args.get("format") != null) {
+            Format format = new DecimalFormat((String) args.get("format"), new DecimalFormatSymbols(locale));
+            return format.format(number);
+        } else {
+            NumberFormat numberFormat = NumberFormat.getInstance(locale);
+            return numberFormat.format(number);
+        }
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/ReplaceFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/ReplaceFilter.java
new file mode 100644
index 0000000..5c47aac
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/ReplaceFilter.java
@@ -0,0 +1,42 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.text.MessageFormat;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+import java.util.Map.Entry;
+
+/**
+ * This class implements the 'replace' filter.
+ */
+public class ReplaceFilter implements Filter {
+
+    public static final String FILTER_NAME = "replace";
+
+    private static final String ARGUMENT_NAME = "replace_pairs";
+
+    private final static List<String> ARGS = Collections.unmodifiableList(Arrays.asList(ARGUMENT_NAME));
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return ARGS;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        String data = input.toString();
+        if (args.get(ARGUMENT_NAME) == null) {
+            throw new IllegalArgumentException(MessageFormat.format("The argument ''{0}'' is required.", ARGUMENT_NAME));
+        }
+        Map<?, ?> replacePair = (Map<?, ?>) args.get(ARGUMENT_NAME);
+
+        for (Entry<?, ?> entry : replacePair.entrySet()) {
+           data = data.replace(entry.getKey().toString(), entry.getValue().toString());
+        }
+
+        return data;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/RsortFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/RsortFilter.java
new file mode 100644
index 0000000..2666890
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/RsortFilter.java
@@ -0,0 +1,28 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Sort list items in the reverse order
+ */
+public class RsortFilter implements Filter {
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    @Override
+    public List<Comparable> apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+        List<Comparable> collection = (List<Comparable>) input;
+        Collections.sort(collection, Collections.reverseOrder());
+        return collection;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/SliceFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/SliceFilter.java
new file mode 100644
index 0000000..285da3a
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/SliceFilter.java
@@ -0,0 +1,114 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.lang.reflect.Array;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Map;
+
+public class SliceFilter implements Filter {
+
+    private final List<String> argumentNames = new ArrayList<>();
+
+    public SliceFilter() {
+        argumentNames.add("fromIndex");
+        argumentNames.add("toIndex");
+    }
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return argumentNames;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+
+        if (input == null) {
+            return null;
+        }
+
+        // argument parsing
+        Object argFrom = args.get("fromIndex");
+
+        if (argFrom == null) { // defaults to 0
+            argFrom = (long) 0;
+        } else if (!(argFrom instanceof Number)) {
+            String msg = String.format("Argument fromIndex must be a number. Actual type: %s", (argFrom == null ? "null" : argFrom.getClass().getName()));
+            throw new IllegalArgumentException(msg);
+        }
+        int from = ((Number) argFrom).intValue();
+        if (from < 0) {
+            throw new IllegalArgumentException("fromIndex must be greater than 0");
+        }
+
+        Object argTo = args.get("toIndex");
+
+        if (argTo == null) {
+            // defaults to input length
+            // argTo == null;
+        } else if (!(argTo instanceof Number)) {
+            String msg = String.format("Argument fromIndex must be a number. Actual type: %s", (argFrom == null ? "null" : argFrom.getClass().getName()));
+            throw new IllegalArgumentException(msg);
+        }
+
+        int length;
+        if (input instanceof List) {
+            length = ((List<?>) input).size();
+        } else if (input.getClass().isArray()) {
+            length = Array.getLength(input);
+        } else if (input instanceof String) {
+            length = ((String) input).length();
+        } else {
+            throw new IllegalArgumentException("Slice filter can only be applied to String, List and array inputs. Actual type was: "
+                            + input.getClass().getName());
+        }
+        int to;
+
+        if (argTo != null) {
+            to = ((Number) argTo).intValue();
+            if (to > length)
+                throw new IllegalArgumentException("toIndex must be smaller than input size: " + length);
+            else if (from >= to)
+                throw new IllegalArgumentException("toIndex must be greater than fromIndex");
+        } else {
+            to = length;
+        }
+
+        // slice input
+        if (input instanceof List) {
+            List<?> value = (List<?>) input;
+            // FIXME maybe sublist() is not the best option due to its
+            // implementation?
+            return value.subList(from, to);
+        } else if (input.getClass().isArray()) {
+            return sliceArray(input, from, to);
+        } else {
+            String value = (String) input;
+            return value.substring(from, to);
+        }
+    }
+
+    private static Object sliceArray(Object input, int from, int to) {
+        if (input instanceof Object[]) {
+            return Arrays.copyOfRange((Object[]) input, from, to);
+        } else if (input instanceof boolean[]) {
+            return Arrays.copyOfRange((boolean[]) input, from, to);
+        } else if (input instanceof byte[]) {
+            return Arrays.copyOfRange((byte[]) input, from, to);
+        } else if (input instanceof char[]) {
+            return Arrays.copyOfRange((char[]) input, from, to);
+        } else if (input instanceof double[]) {
+            return Arrays.copyOfRange((double[]) input, from, to);
+        } else if (input instanceof float[]) {
+            return Arrays.copyOfRange((float[]) input, from, to);
+        } else if (input instanceof int[]) {
+            return Arrays.copyOfRange((int[]) input, from, to);
+        } else if (input instanceof long[]) {
+            return Arrays.copyOfRange((long[]) input, from, to);
+        } else {
+            return Arrays.copyOfRange((short[]) input, from, to);
+        }
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/SortFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/SortFilter.java
new file mode 100644
index 0000000..eda63eb
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/SortFilter.java
@@ -0,0 +1,25 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.util.Collections;
+import java.util.List;
+import java.util.Map;
+
+public class SortFilter implements Filter {
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    @Override
+    public List<Comparable> apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+        List<Comparable> collection = (List<Comparable>) input;
+        Collections.sort(collection);
+        return collection;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/TitleFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/TitleFilter.java
new file mode 100644
index 0000000..d995f3b
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/TitleFilter.java
@@ -0,0 +1,42 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.util.List;
+import java.util.Map;
+
+public class TitleFilter implements Filter {
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+        String value = (String) input;
+
+        if (value.length() == 0) {
+            return value;
+        }
+
+        StringBuilder result = new StringBuilder();
+
+        boolean capitalizeNextCharacter = true;
+
+        for (char c : value.toCharArray()) {
+            if (Character.isWhitespace(c)) {
+                capitalizeNextCharacter = true;
+            } else if (capitalizeNextCharacter) {
+                c = Character.toTitleCase(c);
+                capitalizeNextCharacter = false;
+            }
+            result.append(c);
+        }
+
+        return result.toString();
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/TrimFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/TrimFilter.java
new file mode 100644
index 0000000..94f6445
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/TrimFilter.java
@@ -0,0 +1,23 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.util.List;
+import java.util.Map;
+
+public class TrimFilter implements Filter {
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+        String str = (String) input;
+        return str.trim();
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/UpperFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/UpperFilter.java
new file mode 100644
index 0000000..de29ffc
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/UpperFilter.java
@@ -0,0 +1,22 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.util.List;
+import java.util.Map;
+
+public class UpperFilter implements Filter {
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+        return ((String)input).toUpperCase();
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/filter/UrlEncoderFilter.java b/src/main/java/component/expressionLanguage/extension/core/filter/UrlEncoderFilter.java
new file mode 100644
index 0000000..122650e
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/filter/UrlEncoderFilter.java
@@ -0,0 +1,28 @@
+package component.expressionLanguage.extension.core.filter;
+
+import component.expressionLanguage.filter.Filter;
+import java.io.UnsupportedEncodingException;
+import java.net.URLEncoder;
+import java.util.List;
+import java.util.Map;
+
+public class UrlEncoderFilter implements Filter {
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    public Object apply(Object input, Map<String, Object> args) {
+        if (input == null) {
+            return null;
+        }
+        String arg = (String) input;
+        try {
+            arg = URLEncoder.encode(arg, "UTF-8");
+        } catch (UnsupportedEncodingException e) {
+        }
+        return arg;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/function/MaxFunction.java b/src/main/java/component/expressionLanguage/extension/core/function/MaxFunction.java
new file mode 100644
index 0000000..040a13c
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/function/MaxFunction.java
@@ -0,0 +1,45 @@
+package component.expressionLanguage.extension.core.function;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.function.Function;
+import component.expressionLanguage.operator.OperatorUtils;
+import java.util.List;
+import java.util.Map;
+
+public class MaxFunction implements Function {
+
+    @Override
+    public String getName() {
+        return "max";
+    }
+
+    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    @Override
+    public Object evaluate(EvaluationContext context, Map<String, Object> args) {
+        Object min = null;
+
+        int i = 0;
+
+        while (args.containsKey(String.valueOf(i))) {
+
+            Object candidate = args.get(String.valueOf(i));
+            i++;
+
+            if (min == null) {
+                min = candidate;
+                continue;
+            }
+            if (OperatorUtils.gt(candidate, min)) {
+                min = candidate;
+            }
+
+        }
+        return min;
+
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/function/MinFunction.java b/src/main/java/component/expressionLanguage/extension/core/function/MinFunction.java
new file mode 100644
index 0000000..5016a3d
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/function/MinFunction.java
@@ -0,0 +1,43 @@
+package component.expressionLanguage.extension.core.function;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.function.Function;
+import component.expressionLanguage.operator.OperatorUtils;
+import java.util.List;
+import java.util.Map;
+
+public class MinFunction implements Function {
+
+    @Override
+    public String getName() {
+        return "min";
+    }
+
+    @Override
+    public List<String> getArgumentNames() {
+        return null;
+    }
+
+    @Override
+    public Object evaluate(EvaluationContext context, Map<String, Object> args) {
+        Object min = null;
+
+        int i = 0;
+
+        while (args.containsKey(String.valueOf(i))) {
+
+            Object candidate = args.get(String.valueOf(i));
+            i++;
+
+            if (min == null) {
+                min = candidate;
+                continue;
+            }
+            if (OperatorUtils.lt(candidate, min)) {
+                min = candidate;
+            }
+        }
+        return min;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/function/RangeFunction.java b/src/main/java/component/expressionLanguage/extension/core/function/RangeFunction.java
new file mode 100644
index 0000000..e54ab1a
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/function/RangeFunction.java
@@ -0,0 +1,105 @@
+package component.expressionLanguage.extension.core.function;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.function.Function;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Range function to iterate over long or a string with a length of 1.
+ */
+public class RangeFunction implements Function {
+    
+    public static final String FUNCTION_NAME = "range";
+    private static final String PARAM_END = "end";
+    private static final String PARAM_INCREMENT = "increment";
+    private static final String PARAM_START = "start";
+    
+    private final List<String> argumentNames = new ArrayList<>();
+
+    public RangeFunction() {
+        this.argumentNames.add(PARAM_START);
+        this.argumentNames.add(PARAM_END);
+        this.argumentNames.add(PARAM_INCREMENT);
+    }
+    
+    @Override
+    public String getName() {
+        return FUNCTION_NAME;
+    }
+
+    @Override
+    public Object evaluate(EvaluationContext context, Map<String, Object> args) {
+        Object start = args.get(PARAM_START);
+        Object end = args.get(PARAM_END);
+        Object increment = (Object) args.get(PARAM_INCREMENT);
+        if (increment == null) {
+            increment = 1L;
+        }
+        else if (!(increment instanceof Number)) {
+            throw new IllegalArgumentException("The increment of the range function must be a number " + increment);
+        }
+        
+        Long incrementNum = ((Number) increment).longValue();
+
+        List<Object> results = new ArrayList<>();
+        // Iterating over Number
+        if (start instanceof Number && end instanceof Number) {
+            Long startNum = ((Number) start).longValue();
+            Long endNum = ((Number) end).longValue();
+
+            if (incrementNum > 0) {
+                for (Long i = startNum; i <= endNum; i += incrementNum) {
+                    results.add(i);
+                }
+            }
+            else if (incrementNum < 0) {
+                for (Long i = startNum; i >= endNum; i += incrementNum) {
+                    results.add(i);
+                }
+            }
+            else {
+                throw new IllegalArgumentException("The increment of the range function must be different than 0");
+            }
+        }
+        // Iterating over character
+        else if (start instanceof String && end instanceof String) {
+            String startStr = (String) start;
+            String endStr = (String) end;
+            if (startStr.length() != 1 || endStr.length() != 1) {
+                throw new IllegalArgumentException("Arguments of range function must be of type Number or String with "
+                        + "a length of 1");
+            }
+
+            char startChar = startStr.charAt(0);
+            char endChar = endStr.charAt(0);
+
+            if (incrementNum > 0) {
+                for (int i = startChar; i <= endChar; i += incrementNum) {
+                    results.add((char) i);
+                }
+            }
+            else if (incrementNum < 0) {
+                for (int i = startChar; i >= endChar; i += incrementNum) {
+                    results.add((char) i);
+                }
+            }
+            else {
+                throw new IllegalArgumentException("The increment of the range function must be different than 0");
+            }
+        }
+        else {
+            throw new IllegalArgumentException("Arguments of range function must be of type Number or String with a "
+                    + "length of 1");
+        }
+
+        return results;
+    }
+
+    @Override
+    public List<String> getArgumentNames() {
+        return this.argumentNames;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/test/DefinedTest.java b/src/main/java/component/expressionLanguage/extension/core/test/DefinedTest.java
new file mode 100644
index 0000000..d407bfa
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/test/DefinedTest.java
@@ -0,0 +1,18 @@
+package component.expressionLanguage.extension.core.test;
+
+/**
+ * Implementation for the test function 'defined'.
+ *
+ * <p>
+ * Inversion of 'null' test function to provide better compatibility with the
+ * original twig version and JTwig.
+ *
+ */
+public class DefinedTest extends NullTest {
+
+    @Override
+    public boolean apply(Object input) {
+        return !super.apply(input);
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/test/EmptyTest.java b/src/main/java/component/expressionLanguage/extension/core/test/EmptyTest.java
new file mode 100644
index 0000000..c526338
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/test/EmptyTest.java
@@ -0,0 +1,29 @@
+package component.expressionLanguage.extension.core.test;
+
+import component.expressionLanguage.test.Test;
+import java.util.Collection;
+import java.util.Map;
+
+public class EmptyTest implements Test {
+
+    @Override
+    public boolean apply(Object input) {
+        boolean isEmpty = input == null;
+
+        if (!isEmpty && input instanceof String) {
+            String value = (String) input;
+            isEmpty = "".equals(value.trim());
+        }
+
+        if (!isEmpty && input instanceof Collection) {
+            isEmpty = ((Collection<?>) input).isEmpty();
+        }
+
+        if (!isEmpty && input instanceof Map) {
+            isEmpty = ((Map<?, ?>) input).isEmpty();
+        }
+
+        return isEmpty;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/test/EvenTest.java b/src/main/java/component/expressionLanguage/extension/core/test/EvenTest.java
new file mode 100644
index 0000000..1621ff1
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/test/EvenTest.java
@@ -0,0 +1,19 @@
+package component.expressionLanguage.extension.core.test;
+
+import component.expressionLanguage.test.Test;
+
+public class EvenTest implements Test {
+
+    @Override
+    public boolean apply(Object input) {
+        if (input == null) {
+            throw new IllegalArgumentException("Can not pass null value to \"even\" test.");
+        }
+
+        if (input instanceof Integer) {
+            return ((Integer) input) % 2 == 0;
+        } else {
+            return ((Long) input) % 2 == 0;
+        }
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/test/IterableTest.java b/src/main/java/component/expressionLanguage/extension/core/test/IterableTest.java
new file mode 100644
index 0000000..76547dd
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/test/IterableTest.java
@@ -0,0 +1,11 @@
+package component.expressionLanguage.extension.core.test;
+
+import component.expressionLanguage.test.Test;
+
+public class IterableTest implements Test {
+
+    @Override
+    public boolean apply(Object input) {
+        return input instanceof Iterable;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/test/MapTest.java b/src/main/java/component/expressionLanguage/extension/core/test/MapTest.java
new file mode 100644
index 0000000..d5cfa6f
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/test/MapTest.java
@@ -0,0 +1,13 @@
+package component.expressionLanguage.extension.core.test;
+
+import component.expressionLanguage.test.Test;
+import java.util.Map;
+
+public class MapTest implements Test {
+
+    @Override
+    public boolean apply(Object input) {
+        return input instanceof Map;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/test/NullTest.java b/src/main/java/component/expressionLanguage/extension/core/test/NullTest.java
new file mode 100644
index 0000000..f2d4c5c
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/test/NullTest.java
@@ -0,0 +1,11 @@
+package component.expressionLanguage.extension.core.test;
+
+import component.expressionLanguage.test.Test;
+
+public class NullTest implements Test {
+
+    @Override
+    public boolean apply(Object input) {
+        return input == null;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/test/OddTest.java b/src/main/java/component/expressionLanguage/extension/core/test/OddTest.java
new file mode 100644
index 0000000..50544e5
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/test/OddTest.java
@@ -0,0 +1,15 @@
+package component.expressionLanguage.extension.core.test;
+
+import component.expressionLanguage.test.Test;
+
+public class OddTest implements Test {
+
+    @Override
+    public boolean apply(Object input) {
+        if (input == null) {
+            throw new IllegalArgumentException("Can not pass null value to \"odd\" test.");
+        }
+        EvenTest evenTest = new EvenTest();
+        return !evenTest.apply(input);
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/token/AutoEscapeTokenParser.java b/src/main/java/component/expressionLanguage/extension/core/token/AutoEscapeTokenParser.java
new file mode 100644
index 0000000..c39a894
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/token/AutoEscapeTokenParser.java
@@ -0,0 +1,58 @@
+package component.expressionLanguage.extension.core.token;
+
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.tree.AutoEscapeNode;
+import component.expressionLanguage.model.tree.BodyNode;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import component.expressionLanguage.token.parser.TokenParser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+import java.util.function.Predicate;
+
+public class AutoEscapeTokenParser implements TokenParser {
+
+    @Override
+    public String getTag() {
+        return "autoescape";
+    }
+    
+    @Override
+    public Node parse(Token token, TokenStreamParser parser) {
+        TokenStream stream = parser.getStream();
+        Position position = token.getPosition();
+
+        String strategy = null;
+        boolean active = true;
+
+        // skip over the 'autoescape' token
+        stream.next();
+
+        // did user specify active boolean?
+        if (stream.current().isA(Type.NAME)) {
+            active = Boolean.parseBoolean(stream.current().getValue());
+            stream.next();
+        }
+
+        // did user specify a strategy?
+        if (stream.current().isA(Type.STRING)) {
+            strategy = stream.current().getValue();
+            stream.next();
+        }
+
+        stream.expect(Type.EXECUTE_END);
+
+        // now we parse the block body
+        BodyNode body = parser.subparse((Token token1) -> token1.isA(Type.NAME, "endautoescape"));
+
+        // skip the 'endautoescape' token
+        stream.next();
+
+        stream.expect(Type.EXECUTE_END);
+
+        return new AutoEscapeNode(position, body, active, strategy);
+    }
+
+
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/token/BlockTokenParser.java b/src/main/java/component/expressionLanguage/extension/core/token/BlockTokenParser.java
new file mode 100644
index 0000000..0674011
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/token/BlockTokenParser.java
@@ -0,0 +1,64 @@
+package component.expressionLanguage.extension.core.token;
+
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.tree.BlockNode;
+import component.expressionLanguage.model.tree.BodyNode;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.token.parser.Parser;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import component.expressionLanguage.token.parser.TokenParser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+
+public class BlockTokenParser implements TokenParser {
+
+    @Override
+    public Node parse(Token token, TokenStreamParser parser) {
+        TokenStream stream = parser.getStream();
+        Position position = token.getPosition();
+
+        // skip over the 'block' token to the name token
+        Token blockName = stream.next();
+
+        // expect a name or string for the new block
+        if (!blockName.isA(Type.NAME) && !blockName.isA(Type.STRING)) {
+
+            // we already know an error has occurred but let's just call the
+            // typical "expect" method so that we know a proper error
+            // message is given to user
+            stream.expect(Type.NAME);
+        }
+
+        // get the name of the new block
+        String name = blockName.getValue();
+
+        // skip over name
+        stream.next();
+
+        stream.expect(Type.EXECUTE_END);
+
+        parser.pushBlockStack(name);
+
+        // now we parse the block body
+        BodyNode blockBody = parser.subparse((Token token1) -> token1.isA(Type.NAME, "endblock"));
+        parser.popBlockStack();
+
+        // skip the 'endblock' token
+        stream.next();
+
+        // check if user included block name in endblock
+        Token current = stream.current();
+        if (current.isA(Type.NAME, name) || current.isA(Type.STRING, name)) {
+            stream.next();
+        }
+
+        stream.expect(Type.EXECUTE_END);
+        return new BlockNode(position, name, blockBody);
+    }
+
+    @Override
+    public String getTag() {
+        return "block";
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/token/ExtendsTokenParser.java b/src/main/java/component/expressionLanguage/extension/core/token/ExtendsTokenParser.java
new file mode 100644
index 0000000..2a59521
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/token/ExtendsTokenParser.java
@@ -0,0 +1,34 @@
+package component.expressionLanguage.extension.core.token;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.tree.ExtendsNode;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.token.parser.Parser;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import component.expressionLanguage.token.parser.TokenParser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+
+public class ExtendsTokenParser implements TokenParser {
+
+    @Override
+    public Node parse(Token token, TokenStreamParser parser) {
+        TokenStream stream = parser.getStream();
+        Position position = token.getPosition();
+
+        // skip the 'extends' token
+        stream.next();
+
+        Expression<?> parentTemplateExpression = parser.getExpressionParser().parseExpression();
+
+        stream.expect(Type.EXECUTE_END);
+        return new ExtendsNode(position, parentTemplateExpression);
+    }
+
+    @Override
+    public String getTag() {
+        return "extends";
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/token/FilterTokenParser.java b/src/main/java/component/expressionLanguage/extension/core/token/FilterTokenParser.java
new file mode 100644
index 0000000..38335d2
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/token/FilterTokenParser.java
@@ -0,0 +1,70 @@
+package component.expressionLanguage.extension.core.token;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.extension.core.expression.FilterExpression;
+import component.expressionLanguage.extension.core.expression.RenderableNodeExpression;
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.tree.BodyNode;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.model.tree.PrintNode;
+import component.expressionLanguage.token.parser.Parser;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import component.expressionLanguage.token.parser.TokenParser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Parses the "filter" tag. It has nothing to do with implementing normal
+ * filters.
+ */
+public class FilterTokenParser implements TokenParser {
+
+    @Override
+    public Node parse(Token token, TokenStreamParser parser) {
+        TokenStream stream = parser.getStream();
+        Position position = token.getPosition();
+
+        // skip the 'filter' token
+        stream.next();
+
+        List<Expression<?>> filterInvocationExpressions = new ArrayList<>();
+
+        filterInvocationExpressions.add(parser.getExpressionParser().parseFilterInvocationExpression());
+
+        while(stream.current().isA(Type.OPERATOR, "|")){
+            // skip the '|' token
+            stream.next();
+            filterInvocationExpressions.add(parser.getExpressionParser().parseFilterInvocationExpression());
+        }
+
+        stream.expect(Type.EXECUTE_END);
+
+        BodyNode body = parser.subparse((Token subToken) -> subToken.isA(Type.NAME, "endfilter"));
+
+        stream.next();
+        stream.expect(Type.EXECUTE_END);
+
+        Expression<?> lastExpression = new RenderableNodeExpression(body);
+
+        for(Expression<?> filterInvocationExpression : filterInvocationExpressions){
+
+            FilterExpression filterExpression = new FilterExpression();
+            filterExpression.setRightExpression(filterInvocationExpression);
+            filterExpression.setLeftExpression(lastExpression);
+
+            lastExpression = filterExpression;
+        }
+
+        return new PrintNode(position, lastExpression);
+    }
+
+//    private StoppingCondition endFilter = (Token token) -> token.test(Token.Type.NAME, "endfilter");
+
+    @Override
+    public String getTag() {
+        return "filter";
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/token/FlushTokenParser.java b/src/main/java/component/expressionLanguage/extension/core/token/FlushTokenParser.java
new file mode 100644
index 0000000..88ae85e
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/token/FlushTokenParser.java
@@ -0,0 +1,33 @@
+package component.expressionLanguage.extension.core.token;
+
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.tree.FlushNode;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.token.parser.Parser;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import component.expressionLanguage.token.parser.TokenParser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+
+public class FlushTokenParser implements TokenParser {
+
+    @Override
+    public Node parse(Token token, TokenStreamParser parser) {
+
+        TokenStream stream = parser.getStream();
+        Position position = token.getPosition();
+
+        // skip over the 'flush' token
+        stream.next();
+
+        stream.expect(Type.EXECUTE_END);
+
+        return new FlushNode(position);
+    }
+
+    @Override
+    public String getTag() {
+        return "flush";
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/token/ForTokenParser.java b/src/main/java/component/expressionLanguage/extension/core/token/ForTokenParser.java
new file mode 100644
index 0000000..d50bf90
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/token/ForTokenParser.java
@@ -0,0 +1,58 @@
+package component.expressionLanguage.extension.core.token;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.tree.BodyNode;
+import component.expressionLanguage.model.tree.ForNode;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.token.parser.Parser;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import component.expressionLanguage.token.parser.TokenParser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+
+public class ForTokenParser implements TokenParser {
+
+    @Override
+    public Node parse(Token token, TokenStreamParser parser) {
+        TokenStream stream = parser.getStream();
+        Position position = token.getPosition();
+
+        // skip the 'for' token
+        stream.next();
+
+        // get the iteration variable
+        String iterationVariable = parser.getExpressionParser().parseNewVariableName();
+
+        stream.expect(Type.NAME, "in");
+
+        // get the iterable variable
+        Expression<?> iterable = parser.getExpressionParser().parseExpression();
+
+        stream.expect(Type.EXECUTE_END);
+
+        BodyNode body = parser.subparse((Token subToken) -> subToken.isA(Type.NAME, "else", "endfor"));
+
+        BodyNode elseBody = null;
+
+        if (stream.current().isA(Type.NAME, "else")) {
+            // skip the 'else' token
+            stream.next();
+            stream.expect(Type.EXECUTE_END);
+            elseBody = parser.subparse((Token subToken) -> subToken.isA(Type.NAME, "endfor"));
+        }
+
+        // skip the 'endfor' token
+        stream.next();
+
+        stream.expect(Type.EXECUTE_END);
+
+        return new ForNode(position, iterationVariable, iterable, body, elseBody);
+    }
+    
+    @Override
+    public String getTag() {
+        return "for";
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/token/IfTokenParser.java b/src/main/java/component/expressionLanguage/extension/core/token/IfTokenParser.java
new file mode 100644
index 0000000..6df51dd
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/token/IfTokenParser.java
@@ -0,0 +1,79 @@
+package component.expressionLanguage.extension.core.token;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.tree.BodyNode;
+import component.expressionLanguage.model.tree.IfNode;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.token.parser.Parser;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import component.expressionLanguage.token.parser.TokenParser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Predicate;
+import javafx.util.Pair;
+
+public class IfTokenParser implements TokenParser {
+    
+    private final Predicate<Token> decideIfFork = (Token token) -> token.isA(Type.NAME, "elseif", "else", "endif");
+
+    private final Predicate<Token> decideIfEnd = (Token token) -> token.isA(Type.NAME, "endif");
+
+    @Override
+    public Node parse(Token token, TokenStreamParser parser) {
+        TokenStream stream = parser.getStream();
+        Position position = token.getPosition();
+
+        // skip the 'if' token
+        stream.next();
+
+        List<Pair<Expression<?>, BodyNode>> conditionsWithBodies = new ArrayList<>();
+
+        Expression<?> expression = parser.getExpressionParser().parseExpression();
+
+        stream.expect(Type.EXECUTE_END);
+
+        BodyNode body = parser.subparse(decideIfFork);
+
+        conditionsWithBodies.add(new Pair<>(expression, body));
+
+        BodyNode elseBody = null;
+        boolean end = false;
+        while (!end) {
+            switch (stream.current().getValue()) {
+            case "else":
+                stream.next();
+                stream.expect(Type.EXECUTE_END);
+                elseBody = parser.subparse(decideIfEnd);
+                break;
+
+            case "elseif":
+                stream.next();
+                expression = parser.getExpressionParser().parseExpression();
+                stream.expect(Type.EXECUTE_END);
+                body = parser.subparse(decideIfFork);
+                conditionsWithBodies.add(new Pair<>(expression, body));
+                break;
+
+            case "endif":
+                stream.next();
+                end = true;
+                break;
+            default:
+                String msg = String.format("Unexpected end of template. Pebble was looking for the following tags \"else\", \"elseif\", or \"endif\" at line %s in file %s.", stream.current().getPosition(), stream.getFilename());
+                throw new IllegalStateException(msg);
+            }
+        }
+
+        stream.expect(Type.EXECUTE_END);
+        return new IfNode(position, conditionsWithBodies, elseBody);
+    }
+
+    @Override
+    public String getTag() {
+        return "if";
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/token/ImportTokenParser.java b/src/main/java/component/expressionLanguage/extension/core/token/ImportTokenParser.java
new file mode 100644
index 0000000..2d5570d
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/token/ImportTokenParser.java
@@ -0,0 +1,36 @@
+package component.expressionLanguage.extension.core.token;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.tree.ImportNode;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.token.parser.Parser;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import component.expressionLanguage.token.parser.TokenParser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+
+public class ImportTokenParser implements TokenParser {
+
+    @Override
+    public Node parse(Token token, TokenStreamParser parser) {
+
+        TokenStream stream = parser.getStream();
+        Position position = token.getPosition();
+
+        // skip over the 'import' token
+        stream.next();
+
+        Expression<?> importExpression = parser.getExpressionParser().parseExpression();
+
+        stream.expect(Type.EXECUTE_END);
+
+        return new ImportNode(position, importExpression);
+    }
+
+    @Override
+    public String getTag() {
+        return "import";
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/token/IncludeTokenParser.java b/src/main/java/component/expressionLanguage/extension/core/token/IncludeTokenParser.java
new file mode 100644
index 0000000..174a478
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/token/IncludeTokenParser.java
@@ -0,0 +1,56 @@
+package component.expressionLanguage.extension.core.token;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.extension.core.expression.MapExpression;
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.tree.IncludeNode;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import component.expressionLanguage.token.parser.TokenParser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+
+public class IncludeTokenParser implements TokenParser {
+
+    @Override
+    public Node parse(Token token, TokenStreamParser parser) {
+
+        TokenStream stream = parser.getStream();
+        Position position = token.getPosition();
+
+        // skip over the 'include' token
+        stream.next();
+
+        Expression<?> includeExpression = parser.getExpressionParser().parseExpression();
+
+        Token current = stream.current();
+        MapExpression mapExpression = null;
+
+        // We check if there is an optional 'with' parameter on the include tag.
+        if (current.getType().equals(Type.NAME) && current.getValue().equals("with")) {
+
+            // Skip over 'with'
+            stream.next();
+
+            Expression<?> parsedExpression = parser.getExpressionParser().parseExpression();
+
+            if (parsedExpression instanceof MapExpression) {
+                mapExpression = (MapExpression) parsedExpression;
+            } else {
+                String msg = String.format("Unexpected expression '%1s' at line %s in file %s.", parsedExpression .getClass().getCanonicalName(), token.getPosition(), stream.getFilename());
+                throw new IllegalStateException(msg);
+            }
+
+        }
+
+        stream.expect(Type.EXECUTE_END);
+
+        return new IncludeNode(position, includeExpression, mapExpression);
+    }
+
+    @Override
+    public String getTag() {
+        return "include";
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/token/MacroTokenParser.java b/src/main/java/component/expressionLanguage/extension/core/token/MacroTokenParser.java
new file mode 100644
index 0000000..900ca84
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/token/MacroTokenParser.java
@@ -0,0 +1,47 @@
+package component.expressionLanguage.extension.core.token;
+
+import component.expressionLanguage.model.tree.ArgumentsNode;
+import component.expressionLanguage.model.tree.BodyNode;
+import component.expressionLanguage.model.tree.MacroNode;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import component.expressionLanguage.token.parser.TokenParser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+import java.util.function.Predicate;
+
+public class MacroTokenParser implements TokenParser {
+
+    private final Predicate<Token> decideMacroEnd = (Token token) -> token.isA(Type.NAME, "endmacro");
+
+    @Override
+    public Node parse(Token token, TokenStreamParser parser) {
+
+        TokenStream stream = parser.getStream();
+
+        // skip over the 'macro' token
+        stream.next();
+
+        String macroName = stream.expect(Type.NAME).getValue();
+
+        ArgumentsNode args = parser.getExpressionParser().parseArguments(true);
+
+        stream.expect(Type.EXECUTE_END);
+
+        // parse the body
+        BodyNode body = parser.subparse(decideMacroEnd);
+
+        // skip the 'endmacro' token
+        stream.next();
+
+        stream.expect(Type.EXECUTE_END);
+
+        return new MacroNode(stream.current().getPosition(), macroName, args, body);
+    }
+
+    @Override
+    public String getTag() {
+        return "macro";
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/token/ParallelTokenParser.java b/src/main/java/component/expressionLanguage/extension/core/token/ParallelTokenParser.java
new file mode 100644
index 0000000..2fc3d3d
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/token/ParallelTokenParser.java
@@ -0,0 +1,42 @@
+package component.expressionLanguage.extension.core.token;
+
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.tree.BodyNode;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.model.tree.ParallelNode;
+import component.expressionLanguage.token.parser.Parser;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import component.expressionLanguage.token.parser.TokenParser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+import java.util.function.Predicate;
+
+public class ParallelTokenParser implements TokenParser {
+
+    private final Predicate<Token> decideParallelEnd = (Token token) -> token.isA(Type.NAME, "endparallel");
+
+    @Override
+    public Node parse(Token token, TokenStreamParser parser) {
+        TokenStream stream = parser.getStream();
+        Position position = token.getPosition();
+
+        // skip the 'parallel' token
+        stream.next();
+
+        stream.expect(Type.EXECUTE_END);
+
+        BodyNode body = parser.subparse(decideParallelEnd);
+
+        // skip the 'endparallel' token
+        stream.next();
+
+        stream.expect(Type.EXECUTE_END);
+        return new ParallelNode(position, body);
+    }
+
+    @Override
+    public String getTag() {
+        return "parallel";
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/token/SetTokenParser.java b/src/main/java/component/expressionLanguage/extension/core/token/SetTokenParser.java
new file mode 100644
index 0000000..afb5836
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/token/SetTokenParser.java
@@ -0,0 +1,39 @@
+package component.expressionLanguage.extension.core.token;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.model.tree.SetNode;
+import component.expressionLanguage.token.parser.Parser;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import component.expressionLanguage.token.parser.TokenParser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+
+public class SetTokenParser implements TokenParser {
+
+    @Override
+    public Node parse(Token token, TokenStreamParser parser) {
+        TokenStream stream = parser.getStream();
+        Position position = token.getPosition();
+
+        // skip the 'set' token
+        stream.next();
+
+        String name = parser.getExpressionParser().parseNewVariableName();
+
+        stream.expect(Type.PUNCTUATION, "=");
+
+        Expression<?> value = parser.getExpressionParser().parseExpression();
+
+        stream.expect(Type.EXECUTE_END);
+
+        return new SetNode(position, name, value);
+    }
+
+    @Override
+    public String getTag() {
+        return "set";
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/extension/core/token/VerbatimTokenParser.java b/src/main/java/component/expressionLanguage/extension/core/token/VerbatimTokenParser.java
new file mode 100644
index 0000000..ed7fc2d
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/extension/core/token/VerbatimTokenParser.java
@@ -0,0 +1,24 @@
+package component.expressionLanguage.extension.core.token;
+
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.parser.TokenParser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+
+/**
+ * This is just a dummy class to point developers into the right direction; the
+ * verbatim tag had to be implemented directly into the lexer.
+ *
+ */
+public class VerbatimTokenParser implements TokenParser {
+
+    @Override
+    public Node parse(Token token, TokenStreamParser parser) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String getTag() {
+        return "verbatim";
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/filter/DefaultFilter.java b/src/main/java/component/expressionLanguage/filter/DefaultFilter.java
new file mode 100644
index 0000000..e6b0505
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/filter/DefaultFilter.java
@@ -0,0 +1,48 @@
+package component.expressionLanguage.filter;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.extension.core.test.EmptyTest;
+import component.expressionLanguage.test.Test;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+public class DefaultFilter implements Filter {
+
+    private final List<String> argumentNames = new ArrayList<>();
+
+    public DefaultFilter() {
+        argumentNames.add("default");
+    }
+    
+//    @Override
+    public String getName() {
+        return "default";
+    }
+
+//    @Override
+    public Object evaluate(EvaluationContext context, Map<String, Object> args) {
+        return null;
+    }
+    
+
+//    @Override
+    public List<String> getArgumentNames() {
+        return argumentNames;
+    }
+
+    @Override
+    public Object apply(Object input, Map<String, Object> args) {
+        return filter(input, args.get("default"));
+    }
+    
+    public Object filter(Object input, Object orElse) {
+        if (new EmptyTest().apply(input)) {
+            return orElse;
+        }
+        
+        return input;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/filter/Filter.java b/src/main/java/component/expressionLanguage/filter/Filter.java
new file mode 100644
index 0000000..6f49041
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/filter/Filter.java
@@ -0,0 +1,8 @@
+package component.expressionLanguage.filter;
+
+import java.util.Map;
+
+public interface Filter {
+    
+    Object apply(Object input, Map<String, Object> args);
+}
diff --git a/src/main/java/component/expressionLanguage/function/Function.java b/src/main/java/component/expressionLanguage/function/Function.java
new file mode 100644
index 0000000..7d2e9c1
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/function/Function.java
@@ -0,0 +1,60 @@
+package component.expressionLanguage.function;
+
+import component.expressionLanguage.EvaluationContext;
+import java.util.List;
+import java.util.Map;
+import java.util.function.BiFunction;
+
+public interface Function {
+    
+    String getName();
+    List<String> getArgumentNames();
+    Object evaluate(EvaluationContext context, Map<String, Object> args);
+    
+    public static FunctionBuilder builder() {
+        return new FunctionBuilder();
+    }
+    
+    public static class FunctionBuilder {
+        
+        private String name;
+        
+        private BiFunction<EvaluationContext, Map<String, Object>, String> runnable;
+        
+        private List<String> argumentsNames;
+        
+        public FunctionBuilder named(String name) {
+            this.name = name;
+            return this;
+        }
+        
+        public FunctionBuilder with(String argName) {
+            this.argumentsNames.add(argName);
+            return this;
+        }
+        
+        public FunctionBuilder evaluation(BiFunction<EvaluationContext, Map<String, Object>, String> runnable) {
+            this.runnable = runnable;
+            return this;
+        }
+        
+        public Function build() {
+            return new Function() {
+                @Override
+                public String getName() {
+                    return name;
+                }
+                
+                @Override
+                public String evaluate(EvaluationContext context, Map<String, Object> args) {
+                    return runnable.apply(context, args);
+                }
+
+                @Override
+                public List<String> getArgumentNames() {
+                   return argumentsNames;
+                }
+            };
+        }
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/function/RangeFunction.java b/src/main/java/component/expressionLanguage/function/RangeFunction.java
new file mode 100644
index 0000000..89d3175
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/function/RangeFunction.java
@@ -0,0 +1,104 @@
+package component.expressionLanguage.function;
+
+import component.expressionLanguage.EvaluationContext;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Range function to iterate over long or a string with a length of 1.
+ *
+ */
+public class RangeFunction implements Function {
+    
+    public static final String FUNCTION_NAME = "range";
+    private static final String PARAM_END = "end";
+    private static final String PARAM_INCREMENT = "increment";
+    private static final String PARAM_START = "start";
+    
+    private final List<String> argumentNames = new ArrayList<>();
+
+    public RangeFunction() {
+        this.argumentNames.add(PARAM_START);
+        this.argumentNames.add(PARAM_END);
+        this.argumentNames.add(PARAM_INCREMENT);
+    }
+
+    @Override
+    public String getName() {
+        return FUNCTION_NAME;
+    }
+
+    @Override
+    public String evaluate(EvaluationContext context, Map<String, Object> args) {
+        Object start = args.get(PARAM_START);
+        Object end = args.get(PARAM_END);
+        Object increment = (Object) args.get(PARAM_INCREMENT);
+        if (increment == null) {
+            increment = 1L;
+        }
+        else if (!(increment instanceof Number)) {
+            throw new IllegalArgumentException("The increment of the range function must be a number " + increment);
+        }
+        
+        Long incrementNum = ((Number) increment).longValue();
+
+        List<Object> results = new ArrayList<>();
+        // Iterating over Number
+        if (start instanceof Number && end instanceof Number) {
+            Long startNum = ((Number) start).longValue();
+            Long endNum = ((Number) end).longValue();
+
+            if (incrementNum > 0) {
+                for (Long i = startNum; i <= endNum; i += incrementNum) {
+                    results.add(i);
+                }
+            }
+            else if (incrementNum < 0) {
+                for (Long i = startNum; i >= endNum; i += incrementNum) {
+                    results.add(i);
+                }
+            }
+            else {
+                throw new IllegalArgumentException("The increment of the range function must be different than 0");
+            }
+        }
+        // Iterating over character
+        else if (start instanceof String && end instanceof String) {
+            String startStr = (String) start;
+            String endStr = (String) end;
+            if (startStr.length() != 1 || endStr.length() != 1) {
+                throw new IllegalArgumentException("Arguments of range function must be of type Number or String with "
+                        + "a length of 1");
+            }
+
+            char startChar = startStr.charAt(0);
+            char endChar = endStr.charAt(0);
+
+            if (incrementNum > 0) {
+                for (int i = startChar; i <= endChar; i += incrementNum) {
+                    results.add((char) i);
+                }
+            }
+            else if (incrementNum < 0) {
+                for (int i = startChar; i >= endChar; i += incrementNum) {
+                    results.add((char) i);
+                }
+            }
+            else {
+                throw new IllegalArgumentException("The increment of the range function must be different than 0");
+            }
+        }
+        else {
+            throw new IllegalArgumentException("Arguments of range function must be of type Number or String with a "
+                    + "length of 1");
+        }
+
+        return results.toString();
+    }
+
+    @Override
+    public List<String> getArgumentNames() {
+        return this.argumentNames;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/lexer/Lexer.java b/src/main/java/component/expressionLanguage/lexer/Lexer.java
new file mode 100644
index 0000000..0b0f8eb
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/lexer/Lexer.java
@@ -0,0 +1,515 @@
+package component.expressionLanguage.lexer;
+
+import component.util.StringUtils;
+import component.expressionLanguage.model.position.Source;
+import component.expressionLanguage.operator.Operator;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import static java.util.regex.Pattern.compile;
+import javafx.util.Pair;
+
+public class Lexer {
+
+    private static final Pattern PATTERN_NAME = compile("^[a-zA-Z_][a-zA-Z0-9_]*");
+
+    private static final Pattern PATTERN_NUMBER = compile("^[0-9]+(\\.[0-9]+)?");
+
+    // the negative lookbehind assertion is used to ignore escaped quotation marks
+    private static final Pattern PATTERN_STRING = compile("((\").*?(?<!\\\\)(\"))|((').*?(?<!\\\\)('))", Pattern.DOTALL);
+
+    private static final String PUNCTUATION = "()[]{}?:.,|=";
+
+    protected Syntax syntax;
+
+    protected Source source;
+
+    protected ArrayList<Token> tokens;
+
+    protected Pattern regexOperators;
+
+    private LinkedList<Pair<String, Integer>> brackets;
+    
+    private boolean trimLeadingWhitespaceFromNextData = false;
+
+    /**
+     * The state of the lexer is important so that we know what to expect next
+     * and to help discover errors in the template (ex. unclosed comments).
+     */
+    private State state;
+
+    private LinkedList<State> states;
+
+    private enum State {
+        DATA, EXECUTE, PRINT, COMMENT
+    }
+
+
+    public Lexer() {
+        
+    }
+    
+    public TokenStream tokenize(Source source) {
+        this.tokens = new ArrayList();
+        this.source = source;
+        
+        return doTokenize();
+    }
+
+    public TokenStream doTokenize() {
+
+        this.brackets = new LinkedList<>();
+
+        this.states = new LinkedList<>();
+        this.state = State.DATA;
+        /*
+         * loop through the entire source and apply different lexing methods
+         * depending on what kind of state we are in at the time.
+         *
+         * This will always start on lexData();
+         */
+        while (this.source.length() > 0) {
+            switch (this.state) {
+                case DATA:
+                    lexData();
+                    break;
+                case EXECUTE:
+                    lexExecute();
+                    break;
+                case PRINT:
+                    lexPrint();
+                    break;
+                case COMMENT:
+                    lexComment();
+                    break;
+                default:
+                    break;
+            }
+
+        }
+
+        // end of file token
+        pushToken(Type.EOF);
+
+        // make sure that all brackets have been closed, else throw an error
+        if (!this.brackets.isEmpty()) {
+            String msg = String.format("Unclosed \"%s\" at .", brackets.pop().getKey(), source.getPosition());
+            throw new IllegalStateException(msg);
+        }
+
+        return new TokenStream(tokens, source.getName());
+    }
+
+    private void lexData() {
+
+        Matcher matcher = this.syntax.getRegexStartDelimiters().matcher(source);
+        boolean match = matcher.find();
+
+        String text;
+        String startDelimiterToken = null;
+
+        if (!match) {
+
+            text = source.toString();
+            source.advance(source.length());
+
+        } else {
+
+            text = source.substring(matcher.start());
+            startDelimiterToken = source.substring(matcher.start(), matcher.end());
+            source.advance(matcher.end());
+        }
+        
+        if (trimLeadingWhitespaceFromNextData) {
+            text = StringUtils.trimLeadingWhitespace(text);
+            trimLeadingWhitespaceFromNextData = false;
+        }
+        
+        Token textToken = pushToken(Type.TEXT, text);
+
+        if (match) {
+
+            checkForLeadingWhitespaceTrim(textToken);
+
+            if (this.syntax.getCommentOpen().equals(startDelimiterToken)) {
+                pushState(State.COMMENT);
+            } else if (this.syntax.getPrintOpen().equals(startDelimiterToken)) {
+
+                pushToken(Type.PRINT_START, this.syntax.getPrintOpen());
+                pushState(State.PRINT);
+
+            } else if ((this.syntax.getExecuteOpen().equals(startDelimiterToken))) {
+                pushToken(Type.EXECUTE_START, this.syntax.getExecuteOpen());
+                pushState(State.EXECUTE);
+            }
+        }
+
+    }
+
+    private void lexExecute() {
+
+        // check for the trailing whitespace trim character
+        checkForTrailingWhitespaceTrim();
+
+        Matcher matcher = this.syntax.getRegexExecuteClose().matcher(source);
+
+        // check if we are at the execute closing delimiter
+        if (matcher.lookingAt() && brackets.isEmpty()) {
+            pushToken(Type.EXECUTE_END, this.syntax.getExecuteClose());
+            source.advance(matcher.end());
+            popState();
+        } else {
+            lexExpression();
+        }
+
+    }
+
+    private void lexPrint() {
+
+        // check for the trailing whitespace trim character
+        checkForTrailingWhitespaceTrim();
+        Matcher matcher = this.syntax.getRegexPrintClose().matcher(source);
+
+        // check if we are at the print closing delimiter
+        if (matcher.lookingAt() && brackets.isEmpty()) {
+            pushToken(Type.PRINT_END, this.syntax.getPrintClose());
+            source.advance(matcher.end());
+            popState();
+        } else {
+            lexExpression();
+        }
+
+    }
+
+    private void lexExpression() {
+        String token;
+
+        // whitespace
+        source.advanceThroughWhitespace();
+
+        Matcher matcher;
+
+        /*
+         * Matcher matcher = REGEX_WHITESPACE.matcher(source); if
+         * (matcher.lookingAt()) { source.advance(matcher.end()); }
+         */
+        // operators
+        if (regexOperators != null) {
+            matcher = regexOperators.matcher(source);
+            if (matcher.lookingAt()) {
+                token = source.substring(matcher.end());
+                pushToken(Type.OPERATOR, token);
+                source.advance(matcher.end());
+                return;
+            }
+        }
+
+        // names
+        matcher = PATTERN_NAME.matcher(source);
+        if (matcher.lookingAt()) {
+            token = source.substring(matcher.end());
+            pushToken(Type.NAME, token);
+            source.advance(matcher.end());
+            return;
+        }
+
+        // numbers
+        matcher = PATTERN_NUMBER.matcher(source);
+        if (matcher.lookingAt()) {
+            token = source.substring(matcher.end());
+            pushToken(Type.NUMBER, token);
+            source.advance(matcher.end());
+            return;
+        }
+
+        // punctuation
+        if (PUNCTUATION.indexOf(source.charAt(0)) >= 0) {
+            String character = String.valueOf(source.charAt(0));
+
+            // opening bracket
+            if ("([{".contains(character)) {
+                brackets.push(new Pair<>(character, source.getLineNumber()));
+            } // closing bracket
+            else if (")]}".contains(character)) {
+                if (brackets.isEmpty()) {
+                    String msg = String.format("Unexpected \"" + character + "\" at %s", source.getPosition());
+                    throw new IllegalStateException(msg);
+                } else {
+                    HashMap<String, String> validPairs = new HashMap<>();
+                    validPairs.put("(", ")");
+                    validPairs.put("[", "]");
+                    validPairs.put("{", "}");
+                    String lastBracket = brackets.pop().getKey();
+                    String expected = validPairs.get(lastBracket);
+                    if (!expected.equals(character)) {
+                        String msg = String.format("Unclosed \"" + expected + "\" at %s", source.getPosition());
+                        throw new IllegalStateException(msg);
+                    }
+                }
+            }
+
+            pushToken(Type.PUNCTUATION, character);
+            source.advance(1);
+            return;
+        }
+
+        // strings
+        matcher = PATTERN_STRING.matcher(source);
+        if (matcher.lookingAt()) {
+            token = source.substring(matcher.end());
+
+            source.advance(matcher.end());
+
+            char quotationType = token.charAt(0);
+
+            // remove first and last quotation marks
+            token = token.substring(1, token.length() - 1);
+
+            // remove backslashes used to escape inner quotation marks
+            if (quotationType == '\'') {
+                token = token.replaceAll("\\\\(')", "$1");
+            } else if (quotationType == '"') {
+                token = token.replaceAll("\\\\(\")", "$1");
+            }
+
+            pushToken(Type.STRING, token);
+            return;
+        }
+
+        String msg = String.format("Unexpected character [%s], at %s.", source.charAt(0), source.getPosition());
+        // we should have found something and returned by this point
+        throw new IllegalStateException(msg);
+    }
+
+    private void lexComment() {
+
+        // all we need to do is find the end of the comment.
+        Matcher matcher = this.syntax.getRegexCommentClose().matcher(source);
+
+        boolean match = matcher.find(0);
+
+        if (!match) {
+            String msg = String.format("Unclosed comment at line %s, in file %s.", source.getLineNumber(), source.getName());
+            throw new IllegalStateException(msg);
+        }
+
+        /*
+         * check if the commented ended with the whitespace trim character by
+         * reversing the comment and performing a regular forward regex search.
+         */
+        String comment = source.substring(matcher.start());
+        String reversedComment = new StringBuilder(comment).reverse().toString();
+        Matcher whitespaceTrimMatcher = this.syntax.getRegexLeadingWhitespaceTrim().matcher(reversedComment);
+
+        if (whitespaceTrimMatcher.lookingAt()) {
+            this.trimLeadingWhitespaceFromNextData = true;
+        }
+
+        // move cursor to end of comment (and closing delimiter)
+        source.advance(matcher.end());
+        popState();
+    }
+
+    private void checkForTrailingWhitespaceTrim() {
+        Matcher whitespaceTrimMatcher = this.syntax.getRegexTrailingWhitespaceTrim().matcher(source);
+        
+        if(whitespaceTrimMatcher.lookingAt()) {
+            this.trimLeadingWhitespaceFromNextData = true;
+        }
+    }
+
+    private void checkForLeadingWhitespaceTrim(Token leadingToken) {
+
+        Matcher whitespaceTrimMatcher = this.syntax.getRegexLeadingWhitespaceTrim().matcher(source);
+
+        if (whitespaceTrimMatcher.lookingAt()) {
+            if (leadingToken != null) {
+                leadingToken.setValue(StringUtils.trimLeadingWhitespace(leadingToken.getValue()));
+            }
+            source.advance(whitespaceTrimMatcher.end());
+        }
+    }
+
+    private Token pushToken(Type type) {
+        return pushToken(type, null);
+    }
+
+    /**
+     * Create a Token of a certain type and value and push it into the list of
+     * tokens that we are maintaining. `
+     *
+     * @param type The type of token we are creating
+     * @param value The value of the new token
+     */
+    private Token pushToken(Type type, String value) {
+
+        // ignore empty text tokens
+        if (type.equals(Type.TEXT) && (value == null || "".equals(value))) {
+            return null;
+        }
+//source.getName(), source.getLineNumber(), 0
+        Token result = new Token(type, value, this.source.getPosition());
+
+        this.tokens.add(result);
+
+        return result;
+    }
+
+//    /**
+//     * Retrieves the operators (both unary and binary) from the PebbleEngine and
+//     * then dynamically creates one giant regular expression to detect for the
+//     * existence of one of these operators.
+//     *
+//     * @return Pattern The regular expression used to find an operator
+//     */
+//    private void buildOperatorRegex() {
+//
+//        List<String> operators = new ArrayList<>();
+//
+//        if (unaryOperators != null) {
+//            unaryOperators.keySet().stream().forEach(operators::add);
+//        }
+//
+//        if (binaryOperators != null) {
+//            binaryOperators.keySet().stream().forEach(operators::add);
+//        }
+//
+//        if (!operators.isEmpty()) {
+//            StringBuilder regex = new StringBuilder("^");
+//
+//            boolean isFirst = true;
+//
+//            for (String operator : operators) {
+//                if (isFirst) {
+//                    isFirst = false;
+//                } else {
+//                    regex.append("|");
+//                }
+//                regex.append(Pattern.quote(operator));
+//
+//                char nextChar = operator.charAt(operator.length() - 1);
+//                if (Character.isLetter(nextChar) || Character.getType(nextChar) == Character.LETTER_NUMBER) {
+//                    regex.append("(?![a-zA-Z])");
+//                }
+//            }
+//
+//            this.regexOperators = Pattern.compile(regex.toString());
+//        }
+//
+//    }
+
+    /**
+     * Pushes the current state onto the stack and then updates the current
+     * state to the new state.
+     *
+     * @param state The new state to use as the current state
+     */
+    private void pushState(State state) {
+        this.states.push(this.state);
+        this.state = state;
+    }
+
+    /**
+     * Pop state from the stack
+     */
+    private void popState() {
+        this.state = this.states.pop();
+    }
+
+    public Syntax getSyntax() {
+        return syntax;
+    }
+
+    public void setSyntax(Syntax syntax) {
+        this.syntax = syntax;
+    }
+
+    public Source getSource() {
+        return source;
+    }
+
+    public void setSource(Source source) {
+        this.source = source;
+    }
+
+    public ArrayList<Token> getTokens() {
+        return tokens;
+    }
+
+    public void setRegexOperators(Pattern regexOperators) {
+        this.regexOperators = regexOperators;
+    }
+
+    public void setTrimLeadingWhitespaceFromNextData(boolean trimLeadingWhitespaceFromNextData) {
+        this.trimLeadingWhitespaceFromNextData = trimLeadingWhitespaceFromNextData;
+    }
+    
+    public static LexerBuilder builder() {
+        return new LexerBuilder();
+    }
+    
+    public static class LexerBuilder {
+        
+        protected Syntax syntax;
+
+        protected Map<String, Operator> operators;
+
+        private boolean trimLeadingWhitespaceFromNextData = false;
+        
+        public LexerBuilder syntax(Syntax syntax) {
+            this.syntax = syntax;
+            return this;
+        }
+        
+        public LexerBuilder operator(String symbol, Operator operator) {
+            if (this.operators == null) {
+                this.operators = new HashMap<>();
+            }
+            
+            this.operators.put(symbol, operator);
+            return this;
+        }
+        
+        public LexerBuilder operators(Map<String, Operator> operators) {
+            if (this.operators == null) {
+                this.operators = new HashMap<>();
+            }
+            
+            this.operators.putAll(operators);
+            return this;
+        }
+        
+        public LexerBuilder trim(boolean trim) {
+            this.trimLeadingWhitespaceFromNextData = trim;
+            return this;
+        }
+        
+        
+        public Lexer build() {
+            Lexer lexer = new Lexer();
+            
+            lexer.setSyntax(syntax);
+            lexer.setTrimLeadingWhitespaceFromNextData(trimLeadingWhitespaceFromNextData);
+            
+            if (this.operators != null && !this.operators.isEmpty()) {
+                String regex = this.operators.keySet().stream().reduce("^", (a, symbol) -> {
+                    char nextChar = symbol.charAt(symbol.length() - 1);
+                    return a.concat(a.contentEquals("^") ? "" : "|")
+                            .concat(Pattern.quote(symbol))
+                            .concat(Character.isLetter(nextChar) || Character.getType(nextChar) == Character.LETTER_NUMBER ? "(?![a-zA-Z])" : "");
+                });
+
+                lexer.setRegexOperators(Pattern.compile(regex));
+            }
+            
+            return lexer;
+        }
+        
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/lexer/Syntax.java b/src/main/java/component/expressionLanguage/lexer/Syntax.java
new file mode 100644
index 0000000..f31e301
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/lexer/Syntax.java
@@ -0,0 +1,245 @@
+package component.expressionLanguage.lexer;
+
+import java.util.regex.Pattern;
+
+import static java.util.regex.Pattern.compile;
+import static java.util.regex.Pattern.quote;
+
+public class Syntax {
+
+    private static final String POSSIBLE_NEW_LINE = "(\r\n|\n\r|\r|\n|\u0085|\u2028|\u2029)?";
+    
+    private String commentOpen;
+
+    private String commentClose;
+
+    private String executeOpen;
+
+    private String executeClose;
+
+    private String printOpen;
+
+    private String printClose;
+
+    private String wsTrim;
+
+    private Pattern regexPrintClose;
+
+    private Pattern regexExecuteClose;
+
+    private Pattern regexCommentClose;
+
+    private Pattern regexStartDelimiters;
+
+    private Pattern regexLeadingWhitespaceTrim;
+
+    private Pattern regexTrailingWhitespaceTrim;
+    
+    protected Pattern regexOperators;
+
+    public Pattern getRegexPrintClose() {
+        if (this.regexPrintClose == null) {
+            this.regexPrintClose = compile(
+                    "^\\s*" + quote(wsTrim) + 
+                    "?" + quote(printClose) + 
+                    POSSIBLE_NEW_LINE);
+        }
+        return regexPrintClose;
+    }
+
+    public Pattern getRegexExecuteClose() {
+        if (this.regexExecuteClose == null) {
+            this.regexExecuteClose = compile(
+                    "^\\s*" + quote(wsTrim) + 
+                    "?" + quote(executeClose) + 
+                    POSSIBLE_NEW_LINE);
+        }
+        return regexExecuteClose;
+    }
+
+    public Pattern getRegexCommentClose() {
+        if (this.regexCommentClose == null) {
+            this.regexCommentClose = compile(
+                quote(commentClose) + 
+                POSSIBLE_NEW_LINE);
+        }
+        return regexCommentClose;
+    }
+
+    public Pattern getRegexStartDelimiters() {
+        if (regexStartDelimiters == null) {
+             this.regexStartDelimiters = compile(
+                    quote(printOpen) + "|" + 
+                    quote(executeOpen) + "|" + 
+                    quote(commentOpen));
+        }
+        return regexStartDelimiters;
+    }
+
+    public Pattern getRegexLeadingWhitespaceTrim() {
+        if (regexLeadingWhitespaceTrim == null) {
+            this.regexLeadingWhitespaceTrim = compile(quote(wsTrim) + "\\s+");
+        }
+        return regexLeadingWhitespaceTrim;
+    }
+
+    public Pattern getRegexTrailingWhitespaceTrim() {
+        if (regexTrailingWhitespaceTrim == null) {
+            this.regexTrailingWhitespaceTrim = compile(
+                    "^\\s*" + quote(wsTrim) + 
+                    "(" + quote(printClose) + 
+                        "|" + quote(executeClose) + 
+                        "|" + quote(commentClose) + 
+                    ")");
+        }
+        return regexTrailingWhitespaceTrim;
+    }
+
+    public String getCommentOpen() {
+        return commentOpen;
+    }
+
+    public void setCommentOpen(String commentOpen) {
+        this.commentOpen = commentOpen;
+    }
+
+    public String getCommentClose() {
+        return commentClose;
+    }
+
+    public void setCommentClose(String commentClose) {
+        this.commentClose = commentClose;
+    }
+
+    public String getExecuteOpen() {
+        return executeOpen;
+    }
+
+    public void setExecuteOpen(String executeOpen) {
+        this.executeOpen = executeOpen;
+    }
+
+    public String getExecuteClose() {
+        return executeClose;
+    }
+
+    public void setExecuteClose(String executeClose) {
+        this.executeClose = executeClose;
+    }
+
+    public String getPrintOpen() {
+        return printOpen;
+    }
+
+    public void setPrintOpen(String printOpen) {
+        this.printOpen = printOpen;
+    }
+
+    public String getPrintClose() {
+        return printClose;
+    }
+
+    public void setPrintClose(String printClose) {
+        this.printClose = printClose;
+    }
+
+    public String getWsTrim() {
+        return wsTrim;
+    }
+
+    public void setWsTrim(String wsTrim) {
+        this.wsTrim = wsTrim;
+    }
+
+    public static SyntaxBuilder builder() {
+        return new SyntaxBuilder();
+    }
+
+    public static class SyntaxBuilder {
+
+        private String commentOpen;
+
+        private String commentClose;
+
+        private String executeOpen;
+
+        private String executeClose;
+
+        private String printOpen;
+
+        private String printClose;
+
+        private String wsTrim;
+
+        public SyntaxBuilder comment(String open, String close) {
+            this.commentOpen = open;
+            this.commentClose = close;
+            return this;
+        }
+
+        public SyntaxBuilder commentOpen(String commentOpen) {
+            this.commentOpen = commentOpen;
+            return this;
+        }
+
+        public SyntaxBuilder commentClose(String commentClose) {
+            this.commentClose = commentClose;
+            return this;
+        }
+
+        public SyntaxBuilder execute(String open, String close) {
+            this.executeOpen = open;
+            this.executeClose = close;
+            return this;
+        }
+
+        public SyntaxBuilder executeOpen(String executeOpen) {
+            this.executeOpen = executeOpen;
+            return this;
+        }
+
+        public SyntaxBuilder executeClose(String executeClose) {
+            this.executeClose = executeClose;
+            return this;
+        }
+
+        public SyntaxBuilder print(String open, String close) {
+            this.printOpen = open;
+            this.printClose = close;
+            return this;
+        }
+        
+        public SyntaxBuilder printClose(String printClose) {
+            this.printClose = printClose;
+            return this;
+        }
+
+        public SyntaxBuilder printOpen(String printOpen) {
+            this.printOpen = printOpen;
+            return this;
+        }
+
+        public SyntaxBuilder wsTrim(String wsTrim) {
+            this.wsTrim = wsTrim;
+            return this;
+        }
+
+        public Syntax build() {
+            Syntax syntax = new Syntax();
+
+            syntax.setCommentClose(commentClose);
+            syntax.setCommentOpen(commentOpen);
+
+            syntax.setExecuteClose(executeClose);
+            syntax.setExecuteOpen(executeOpen);
+
+            syntax.setPrintClose(printClose);
+            syntax.setPrintOpen(printOpen);
+
+            syntax.setWsTrim(wsTrim);
+
+            return syntax;
+        }
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/position/Position.java b/src/main/java/component/expressionLanguage/model/position/Position.java
new file mode 100644
index 0000000..2a5094e
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/position/Position.java
@@ -0,0 +1,27 @@
+package component.expressionLanguage.model.position;
+
+public class Position {
+    
+    private final String name;
+    private final int line;
+    private final int column;
+
+    public Position(String name, int line, int column) {
+        this.name = name;
+        this.line = line;
+        this.column = column;
+    }
+
+    public int getLine() {
+        return line;
+    }
+
+    public int getColumn() {
+        return column;
+    }
+
+    @Override
+    public String toString() {
+        return String.format("%s (Line: %d, Column: %d)", name, line, column);
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/model/position/Source.java b/src/main/java/component/expressionLanguage/model/position/Source.java
new file mode 100644
index 0000000..6cd4fce
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/position/Source.java
@@ -0,0 +1,210 @@
+package component.expressionLanguage.model.position;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.util.Arrays;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class Source implements CharSequence {
+
+    private final String name;
+
+    /**
+     * The characters found within the template.
+     */
+    private final char[] source;
+
+    /**
+     * Number of characters stored in source array remaining to be tokenized
+     */
+    private int size = 0;
+
+    /**
+     * Default capacity
+     */
+    private static final int DEFAULT_CAPACITY = 1024;
+
+    /**
+     * An index of the first character for the remaining un-tokenized source.
+     */
+    private int offset = 0;
+
+    /**
+     * Tracking the line number that we are currently tokenizing.
+     */
+    private int lineNumber = 1;
+    private int columnNumber = 1;
+
+    public Source(String name, char[] source, int size) {
+        this.name = name;
+        this.source = source;
+        this.size = size;
+    }
+
+    /**
+     * Moves the start index a certain amount. While traversing this amount we
+     * will count how many newlines have been encountered.
+     *
+     * @param amount Amount of characters to advance by
+     */
+    public void advance(int amount) {
+
+        int index = 0;
+        while (index < amount) {
+            int sizeOfNewline = advanceThroughNewline(index);
+
+            if (sizeOfNewline > 0) {
+                index += sizeOfNewline;
+            } else {
+                index++;
+            }
+        }
+
+        this.size -= amount;
+        this.offset += amount;
+    }
+
+    public void advanceThroughWhitespace() {
+        int index = 0;
+
+        while (Character.isWhitespace(charAt(index))) {
+            int sizeOfNewline = advanceThroughNewline(index);
+
+            if (sizeOfNewline > 0) {
+                index += sizeOfNewline;
+            } else {
+                index++;
+            }
+        }
+
+        this.size -= index;
+        this.offset += index;
+    }
+
+    /**
+     * Advances through possible newline character and returns how many
+     * characters were used to represent the newline (windows uses two
+     * characters to represent one newline).
+     *
+     * @param index The index of the potential newline character
+     * @return
+     */
+    private int advanceThroughNewline(int index) {
+        char character = this.charAt(index);
+        int numOfCharacters = 0;
+
+        // windows newline
+        if ('\r' == character && '\n' == charAt(index + 1)) {
+
+            this.lineNumber++;
+            numOfCharacters = 2;
+
+            // various other newline characters
+        } else if ('\n' == character || '\r' == character 
+                || '\u0085' == character || '\u2028' == character
+                || '\u2029' == character) {
+
+            this.lineNumber++;
+            numOfCharacters = 1;
+        }
+        this.columnNumber++;
+        return numOfCharacters;
+    }
+
+    public String substring(int start, int end) {
+        return new String(Arrays.copyOfRange(source, this.offset + start, this.offset + end));
+    }
+
+    public String substring(int end) {
+        return new String(Arrays.copyOfRange(source, offset, offset + end));
+    }
+
+    @Override
+    public int length() {
+        return size;
+    }
+
+    @Override
+    public char charAt(int index) {
+        return source[offset + index];
+    }
+
+    @Override
+    public CharSequence subSequence(int start, int end) {
+        return new String(Arrays.copyOfRange(source, this.offset + start, this.offset + end));
+    }
+
+    @Override
+    public String toString() {
+        return new String(Arrays.copyOfRange(source, offset, offset + size));
+    }
+    
+    
+    public Position getPosition() {
+        return new Position(getName(), lineNumber, columnNumber);
+    }
+
+    public int getLineNumber() {
+        return lineNumber;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public static SourceBuilder builder(String name) {
+        return new SourceBuilder(name);
+    }
+
+    public static class SourceBuilder {
+
+        private final String name;
+        private char[] source = new char[DEFAULT_CAPACITY];
+        private int size = 0;
+
+        public SourceBuilder(String name) {
+            this.name = name;
+        }
+
+        public SourceBuilder read(Reader reader) {
+            try {
+                char[] buffer = new char[1024 * 4];
+                int amountJustRead = 0;
+                while ((amountJustRead = reader.read(buffer)) != -1) {
+                    ensureCapacity(size + amountJustRead);
+                    append(buffer, amountJustRead);
+                }
+                reader.close();
+            } catch (IOException ex) {
+                Logger.getLogger(Source.class.getName()).log(Level.SEVERE, null, ex);
+            }
+            return this;
+        }
+
+        public SourceBuilder append(char[] characters, int amount) {
+            for (int i = 0; i < amount; ++i) {
+                this.source[size + i] = characters[i];
+            }
+            size += amount;
+            return this;
+        }
+
+        public Source build() {
+            return new Source(this.name, this.source, this.size);
+        }
+
+        private void ensureCapacity(int minCapacity) {
+            if (source.length - minCapacity < 0) {
+                grow(minCapacity);
+            }
+        }
+
+        private void grow(int minCapacity) {
+            int oldCapacity = source.length;
+            int newCapacity = Math.max(oldCapacity << 1, minCapacity);
+
+            this.source = Arrays.copyOf(source, newCapacity);
+        }
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/model/template/Block.java b/src/main/java/component/expressionLanguage/model/template/Block.java
new file mode 100644
index 0000000..33a2372
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/template/Block.java
@@ -0,0 +1,10 @@
+package component.expressionLanguage.model.template;
+
+import component.expressionLanguage.EvaluationContext;
+
+public interface Block {
+
+    String getName();
+
+    void evaluate(Template self, EvaluationContext context);
+}
diff --git a/src/main/java/component/expressionLanguage/model/template/Hierarchy.java b/src/main/java/component/expressionLanguage/model/template/Hierarchy.java
new file mode 100644
index 0000000..42f6168
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/template/Hierarchy.java
@@ -0,0 +1,85 @@
+package component.expressionLanguage.model.template;
+
+import java.util.ArrayList;
+
+/**
+ * A data structure that represents the entire inheritance hierarchy
+ * of the current template and tracks which level in the hierarchy
+ * we are currently evaluating.
+ */
+public class Hierarchy {
+
+    /**
+     * A list of all the templates in this hierarchy. A template at index i is the child
+     * to the template at index i+1.
+     */
+    private final ArrayList<Template> hierarchy = new ArrayList<>();
+
+    /**
+     * Index of the template currently being evaluated.
+     */
+    private int current = 0;
+
+    /**
+     * Constructs an inheritance chain with one known template.
+     *
+     * @param current The current node
+     */
+    public Hierarchy(Template current) {
+        hierarchy.add(current);
+    }
+
+    /**
+     * Adds a known ancestor onto the inheritance chain, does not
+     * increment which template is the "current" template being evaluated.
+     *
+     * @param ancestor The ancestor template
+     */
+    public void pushAncestor(Template ancestor) {
+        hierarchy.add(ancestor);
+    }
+
+    /**
+     * Signifies that the parent template in the hierarchy is now being evaluated so it should
+     * be considered the "current" template.
+     */
+    public void ascend() {
+        current++;
+    }
+
+    /**
+     * Signifies that the child template in the hierarchy is now being evaluated so i t
+     * should be considered the "current" template.
+     */
+    public void descend() {
+        current--;
+    }
+
+    /**
+     * Returns the child of the template currently being evaluated or null if there is no child.
+     *
+     * @return The child template if exists or null
+     */
+    public Template getChild() {
+        if (current == 0) {
+            return null;
+        }
+        return hierarchy.get(current - 1);
+    }
+
+    /**
+     * Returns the parent of the template currently being evaluated or null if there is no parent.
+     *
+     * @return The parent template if exists or null
+     */
+    public Template getParent() {
+        if (current == hierarchy.size() - 1) {
+            return null;
+        }
+        return hierarchy.get(current + 1);
+    }
+    
+    public Template get() {
+        return hierarchy.get(current);
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/model/template/Template.java b/src/main/java/component/expressionLanguage/model/template/Template.java
new file mode 100644
index 0000000..86d84cc
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/template/Template.java
@@ -0,0 +1,203 @@
+package component.expressionLanguage.model.template;
+
+import component.expressionLanguage.Engine;
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.function.Function;
+import component.expressionLanguage.model.tree.ArgumentsNode;
+import component.expressionLanguage.model.tree.RootNode;
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * The actual implementation of a Template
+ */
+public class Template {
+
+    /**
+     * A template has to store a reference to the main engine so that it can
+     * compile other templates when using the "import" or "include" tags.
+     * <p>
+     * It will also retrieve some stateful information such as the default locale
+     * when necessary. Luckily, the engine is immutable so this should be thread safe.
+     */
+    private final Engine engine;
+
+    /**
+     * Blocks defined inside this template.
+     */
+    private final Map<String, Block> blocks = new HashMap<>();
+
+    /**
+     * Macros defined inside this template.
+     */
+    private final Map<String, Function> macros = new HashMap<>();
+
+    /**
+     * The root node of the AST to be rendered.
+     */
+    private final RootNode rootNode;
+
+    /**
+     * Name of template. Used to help with debugging.
+     */
+    private final String name;
+
+    /**
+     * Constructor
+     *
+     * @param engine The engine used to construct this template
+     * @param root   The root not to evaluate
+     * @param name   The name of the template
+     */
+    public Template(Engine engine, RootNode root, String name) {
+        this.engine = engine;
+        this.rootNode = root;
+        this.name = name;
+    }
+    
+    /**
+     * Registers a block.
+     *
+     * @param block The block
+     */
+    public void registerBlock(Block block) {
+        blocks.put(block.getName(), block);
+    }
+
+    /**
+     * Registers a macro
+     *
+     * @param macro The macro
+     */
+    public void registerMacro(Function macro) {
+        if (macros.containsKey(macro.getName())) {
+            String msg = String.format("More than one macro can not share the same name: %s", macro.getName());
+            throw new IllegalStateException(msg);
+        }
+        this.macros.put(macro.getName(), macro);
+    }
+
+    public void setParent(EvaluationContext context, String parentName) throws Exception {
+        context.getHierarchy().pushAncestor(engine.load(parentName));
+    }
+    
+    /**
+     * A typical block declaration will use this method which evaluates the
+     * block using the regular user-provided writer.
+     *
+     * @param blockName       The name of the block
+     * @param context         The evaluation context
+     * @param ignoreOverriden Whether or not to ignore overriden blocks
+     */
+    public void block(EvaluationContext context, String blockName, boolean ignoreOverriden) {
+
+        Hierarchy hierarchy = context.getHierarchy();
+        Template childTemplate = hierarchy.getChild();
+
+        // check child
+        if (!ignoreOverriden && childTemplate != null) {
+            hierarchy.descend();
+            childTemplate.block(context, blockName, false);
+            hierarchy.ascend();
+
+            // check this template
+        } else if (blocks.containsKey(blockName)) {
+            Block block = blocks.get(blockName);
+            block.evaluate(this, context);
+
+            // delegate to parent
+        } else {
+            if (hierarchy.getParent() != null) {
+                Template parent = hierarchy.getParent();
+                hierarchy.ascend();
+                parent.block(context, blockName, true);
+                hierarchy.descend();
+            }
+        }
+
+    }
+    
+    /**
+     * Invokes a macro
+     *
+     * @param context         The evaluation context
+     * @param macroName       The name of the macro
+     * @param args            The arguments
+     * @param ignoreOverriden Whether or not to ignore macro definitions in child template
+     * @return The results of the macro invocation
+     */
+    public String macro(EvaluationContext context, String macroName, ArgumentsNode args, boolean ignoreOverriden) {
+        String result = null;
+        boolean found = false;
+
+        Template childTemplate = context.getHierarchy().getChild();
+
+        // check child template first
+        if (!ignoreOverriden && childTemplate != null) {
+            found = true;
+            context.getHierarchy().descend();
+            result = childTemplate.macro(context, macroName, args, false);
+            context.getHierarchy().ascend();
+
+            // check current template
+        } else if (hasMacro(macroName)) {
+            found = true;
+            Function macro = macros.get(macroName);
+
+            Map<String, Object> namedArguments = args.getArgumentMap(context, macro);
+            result = (String) macro.evaluate(context, namedArguments);
+        }
+
+        // check imported templates
+        if (!found) {
+            for (Template template : context.getImported()) {
+                if (template.hasMacro(macroName)) {
+                    found = true;
+                    result = template.macro(context, macroName, args, false);
+                }
+            }
+        }
+
+        // delegate to parent template
+        if (!found) {
+            if (context.getHierarchy().getParent() != null) {
+                Template parent = context.getHierarchy().getParent();
+                context.getHierarchy().ascend();
+                result = parent.macro(context, macroName, args, true);
+                context.getHierarchy().descend();
+            } else {
+                String msg = String.format("Function or Macro [%s] does not exist.", macroName);
+                throw new IllegalStateException(msg);
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * Checks if a macro exists
+     *
+     * @param macroName The name of the macro
+     * @return Whether or not the macro exists
+     */
+    public boolean hasMacro(String macroName) {
+        return macros.containsKey(macroName);
+    }
+    /**
+     * Returns the template name
+     *
+     * @return The name of the template
+     */
+    public String getName() {
+        return name;
+    }
+
+    public RootNode getRootNode() {
+        return rootNode;
+    }
+    
+    @Override
+    public String toString() {
+        return "Template{" + "engine=" + engine + ", blocks=" + blocks + ", macros=" + macros + ", rootNode=" + rootNode + ", name=" + name + '}';
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/ArgumentNode.java b/src/main/java/component/expressionLanguage/model/tree/ArgumentNode.java
new file mode 100644
index 0000000..6345d65
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/ArgumentNode.java
@@ -0,0 +1,29 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+
+public class ArgumentNode extends Node {
+
+    private String name;
+    private final Expression<?> value;
+
+    public ArgumentNode(Position position, Expression<?> value) {
+        super(position);
+        this.value = value;
+    }
+    
+    public ArgumentNode(Position position, Expression<?> value, String name) {
+        this(position, value);
+        this.name = name;
+    }
+
+    public Expression<?> getValue() {
+        return value;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/ArgumentsNode.java b/src/main/java/component/expressionLanguage/model/tree/ArgumentsNode.java
new file mode 100644
index 0000000..d78afed
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/ArgumentsNode.java
@@ -0,0 +1,80 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.function.Function;
+import component.expressionLanguage.model.position.Position;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+public class ArgumentsNode extends Node {
+
+    private final List<ArgumentNode> args;
+
+    public ArgumentsNode(Position position, List<ArgumentNode> args) {
+        super(position);
+        this.args = args;
+    }
+
+    public List<ArgumentNode> getArgs() {
+        return args;
+    }
+
+    /**
+     * Using hints from the filter/function/test/macro it will convert an
+     * ArgumentMap (which holds both positional and named arguments) into a
+     * regular Map that the filter/function/test/macro is expecting.
+     *
+     * @param context
+     *            The evaluation context
+     * @param invocableWithNamedArguments
+     *            The named arguments object
+     * @return Returns a map representaion of the arguments
+     */
+    public Map<String, Object> getArgumentMap(EvaluationContext context, Function invocableWithNamedArguments) {
+        Map<String, Object> result = new HashMap<>();
+        List<String> argumentNames = invocableWithNamedArguments.getArgumentNames();
+
+        if (argumentNames == null) {
+
+            /* Some functions such as min and max use un-named varags */
+            if (args != null && !args.isEmpty()) {
+                for (int i = 0; i < args.size(); i++) {
+                    result.put(String.valueOf(i), args.get(i).getValue().evaluate(context));
+                }
+            }
+        } else {
+
+            if (args != null) {
+                int nameIndex = 0;
+
+                for (ArgumentNode arg : args) {
+                    if (argumentNames.size() <= nameIndex) {
+                        String msg = String.format("The argument at position %s is not allowed. Only %s argument(s) are allowed at line %s in file %s.", nameIndex + 1, argumentNames.size());
+                        throw new IllegalArgumentException(msg);
+                    }
+
+                    result.put(argumentNames.get(nameIndex), arg.getValue().evaluate(context));
+                    nameIndex++;
+                }
+            }
+
+            if (args != null) {
+                for (ArgumentNode arg : args) {
+                    // check if user used an incorrect name
+                    if (!argumentNames.contains(arg.getName())) {
+                        String msg = String.format("The following named argument does not exist: %s at line %s in file %s", arg.getName());
+                        throw new IllegalArgumentException(msg);
+                    }
+                    Object value = arg.getValue() == null ? null : arg.getValue().evaluate(context);
+                    result.put(arg.getName(), value);
+                }
+            }
+        }
+
+        result.put("_context", context);
+
+        return result;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/AutoEscapeNode.java b/src/main/java/component/expressionLanguage/model/tree/AutoEscapeNode.java
new file mode 100644
index 0000000..43d185f
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/AutoEscapeNode.java
@@ -0,0 +1,42 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.model.position.Position;
+
+public class AutoEscapeNode extends Node {
+
+    private final BodyNode body;
+
+    private final String strategy;
+
+    private final boolean active;
+
+    public AutoEscapeNode(Position position, BodyNode body, boolean active, String strategy) {
+        super(position);
+        this.body = body;
+        this.strategy = strategy;
+        this.active = active;
+    }
+
+//    @Override
+//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
+//        body.render(self, writer, context);
+//    }
+
+//    @Override
+//    public void visit(NodeVisitor visitor) {
+//        visitor.accept(this);
+//    }
+
+    public BodyNode getBody() {
+        return body;
+    }
+
+    public String getStrategy() {
+        return strategy;
+    }
+
+    public boolean isActive() {
+        return active;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/BlockNode.java b/src/main/java/component/expressionLanguage/model/tree/BlockNode.java
new file mode 100644
index 0000000..6ed9a35
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/BlockNode.java
@@ -0,0 +1,58 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.template.Block;
+import component.expressionLanguage.model.template.Template;
+import java.io.IOException;
+
+public class BlockNode extends Node {
+
+    private final BodyNode body;
+
+    private String name;
+
+    public BlockNode(Position position, String name) {
+        this(position, name, null);
+    }
+
+    public BlockNode(Position position, String name, BodyNode body) {
+        super(position);
+        this.body = body;
+        this.name = name;
+    }
+
+//    @Override
+//    public void render(final Template self, Writer writer, EvaluationContext context) throws Exception {
+//        self.block(writer, context, name, false);
+//    }
+//
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    public Block getBlock() {
+        return new Block() {
+
+            @Override
+            public String getName() {
+                return name;
+            }
+
+            @Override
+            public void evaluate(Template self, EvaluationContext context) {
+//                body.render(self, writer, context);
+            }
+        };
+    }
+
+    public BodyNode getBody() {
+        return body;
+    }
+
+    public String getName() {
+        return name;
+    }
+    
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/BodyNode.java b/src/main/java/component/expressionLanguage/model/tree/BodyNode.java
new file mode 100644
index 0000000..b277d62
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/BodyNode.java
@@ -0,0 +1,63 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.visitor.NodeVisitor;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Consumer;
+
+public class BodyNode extends Node {
+
+    private final List<Node> children;
+
+    private static final List<Class<? extends Node>> nodesToRenderInChild = new ArrayList<>();
+
+    static {
+        nodesToRenderInChild.add(SetNode.class);
+        nodesToRenderInChild.add(ImportNode.class);
+    }
+
+    /**
+     * When a template extends a parent template there are very few nodes in the
+     * child that should actually get rendered such as set and import. All
+     * others should be ignored.
+     */
+    private boolean onlyRenderInheritanceSafeNodes = false;
+
+    public BodyNode(Position position, List<Node> children) {
+        super(position);
+        this.children = children;
+    }
+
+//    @Override
+//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
+//        for (RenderableNode child : children) {
+//            if (onlyRenderInheritanceSafeNodes && context.getHierarchy().getParent() != null) {
+//                if (!nodesToRenderInChild.contains(child.getClass())) {
+//                    continue;
+//                }
+//            }
+//            child.render(self, writer, context);
+//        }
+//    }
+
+    @Override
+    public void accept(NodeVisitor visitor) {
+        super.accept(visitor);
+        
+        this.children.forEach((node) -> node.accept(visitor));
+    }
+
+    public List<Node> getChildren() {
+        return children;
+    }
+
+    public boolean isOnlyRenderInheritanceSafeNodes() {
+        return onlyRenderInheritanceSafeNodes;
+    }
+
+    public void setOnlyRenderInheritanceSafeNodes(boolean onlyRenderInheritanceSafeNodes) {
+        this.onlyRenderInheritanceSafeNodes = onlyRenderInheritanceSafeNodes;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/ExtendsNode.java b/src/main/java/component/expressionLanguage/model/tree/ExtendsNode.java
new file mode 100644
index 0000000..b1995ea
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/ExtendsNode.java
@@ -0,0 +1,28 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+
+public class ExtendsNode extends Node {
+
+    Expression<?> parentExpression;
+
+    public ExtendsNode(Position position, Expression<?> parentExpression) {
+        super(position);
+        this.parentExpression = parentExpression;
+    }
+
+//    @Override
+//    public void render(final Template self, Writer writer, final EvaluationContext context) throws Exception {
+//        self.setParent(context, (String) parentExpression.evaluate(self, context));
+//    }
+//
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    public Expression<?> getParentExpression() {
+        return parentExpression;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/FlushNode.java b/src/main/java/component/expressionLanguage/model/tree/FlushNode.java
new file mode 100644
index 0000000..c0a25b8
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/FlushNode.java
@@ -0,0 +1,20 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.model.position.Position;
+
+public class FlushNode extends Node {
+
+    public FlushNode(Position position) {
+        super(position);
+    }
+
+//    @Override
+//    public void render(Template self, Writer writer, EvaluationContext context) throws IOException {
+//        writer.flush();
+//    }
+//
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/ForNode.java b/src/main/java/component/expressionLanguage/model/tree/ForNode.java
new file mode 100644
index 0000000..693d5ca
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/ForNode.java
@@ -0,0 +1,214 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.visitor.NodeVisitor;
+import java.lang.reflect.Array;
+import java.util.*;
+
+/**
+ * Represents a "for" loop within the template.
+ *
+ */
+public class ForNode extends Node {
+
+    private final String variableName;
+
+    private final Expression<?> iterableExpression;
+
+    private final BodyNode body;
+
+    private final BodyNode elseBody;
+
+    public ForNode(Position position, String variableName, Expression<?> iterableExpression, BodyNode body, BodyNode elseBody) {
+        super(position);
+        this.variableName = variableName;
+        this.iterableExpression = iterableExpression;
+        this.body = body;
+        this.elseBody = elseBody;
+    }
+
+    @Override
+    public void accept(NodeVisitor visitor) {
+        super.accept(visitor);
+//        Object iterableEvaluation = iterableExpression.evaluate(self, context);
+//        Iterable<?> iterable;
+//
+    }
+    
+//    @Override
+//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
+//        Object iterableEvaluation = iterableExpression.evaluate(self, context);
+//        Iterable<?> iterable;
+//
+//        if (iterableEvaluation == null) {
+//            return;
+//        }
+//
+//        iterable = toIterable(iterableEvaluation);
+//
+//        if (iterable == null) {
+//            String msg = String.format("Not an iterable object. Value = [%s] at line %s in file %s.", iterableEvaluation, getLineNumber(), self.getName());
+//            throw new Exception(msg);
+//        }
+//
+//        Iterator<?> iterator = iterable.iterator();
+//
+//        boolean newScope = false;
+//
+//        if (iterator.hasNext()) {
+//
+//            ScopeChain scopeChain = context.getScopeChain();
+//
+//            /*
+//             * Only if there is a variable name conflict between one of the
+//             * variables added by the for loop construct and an existing
+//             * variable do we push another scope, otherwise we reuse the current
+//             * scope for performance purposes.
+//             */
+//            if (scopeChain.currentScopeContainsVariable("loop") || scopeChain
+//                    .currentScopeContainsVariable(variableName)) {
+//                scopeChain.pushScope();
+//                newScope = true;
+//            }
+//
+//            int length = getIteratorSize(iterableEvaluation);
+//            int index = 0;
+//
+//            Map<String, Object> loop = new HashMap<>();
+//
+//            boolean usingExecutorService = context.getExecutorService() != null;
+//
+//            while (iterator.hasNext()) {
+//
+//                /*
+//                 * If the user is using an executor service (i.e. parallel node), we
+//                 * must create a new map with every iteration instead of
+//                 * re-using the same one; it's imperative that each thread would
+//                 * get it's own distinct copy of the context.
+//                 */
+//                if (index == 0 || usingExecutorService) {
+//                    loop.put("first", index == 0);
+//                    loop.put("last", index == length - 1);
+//                    loop.put("length", length);
+//                }else{
+//
+//                    // second iteration
+//                    if(index == 1){
+//                        loop.put("first", false);
+//                    }
+//
+//                    // last iteration
+//                    if(index == length - 1){
+//                        loop.put("last", true);
+//                    }
+//                }
+//
+//                loop.put("revindex", length - index - 1);
+//                loop.put("index", index++);
+//
+//                scopeChain.put("loop", loop);
+//
+//                scopeChain.put(variableName, iterator.next());
+//                body.render(self, writer, context);
+//            }
+//
+//            if (newScope) {
+//                scopeChain.popScope();
+//            }
+//
+//        } else if (elseBody != null) {
+//            elseBody.render(self, writer, context);
+//        }
+//
+//    }
+//
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    public String getIterationVariable() {
+        return variableName;
+    }
+
+    public Expression<?> getIterable() {
+        return iterableExpression;
+    }
+
+    public BodyNode getBody() {
+        return body;
+    }
+
+    public BodyNode getElseBody() {
+        return elseBody;
+    }
+
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    private Iterable<Object> toIterable(final Object obj) {
+
+        Iterable<Object> result = null;
+
+        if (obj instanceof Iterable<?>) {
+
+            result = (Iterable<Object>) obj;
+
+        } else if (obj instanceof Map) {
+
+            // raw type
+            result = ((Map) obj).entrySet();
+
+        } else if (obj.getClass().isArray()) {
+
+            if (Array.getLength(obj) == 0) {
+                return new ArrayList<>(0);
+            }
+
+            result = () -> new Iterator<Object>() {
+                
+                private int index = 0;
+                
+                private final int length = Array.getLength(obj);
+                
+                @Override
+                public boolean hasNext() {
+                    return index < length;
+                }
+                
+                @Override
+                public Object next() {
+                    return Array.get(obj, index++);
+                }
+                
+                @Override
+                public void remove() {
+                    throw new UnsupportedOperationException();
+                }
+            };
+        }
+
+        return result;
+    }
+
+    private int getIteratorSize(Object iterable) {
+        if (iterable == null) {
+            return 0;
+        }
+        if (iterable instanceof Collection) {
+            return ((Collection<?>) iterable).size();
+        } else if (iterable instanceof Map) {
+            return ((Map<?, ?>) iterable).size();
+        } else if (iterable.getClass().isArray()) {
+            return Array.getLength(iterable);
+        }
+
+        // assumed to be of type Iterator
+        Iterator<?> it = ((Iterable<?>) iterable).iterator();
+        int size = 0;
+        while (it.hasNext()) {
+            size++;
+            it.next();
+        }
+        return size;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/FunctionOrMacroNameNode.java b/src/main/java/component/expressionLanguage/model/tree/FunctionOrMacroNameNode.java
new file mode 100644
index 0000000..1c69597
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/FunctionOrMacroNameNode.java
@@ -0,0 +1,35 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+
+public class FunctionOrMacroNameNode extends Node implements Expression<String> {
+
+    private final String name;
+
+    public FunctionOrMacroNameNode(Position position, String name) {
+        super(position);
+        this.name = name;
+    }
+
+    @Override
+    public String evaluate(EvaluationContext context) {
+        throw new UnsupportedOperationException();
+    }
+//
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    public String getName() {
+        return name;
+    }
+
+//    @Override
+//    public int getLineNumber() {
+//        return this.lineNumber;
+//    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/IfNode.java b/src/main/java/component/expressionLanguage/model/tree/IfNode.java
new file mode 100644
index 0000000..0f0c122
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/IfNode.java
@@ -0,0 +1,74 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+import java.util.List;
+import javafx.util.Pair;
+
+public class IfNode extends Node {
+
+    private final List<Pair<Expression<?>, BodyNode>> conditionsWithBodies;
+
+    private final BodyNode elseBody;
+
+    public IfNode(Position position, List<Pair<Expression<?>, BodyNode>> conditionsWithBodies) {
+        this(position, conditionsWithBodies, null);
+    }
+
+    public IfNode(Position position, List<Pair<Expression<?>, BodyNode>> conditionsWithBodies, BodyNode elseBody) {
+        super(position);
+        this.conditionsWithBodies = conditionsWithBodies;
+        this.elseBody = elseBody;
+    }
+
+//    @Override
+//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
+//
+//        boolean satisfied = false;
+//        for (Pair<Expression<?>, BodyNode> ifStatement : conditionsWithBodies) {
+//
+//            Expression<?> conditionalExpression = ifStatement.getKey();
+//
+//            try {
+//
+//                Object result = conditionalExpression.evaluate(self, context);
+//
+//                if (result != null) {
+//                    try {
+//                        satisfied = (Boolean) result;
+//                    } catch (ClassCastException ex) {
+//                        String msg = String.format("Expected a Boolean in \"if\" statement at line %s in file %s.", getLineNumber(), self.getName());
+//                        throw new Exception(msg);
+//                    }
+//                }
+//
+//            } catch (RuntimeException ex) {
+//                String msg = String.format("Wrong operand(s) type in conditional expression at line %s in file %s.", getLineNumber(), self.getName());
+//                throw new Exception(msg);
+//            }
+//
+//            if (satisfied) {
+//                ifStatement.getValue().render(self, writer, context);
+//                break;
+//            }
+//        }
+//
+//        if (!satisfied && elseBody != null) {
+//            elseBody.render(self, writer, context);
+//        }
+//    }
+
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    public List<Pair<Expression<?>, BodyNode>> getConditionsWithBodies() {
+        return conditionsWithBodies;
+    }
+
+    public BodyNode getElseBody() {
+        return elseBody;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/ImportNode.java b/src/main/java/component/expressionLanguage/model/tree/ImportNode.java
new file mode 100644
index 0000000..31188ee
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/ImportNode.java
@@ -0,0 +1,29 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+
+public class ImportNode extends Node {
+
+    private final Expression<?> importExpression;
+
+    public ImportNode(Position position, Expression<?> importExpression) {
+        super(position);
+        this.importExpression = importExpression;
+    }
+
+//    @Override
+//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
+//        self.importTemplate(context, (String) importExpression.evaluate(self, context));
+//    }
+//
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    public Expression<?> getImportExpression() {
+        return importExpression;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/IncludeNode.java b/src/main/java/component/expressionLanguage/model/tree/IncludeNode.java
new file mode 100644
index 0000000..54d66eb
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/IncludeNode.java
@@ -0,0 +1,44 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.extension.core.expression.MapExpression;
+import component.expressionLanguage.model.position.Position;
+
+public class IncludeNode extends Node {
+
+    private final Expression<?> includeExpression;
+
+    private final MapExpression mapExpression;
+
+    public IncludeNode(Position position, Expression<?> includeExpression, MapExpression mapExpression) {
+        super(position);
+        this.includeExpression = includeExpression;
+        this.mapExpression = mapExpression;
+    }
+
+//    @Override
+//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
+//        String templateName = (String) includeExpression.evaluate(self, context);
+//
+//        Map<?, ?> map = Collections.emptyMap();
+//        if (this.mapExpression != null) {
+//            map = this.mapExpression.evaluate(self, context);
+//        }
+//
+//        if (templateName == null) {
+//            String msg = String.format("The template name in an include tag evaluated to NULL. If the template name is static, make sure to wrap it in quotes. template [%s] at line %s in file %s.", templateName, getLineNumber(), self.getName());
+//            throw new Exception(msg);
+//        }
+//        self.includeTemplate(writer, context, templateName, map);
+//    }
+//
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    public Expression<?> getIncludeExpression() {
+        return includeExpression;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/MacroNode.java b/src/main/java/component/expressionLanguage/model/tree/MacroNode.java
new file mode 100644
index 0000000..654ba8e
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/MacroNode.java
@@ -0,0 +1,120 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.EvaluationContext;
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.function.Function;
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.scope.ScopeChain;
+import java.util.Map;
+
+public class MacroNode extends Node {
+
+    private final String name;
+
+    private final ArgumentsNode args;
+
+    private final BodyNode body;
+
+    public MacroNode(Position position, String name, ArgumentsNode args, BodyNode body) {
+        super(position);
+        this.name = name;
+        this.args = args;
+        this.body = body;
+    }
+
+//    @Override
+//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
+//        // do nothing
+//    }
+//
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    public Function getMacro() {
+        return Function.builder()
+                .named(name)
+                .evaluation((EvaluationContext context, Map<String, Object> macroArgs) -> {
+                    ScopeChain scopeChain = context.getScopeChain();
+                    scopeChain.pushLocalScope();
+                    getArgs().getArgs().stream().forEach((arg) -> {
+                        Expression<?> valueExpression = arg.getValue();
+                        if (valueExpression == null) {
+                            scopeChain.put(arg.getName(), null);
+                        } else {
+                            scopeChain.put(arg.getName(), valueExpression.evaluate(context));
+                        }
+                    });
+                    
+                    // scope for user provided arguments
+                    scopeChain.pushScope(macroArgs);
+
+//                    getBody().render(self, writer, context);
+
+                    scopeChain.popScope(); // user arguments
+                    scopeChain.popScope(); // default arguments
+
+                    return "";
+                })
+                .build();
+                
+//                new Macro() {
+//
+//            @Override
+//            public List<String> getArgumentNames() {
+//                List<String> names = new ArrayList<>();
+//                getArgs().getNamedArgs().stream().forEach((arg) -> {
+//                    names.add(arg.getName());
+//                });
+//                return names;
+//            }
+//
+//            @Override
+//            public String getName() {
+//                return name;
+//            }
+//
+//            @Override
+//            public String call(EvaluationContext context, Map<String, Object> macroArgs) throws Exception {
+//                Writer writer = new StringWriter();
+//                ScopeChain scopeChain = context.getScopeChain();
+//
+//                // scope for default arguments
+//                scopeChain.pushLocalScope();
+//                for (NamedArgumentNode arg : getArgs().getNamedArgs()) {
+//                    Expression<?> valueExpression = arg.getValueExpression();
+//                    if (valueExpression == null) {
+//                        scopeChain.put(arg.getName(), null);
+//                    } else {
+//                        scopeChain.put(arg.getName(), arg.getValueExpression().evaluate(context));
+//                    }
+//                }
+//
+//                // scope for user provided arguments
+//                scopeChain.pushScope(macroArgs);
+//                
+////                getBody().render(self, writer, context);
+//
+//                scopeChain.popScope(); // user arguments
+//                scopeChain.popScope(); // default arguments
+//
+//                return writer.toString();
+//            }
+
+//        };
+    }
+
+    public BodyNode getBody() {
+        return body;
+    }
+
+    public ArgumentsNode getArgs() {
+        return args;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/NamedArgumentNode.java b/src/main/java/component/expressionLanguage/model/tree/NamedArgumentNode.java
new file mode 100644
index 0000000..a34658b
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/NamedArgumentNode.java
@@ -0,0 +1,26 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+
+public class NamedArgumentNode extends Node {
+
+    private final Expression<?> value;
+
+    private final String name;
+
+    public NamedArgumentNode(Position position, String name, Expression<?> value) {
+        super(position);
+        this.name = name;
+        this.value = value;
+    }
+
+    public Expression<?> getValueExpression() {
+        return value;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/Node.java b/src/main/java/component/expressionLanguage/model/tree/Node.java
new file mode 100644
index 0000000..24e1bb1
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/Node.java
@@ -0,0 +1,21 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.visitor.NodeVisitor;
+
+public abstract class Node {
+
+    private final Position position;
+
+    protected Node(Position position) {
+        this.position = position;
+    }
+
+    public Position getPosition() {
+        return position;
+    }
+
+    public void accept(NodeVisitor visitor) {
+        visitor.visit(this);
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/ParallelNode.java b/src/main/java/component/expressionLanguage/model/tree/ParallelNode.java
new file mode 100644
index 0000000..4a28d0f
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/ParallelNode.java
@@ -0,0 +1,72 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.model.position.Position;
+import java.util.logging.Logger;
+
+public class ParallelNode extends Node {
+
+    private static final Logger LOGGER = Logger.getLogger(ParallelNode.class.getName());
+
+    private final BodyNode body;
+
+    /**
+     * If the user is using the parallel tag but doesn't provide an
+     * ExecutorService we will warn them that this tag will essentially be
+     * ignored but it's important that we only warn them once because this tag
+     * may show up in a loop.
+     */
+    private boolean hasWarnedAboutNonExistingExecutorService = false;
+
+    public ParallelNode(Position position, BodyNode body) {
+        super(position);
+        this.body = body;
+    }
+
+//    @Override
+//    public void render(final Template self, Writer writer, final EvaluationContext context) throws Exception {
+//
+//        ExecutorService es = context.getExecutorService();
+//
+//        if (es == null) {
+//
+//            if (!hasWarnedAboutNonExistingExecutorService) {
+//                LOGGER.info(String.format(
+//                        "The parallel tag was used [%s:%d] but no ExecutorService was provided. The parallel tag will be ignored "
+//                                + "and it's contents will be rendered in sequence with the rest of the template.",
+//                        self.getName(), getLineNumber()));
+//                hasWarnedAboutNonExistingExecutorService = true;
+//            }
+//
+//            /*
+//             * If user did not provide an ExecutorService, we simply ignore the
+//             * parallel tag and render it's contents like we normally would.
+//             */
+//            body.render(self, writer, context);
+//            
+//        } else {
+//
+//            final EvaluationContext contextCopy = context.threadSafeCopy(self);
+//
+//            final StringWriter newStringWriter = new StringWriter();
+//            final Writer newFutureWriter = new FutureWriter(newStringWriter);
+//
+//            Future<String> future = es.submit(() -> {
+//                body.render(self, newFutureWriter, contextCopy);
+//                newFutureWriter.flush();
+//                newFutureWriter.close();
+//                return newStringWriter.toString();
+//            });
+//            
+//            ((FutureWriter) writer).enqueue(future);
+//        }
+//    }
+//
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    public BodyNode getBody() {
+        return body;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/PrintNode.java b/src/main/java/component/expressionLanguage/model/tree/PrintNode.java
new file mode 100644
index 0000000..dc02d4a
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/PrintNode.java
@@ -0,0 +1,31 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+
+public class PrintNode extends Node {
+
+    private Expression<?> expression;
+
+    public PrintNode(Position position, Expression<?> expression) {
+        super(position);
+        this.expression = expression;
+    }
+
+//    @Override
+//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
+//        Object var = expression.evaluate(self, context);
+//        if (var != null) {
+//            writer.write(ObjectUtils.nullSafeToString(var));
+//        }
+//    }
+
+    public Expression<?> getExpression() {
+        return expression;
+    }
+
+    public void setExpression(Expression<?> expression) {
+        this.expression = expression;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/RootNode.java b/src/main/java/component/expressionLanguage/model/tree/RootNode.java
new file mode 100644
index 0000000..11e0675
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/RootNode.java
@@ -0,0 +1,33 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.model.position.Position;
+import component.expressionLanguage.model.visitor.NodeVisitor;
+
+public class RootNode extends Node {
+
+    private final BodyNode body;
+
+    public RootNode(Position position, BodyNode body) {
+        super(position);
+        this.body = body;
+    }
+
+//    @Override
+//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
+//        body.setOnlyRenderInheritanceSafeNodes(true);
+//        body.render(self, writer, context);
+//    }
+//
+    @Override
+    public void accept(NodeVisitor visitor) {
+        super.accept(visitor);
+        
+        if (getBody() != null) {
+            getBody().accept(visitor);
+        }
+    }
+
+    public BodyNode getBody() {
+        return body;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/SetNode.java b/src/main/java/component/expressionLanguage/model/tree/SetNode.java
new file mode 100644
index 0000000..731cbfc
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/SetNode.java
@@ -0,0 +1,31 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.model.position.Position;
+
+public class SetNode extends Node {
+
+    private final String name;
+
+    private final Expression<?> value;
+
+    public SetNode(Position position, String name, Expression<?> value) {
+        super(position);
+        this.name = name;
+        this.value = value;
+    }
+
+//    @Override
+//    public void render(Template self, Writer writer, EvaluationContext context) throws Exception {
+//        context.getScopeChain().put(name, value.evaluate(self, context));
+//    }
+
+    public Expression<?> getValue() {
+        return value;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/TestInvocationExpressionNode.java b/src/main/java/component/expressionLanguage/model/tree/TestInvocationExpressionNode.java
new file mode 100644
index 0000000..e259de4
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/TestInvocationExpressionNode.java
@@ -0,0 +1,28 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.model.position.Position;
+
+/**
+ * The right hand side to the test expression.
+ */
+public class TestInvocationExpressionNode extends Node {
+
+    private final String testName;
+
+    private final ArgumentsNode args;
+
+    public TestInvocationExpressionNode(Position position, String testName, ArgumentsNode args) {
+        super(position);
+        this.testName = testName;
+        this.args = args;
+    }
+
+    public ArgumentsNode getArgs() {
+        return args;
+    }
+
+    public String getTestName() {
+        return testName;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/tree/TextNode.java b/src/main/java/component/expressionLanguage/model/tree/TextNode.java
new file mode 100644
index 0000000..6867770
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/tree/TextNode.java
@@ -0,0 +1,38 @@
+package component.expressionLanguage.model.tree;
+
+import component.expressionLanguage.model.position.Position;
+
+/**
+ * Represents static text in a template.
+ */
+public class TextNode extends Node {
+
+    /**
+     * Most Writers will convert strings to char[] so we might as well store it
+     * as a char[] to begin with; small performance optimization.
+     */
+    private final char[] data;
+
+    public TextNode(Position position, String text) {
+        super(position);
+
+        int length = text.length();
+        this.data = new char[text.length()];
+        text.getChars(0, length, this.data, 0);
+    }
+
+//    @Override
+//    public void render(Template self, Writer writer, EvaluationContext context) throws IOException {
+//        writer.write(data);
+//    }
+//
+//    @Override
+//    public void accept(NodeVisitor visitor) {
+//        visitor.visit(this);
+//    }
+
+    public char[] getData() {
+        return data;
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/visitor/BlockRegistrantVisitor.java b/src/main/java/component/expressionLanguage/model/visitor/BlockRegistrantVisitor.java
new file mode 100644
index 0000000..fba9a4d
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/visitor/BlockRegistrantVisitor.java
@@ -0,0 +1,24 @@
+package component.expressionLanguage.model.visitor;
+
+import component.expressionLanguage.model.template.Template;
+import component.expressionLanguage.model.tree.BlockNode;
+import component.expressionLanguage.model.tree.Node;
+
+public class BlockRegistrantVisitor implements NodeVisitor {
+        
+    private Template template;
+    
+    public BlockRegistrantVisitor(Template template) {
+        this.template = template;
+    }
+
+    @Override
+    public void visit(Node node) {
+        if (!(node instanceof BlockNode)) {
+            return;
+        }
+        
+        this.template.registerBlock(((BlockNode) node).getBlock());
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/model/visitor/MacroRegistrantVisitor.java b/src/main/java/component/expressionLanguage/model/visitor/MacroRegistrantVisitor.java
new file mode 100644
index 0000000..7dd4b43
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/visitor/MacroRegistrantVisitor.java
@@ -0,0 +1,24 @@
+package component.expressionLanguage.model.visitor;
+
+import component.expressionLanguage.function.Function;
+import component.expressionLanguage.model.template.Template;
+import component.expressionLanguage.model.tree.MacroNode;
+import component.expressionLanguage.model.tree.Node;
+
+public class MacroRegistrantVisitor implements NodeVisitor {
+        
+    private Template template;
+    
+    public MacroRegistrantVisitor(Template template) {
+        this.template = template;
+    }
+
+    @Override
+    public void visit(Node node) {
+        if (!(node instanceof MacroNode)) {
+            return;
+        }
+        Function.builder().build();
+        this.template.registerMacro(((MacroNode) node).getMacro());
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/model/visitor/NodeVisitor.java b/src/main/java/component/expressionLanguage/model/visitor/NodeVisitor.java
new file mode 100644
index 0000000..9ab3db0
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/model/visitor/NodeVisitor.java
@@ -0,0 +1,9 @@
+package component.expressionLanguage.model.visitor;
+
+import component.expressionLanguage.model.tree.Node;
+
+@FunctionalInterface
+public interface NodeVisitor {
+    
+    void visit(Node node);
+}
diff --git a/src/main/java/component/expressionLanguage/operator/Associativity.java b/src/main/java/component/expressionLanguage/operator/Associativity.java
new file mode 100644
index 0000000..3644dfe
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/operator/Associativity.java
@@ -0,0 +1,6 @@
+package component.expressionLanguage.operator;
+
+public enum Associativity {
+    RIGHT,
+    LEFT
+}
diff --git a/src/main/java/component/expressionLanguage/operator/BinaryOperator.java b/src/main/java/component/expressionLanguage/operator/BinaryOperator.java
new file mode 100644
index 0000000..21e8bad
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/operator/BinaryOperator.java
@@ -0,0 +1,17 @@
+package component.expressionLanguage.operator;
+
+import component.expressionLanguage.expression.BinaryExpression;
+
+public class BinaryOperator extends Operator {
+    
+    protected Associativity associativity;
+
+    public BinaryOperator(int precedence, Class<? extends BinaryExpression<?>> nodeClass, Associativity associativity) {
+        super(precedence, nodeClass);
+        this.associativity = associativity;
+    }
+    
+    public Associativity getAssociativity() {
+        return associativity;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/operator/Operator.java b/src/main/java/component/expressionLanguage/operator/Operator.java
new file mode 100644
index 0000000..416bb4b
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/operator/Operator.java
@@ -0,0 +1,33 @@
+package component.expressionLanguage.operator;
+
+import component.expressionLanguage.expression.Expression;
+
+public abstract class Operator {
+    
+//    protected String symbol;
+    
+    protected int precedence;
+    protected Class<? extends Expression<?>> expression;
+
+    public Operator(int precedence, Class<? extends Expression<?>> expression) {
+        this.precedence = precedence;
+        this.expression = expression;
+    }
+    
+//    public Operator(String symbol, Class<? extends Expression<?>> expression) {
+//        this.symbol = symbol;
+//        this.expression = expression;
+//    }
+    
+//    public String getSymbol(){
+//        return this.symbol;
+//    }
+
+    public Class<? extends Expression<?>> getExpression() {
+        return expression;
+    }
+    
+    public int getPrecedence(){
+        return this.precedence;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/operator/OperatorUtils.java b/src/main/java/component/expressionLanguage/operator/OperatorUtils.java
new file mode 100644
index 0000000..d40e3d2
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/operator/OperatorUtils.java
@@ -0,0 +1,288 @@
+package component.expressionLanguage.operator;
+
+import java.math.BigDecimal;
+import java.math.MathContext;
+import java.util.Collection;
+import java.util.List;
+
+/**
+ *
+ * This class acts as a sort of wrapper around Java's built in operators. This
+ * is necessary because Pebble treats all user provided variables as Objects
+ * even if they were originally primitives.
+ * <p>
+ * It's important that this class mimics the natural type conversion that Java
+ * will apply when performing operators. This can be found in section 5.6.2 of
+ * the Java 7 spec, under Binary Numeric Promotion.
+ *
+ */
+public class OperatorUtils {
+
+    private enum Operation {
+        ADD, SUBTRACT, MULTIPLICATION, DIVISION, MODULUS
+    }
+
+    private enum Comparison {
+        GREATER_THAN, GREATER_THAN_EQUALS, LESS_THAN, LESS_THAN_EQUALS, EQUALS
+    }
+
+    public static Object add(Object op1, Object op2) {
+        if (op1 instanceof String || op2 instanceof String) {
+            return concatenateStrings(String.valueOf(op1), String.valueOf(op2));
+        } else if (op1 instanceof List) {
+            return addToList((List<?>) op1, op2);
+        }
+        return wideningConversionBinaryOperation(op1, op2, Operation.ADD);
+    }
+
+    public static Object subtract(Object op1, Object op2) {
+        if (op1 instanceof List) {
+            return subtractFromList((List<?>) op1, op2);
+        }
+        return wideningConversionBinaryOperation(op1, op2, Operation.SUBTRACT);
+    }
+
+    public static Object multiply(Object op1, Object op2) {
+        return wideningConversionBinaryOperation(op1, op2, Operation.MULTIPLICATION);
+    }
+
+    public static Object divide(Object op1, Object op2) {
+        return wideningConversionBinaryOperation(op1, op2, Operation.DIVISION);
+    }
+
+    public static Object mod(Object op1, Object op2) {
+        return wideningConversionBinaryOperation(op1, op2, Operation.MODULUS);
+    }
+
+    public static boolean equals(Object op1, Object op2) {
+        if (op1 != null && op1 instanceof Number && op2 != null && op2 instanceof Number) {
+            return wideningConversionBinaryComparison(op1, op2, Comparison.EQUALS);
+        } else if (op1 != null && op1 instanceof Enum<?> && op2 != null && op2 instanceof String) {
+            return compareEnum((Enum<?>) op1, (String) op2);
+        } else if (op2 != null && op2 instanceof Enum<?> && op1 != null && op1 instanceof String) {
+            return compareEnum((Enum<?>) op2, (String) op1);
+        } else {
+            return ((op1 == op2) || ((op1 != null) && op1.equals(op2)));
+        }
+    }
+
+    private static <T extends Enum<T>> boolean compareEnum(Enum<T> enumVariable, String compareToString) {
+        return enumVariable.name().equals(compareToString);
+    }
+
+    public static boolean gt(Object op1, Object op2) {
+        return wideningConversionBinaryComparison(op1, op2, Comparison.GREATER_THAN);
+    }
+
+    public static boolean gte(Object op1, Object op2) {
+        return wideningConversionBinaryComparison(op1, op2, Comparison.GREATER_THAN_EQUALS);
+    }
+
+    public static boolean lt(Object op1, Object op2) {
+        return wideningConversionBinaryComparison(op1, op2, Comparison.LESS_THAN);
+    }
+
+    public static boolean lte(Object op1, Object op2) {
+        return wideningConversionBinaryComparison(op1, op2, Comparison.LESS_THAN_EQUALS);
+    }
+
+    public static Object unaryPlus(Object op1) {
+        return multiply(1, op1);
+    }
+
+    public static Object unaryMinus(Object op1) {
+        return multiply(-1, op1);
+    }
+
+    private static Object concatenateStrings(String op1, String op2) {
+        return op1 + op2;
+    }
+
+    /**
+     * This is not a documented feature but we are leaving this in for now. I'm
+     * unsure if there is demand for this feature.
+     *
+     * @param op1
+     * @param op2
+     * @return
+     */
+    @Deprecated
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    private static Object addToList(List<?> op1, Object op2) {
+        if (op2 instanceof Collection) {
+            op1.addAll((Collection) op2);
+        } else {
+            ((List<Object>) op1).add(op2);
+        }
+        return op1;
+    }
+
+    /**
+     * This is not a documented feature but we are leaving this in for now. I'm
+     * unsure if there is demand for this feature.
+     *
+     * @param op1
+     * @param op2
+     * @return
+     */
+    @Deprecated
+    @SuppressWarnings({ "unchecked", "rawtypes" })
+    private static Object subtractFromList(List<?> op1, Object op2) {
+        if (op2 instanceof Collection) {
+            op1.removeAll((Collection) op2);
+        } else {
+            op1.remove(op2);
+        }
+        return op1;
+    }
+
+    private static Object wideningConversionBinaryOperation(Object op1, Object op2, Operation operation) {
+
+        if (!(op1 instanceof Number) || !(op2 instanceof Number)) {
+            throw new RuntimeException(
+                    String.format("invalid operands for mathematical operation [%s]", operation.toString()));
+        }
+
+        Number num1 = (Number) op1;
+        Number num2 = (Number) op2;
+
+        if (num1 instanceof BigDecimal || num2 instanceof BigDecimal) {
+            return bigDecimalOperation(BigDecimal.valueOf(num1.doubleValue()), BigDecimal.valueOf(num2.doubleValue()),
+                    operation);
+        }
+
+        if (num1 instanceof Double || num2 instanceof Double) {
+            return doubleOperation(num1.doubleValue(), num2.doubleValue(), operation);
+        }
+
+        if (num1 instanceof Float || num2 instanceof Float) {
+            return floatOperation(num1.floatValue(), num2.floatValue(), operation);
+        }
+
+        if (num1 instanceof Long || num2 instanceof Long) {
+            return longOperation(num1.longValue(), num2.longValue(), operation);
+        }
+
+        return integerOperation(num1.intValue(), num2.intValue(), operation);
+    }
+
+    private static boolean wideningConversionBinaryComparison(Object op1, Object op2, Comparison comparison) {
+        if (op1 == null || op2 == null) {
+            return false;
+        }
+
+        Number num1;
+        Number num2;
+        try {
+            num1 = (Number) op1;
+            num2 = (Number) op2;
+        } catch (ClassCastException ex) {
+            throw new RuntimeException(
+                    String.format("invalid operands for mathematical comparison [%s]", comparison.toString()));
+        }
+
+        return doubleComparison(num1.doubleValue(), num2.doubleValue(), comparison);
+    }
+
+    private static double doubleOperation(double op1, double op2, Operation operation) {
+        switch (operation) {
+        case ADD:
+            return op1 + op2;
+        case SUBTRACT:
+            return op1 - op2;
+        case MULTIPLICATION:
+            return op1 * op2;
+        case DIVISION:
+            return op1 / op2;
+        case MODULUS:
+            return op1 % op2;
+        default:
+            throw new RuntimeException("Bug in OperatorUtils in pebble library");
+        }
+    }
+
+    private static boolean doubleComparison(double op1, double op2, Comparison comparison) {
+        switch (comparison) {
+        case GREATER_THAN:
+            return op1 > op2;
+        case GREATER_THAN_EQUALS:
+            return op1 >= op2;
+        case LESS_THAN:
+            return op1 < op2;
+        case LESS_THAN_EQUALS:
+            return op1 <= op2;
+        case EQUALS:
+            return op1 == op2;
+        default:
+            throw new RuntimeException("Bug in OperatorUtils in pebble library");
+        }
+    }
+
+    private static BigDecimal bigDecimalOperation(BigDecimal op1, BigDecimal op2, Operation operation) {
+        switch (operation) {
+        case ADD:
+            return op1.add(op2);
+        case SUBTRACT:
+            return op1.subtract(op2);
+        case MULTIPLICATION:
+            return op1.multiply(op2, MathContext.DECIMAL128);
+        case DIVISION:
+            return op1.divide(op2, MathContext.DECIMAL128);
+        case MODULUS:
+            return op1.remainder(op2, MathContext.DECIMAL128);
+        default:
+            throw new RuntimeException("Bug in OperatorUtils in pebble library");
+        }
+    }
+
+    private static Float floatOperation(Float op1, Float op2, Operation operation) {
+        switch (operation) {
+        case ADD:
+            return op1 + op2;
+        case SUBTRACT:
+            return op1 - op2;
+        case MULTIPLICATION:
+            return op1 * op2;
+        case DIVISION:
+            return op1 / op2;
+        case MODULUS:
+            return op1 % op2;
+        default:
+            throw new RuntimeException("Bug in OperatorUtils in pebble library");
+        }
+    }
+
+    private static long longOperation(long op1, long op2, Operation operation) {
+        switch (operation) {
+        case ADD:
+            return op1 + op2;
+        case SUBTRACT:
+            return op1 - op2;
+        case MULTIPLICATION:
+            return op1 * op2;
+        case DIVISION:
+            return op1 / op2;
+        case MODULUS:
+            return op1 % op2;
+        default:
+            throw new RuntimeException("Bug in OperatorUtils in pebble library");
+        }
+    }
+
+    private static long integerOperation(int op1, int op2, Operation operation) {
+        switch (operation) {
+        case ADD:
+            return op1 + op2;
+        case SUBTRACT:
+            return op1 - op2;
+        case MULTIPLICATION:
+            return op1 * op2;
+        case DIVISION:
+            return op1 / op2;
+        case MODULUS:
+            return op1 % op2;
+        default:
+            throw new RuntimeException("Bug in OperatorUtils in pebble library");
+        }
+    }
+} 
diff --git a/src/main/java/component/expressionLanguage/operator/UnaryOperator.java b/src/main/java/component/expressionLanguage/operator/UnaryOperator.java
new file mode 100644
index 0000000..01d321a
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/operator/UnaryOperator.java
@@ -0,0 +1,10 @@
+package component.expressionLanguage.operator;
+
+import component.expressionLanguage.expression.UnaryExpression;
+
+public class UnaryOperator extends Operator {
+    
+    public UnaryOperator(int precedence, Class<? extends UnaryExpression> nodeClass) {
+        super(precedence, nodeClass);
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/scope/Scope.java b/src/main/java/component/expressionLanguage/scope/Scope.java
new file mode 100644
index 0000000..51a34eb
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/scope/Scope.java
@@ -0,0 +1,97 @@
+package component.expressionLanguage.scope;
+
+import java.util.HashMap;
+import java.util.Map;
+
+/**
+ * A scope is a map of variables. A "local" scope ensures that
+ * the search for a particular variable will end at this scope
+ * whether or not it was found.
+ *
+ */
+public class Scope {
+
+    /**
+     * A "local" scope ensures that
+     * the search for a particular variable will end at this scope
+     * whether or not it was found.
+     */
+    private final boolean isLocal;
+
+    /**
+     * The map of variables known at this scope
+     */
+    private final Map<String, Object> backingMap;
+
+    /**
+     * Constructor
+     *
+     * @param backingMap The backing map of variables
+     * @param isLocal    Whether this scope is local or not
+     */
+    public Scope(Map<String, Object> backingMap, boolean isLocal) {
+        this.backingMap = backingMap == null ? new HashMap<>() : backingMap;
+        this.isLocal = isLocal;
+    }
+
+    /**
+     * Creates a shallow copy of the Scope.
+     * <p>
+     * This is used for the parallel tag  because every new thread should have a
+     * "snapshot" of the scopes, i.e. one thread should not affect rendering output of another.
+     * <p>
+     * It will construct a new collection but
+     * it will contain references to all of the original variables therefore it is not
+     * a deep copy. This is why it is import for the user to use thread-safe variables
+     * when using the parallel tag.
+     *
+     * @return A copy of the scope
+     */
+    public Scope shallowCopy() {
+
+        Map<String, Object> backingMapCopy = new HashMap<>();
+        backingMapCopy.putAll(backingMap);
+
+        return new Scope(backingMapCopy, isLocal);
+    }
+
+    /**
+     * Returns whether or not this scope is "local".
+     *
+     * @return boolean stating whether this scope is local or not.
+     */
+    public boolean isLocal() {
+        return isLocal;
+    }
+
+    /**
+     * Adds a variable to this scope
+     *
+     * @param key   The name of the variable
+     * @param value The value of the variable
+     */
+    public void put(String key, Object value) {
+        backingMap.put(key, value);
+    }
+
+    /**
+     * Retrieves the variable at this scope
+     *
+     * @param key The name of the variable
+     * @return The value of the variable
+     */
+    public Object get(String key) {
+        return backingMap.get(key);
+    }
+
+    /**
+     * Checks if this scope contains a variable of a certain name.
+     *
+     * @param key The name of the variable
+     * @return boolean stating whether or not the backing map of this scope contains that variable
+     */
+    public boolean containsKey(String key) {
+        return backingMap.containsKey(key);
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/scope/ScopeChain.java b/src/main/java/component/expressionLanguage/scope/ScopeChain.java
new file mode 100644
index 0000000..8b75f2b
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/scope/ScopeChain.java
@@ -0,0 +1,190 @@
+package component.expressionLanguage.scope;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.Map;
+
+/**
+ * A stack data structure used to represent the scope of variables that are currently accessible. 
+ * Pushing a new scope will allow the template to add variables with names of pre-existing variables 
+ * without overriding the originals; 
+ * to access the original variables you would pop the scope again.
+ */
+public class ScopeChain {
+
+    /**
+     * The stack of scopes
+     */
+    private final LinkedList<Scope> stack = new LinkedList<>();
+
+    /**
+     * Constructs an empty scope chain without any known scopes.
+     */
+    public ScopeChain() {
+    }
+
+    /**
+     * Constructs a new scope chain with one known scope.
+     *
+     * @param map The map of variables used to initialize a scope.
+     */
+    public ScopeChain(Map<String, Object> map) {
+        Scope scope = new Scope(new HashMap<>(map), false);
+        stack.push(scope);
+    }
+
+    /**
+     * Creates a deep copy of the ScopeChain. This is used for the parallel tag
+     * because every new thread should have a "snapshot" of the scopes, i.e. if
+     * one thread adds a new object to a scope, it should not be available to
+     * the other threads.
+     * <p>
+     * This will construct a new scope chain and new scopes but it will continue
+     * to have references to the original user-provided variables. This is why
+     * it is important for the user to only provide thread-safe variables
+     * when using the "parallel" tag.
+     *
+     * @return A copy of the scope chain
+     */
+    public ScopeChain deepCopy() {
+        ScopeChain copy = new ScopeChain();
+
+        stack.stream().forEach((originalScope) -> {
+            copy.stack.add(originalScope.shallowCopy());
+        });
+        
+        return copy;
+    }
+
+    /**
+     * Adds an empty non-local scope to the scope chain
+     */
+    public void pushScope() {
+        pushScope(new HashMap<>());
+    }
+
+    /**
+     * Adds a new non-local scope to the scope chain
+     *
+     * @param map The known variables of this scope.
+     */
+    public void pushScope(Map<String, Object> map) {
+        Scope scope = new Scope(map, false);
+        stack.push(scope);
+    }
+
+    /**
+     * Adds a new local scope to the scope chain
+     */
+    public void pushLocalScope() {
+        Scope scope = new Scope(new HashMap<>(), true);
+        stack.push(scope);
+    }
+
+    /**
+     * Pops the most recent scope from the scope chain.
+     */
+    public void popScope() {
+        stack.pop();
+    }
+
+    /**
+     * Adds a variable to the current scope.
+     *
+     * @param key   The name of the variable
+     * @param value The value of the variable
+     */
+    public void put(String key, Object value) {
+        stack.peek().put(key, value);
+    }
+
+    /**
+     * Retrieves a variable from the scope chain, starting at the current
+     * scope and working it's way up all visible scopes.
+     *
+     * @param key The name of the variable
+     * @return The value of the variable
+     */
+    public Object get(String key) {
+        Object result;
+
+        /*
+         * The majority of time, the requested variable will be in the first
+         * scope so we do a quick lookup in that scope before attempting to
+         * create an iterator, etc. This is solely for performance.
+         */
+        Scope scope = stack.getFirst();
+        result = scope.get(key);
+
+        if (result == null) {
+
+            Iterator<Scope> iterator = stack.iterator();
+
+            // account for the first lookup we did
+            iterator.next();
+
+            while (result == null && iterator.hasNext()) {
+                scope = iterator.next();
+
+                result = scope.get(key);
+                if (scope.isLocal()) {
+                    break;
+                }
+            }
+        }
+
+        return result;
+    }
+
+    /**
+     * This method checks if the given {@code key} does exists within the scope
+     * chain.
+     *
+     * @param key the for which the the check should be executed for.
+     * @return {@code true} when the key does exists or {@code false} when the
+     * given key does not exists.
+     */
+    public boolean containsKey(String key) {
+
+        /*
+         * The majority of time, the requested variable will be in the first
+         * scope so we do a quick lookup in that scope before attempting to
+         * create an iterator, etc. This is solely for performance.
+         */
+        Scope scope = stack.getFirst();
+        if (scope.containsKey(key)) {
+            return true;
+        }
+
+        Iterator<Scope> iterator = stack.iterator();
+
+        // account for the first lookup we did
+        iterator.next();
+
+        while (iterator.hasNext()) {
+            scope = iterator.next();
+
+            if (scope.containsKey(key)) {
+                return true;
+            }
+            if (scope.isLocal()) {
+                break;
+            }
+        }
+
+        return false;
+    }
+
+    /**
+     * Checks if the current scope contains a variable without
+     * then looking up the scope chain.
+     *
+     * @param variableName The name of the variable
+     * @return Whether or not the variable exists in the current scope
+     */
+    public boolean currentScopeContainsVariable(String variableName) {
+        return stack.getFirst().containsKey(variableName);
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/test/Test.java b/src/main/java/component/expressionLanguage/test/Test.java
new file mode 100644
index 0000000..ecc9bcf
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/test/Test.java
@@ -0,0 +1,7 @@
+package component.expressionLanguage.test;
+
+@FunctionalInterface
+public interface Test {
+
+    boolean apply(Object input);
+}
diff --git a/src/main/java/component/expressionLanguage/token/Token.java b/src/main/java/component/expressionLanguage/token/Token.java
new file mode 100644
index 0000000..654df12
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/token/Token.java
@@ -0,0 +1,66 @@
+package component.expressionLanguage.token;
+
+import component.expressionLanguage.model.position.Position;
+import java.util.Arrays;
+
+public class Token {
+    
+    private String value;
+
+    private Type type;
+
+    private Position position;
+    
+    public Token(Type type, String value, Position position) {
+        this.type = type;
+        this.value = value;
+        this.position = position;
+    }
+    
+    public boolean isA(Type type) {
+        return this.type.equals(type);
+    }
+
+    public boolean isA(Type type, String... values) {
+        boolean test = true;
+        
+        if (values.length > 0) {
+            test = Arrays.asList(values).contains(this.value);
+        }
+        
+        return test && isA(type);
+    }
+
+    public String getValue() {
+        return value;
+    }
+
+    public void setValue(String value) {
+        this.value = value;
+    }
+
+    public Type getType() {
+        return type;
+    }
+
+    public void setType(Type type) {
+        this.type = type;
+    }
+
+    public Position getPosition() {
+        return position;
+    }
+
+    public void setPosition(Position position) {
+        this.position = position;
+    }
+    
+    public boolean isEOF() {
+        return Type.EOF.equals(getType());
+    }
+
+    @Override
+    public String toString() {
+        return "Token[" + this.getType() + "](" + this.getValue() + ")";
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/token/TokenStream.java b/src/main/java/component/expressionLanguage/token/TokenStream.java
new file mode 100644
index 0000000..24cff32
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/token/TokenStream.java
@@ -0,0 +1,114 @@
+package component.expressionLanguage.token;
+
+import java.util.ArrayList;
+import java.util.Collection;
+
+public class TokenStream {
+
+    private final ArrayList<Token> tokens = new ArrayList<>();
+    private final String filename;
+    private int current;
+
+    /**
+     * Constructor for a Token Stream
+     *
+     * @param tokens A collection of tokens
+     * @param name The filename of the template that these tokens came from
+     */
+    public TokenStream(Collection<Token> tokens, String name) {
+        this.tokens.addAll(tokens);
+        this.current = 0;
+        this.filename = name;
+    }
+
+    /**
+     * Consumes and returns the next token in the stream.
+     *
+     * @return The next token
+     */
+    public Token next() {
+        return tokens.get(++current);
+    }
+
+    /**
+     * Checks the current token to see if it matches the provided type. If it
+     * doesn't match this will throw a SyntaxException. This will consume a
+     * token.
+     *
+     * @param type The type of token that we expect
+     * @return Token The current token
+     */
+    public Token expect(Type type) {
+        return expect(type, null);
+    }
+
+    /**
+     * Checks the current token to see if it matches the provided type. If it
+     * doesn't match this will throw a SyntaxException. This will consume a
+     * token.
+     *
+     * @param type The type of token that we expect
+     * @param value The expected value of the token
+     * @return Token The current token
+     */
+    public Token expect(Type type, String value) {
+        Token token = tokens.get(current);
+
+        boolean success = token.isA(type, value);
+
+        if (!success) {
+            String message = String.format("Unexpected token of value \"%s\" and type %s, expected token of type %s",
+                    token.getValue(), token.getType().toString(), type);
+            throw new IllegalStateException(message);
+        }
+        this.next();
+        return token;
+    }
+
+    /**
+     * Returns the next token in the stream without consuming it.
+     *
+     * @return The next token
+     */
+    public Token peek() {
+        return peek(1);
+    }
+
+    /**
+     * Returns a future token in the stream without consuming any.
+     *
+     * @param number How many tokens to lookahead
+     * @return The token we are peeking at
+     */
+    public Token peek(int number) {
+        return this.tokens.get(this.current + number);
+    }
+
+
+    @Override
+    public String toString() {
+        return tokens.toString();
+    }
+
+    /**
+     * Looks at the current token. Does not consume the token.
+     *
+     * @return Token The current token
+     */
+    public Token current() {
+        return this.tokens.get(current);
+    }
+
+    public String getFilename() {
+        return filename;
+    }
+
+    /**
+     * used for testing purposes
+     *
+     * @return List of tokens
+     */
+    public ArrayList<Token> getTokens() {
+        return tokens;
+    }
+}
diff --git a/src/main/java/component/expressionLanguage/token/Type.java b/src/main/java/component/expressionLanguage/token/Type.java
new file mode 100644
index 0000000..758a84e
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/token/Type.java
@@ -0,0 +1,15 @@
+package component.expressionLanguage.token;
+
+public enum Type {
+    EOF, 
+    TEXT, 
+    EXECUTE_START, 
+    EXECUTE_END, 
+    PRINT_START, 
+    PRINT_END, 
+    NAME, 
+    NUMBER, 
+    STRING, 
+    OPERATOR, 
+    PUNCTUATION;
+}
diff --git a/src/main/java/component/expressionLanguage/token/parser/Parser.java b/src/main/java/component/expressionLanguage/token/parser/Parser.java
new file mode 100644
index 0000000..d7174be
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/token/parser/Parser.java
@@ -0,0 +1,7 @@
+package component.expressionLanguage.token.parser;
+
+@FunctionalInterface
+public interface Parser<I, R> {
+
+    R parse(I stream);
+}
diff --git a/src/main/java/component/expressionLanguage/token/parser/TokenParser.java b/src/main/java/component/expressionLanguage/token/parser/TokenParser.java
new file mode 100644
index 0000000..63cfd4d
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/token/parser/TokenParser.java
@@ -0,0 +1,77 @@
+package component.expressionLanguage.token.parser;
+
+import component.expressionLanguage.model.tree.BodyNode;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.function.Predicate;
+
+/**
+ * A TokenParser is responsible for converting a stream of Tokens into a Node. A
+ * TokenParser often has to temporarily delegate responsibility.
+ */
+public interface TokenParser extends Parser<TokenStream, Node> {
+
+    /**
+     * The "tag" is used to determine when to use a particular instance of a
+     * TokenParser. For example, the TokenParser that handles the "block" tag
+     * would return "block" with this method.
+     *
+     * @return The tag used to define this TokenParser.
+     */
+    default String getTag() {
+        return this.getClass().getSimpleName().replace("TokenParser", "").toLowerCase();
+    }
+    
+    @Override
+    default Node parse(TokenStream stream) {
+        return parse(stream, Token::isEOF);
+    }
+
+    public default Node parse(TokenStream stream, Predicate<Token> stop) {
+        Token current = stream.current();
+        List<Node> children = new ArrayList<>();
+        while (!stop.test(current)) {
+            children.add(parse(stream));
+        }
+        return new BodyNode(current.getPosition(), children);
+    }
+    
+    /**
+     * The TokenParser is responsible to convert all the necessary tokens into
+     * appropriate Nodes. It can access tokens using parser.getTokenStream().
+     *
+     * The tag may be self contained like the "extends" tag or it may have a
+     * start and end point with content in the middle like the "block" tag. If
+     * it contains content in the middle, it can use
+     * parser.subparse(stopCondition) to parse the middle content at which point
+     * responsibility comes back to the TokenParser to parse the end point.
+     *
+     * It is the responsibility of the TokenParser to ensure that when it is
+     * complete, the "current" token of the primary Parser's TokenStream is
+     * pointing to the NEXT token. USUALLY this means the last statement in this
+     * parse method, immediately prior to the return statement, is the following
+     * which will consume one token:
+     *
+     * stream.expect(Token.Type.EXECUTE_END);
+     *
+     * Here are two relatively simple examples of how TokenParsers are
+     * implemented:
+     *
+     * - self contained: com.mitchellbosecke.pebble.tokenParser.SetTokenParser -
+     * middle content: com.mitchellbosecke.pebble.tokenParser.BlockTokenParser
+     *
+     * @param token
+     *            The token to parse
+     * @param parser
+     *            the parser which should be used to parse the token
+     * @return A node representation of the token
+     */
+    default Node parse(Token token, TokenStreamParser parser) {
+        TokenStream stream = parser.getStream();
+        return parse(stream);
+    }
+
+}
diff --git a/src/main/java/component/expressionLanguage/token/parser/TokenStreamParser.java b/src/main/java/component/expressionLanguage/token/parser/TokenStreamParser.java
new file mode 100644
index 0000000..6019600
--- /dev/null
+++ b/src/main/java/component/expressionLanguage/token/parser/TokenStreamParser.java
@@ -0,0 +1,201 @@
+package component.expressionLanguage.token.parser;
+
+import component.expressionLanguage.expression.Expression;
+import component.expressionLanguage.expression.parser.ExpressionParser;
+import component.expressionLanguage.model.tree.BodyNode;
+import component.expressionLanguage.model.tree.Node;
+import component.expressionLanguage.model.tree.PrintNode;
+import component.expressionLanguage.model.tree.RootNode;
+import component.expressionLanguage.model.tree.TextNode;
+import component.expressionLanguage.operator.Operator;
+import component.expressionLanguage.token.Token;
+import component.expressionLanguage.token.TokenStream;
+import component.expressionLanguage.token.Type;
+import java.util.ArrayList;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.function.Predicate;
+
+public class TokenStreamParser implements Parser<TokenStream, RootNode> {
+
+    /**
+     * operators
+     */
+    private final Map<String, Operator> operators;
+
+    /**
+     * Token parsers
+     */
+    private final Map<String, TokenParser> tokenParsers;
+
+    /**
+     * An expression parser.
+     */
+    private ExpressionParser expressionParser;
+
+    /**
+     * The TokenStream that we are converting into an Abstract Syntax Tree.
+     */
+    private TokenStream stream;
+
+    /**
+     * TokenParser objects provided by the extensions. Used to keep track of the
+     * name of the block that we are currently inside of. This is purely just
+     * for the parent() function.
+     */
+    private LinkedList<String> blockStack;
+
+    /**
+     * Constructor
+     *
+     * @param operators A map of operators
+     * @param tokenParsers A map of token parsers
+     */
+    public TokenStreamParser(Map<String, Operator> operators, Map<String, TokenParser> tokenParsers) {
+        this.operators = operators;
+        this.tokenParsers = tokenParsers;
+    }
+
+    @Override
+    public RootNode parse(TokenStream stream) {
+
+        // expression parser
+        this.expressionParser = new ExpressionParser(this, this.operators);
+
+        this.stream = stream;
+        this.blockStack = new LinkedList<>();
+        
+        BodyNode body = subparse(Token::isEOF);
+
+//        stop != null && stop.test(stream)
+        RootNode root = new RootNode(stream.current().getPosition(), body);
+        return root;
+    }
+
+    /**
+     * The main method for the parser. This method does the work of converting a
+     * TokenStream into a Node
+     *
+     * @param stop A stopping condition provided by a token parser
+     * @return Node The root node of the generated Abstract Syntax Tree
+     */
+    public BodyNode subparse(Predicate<Token> stop) {
+        // these nodes will be the children of the root node
+        List<Node> nodes = new ArrayList<>();
+
+        Token token = stream.current();
+        while (!token.isEOF()) {
+
+            switch (token.getType()) {
+                case TEXT:
+
+                    /*
+                 * The current token is a text token. Not much to do here other
+                 * than convert it to a text Node.
+                     */
+                    token = stream.current();
+                    nodes.add(new TextNode(token.getPosition(), token.getValue()));
+                    stream.next();
+                    break;
+
+                case PRINT_START:
+
+                    /*
+                 * We are entering a print delimited region at this point. These
+                 * regions will contain some sort of expression so let's pass
+                 * control to our expression parser.
+                     */
+                    // go to the next token because the current one is just the
+                    // opening delimiter
+                    token = stream.next();
+
+                    Expression<?> expression = this.expressionParser.parseExpression();
+                    nodes.add(new PrintNode(token.getPosition(), expression));
+
+                    // we expect to see a print closing delimiter
+                    stream.expect(Type.PRINT_END);
+
+                    break;
+
+                case EXECUTE_START:
+
+                    // go to the next token because the current one is just the
+                    // opening delimiter
+                    stream.next();
+
+                    token = stream.current();
+
+                    /*
+                    * We expect a name token at the beginning of every block.
+                    *
+                    * We do not use stream.expect() because it consumes the current
+                    * token. The current token may be needed by a token parser
+                    * which has provided a stopping condition. Ex. the 'if' token
+                    * parser may need to check if the current token is either
+                    * 'endif' or 'else' and act accordingly, thus we should not
+                    * consume it.
+                     */
+                    if (!Type.NAME.equals(token.getType())) {
+                        String msg = String.format("A block must start with a tag name at line %s in file %s.", token.getPosition(), stream.getFilename());
+                        throw new IllegalStateException(msg);
+                    }
+
+                    // If this method was executed using a TokenParser and
+                    // that parser provided a stopping condition (ex. checking
+                    // for the 'endif' token) let's check for that condition
+                    // now.
+                    if (stop != null && stop.test(token)) {
+                        return new BodyNode(token.getPosition(), nodes);
+                    }
+
+                    // find an appropriate parser for this name
+                    TokenParser tokenParser = tokenParsers.get(token.getValue());
+
+                    if (tokenParser == null) {
+                        String msg = String.format("Unexpected tag name \"%s\" at %s", token.getValue(), token.getPosition());
+                        throw new IllegalStateException(msg);
+                    }
+
+                    Node node = tokenParser.parse(token, this);
+
+                    // node might be null (ex. "extend" token parser)
+                    if (node != null) {
+                        nodes.add(node);
+                    }
+
+                    break;
+
+                default:
+                    String msg = String.format("Parser ended in undefined state.", stream.current().getPosition());
+                    throw new IllegalStateException(msg);
+            }
+        }
+        return new BodyNode(stream.current().getPosition(), nodes);
+    }
+
+    public TokenStream getStream() {
+        return stream;
+    }
+
+    public void setStream(TokenStream stream) {
+        this.stream = stream;
+    }
+
+    public ExpressionParser getExpressionParser() {
+        return this.expressionParser;
+    }
+
+    public String peekBlockStack() {
+        return blockStack.peek();
+    }
+
+    public String popBlockStack() {
+        return blockStack.pop();
+    }
+
+    public void pushBlockStack(String blockName) {
+        blockStack.push(blockName);
+    }
+
+}
diff --git a/src/main/java/component/extractor/Extractor.java b/src/main/java/component/extractor/Extractor.java
new file mode 100644
index 0000000..4338166
--- /dev/null
+++ b/src/main/java/component/extractor/Extractor.java
@@ -0,0 +1,7 @@
+package component.extractor;
+
+@FunctionalInterface
+public interface Extractor<T, R> {
+    
+    R extract(T spec);
+}
diff --git a/src/main/java/component/node/Node.java b/src/main/java/component/node/Node.java
new file mode 100644
index 0000000..3ffb04d
--- /dev/null
+++ b/src/main/java/component/node/Node.java
@@ -0,0 +1,200 @@
+package component.node;
+
+import java.util.*;
+import java.util.function.BiConsumer;
+import java.util.function.Consumer;
+import java.util.function.Supplier;
+
+public class Node {
+
+    protected String name;
+    protected String namespace;
+    protected Object value;
+    protected Object defaultValue;
+    protected boolean useDefault;
+    protected boolean required;
+    protected boolean allowEmptyValue = true;
+    protected Map<String, Object> attributes = new HashMap<>();
+    
+    protected Node parent;
+    protected Collection<Node> children;
+
+    public Node() {
+        
+    }
+    
+    public Node(String name) {
+        this.name = name;
+    }
+    
+    public Node(String namespace, String name, Object value, Map<String, Object> attributes) {
+        this.namespace = namespace;
+        this.name = name;
+        this.value = value;
+        this.attributes = attributes;
+    }
+
+    public Node(String namespace, String name, Object value) {
+        this(namespace, name, value, null);
+    }
+
+//    public static NodeBuilder builder() {
+//        return new NodeBuilder();
+//    }
+
+    public Node getParent() {
+        return parent;
+    }
+
+    public void setParent(Node parent) {
+        this.parent = parent;
+    }
+    
+    public Collection<Node> getChildren() {
+        if (children == null) {
+            this.children = new ArrayList<>();
+        }
+        return children;
+    }
+
+    public void setChildren(Collection<Node> children) {
+        this.children = children;
+    }
+
+    public Node attr(String name, Object val) {
+        getAttributes().put(name, val);
+        return this;
+    }
+    
+    public Node child(Node child) {
+        if (children == null) {
+            children = new ArrayList<>();
+        }
+        this.children.add(child);
+        child.setParent(this);
+        return this;
+    }
+
+    public void setDefaultValue(Object defaultValue) {
+        this.useDefault = true;
+        this.defaultValue = defaultValue;
+    }
+
+    public boolean isRequired() {
+        return required;
+    }
+
+    public void setRequired(boolean required) {
+        this.required = required;
+    }
+
+    public boolean isAllowEmptyValue() {
+        return allowEmptyValue;
+    }
+
+    public void setAllowEmptyValue(boolean allowEmptyValue) {
+        this.allowEmptyValue = allowEmptyValue;
+    }
+    
+    public Object getValue() {
+        if (value instanceof Supplier) {
+            return ((Supplier) value).get();
+        }
+        return value;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+    
+    public String getName() {
+        return name;
+    }
+
+    public void setNamespace(String namespace) {
+        this.namespace = namespace;
+    }
+    
+    public String getNamespace() {
+        return namespace;
+    }
+
+    public Map getAttributes() {
+        if (attributes == null) {
+            attributes = new LinkedHashMap<>(3, 1.0f);
+        }
+        return attributes;
+    }
+
+    public void eachChild(Consumer<Node> consumer) {
+        getChildren().forEach((child) -> {
+            consumer.accept(child);
+            child.visit(consumer);
+        });
+    }
+
+    public Node visit(Consumer<Node> consumer) {
+        eachChild(consumer);
+        consumer.accept(this);
+        return this;
+    }
+
+    public Node visitBeforeAndAfter(BiConsumer<Boolean, Node> consumer) {
+        consumer.accept(true, this);
+        getChildren().forEach((child) -> {
+            child.visitBeforeAndAfter(consumer);
+        });
+        consumer.accept(false, this);
+        return this;
+    }
+
+    @Override
+    public int hashCode() {
+        int hash = 5;
+        hash = 97 * hash + Objects.hashCode(this.attributes);
+        hash = 97 * hash + Objects.hashCode(this.value);
+        hash = 97 * hash + Objects.hashCode(this.name);
+        hash = 97 * hash + Objects.hashCode(this.namespace);
+        hash = 97 * hash + Objects.hashCode(this.children);
+        hash = 97 * hash + Objects.hashCode(this.parent);
+        return hash;
+    }
+
+    @Override
+    public boolean equals(Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        final Node other = (Node) obj;
+        if (!Objects.equals(this.name, other.name)) {
+            return false;
+        }
+        if (!Objects.equals(this.namespace, other.namespace)) {
+            return false;
+        }
+        if (!Objects.equals(this.attributes, other.attributes)) {
+            return false;
+        }
+        if (!Objects.equals(this.value, other.value)) {
+            return false;
+        }
+        if (!Objects.equals(this.children, other.children)) {
+            return false;
+        }
+        if (!Objects.equals(this.parent, other.parent)) {
+            return false;
+        }
+        return true;
+    }
+
+    @Override
+    public String toString() {
+        return "Node{" + "attributes=" + attributes + ", value=" + value + ", name=" + name + ", namespace=" + namespace + ", children=" + children + '}';
+    }
+}
diff --git a/src/main/java/component/node/NodeFactory.java b/src/main/java/component/node/NodeFactory.java
new file mode 100644
index 0000000..5ec5ee2
--- /dev/null
+++ b/src/main/java/component/node/NodeFactory.java
@@ -0,0 +1,5 @@
+package component.node;
+
+public class NodeFactory {
+    
+}
diff --git a/src/main/java/component/node/builder/NodeBuilder.java b/src/main/java/component/node/builder/NodeBuilder.java
new file mode 100644
index 0000000..3011016
--- /dev/null
+++ b/src/main/java/component/node/builder/NodeBuilder.java
@@ -0,0 +1,63 @@
+package component.node.builder;
+
+import component.node.Node;
+import component.builder.Builder;
+import java.util.ArrayList;
+import java.util.Collection;
+
+public class NodeBuilder extends Builder<Node> implements NodeBuilderInterface {
+
+    public static final String DEFAULT_NS = "_default_ns";
+    
+    protected NodeBuilderInterface parent;
+    
+    protected Collection<NodeBuilderInterface> children;
+    
+    public NodeBuilder() {
+        this(new Node());
+    }
+    
+    public NodeBuilder(Node node) {
+        super(node);
+    }
+    
+    public Collection<NodeBuilderInterface> getChildren() {
+        if (this.children == null) {
+            this.children = new ArrayList<>();
+        }
+        return children;
+    }
+
+    public void setChildren(Collection<NodeBuilderInterface> children) {
+        this.children = children;
+    }
+    
+    public void setParent(NodeBuilderInterface parent) {
+        this.parent = parent;
+    }
+
+    @Override
+    public NodeBuilderInterface end() {
+        return parent;
+    }
+    
+    public static NodeBuilder root() {
+        return new NodeBuilder(new Node("root"));
+    }
+
+    @Override
+    public NodeBuilderInterface array(String name) {
+        NodeBuilder builder = new NodeBuilder(node(name));
+        builder.setParent(this);
+        this.getChildren().add(builder);
+        return builder;
+    }
+
+    @Override
+    public NodeBuilderInterface bool(String name) {
+        NodeBuilder builder = new NodeBuilder(child(name));
+        builder.setParent(this);
+        this.getChildren().add(builder);
+        return builder;
+    }
+}
diff --git a/src/main/java/component/node/builder/NodeBuilderInterface.java b/src/main/java/component/node/builder/NodeBuilderInterface.java
new file mode 100644
index 0000000..eab0207
--- /dev/null
+++ b/src/main/java/component/node/builder/NodeBuilderInterface.java
@@ -0,0 +1,92 @@
+package component.node.builder;
+
+import component.node.Node;
+import component.builder.BuilderInterface;
+import java.util.function.Consumer;
+
+public interface NodeBuilderInterface extends BuilderInterface<Node> {
+    
+    public NodeBuilderInterface array(String name);
+    public NodeBuilderInterface bool(String name);
+    public NodeBuilderInterface end();
+    
+    default Node child(String name) {
+        return child(node(name));
+    }
+    
+    default Node child(Node node) {
+        consume((parent) -> {
+            parent.child(node);
+        });
+        return node;
+    }
+    
+    default Node node(String name) {
+        return new Node(name);
+    }
+    
+    default NodeBuilderInterface name(String name) {
+        consume((node) -> {
+            node.setName(name);
+        });
+        return this;
+    }
+    
+    default NodeBuilderInterface visit(Consumer<Node> consumer) {
+        consume((node) -> {
+            node.visit(consumer);
+        });
+        return this;
+    }
+    
+    default NodeBuilderInterface namespace(String namespace) {
+        consume((node) -> {
+            node.setNamespace(namespace);
+        });
+        return this;
+    }
+    
+    default NodeBuilderInterface attribute(String key, Object attribute) {
+        consume((node) -> {
+            node.attr(key, attribute);
+        });
+        return this;
+    }
+    
+    default NodeBuilderInterface defaultValue(Object value) {
+        consume((node) -> {
+            node.setDefaultValue(value);
+        });
+        return this;
+    }
+    
+    default NodeBuilderInterface defaultNull() {
+        return defaultValue(null);
+    }
+    
+    default NodeBuilderInterface defaultTrue() {
+        return defaultValue(true);
+    }
+
+    default NodeBuilderInterface defaultFalse() {
+        return defaultValue(false);
+    }
+    
+    default NodeBuilderInterface required() {
+        consume((node) -> {
+            node.setRequired(true);
+        });
+        return this;
+    }
+    
+    default NodeBuilderInterface cannotBeEmpty() {
+        consume((node) -> {
+            node.setAllowEmptyValue(false);
+        });
+        return this;
+    }
+    
+    default NodeBuilderInterface info(String info) {
+        return attribute("info", info);
+    }
+}
diff --git a/src/main/java/component/node/legacy/ArrayNode.java b/src/main/java/component/node/legacy/ArrayNode.java
new file mode 100644
index 0000000..e34f2e8
--- /dev/null
+++ b/src/main/java/component/node/legacy/ArrayNode.java
@@ -0,0 +1,228 @@
+package component.node.legacy;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import component.utils.ObjectUtils;
+
+public class ArrayNode extends Node {
+
+    protected boolean addIfNotSet = false;
+    protected boolean normalizeKeys = true;
+    protected boolean removeExtraKeys = true;
+    protected boolean deepMerging = true;
+    protected boolean allowNewKeys = true;
+    protected HashMap<String, String> xmlRemapping = new HashMap<>();
+    
+    public ArrayNode(String name) {
+        super(name);
+    }
+
+    @Override
+    protected Object preNormalize(Object value) {
+        
+        if(!isNormalizeKeys() || !(value instanceof Map)) {
+            return value;
+        }
+        
+        Map<String, Object> normalized = new HashMap();
+        
+        Map<String, Object> typedValue = (Map<String, Object>) value;
+        typedValue.forEach((String k, Object val) -> {
+            
+            if(k.contains("-") && !k.contains("_")) {
+                String normalizedKey = k.replace("-", "_");
+                if(!typedValue.containsKey(normalizedKey)) {
+                    k = normalizedKey;
+                }
+            }
+            
+            normalized.put(k, val);
+        });
+        
+        return super.preNormalize(value); //To change body of generated methods, choose Tools | Templates.
+    }
+    
+    @Override
+    protected void validateType(Object value) {
+        if(!ObjectUtils.isArray(value) 
+                && !(value instanceof Map) 
+                && !(value instanceof Set) 
+                && !(value instanceof List)) {
+            String msg = String.format("Invalid type for path %s. Expected array but got %s", this.getPath(), value == null ? null: value.getClass());
+            throw new RuntimeException(msg);
+        }
+    }
+
+    @Override
+    protected Object normalizeValue(Object value) {
+        
+        HashMap<String, Object> normalized = new HashMap<>();
+        
+        if(value == null) {
+            return normalized;
+        }
+        
+        HashMap<String, Object> casted = (HashMap<String, Object>) value;
+        casted = remapXml(casted);
+        
+        casted.forEach((String key, Object val) -> {
+            if(getChildren().containsKey(key)) {
+                normalized.put(key, getChildren().get(key).normalizeValue(val));
+            } else if (!isRemoveExtraKeys()) {
+                normalized.put(key, val);
+            }
+        });
+        
+        return normalized;
+    }
+
+    @Override
+    protected Object mergeValues(Object left, Object right) throws Exception {
+        
+        if(Boolean.FALSE.equals(right)) {
+            return false;
+        }
+        
+        if(Boolean.FALSE.equals(left) || !isDeepMerging()) {
+            return right;
+        }
+        
+        return mergeMap((Map) left, (Map) right);
+    }
+    
+    protected Map<String, Object> mergeMap(Map<String, Object> left, Map<String, Object> right) throws Exception{
+        for (Map.Entry<String, Object> entrySet : right.entrySet()) {
+            String key = entrySet.getKey();
+            Object value = entrySet.getValue();
+            
+            // no conflict
+            if(!left.containsKey(key)) {
+                if(!isAllowNewKeys()) {
+                    String msg = String.format("You are not allowed to define new elements for path '%s'", this.getPath());
+                    throw new Exception(msg);
+                }
+                
+                left.put(key, value);
+                continue;
+            }
+            
+            if(!getChildren().containsKey(key)){
+                throw new Exception("merge() expects a normalized config array.");
+            }
+            
+            left.put(key, getChildren().get(key).merge(left.get(key), value));
+        }
+        
+        return left;
+    }
+
+    @Override
+    protected Object finalizeValue(Object value) {
+        HashMap<String, Object> casted = (HashMap<String, Object>) value;
+        
+        if(getChildren() != null) {
+            for(Map.Entry<String, Node> entry : getChildren().entrySet()) {
+                String key = entry.getKey();
+                Node child = entry.getValue();
+
+                if(!casted.containsKey(key)) {
+                    if(child.isRequired()) {
+                        String msg = String.format("The child node '%s' at path '%s' must be configured.", key, this.getPath());
+                        throw new RuntimeException(msg);
+                    }
+
+                    if(child.hasDefaultValue()) {
+                        casted.put(key, child.getDefaultValue());
+                    }
+
+                    continue;
+                }
+
+                casted.put(key, child.finalize(casted.get(key)));
+            }
+        }
+        
+        return casted;
+    }
+    
+    protected HashMap<String, Object> remapXml(HashMap<String, Object> value){
+        getXmlRemapping().forEach((String singular, String plural) -> {
+            if(value.containsKey(singular)) {
+                value.put(plural, value.get(singular));
+                value.remove(singular);
+            }
+        });
+        
+        return value;
+    }
+    
+    @Override
+    public boolean hasDefaultValue() {
+        return this.addIfNotSet;
+    }
+
+    @Override
+    public Object getDefaultValue() {
+       
+        HashMap<String, Object> defaults = new HashMap<>();
+        
+        getChildren().forEach((String key, Node child) -> {
+            if(child.hasDefaultValue()) {
+                defaults.put(key, child.getDefaultValue());
+            }
+        });
+        
+        return defaults;
+    }
+
+    public void setNormalizeKeys(boolean normalizeKeys) {
+        this.normalizeKeys = normalizeKeys;
+    }
+
+    public void setXmlRemapping(HashMap<String, String> xmlRemapping) {
+        this.xmlRemapping = xmlRemapping;
+    }
+
+    public HashMap<String, String> getXmlRemapping() {
+        return xmlRemapping;
+    }
+
+    public boolean isDeepMerging() {
+        return deepMerging;
+    }
+
+    public boolean isAddIfNotSet() {
+        return addIfNotSet;
+    }
+
+    public boolean isAllowNewKeys() {
+        return allowNewKeys;
+    }
+
+    public boolean isNormalizeKeys() {
+        return normalizeKeys;
+    }
+
+    public boolean isRemoveExtraKeys() {
+        return removeExtraKeys;
+    }
+
+    public void setAddIfNotSet(boolean addIfNotSet) {
+        this.addIfNotSet = addIfNotSet;
+    }
+
+    public void setAllowNewKeys(boolean allowNewKeys) {
+        this.allowNewKeys = allowNewKeys;
+    }
+
+    public void setDeepMerging(boolean deepMerging) {
+        this.deepMerging = deepMerging;
+    }
+
+    public void setRemoveExtraKeys(boolean removeExtraKeys) {
+        this.removeExtraKeys = removeExtraKeys;
+    }
+    
+}
diff --git a/src/main/java/component/node/legacy/BooleanNode.java b/src/main/java/component/node/legacy/BooleanNode.java
new file mode 100644
index 0000000..f6d2b4c
--- /dev/null
+++ b/src/main/java/component/node/legacy/BooleanNode.java
@@ -0,0 +1,9 @@
+package component.node.legacy;
+
+public class BooleanNode extends ScalarNode {
+
+    public BooleanNode(String name) {
+        super(name);
+    }
+    
+}
diff --git a/src/main/java/component/node/legacy/EnumNode.java b/src/main/java/component/node/legacy/EnumNode.java
new file mode 100644
index 0000000..b7e1019
--- /dev/null
+++ b/src/main/java/component/node/legacy/EnumNode.java
@@ -0,0 +1,16 @@
+package component.node.legacy;
+
+public class EnumNode extends ScalarNode {
+
+    protected Object[] values;
+    
+    public EnumNode(String name) {
+        super(name);
+    }
+    
+    public EnumNode(String name, Object[] values) {
+        super(name);
+        this.values = values;
+    }
+    
+}
diff --git a/src/main/java/component/node/legacy/FloatNode.java b/src/main/java/component/node/legacy/FloatNode.java
new file mode 100644
index 0000000..ebfb5f0
--- /dev/null
+++ b/src/main/java/component/node/legacy/FloatNode.java
@@ -0,0 +1,13 @@
+package component.node.legacy;
+
+public class FloatNode extends NumericNode {
+
+    public FloatNode(String name) {
+        super(name);
+    }
+    
+    public FloatNode(String name, Node parent) {
+        super(name, parent);
+    }
+    
+}
diff --git a/src/main/java/component/node/legacy/IntegerNode.java b/src/main/java/component/node/legacy/IntegerNode.java
new file mode 100644
index 0000000..3aa9374
--- /dev/null
+++ b/src/main/java/component/node/legacy/IntegerNode.java
@@ -0,0 +1,13 @@
+package component.node.legacy;
+
+public class IntegerNode extends NumericNode {
+
+    public IntegerNode(String name) {
+        super(name);
+    }
+    
+    public IntegerNode(String name, Node parent) {
+        super(name, parent);
+    }
+    
+}
diff --git a/src/main/java/component/node/legacy/Node.java b/src/main/java/component/node/legacy/Node.java
new file mode 100644
index 0000000..ad66934
--- /dev/null
+++ b/src/main/java/component/node/legacy/Node.java
@@ -0,0 +1,219 @@
+package component.node.legacy;
+
+import java.util.HashMap;
+import java.util.LinkedHashMap;
+import java.util.List;
+import java.util.function.Function;
+
+public abstract class Node {
+    
+    protected String name;
+    protected Node parent;
+    protected boolean required;
+    protected boolean allowOverWrite = true;
+    protected boolean useDefault = true;
+    protected Object defaultValue;
+    protected HashMap<String, Object> attributes;
+    
+    protected LinkedHashMap<String, Node> children;
+    
+    protected List<Function<Object, Object>> normalizationClosures;
+    protected List<Function<Object, Object>> finalValidationClosures;
+    
+    public Node(String name) {
+        this.name = name;
+    }
+
+    public Node(String name, Node parent) {
+        this.name = name;
+        this.parent = parent;
+    }
+    
+    protected Object preNormalize(Object value) {
+        return value;
+    }
+    
+    final public Object normalize(Object value) {
+        
+        value = preNormalize(value);
+        
+        if(getNormalizationClosures() != null) {
+            for (Function<Object, Object> closure : getNormalizationClosures()) {
+                value = closure.apply(value);
+            }
+        }
+        
+        // replaces with equivalent values
+        // dans un tableau de valeur
+        
+        validateType(value);
+        
+        return normalizeValue(value);
+    }
+    
+    final public Object merge(Object left, Object right) throws Exception {
+        
+        if(!isAllowOverWrite()) {
+            String msg = String.format("Configuration path %s, can not be overwritten. "
+                    + "You have to define all options for this path, "
+                    + "and any of its sub-paths in one configuration section.", this.getPath());
+            throw new Exception(msg);
+        }
+        
+        // validate type of left side object
+        validateType(left);
+        
+        // validate type of right side object
+        validateType(right);
+        
+        return mergeValues(left, right);
+    }
+    
+    final public Object finalize(Object value) {
+        
+        validateType(value);
+        
+        value = finalizeValue(value);
+        
+        if(getFinalValidationClosures() != null) {
+            for (Function<Object, Object> closure : getFinalValidationClosures()) {
+                value = closure.apply(value);
+            }
+        }
+        
+        return value;
+    }
+    
+    abstract protected void validateType(Object value);
+    
+    abstract protected Object normalizeValue(Object value);
+    
+    abstract protected Object mergeValues(Object left, Object right) throws Exception;
+
+    abstract protected Object finalizeValue(Object value);
+    
+    abstract public boolean hasDefaultValue();
+    
+    abstract public Object getDefaultValue();
+    
+    public void addChild(Node child){
+        
+        if(getChildren() == null) {
+            setChildren(new LinkedHashMap<>());
+        }
+        
+        getChildren().putIfAbsent(child.getName(), child);
+        child.setParent(this);
+    }
+    
+    public final String getPath() {
+        String path = getName();
+        
+        if(getParent() != null) {
+            path = getParent().getName() + "." + path;
+        }
+        
+        return path;
+    }
+
+    public String getName() {
+        return this.name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public boolean isRequired() {
+        return this.required;
+    }
+
+    public void setRequired(boolean required) {
+        this.required = required;
+    }
+
+    public Node getParent() {
+        return this.parent;
+    }
+
+    public void setParent(Node parent) {
+        this.parent = parent;
+    }
+
+    public HashMap<String, Object> getAttributes() {
+        return this.attributes;
+    }
+
+    public void setAttributes(HashMap<String, Object> attributes) {
+        this.attributes = attributes;
+    }
+
+    public boolean isAllowOverWrite() {
+        return this.allowOverWrite;
+    }
+    
+    public void setAllowOverWrite(boolean allowOverWrite) {
+        this.allowOverWrite = allowOverWrite;
+    }
+
+    public List<Function<Object, Object>> getFinalValidationClosures() {
+        return this.finalValidationClosures;
+    }
+
+    public List<Function<Object, Object>> getNormalizationClosures() {
+        return this.normalizationClosures;
+    }
+
+    public void setFinalValidationClosures(List<Function<Object, Object>> finalValidationClosures) {
+        this.finalValidationClosures = finalValidationClosures;
+    }
+
+    public void setNormalizationClosures(List<Function<Object, Object>> normalizationClosures) {
+        this.normalizationClosures = normalizationClosures;
+    }
+
+    public void setChildren(LinkedHashMap<String, Node> children) {
+        this.children = children;
+    }
+
+    public LinkedHashMap<String, Node> getChildren() {
+        return this.children;
+    }
+    
+    private int getRank(){
+        int rank = 0;
+        
+        Node current = this;
+        
+        while(current.parent != null) {
+            rank++;
+            current = current.parent;
+        }
+        
+        return rank;
+    }
+
+//    @Override
+//    public String toString() {
+//        StringBuilder builder = new StringBuilder();
+//        
+//        int rank = this.getRank();
+//        builder.append("|");
+//        
+//        for (int i = 0; i < rank; i++) {
+//            builder.append("-----");
+//        }
+//        
+//        builder.append(this.name);
+//        builder.append("\n");
+//        
+//        if(this.children != null) {
+//            this.children.values().forEach((Node child) -> {
+//                builder.append(child);
+//            });
+//        }
+//        
+//        return builder.toString();
+//    }
+    
+}
diff --git a/src/main/java/component/node/legacy/NumericNode.java b/src/main/java/component/node/legacy/NumericNode.java
new file mode 100644
index 0000000..b60c19c
--- /dev/null
+++ b/src/main/java/component/node/legacy/NumericNode.java
@@ -0,0 +1,13 @@
+package component.node.legacy;
+
+public abstract class NumericNode extends ScalarNode {
+
+    public NumericNode(String name) {
+        super(name);
+    }
+    
+    public NumericNode(String name, Node parent) {
+        super(name, parent);
+    }
+    
+}
diff --git a/src/main/java/component/node/legacy/PrototypedArrayNode.java b/src/main/java/component/node/legacy/PrototypedArrayNode.java
new file mode 100644
index 0000000..eca1bc3
--- /dev/null
+++ b/src/main/java/component/node/legacy/PrototypedArrayNode.java
@@ -0,0 +1,18 @@
+package component.node.legacy;
+
+public class PrototypedArrayNode extends ArrayNode {
+
+    protected Node prototype;
+    
+    public PrototypedArrayNode(String name) {
+        super(name);
+    }
+
+    public Node getPrototype() {
+        return this.prototype;
+    }
+
+    public void setPrototype(Node prototype) {
+        this.prototype = prototype;
+    }
+}
diff --git a/src/main/java/component/node/legacy/ScalarNode.java b/src/main/java/component/node/legacy/ScalarNode.java
new file mode 100644
index 0000000..2588216
--- /dev/null
+++ b/src/main/java/component/node/legacy/ScalarNode.java
@@ -0,0 +1,13 @@
+package component.node.legacy;
+
+public class ScalarNode extends VariableNode {
+
+    public ScalarNode(String name) {
+        super(name);
+    }
+
+    public ScalarNode(String name, Node parent) {
+        super(name, parent);
+    }
+    
+}
diff --git a/src/main/java/component/node/legacy/VariableNode.java b/src/main/java/component/node/legacy/VariableNode.java
new file mode 100644
index 0000000..e2f5fa5
--- /dev/null
+++ b/src/main/java/component/node/legacy/VariableNode.java
@@ -0,0 +1,74 @@
+package component.node.legacy;
+
+import java.util.function.Supplier;
+import component.utils.ObjectUtils;
+
+public class VariableNode extends Node {
+
+    protected boolean defaultValueSet = false;
+    protected boolean allowEmptyValue = true;
+    protected Object defaultValue;
+    
+    public VariableNode(String name) {
+        super(name);
+    }
+
+    public VariableNode(String name, Node parent) {
+        super(name, parent);
+    }
+
+    @Override
+    public boolean hasDefaultValue() {
+        return this.defaultValueSet;
+    }
+
+    public void setDefaultValue(Object defaultValue) {
+        this.defaultValueSet = true;
+        this.defaultValue = defaultValue;
+    }
+
+    @Override
+    public Object getDefaultValue() {
+        Object v = defaultValue;
+        
+        if(v instanceof Supplier) {
+            v = ((Supplier) defaultValue).get();
+        }
+        
+        return v;
+    }
+
+    @Override
+    protected void validateType(Object value) {
+        // do nothing
+    }
+
+    @Override
+    protected Object normalizeValue(Object value) {
+        return value;
+    }
+
+    @Override
+    protected Object mergeValues(Object left, Object right) {
+        return right;
+    }
+
+    @Override
+    protected Object finalizeValue(Object value) {
+        
+        if(!isAllowEmptyValue() && ObjectUtils.isEmpty(value)) {
+            String msg = String.format("The path '%s' cannot contain an empty value, but got %s.", this.getPath(), value);
+            throw new RuntimeException(msg);
+        }
+        
+        return value;
+    }
+
+    public boolean isAllowEmptyValue() {
+        return allowEmptyValue;
+    }
+
+    public void setAllowEmptyValue(boolean allowEmptyValue) {
+        this.allowEmptyValue = allowEmptyValue;
+    }
+}
diff --git a/src/main/java/component/node/normalization/NodeNormalizer.java b/src/main/java/component/node/normalization/NodeNormalizer.java
new file mode 100644
index 0000000..4570805
--- /dev/null
+++ b/src/main/java/component/node/normalization/NodeNormalizer.java
@@ -0,0 +1,12 @@
+package component.node.normalization;
+
+import component.node.Node;
+import component.normalizer.Normalizer;
+
+public class NodeNormalizer extends Normalizer<Node> {
+    
+    public NodeNormalizer() {
+        super();
+    }
+    
+}
diff --git a/src/main/java/component/node/normalization/NodeValueNormalization.java b/src/main/java/component/node/normalization/NodeValueNormalization.java
new file mode 100644
index 0000000..839bbc5
--- /dev/null
+++ b/src/main/java/component/node/normalization/NodeValueNormalization.java
@@ -0,0 +1,33 @@
+package component.node.normalization;
+
+import java.util.HashMap;
+import java.util.Map;
+import component.normalizer.Normalization;
+
+public class NodeValueNormalization implements Normalization<Object> {
+
+    @Override
+    public Object apply(Object value) {
+        if(!(value instanceof Map)) {
+            return value;
+        }
+        
+        Map<String, Object> normalized = new HashMap();
+        
+        Map<String, Object> typedValue = (Map<String, Object>) value;
+        typedValue.forEach((String k, Object val) -> {
+            
+            if(k.contains("-") && !k.contains("_")) {
+                String normalizedKey = k.replace("-", "_");
+                if(!typedValue.containsKey(normalizedKey)) {
+                    k = normalizedKey;
+                }
+            }
+            
+            normalized.put(k, val);
+        });
+        
+        return value;
+    }
+    
+}
diff --git a/src/main/java/component/normalizer/Normalization.java b/src/main/java/component/normalizer/Normalization.java
new file mode 100644
index 0000000..b26ce08
--- /dev/null
+++ b/src/main/java/component/normalizer/Normalization.java
@@ -0,0 +1,11 @@
+package component.normalizer;
+
+import java.util.function.Function;
+
+public interface Normalization<O> extends Function<O , O> {
+
+    @Override
+    public default O apply(O value) {
+        return value;
+    }
+}
diff --git a/src/main/java/component/normalizer/Normalizer.java b/src/main/java/component/normalizer/Normalizer.java
new file mode 100644
index 0000000..49ff3dc
--- /dev/null
+++ b/src/main/java/component/normalizer/Normalizer.java
@@ -0,0 +1,45 @@
+package component.normalizer;
+
+import java.util.List;
+import java.util.function.Function;
+
+public abstract class Normalizer<O> implements NormalizerInterface<O> {
+    
+    protected Normalization<O> preNormalization;
+    protected List<Normalization<O>> normalizations;
+    
+    public Normalizer() {
+        super();
+    }
+    
+    public Normalizer(Normalization<O> preNormalizationClosures) {
+        this();
+        this.preNormalization = preNormalizationClosures;
+    }
+
+    public Normalizer(Normalization<O> preNormalization, 
+            List<Normalization<O>> normalizations) {
+        this(preNormalization);
+        this.normalizations = normalizations;
+    }
+    
+    @Override
+    public O normalize(O value) {
+        if(this.preNormalization == null) {
+            return value;
+        }
+        
+        value = this.preNormalization.apply(value);
+        
+        if(this.normalizations == null) {
+            return value;
+        }
+        
+        for (Function<O, O> closure : this.normalizations) {
+            value = closure.apply(value);
+        }
+        
+        return value;
+    }
+    
+}
diff --git a/src/main/java/component/normalizer/NormalizerInterface.java b/src/main/java/component/normalizer/NormalizerInterface.java
new file mode 100644
index 0000000..3c6673c
--- /dev/null
+++ b/src/main/java/component/normalizer/NormalizerInterface.java
@@ -0,0 +1,7 @@
+package component.normalizer;
+
+public interface NormalizerInterface<O> {
+
+    O normalize(O value);
+    
+}
diff --git a/src/main/java/component/others/Command.java b/src/main/java/component/others/Command.java
new file mode 100644
index 0000000..d3484ba
--- /dev/null
+++ b/src/main/java/component/others/Command.java
@@ -0,0 +1,18 @@
+package component.others;
+
+import java.util.regex.Pattern;
+
+public class Command {
+    
+//    private static final String COMMAND_PATTERN = "(?<open>%s+)(?<expression>.*)(?<close>%s+)";
+    
+    private String name;
+    private String open;
+    private String close;
+
+    public Command(String name, String open, String close) {
+        this.name = name;
+        this.open = open;
+        this.close = close;
+    }
+}
diff --git a/src/main/java/component/others/Rule.java b/src/main/java/component/others/Rule.java
new file mode 100644
index 0000000..73e9f74
--- /dev/null
+++ b/src/main/java/component/others/Rule.java
@@ -0,0 +1,70 @@
+package component.others;
+
+import java.util.function.Predicate;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public class Rule {
+    
+    private String name;
+    private Pattern intern;
+    private Predicate<Matcher> validate;
+
+    public Rule(String name, Pattern intern, Predicate<Matcher> validate) {
+        this.name = name;
+        this.intern = intern;
+        this.validate = validate;
+    }
+    
+    public boolean validate(String value) {
+        return this.validate.test(match(value));
+    }
+    
+    public Matcher match(String value) {
+        return this.intern.matcher(value);
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+    
+    public Pattern getIntern() {
+        return intern;
+    }
+
+    public Predicate<Matcher> getValidate() {
+        return validate;
+    }
+
+    public void setIntern(Pattern intern) {
+        this.intern = intern;
+    }
+
+    public void setValidate(Predicate<Matcher> validate) {
+        this.validate = validate;
+    }
+    
+    public String extract(String from) {
+        Matcher matcher = match(from);
+        if (!matcher.find()) {
+            return "";
+        }
+        return matcher.group(name);
+    }
+    
+    public static Rule group(String name, String value) {
+        return group(name, value, "");
+    }
+    
+    public static Rule group(String name, String value, String quantity) {
+        String pattern = "(?<".concat(name).concat(">")
+                .concat(value).concat(quantity).concat(")");
+        return new Rule(name, Pattern.compile(pattern), (matcher) -> {
+            return matcher.find();
+        });
+    }
+}
diff --git a/src/main/java/component/others/Sequence.java b/src/main/java/component/others/Sequence.java
new file mode 100644
index 0000000..18c4427
--- /dev/null
+++ b/src/main/java/component/others/Sequence.java
@@ -0,0 +1,193 @@
+package component.others;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Objects;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+import component.utils.StringUtils;
+
+public class Sequence {
+    
+    private List<Rule> rules;
+    
+    private Sequence parent;
+    
+    private List<Sequence> subSequences;
+
+    public Sequence() {
+        
+    }
+    
+    public Sequence(Sequence parent, List<Rule> rules, List<Sequence> subSequences) {
+        this.parent = parent;
+        this.rules = rules;
+        this.subSequences = subSequences;
+    }
+    
+    public List<String> groups(String value) {
+        List<String> results = new ArrayList<>();
+        
+        if (Objects.isNull(this.rules)) {
+            return results;
+        }
+        
+//        this.rules.stream().map((rule) -> rule.extract(value))
+//                .peek(System.out::println);
+
+        List<String> names = new ArrayList<>();
+        this.rules.stream().map(Rule::getName).forEach(names::add);
+        
+        for (Rule rule : this.rules) {
+            System.out.print("value : ");
+            System.out.println(value);
+            String extracted = rule.extract(value);
+            if (StringUtils.hasText(extracted)) {
+                value = value.replaceFirst(Pattern.quote(extracted), "");
+            }
+            System.out.print("Result : ");
+            System.out.println(extracted);
+        }
+        Pattern compiled = Pattern.compile(this.rules.stream()
+            .peek((rule) -> names.add(rule.getName()))
+            .map((rule) -> rule.getIntern().pattern())
+            .collect(Collectors.joining()));
+        
+        System.out.print("Pattern : ");
+        System.out.println(compiled.pattern());
+//        
+//        Matcher matcher = compiled.matcher(value);
+        
+//        if(!matcher.find()) {
+//            return result;
+//        }
+//        int count = matcher.groupCount();
+        
+//        System.out.print("Count : ");
+//        System.out.println(count);
+//        
+//        System.out.print("Name Count : ");
+//        System.out.println(names.size());
+//        
+//        names.stream().forEach((name) -> {
+//            System.out.print(name);
+//            System.out.print(" : ");
+//            System.out.println(matcher.group(name));
+//            
+//            result.add(matcher.group(name));
+//        });
+//        
+//        System.out.print("Result : ");
+//        System.out.println(result);
+        
+//        for (int i = 0; i < count; i++) {
+//            result.add(matcher.group(i));
+//            System.out.print("Result : ");
+//            System.out.println(result);
+//        }
+        
+//        while(matcher.find()) {
+//            result.add(matcher.group());
+//            System.out.print("Result : ");
+//            System.out.println(result);
+//        }
+        return results;
+    }
+    
+    public boolean validate(String value) {
+        boolean invalid = false;
+        
+        if (!Objects.isNull(this.rules)) {
+            invalid = this.rules.stream().anyMatch((rule) -> !rule.validate(value));
+        }
+        
+        if (!Objects.isNull(this.subSequences)) {
+            invalid = this.subSequences.stream().anyMatch((sequence) -> !sequence.validate(value));
+        }
+        
+        return !invalid;
+    }
+
+    public List<Rule> getRules() {
+        return rules;
+    }
+
+    public void setRules(List<Rule> rules) {
+        this.rules = rules;
+    }
+    
+    public void addRule(Rule rule) {
+        if (Objects.isNull(rules)) {
+            rules = new ArrayList<>();
+        }
+        
+        rules.add(rule);
+    }
+
+    public Sequence getParent() {
+        return parent;
+    }
+
+    public void setParent(Sequence parent) {
+        this.parent = parent;
+    }
+
+    public List<Sequence> getSubSequences() {
+        return subSequences;
+    }
+
+    public void setSubSequences(List<Sequence> subSequences) {
+        this.subSequences = subSequences;
+    }
+    
+    public void subSequence(Sequence sequence) {
+        if (Objects.isNull(subSequences)) {
+            subSequences = new ArrayList<>();
+        }
+        sequence.setParent(this);
+        subSequences.add(sequence);
+    }
+    
+    public static SequenceBuilder builder() {
+        return new SequenceBuilder();
+    }
+    
+    public static class SequenceBuilder {
+        
+        private List<Rule> rules = new ArrayList<>();
+
+        private Sequence parent;
+
+        private List<Sequence> subSequences;
+        
+        public SequenceBuilder withParent(Sequence parent) {
+            this.parent = parent;
+            return this;
+        }
+        
+        public SequenceBuilder withSequence(Sequence... subSequences) {
+            this.subSequences = Arrays.asList(subSequences);
+            return this;
+        }
+        
+        public SequenceBuilder withRule(Rule... rules) {
+            this.rules.addAll(Arrays.asList(rules));
+            return this;
+        }
+        
+        public Sequence build() {
+            Sequence sequence = new Sequence();
+            
+            sequence.setParent(parent);
+            
+            this.rules.forEach(sequence::addRule);
+            
+            if (!Objects.isNull(this.subSequences)) {
+                this.subSequences.forEach(sequence::subSequence);
+            }
+            
+            return sequence;
+        }
+    }
+}
diff --git a/src/main/java/component/resolver/PathResolver.java b/src/main/java/component/resolver/PathResolver.java
new file mode 100644
index 0000000..d1cc523
--- /dev/null
+++ b/src/main/java/component/resolver/PathResolver.java
@@ -0,0 +1,51 @@
+package component.resolver;
+
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+public abstract class PathResolver<O> implements Resolver<String, O> {
+
+    private String prefix;
+    private String sufix;
+    
+    public PathResolver() {
+    }
+    
+    public PathResolver(String prefix, String sufix) {
+        this.prefix = prefix;
+        this.sufix = sufix;
+    }
+
+    @Override
+    public Optional<O> resolve(String object) {
+        return doResolve(resolvePath(object));
+    }
+    
+    protected abstract Optional<O> doResolve(String object);
+    
+    protected String resolvePath(String path) {
+        return Arrays.asList(this.prefix, path, this.sufix).stream()
+                .filter(Objects::nonNull)
+                .collect(Collectors.joining());
+    }
+    
+    public String getSufix() {
+        return sufix;
+    }
+
+    public String getPrefix() {
+        return prefix;
+    }
+
+    public void setPrefix(String prefix) {
+        this.prefix = prefix;
+    }
+
+    public void setSufix(String sufix) {
+        this.sufix = sufix;
+    }
+    
+}
diff --git a/src/main/java/component/resolver/Resolver.java b/src/main/java/component/resolver/Resolver.java
new file mode 100644
index 0000000..7648292
--- /dev/null
+++ b/src/main/java/component/resolver/Resolver.java
@@ -0,0 +1,9 @@
+package component.resolver;
+
+import java.util.Optional;
+
+@FunctionalInterface
+public interface Resolver<I, O> {
+    
+    Optional<O> resolve(I object);
+}
diff --git a/src/main/java/component/resolver/ResolverDelegate.java b/src/main/java/component/resolver/ResolverDelegate.java
new file mode 100644
index 0000000..b0d7ff5
--- /dev/null
+++ b/src/main/java/component/resolver/ResolverDelegate.java
@@ -0,0 +1,47 @@
+package component.resolver;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Optional;
+import java.util.function.Predicate;
+
+public class ResolverDelegate<I, O> implements Resolver<I, O> {
+
+    protected Map<Predicate<I>, Resolver<I, O>> resolvers;
+
+    public ResolverDelegate() {
+        this.resolvers = new HashMap<>();
+    }
+    
+    public ResolverDelegate(Map<Predicate<I>, Resolver<I, O>> resolvers) {
+        this.resolvers = resolvers;
+    }
+
+    @Override
+    public Optional<O> resolve(I object) {
+        Optional<Resolver<I, O>> resolver = getResolvers().entrySet().stream()
+                .filter((a) -> a.getKey().test(object))
+                .map((e) -> e.getValue())
+                .findFirst();
+
+        if (resolver.isPresent()) {
+            return resolver.get().resolve(object);
+        }
+        return Optional.empty();
+    }
+
+    public Map<Predicate<I>, Resolver<I, O>> getResolvers() {
+        if(this.resolvers == null) {
+            this.resolvers = new HashMap<>();
+        }
+        return this.resolvers;
+    }
+
+    public void setResolvers(Map<Predicate<I>, Resolver<I, O>> resolvers) {
+        this.resolvers = resolvers;
+    }
+    
+    public void addResolver(Predicate<I> predicate, Resolver<I, O> resolver) {
+        getResolvers().put(predicate, resolver);
+    }
+}
diff --git a/src/main/java/component/resource/FileSystem.java b/src/main/java/component/resource/FileSystem.java
new file mode 100644
index 0000000..1ee3791
--- /dev/null
+++ b/src/main/java/component/resource/FileSystem.java
@@ -0,0 +1,43 @@
+package component.resource;
+
+import java.io.File;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.nio.file.InvalidPathException;
+import component.resource.exceptions.ResourceException;
+
+public class FileSystem {
+    
+    public static final String ROOT_PATH = "/";
+    private final File baseDirectory;
+
+    public FileSystem() {
+        this.baseDirectory = new File(ROOT_PATH);
+    }
+    
+    public FileSystem(File baseDirectory) {
+        this.baseDirectory = baseDirectory;
+    }
+    
+    private File file(String path) {
+        File file = new File(path);
+        if (file.isAbsolute()) {
+            return file;
+        } else {
+            return new File(baseDirectory, path);
+        }
+    }
+    
+    public static boolean isRelative(String path) {
+        return !path.startsWith(ROOT_PATH);
+    }
+    
+    public static String resolve(String parent, String child) {
+        try {
+            return new URI(String.format("%s/../%s", parent, child)).normalize().toString();
+        } catch (InvalidPathException | URISyntaxException e) {
+            throw new ResourceException("Invalid path", e);
+        }
+    }
+    
+}
diff --git a/src/main/java/component/resource/ResourceService.java b/src/main/java/component/resource/ResourceService.java
new file mode 100644
index 0000000..17cfc53
--- /dev/null
+++ b/src/main/java/component/resource/ResourceService.java
@@ -0,0 +1,107 @@
+package component.resource;
+
+import java.io.InputStream;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import component.resource.exceptions.ResourceException;
+import component.resource.loader.ResourceLoader;
+import component.resource.loader.ResourceLoaderDelegate;
+import component.resource.metatada.ResourceMetadata;
+import component.resource.metatada.ResourceReferenceMetadata;
+import component.resource.reference.ResourceReference;
+import component.resource.reference.ResourceReferenceExtractor;
+import component.utils.Assert;
+
+public class ResourceService {
+    
+    private final Map<String, ResourceLoader> loaders;
+    
+    private final ResourceReferenceExtractor extractor;
+
+    public ResourceService(Map<String, ResourceLoader> loaders) {
+        this(loaders, ResourceReferenceExtractor.defaultExtractor());
+    }
+    
+    public ResourceService(Map<String, ResourceLoader> loaders, ResourceReferenceExtractor extractor) {
+        this.loaders = loaders;
+        this.extractor = extractor;
+    }
+    
+    public ResourceMetadata metadata(ResourceReference reference) {
+        Assert.notNull(reference);
+        Assert.hasLength(reference.getPath());
+        
+        Optional<ResourceLoader> optional;
+        
+        switch(reference.getType()) {
+            case ResourceReference.ANY_TYPE:
+                optional = this.loaders.values().stream()
+                    .filter((loader) -> loader.exists(reference.getPath()))
+                    .findFirst();
+                break;
+                
+            default:
+                optional = Optional.ofNullable(this.loaders.get(reference.getType()));
+                break;
+        }
+        
+        if (!optional.isPresent()) {
+            throw new ResourceException(String.format("Cannot load resource %s. Resource loader for type '%s' not configured", reference, reference.getType()));
+        }
+        
+        return new ResourceReferenceMetadata(optional.get(), reference);
+    }
+    
+    public ResourceMetadata metadata(String path) {
+        ResourceReference reference = this.extractor.extract(path);
+        return metadata(reference);
+    }
+    
+    public InputStream load(String path) {
+        return metadata(path).load();
+    }
+    
+    public void addLoader(String key, ResourceLoader loader) {
+        if (!this.loaders.containsKey(key)) {
+            this.loaders.put(key, new ResourceLoaderDelegate());
+        }
+        ((ResourceLoaderDelegate) this.loaders.get(key)).with(loader);
+    }
+    
+    public static ResourceServiceBuilder builder() {
+        return new ResourceServiceBuilder();
+    }
+    
+    public static class ResourceServiceBuilder {
+        
+        private Map<String, ResourceLoader> loaders;
+
+        public ResourceServiceBuilder() {
+        }
+
+        public ResourceServiceBuilder with(String type, ResourceLoader loader) {
+            if (Objects.isNull(this.loaders)) {
+                this.loaders = new HashMap<>();
+            }
+            
+            if (!this.loaders.containsKey(type)) {
+                this.loaders.put(type, new ResourceLoaderDelegate());
+            }
+            
+            ((ResourceLoaderDelegate) this.loaders.get(type)).with(loader);
+            return this;
+        }
+        
+        public ResourceService build() {
+            ResourceService service = new ResourceService(this.loaders);
+            return service;
+        }
+    }
+
+    @Override
+    public String toString() {
+        return "ResourceService{" + "loaders=" + loaders + ", extractor=" + extractor + '}';
+    }
+}
diff --git a/src/main/java/component/resource/exceptions/ResourceException.java b/src/main/java/component/resource/exceptions/ResourceException.java
new file mode 100644
index 0000000..d3e725b
--- /dev/null
+++ b/src/main/java/component/resource/exceptions/ResourceException.java
@@ -0,0 +1,16 @@
+package component.resource.exceptions;
+
+public class ResourceException extends RuntimeException {
+    
+    public ResourceException(String message) {
+        super(message);
+    }
+
+    public ResourceException(Throwable cause) {
+        super(cause);
+    }
+
+    public ResourceException(String message, Throwable cause) {
+        super(message, cause);
+    }
+}
diff --git a/src/main/java/component/resource/exceptions/ResourceNotFoundException.java b/src/main/java/component/resource/exceptions/ResourceNotFoundException.java
new file mode 100644
index 0000000..a745b9f
--- /dev/null
+++ b/src/main/java/component/resource/exceptions/ResourceNotFoundException.java
@@ -0,0 +1,11 @@
+package component.resource.exceptions;
+
+public class ResourceNotFoundException extends ResourceException {
+    public ResourceNotFoundException(String message) {
+        super(message);
+    }
+
+    public ResourceNotFoundException(Throwable e) {
+        super(e);
+    }
+}
diff --git a/src/main/java/component/resource/extractor/Extractor.java b/src/main/java/component/resource/extractor/Extractor.java
new file mode 100644
index 0000000..53c8f44
--- /dev/null
+++ b/src/main/java/component/resource/extractor/Extractor.java
@@ -0,0 +1,7 @@
+package component.resource.extractor;
+
+@FunctionalInterface
+public interface Extractor<T, R> {
+    
+    R extract(T spec);
+}
diff --git a/src/main/java/component/resource/loader/ClasspathResourceLoader.java b/src/main/java/component/resource/loader/ClasspathResourceLoader.java
new file mode 100644
index 0000000..a025d6c
--- /dev/null
+++ b/src/main/java/component/resource/loader/ClasspathResourceLoader.java
@@ -0,0 +1,62 @@
+package component.resource.loader;
+
+import component.utils.ClassUtils;
+import java.io.InputStream;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.util.Optional;
+
+public class ClasspathResourceLoader implements ResourceLoader {
+    
+    public static final String ROOT_PATH = "/";
+    private final ClassLoader classLoader;
+    protected Class clazz;
+
+    public ClasspathResourceLoader() {
+        this(ClassUtils.getDefaultClassLoader());
+    }
+    
+    public ClasspathResourceLoader(ClassLoader classLoader) {
+        this.classLoader = classLoader;
+    }
+    
+    public ClasspathResourceLoader(Class clazz) {
+        this.classLoader = clazz.getClassLoader();
+        this.clazz = clazz;
+    }
+
+    @Override
+    public Optional<Charset> getCharset(String path) {
+        return Optional.empty();
+    }
+
+    @Override
+    public InputStream load(String path) {
+        path = getPath(path);
+        if (this.clazz != null) {
+            return this.clazz.getResourceAsStream(path);
+        } else if (this.classLoader != null) {
+            return this.classLoader.getResourceAsStream(path);
+        } else {
+            return ClassLoader.getSystemResourceAsStream(path);
+        }
+    }
+
+    @Override
+    public boolean exists(String path) {
+        return load(path) != null;
+    }
+
+    @Override
+    public Optional<URL> toUrl(String path) {
+        return Optional.ofNullable(classLoader.getResource(getPath(path)));
+    }
+
+    private String getPath(String path) {
+        if (path.startsWith(ROOT_PATH)) {
+            return path.substring(1);
+        }
+        return path;
+    }
+    
+}
diff --git a/src/main/java/component/resource/loader/FileResourceLoader.java b/src/main/java/component/resource/loader/FileResourceLoader.java
new file mode 100644
index 0000000..5e6b853
--- /dev/null
+++ b/src/main/java/component/resource/loader/FileResourceLoader.java
@@ -0,0 +1,63 @@
+package component.resource.loader;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.util.Optional;
+import component.resource.exceptions.ResourceNotFoundException;
+
+public class FileResourceLoader implements ResourceLoader {
+    
+    public static FileResourceLoader instance(String path) {
+        return instance(new File(path));
+    }
+    
+    public static FileResourceLoader instance(File file) {
+        return new FileResourceLoader(file);
+    }
+    
+    public static FileResourceLoader instance() {
+        return instance(new File("/"));
+    }
+
+    private final File baseDirectory;
+
+    public FileResourceLoader(File baseDirectory) {
+        this.baseDirectory = baseDirectory;
+    }
+
+    @Override
+    public InputStream load(String path) {
+        try {
+            return new FileInputStream(file(path));
+        } catch (FileNotFoundException e) {
+            throw new ResourceNotFoundException(e);
+        }
+    }
+
+    @Override
+    public boolean exists(String path) {
+        return file(path).exists();
+    }
+
+    @Override
+    public Optional<URL> toUrl(String path) {
+        try {
+            return Optional.of(file(path).toURI().toURL());
+        } catch (MalformedURLException e) {
+            return Optional.empty();
+        }
+    }
+
+    private File file(String path) {
+        File file = new File(path);
+        if (file.isAbsolute()) {
+            return file;
+        } else {
+            return new File(baseDirectory, path);
+        }
+    }
+}
diff --git a/src/main/java/component/resource/loader/InMemoryResourceLoader.java b/src/main/java/component/resource/loader/InMemoryResourceLoader.java
new file mode 100644
index 0000000..c5cbc4c
--- /dev/null
+++ b/src/main/java/component/resource/loader/InMemoryResourceLoader.java
@@ -0,0 +1,61 @@
+package component.resource.loader;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.function.Supplier;
+import component.resource.exceptions.ResourceNotFoundException;
+
+public class InMemoryResourceLoader implements ResourceLoader {
+    public static InMemoryResourceLoader.Builder builder () {
+        return new InMemoryResourceLoader.Builder();
+    }
+
+    private final Map<String, Supplier<InputStream>> inputStreamMap;
+
+    public InMemoryResourceLoader(Map<String, Supplier<InputStream>> inputStreamMap) {
+        this.inputStreamMap = inputStreamMap;
+    }
+
+    @Override
+    public InputStream load(String path) {
+        Supplier<InputStream> streamSupplier = inputStreamMap.get(path);
+        if (streamSupplier == null) {
+            throw new ResourceNotFoundException(String.format("Resource '%s' not found", path));
+        }
+        return streamSupplier.get();
+    }
+
+    @Override
+    public boolean exists(String path) {
+        return inputStreamMap.containsKey(path);
+    }
+    
+    public static class Builder {
+        private final Map<String, Supplier<InputStream>> supplierMap = new HashMap<>();
+
+        public Builder withResource (String key, String content) {
+            supplierMap.put(key, new StringInputStreamSupplier(content));
+            return this;
+        }
+
+        public InMemoryResourceLoader build() {
+            return new InMemoryResourceLoader(supplierMap);
+        }
+    }
+
+    public static class StringInputStreamSupplier implements Supplier<InputStream> {
+        private final String content;
+
+        public StringInputStreamSupplier(String content) {
+            this.content = content;
+        }
+
+        @Override
+        public InputStream get() {
+            return new ByteArrayInputStream(content.getBytes());
+        }
+    }
+    
+}
diff --git a/src/main/java/component/resource/loader/ResourceLoader.java b/src/main/java/component/resource/loader/ResourceLoader.java
new file mode 100644
index 0000000..4d40bd7
--- /dev/null
+++ b/src/main/java/component/resource/loader/ResourceLoader.java
@@ -0,0 +1,21 @@
+package component.resource.loader;
+
+import java.io.InputStream;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.util.Optional;
+
+public interface ResourceLoader {
+    
+    InputStream load (String path);
+    
+    boolean exists (String path);
+    
+    default Optional<Charset> getCharset(String path) {
+        return Optional.empty();
+    }
+    
+    default Optional<URL> toUrl (String path) {
+        return Optional.empty();
+    }
+}
diff --git a/src/main/java/component/resource/loader/ResourceLoaderDelegate.java b/src/main/java/component/resource/loader/ResourceLoaderDelegate.java
new file mode 100644
index 0000000..da371ae
--- /dev/null
+++ b/src/main/java/component/resource/loader/ResourceLoaderDelegate.java
@@ -0,0 +1,71 @@
+package component.resource.loader;
+
+import java.io.InputStream;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Optional;
+import component.resource.exceptions.ResourceNotFoundException;
+
+public class ResourceLoaderDelegate implements ResourceLoader {
+    
+    private Collection<ResourceLoader> loaders = new ArrayList<>();
+
+    public ResourceLoaderDelegate() {
+    }
+    
+    public ResourceLoaderDelegate(Collection<ResourceLoader> loaders) {
+        this.loaders = loaders;
+    }
+
+    @Override
+    public Optional<Charset> getCharset(String path) {
+        Optional<ResourceLoader> loader = matches(path);
+        if (loader.isPresent()) {
+            return loader.get().getCharset(path);
+        }
+        return Optional.empty();
+    }
+
+    @Override
+    public InputStream load(String path) {
+        Optional<ResourceLoader> loader = matches(path);
+        if (loader.isPresent()) {
+            return loader.get().load(path);
+        }
+        
+        throw new ResourceNotFoundException(String.format("Resource '%s' not found", path));
+    }
+
+    @Override
+    public boolean exists(String path) {
+        return matches(path).isPresent();
+    }
+
+    @Override
+    public Optional<URL> toUrl(String path) {
+        Optional<ResourceLoader> loader = matches(path);
+        if (loader.isPresent()) {
+            return loader.get().toUrl(path);
+        }
+        
+        return Optional.empty();
+    }
+    
+    public void with(ResourceLoader loader) {
+        this.loaders.add(loader);
+    }
+    
+    private Optional<ResourceLoader> matches(String path) {
+        return this.loaders.stream()
+                .filter((loader) -> loader.exists(path))
+                .findFirst();
+    }
+
+    @Override
+    public String toString() {
+        return "ResourceLoaderDelegate{" + "loaders=" + loaders + '}';
+    }
+    
+}
diff --git a/src/main/java/component/resource/loader/StringResourceLoader.java b/src/main/java/component/resource/loader/StringResourceLoader.java
new file mode 100644
index 0000000..9572d44
--- /dev/null
+++ b/src/main/java/component/resource/loader/StringResourceLoader.java
@@ -0,0 +1,20 @@
+package component.resource.loader;
+
+import java.io.ByteArrayInputStream;
+import java.io.InputStream;
+
+public class StringResourceLoader implements ResourceLoader {
+
+    public StringResourceLoader() {
+    }
+    
+    @Override
+    public InputStream load(String path) {
+        return new ByteArrayInputStream(path.getBytes());
+    }
+
+    @Override
+    public boolean exists(String path) {
+        return path != null;
+    }
+}
diff --git a/src/main/java/component/resource/loader/TypedResourceLoader.java b/src/main/java/component/resource/loader/TypedResourceLoader.java
new file mode 100644
index 0000000..b6d0aaf
--- /dev/null
+++ b/src/main/java/component/resource/loader/TypedResourceLoader.java
@@ -0,0 +1,14 @@
+package component.resource.loader;
+
+public abstract class TypedResourceLoader implements ResourceLoader {
+    
+    private final String type;
+
+    public TypedResourceLoader(String type) {
+        this.type = type;
+    }
+
+    public String getType() {
+        return type;
+    }
+}
diff --git a/src/main/java/component/resource/metatada/ResourceMetadata.java b/src/main/java/component/resource/metatada/ResourceMetadata.java
new file mode 100644
index 0000000..35a7447
--- /dev/null
+++ b/src/main/java/component/resource/metatada/ResourceMetadata.java
@@ -0,0 +1,13 @@
+package component.resource.metatada;
+
+import java.io.InputStream;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.util.Optional;
+
+public interface ResourceMetadata {
+    boolean exists ();
+    InputStream load();
+    Optional<Charset> getCharset ();
+    Optional<URL> toUrl ();
+}
diff --git a/src/main/java/component/resource/metatada/ResourceReferenceMetadata.java b/src/main/java/component/resource/metatada/ResourceReferenceMetadata.java
new file mode 100644
index 0000000..ea492d0
--- /dev/null
+++ b/src/main/java/component/resource/metatada/ResourceReferenceMetadata.java
@@ -0,0 +1,43 @@
+package component.resource.metatada;
+
+import java.io.InputStream;
+import java.net.URL;
+import java.nio.charset.Charset;
+import java.util.Optional;
+import component.resource.loader.ResourceLoader;
+import component.resource.reference.ResourceReference;
+
+public class ResourceReferenceMetadata implements ResourceMetadata {
+    
+    private final ResourceLoader resourceLoader;
+    private final ResourceReference resourceReference;
+
+    public ResourceReferenceMetadata(ResourceLoader resourceLoader, ResourceReference resourceReference) {
+        this.resourceLoader = resourceLoader;
+        this.resourceReference = resourceReference;
+    }
+
+    @Override
+    public boolean exists() {
+        return resourceLoader.exists(resourceReference.getPath());
+    }
+
+    @Override
+    public InputStream load() {
+        return resourceLoader.load(resourceReference.getPath());
+    }
+
+    @Override
+    public Optional<Charset> getCharset() {
+        return resourceLoader.getCharset(resourceReference.getPath());
+    }
+
+    @Override
+    public Optional<URL> toUrl () {
+        return resourceLoader.toUrl(resourceReference.getPath());
+    }
+
+    public ResourceReference getResourceReference() {
+        return resourceReference;
+    }
+}
diff --git a/src/main/java/component/resource/reference/PosixResourceReferenceExtractor.java b/src/main/java/component/resource/reference/PosixResourceReferenceExtractor.java
new file mode 100644
index 0000000..ec1a059
--- /dev/null
+++ b/src/main/java/component/resource/reference/PosixResourceReferenceExtractor.java
@@ -0,0 +1,18 @@
+package component.resource.reference;
+
+import component.resource.extractor.Extractor;
+
+public class PosixResourceReferenceExtractor implements Extractor<String, ResourceReference> {
+
+    @Override
+    public ResourceReference extract(String spec) {
+        int indexOf = spec.indexOf(":");
+        
+        if (indexOf == -1) {
+            return new ResourceReference(ResourceReference.ANY_TYPE, spec);
+        }
+        
+        return new ResourceReference(spec.substring(0, indexOf), spec.substring(indexOf + 1));
+    }
+    
+}
diff --git a/src/main/java/component/resource/reference/ResourceReference.java b/src/main/java/component/resource/reference/ResourceReference.java
new file mode 100644
index 0000000..1e52080
--- /dev/null
+++ b/src/main/java/component/resource/reference/ResourceReference.java
@@ -0,0 +1,71 @@
+package component.resource.reference;
+
+import java.io.File;
+import component.resource.FileSystem;
+
+public class ResourceReference {
+    
+    public static final String ANY_TYPE = "any";
+    public static final String STRING = "string";
+    public static final String FILE = "file";
+    public static final String MEMORY = "memory";
+    public static final String CLASSPATH = "classpath";
+
+    public static ResourceReference reference(String type, String resource) {
+        return new ResourceReference(type, resource);
+    }
+    
+    public static ResourceReference inline(String resource) {
+        return reference(STRING, resource);
+    }
+
+    public static ResourceReference memory(String name) {
+        return reference(MEMORY, name);
+    }
+
+    public static ResourceReference file(String path) {
+        return reference(FILE, path);
+    }
+
+    public static ResourceReference file(File path) {
+        return reference(FILE, path.getAbsolutePath());
+    }
+
+    public static ResourceReference classpath(String path) {
+        return reference(CLASSPATH, path);
+    }
+ 
+    private final String type;
+    private final String path;
+
+    public ResourceReference(String type, String path) {
+        this.type = type;
+        this.path = path;
+    }
+
+    public String getType() {
+        return type;
+    }
+
+    public String getPath() {
+        return path;
+    }
+    
+    public ResourceReference relativeTo(ResourceReference parent) {
+        if (!getType().equals(parent.getType())) {
+            // show smthing
+            return this;
+        }
+        
+        if (FileSystem.isRelative(getPath())) {
+            return new ResourceReference(parent.getType(), FileSystem.resolve(parent.getPath(), getPath()));
+        }
+        
+        return this;
+    }
+
+    @Override
+    public String toString() {
+        return "ResourceReference{" + "type=" + type + ", path=" + path + '}';
+    }
+}
diff --git a/src/main/java/component/resource/reference/ResourceReferenceExtractor.java b/src/main/java/component/resource/reference/ResourceReferenceExtractor.java
new file mode 100644
index 0000000..1dc0be8
--- /dev/null
+++ b/src/main/java/component/resource/reference/ResourceReferenceExtractor.java
@@ -0,0 +1,36 @@
+package component.resource.reference;
+
+import component.resource.extractor.Extractor;
+import java.util.function.Supplier;
+import component.resource.reference.path.PathType;
+import component.resource.reference.path.PathTypeSupplier;
+
+public class ResourceReferenceExtractor implements Extractor<String, ResourceReference> {
+    
+    private final Supplier<PathType> pathTypeSupplier;
+    private final Extractor<String, ResourceReference> posixResourceReferenceExtractor;
+    private final Extractor<String, ResourceReference> uncResourceReferenceExtractor;
+
+    public ResourceReferenceExtractor(Supplier<PathType> pathTypeSupplier, 
+            Extractor<String, ResourceReference> posixResourceReferenceExtractor, 
+            Extractor<String, ResourceReference> uncResourceReferenceExtractor) {
+        this.pathTypeSupplier = pathTypeSupplier;
+        this.posixResourceReferenceExtractor = posixResourceReferenceExtractor;
+        this.uncResourceReferenceExtractor = uncResourceReferenceExtractor;
+    }
+
+    @Override
+    public ResourceReference extract(String spec) {
+        if (pathTypeSupplier.get() == PathType.UNC) {
+            return uncResourceReferenceExtractor.extract(spec);
+        }
+        
+        return posixResourceReferenceExtractor.extract(spec);
+    }
+    
+    public static ResourceReferenceExtractor defaultExtractor() {
+        return new ResourceReferenceExtractor(new PathTypeSupplier(), 
+                new PosixResourceReferenceExtractor(), 
+                new UncResourceReferenceExtractor());
+    }
+}
diff --git a/src/main/java/component/resource/reference/UncResourceReferenceExtractor.java b/src/main/java/component/resource/reference/UncResourceReferenceExtractor.java
new file mode 100644
index 0000000..7a16ace
--- /dev/null
+++ b/src/main/java/component/resource/reference/UncResourceReferenceExtractor.java
@@ -0,0 +1,25 @@
+package component.resource.reference;
+
+import component.resource.extractor.Extractor;
+
+public class UncResourceReferenceExtractor implements Extractor<String, ResourceReference> {
+
+    @Override
+    public ResourceReference extract(String spec) {
+        if (isAbsolute(spec)) {
+            return new ResourceReference(ResourceReference.ANY_TYPE, spec);
+        }
+        
+        int indexOf = spec.indexOf(":");
+        if (indexOf == -1) {
+            return new ResourceReference(ResourceReference.ANY_TYPE, spec);
+        }
+        
+        return new ResourceReference(spec.substring(0, indexOf), spec.substring(indexOf + 1));
+    }
+    
+    private boolean isAbsolute(String spec) {
+        return spec.length() > 2 && spec.charAt(1) == ':' && spec.charAt(2) == '\\';
+    }
+    
+}
diff --git a/src/main/java/component/resource/reference/path/PathType.java b/src/main/java/component/resource/reference/path/PathType.java
new file mode 100644
index 0000000..ea00e52
--- /dev/null
+++ b/src/main/java/component/resource/reference/path/PathType.java
@@ -0,0 +1,5 @@
+package component.resource.reference.path;
+
+public enum PathType {
+    UNC, POSIX
+}
diff --git a/src/main/java/component/resource/reference/path/PathTypeSupplier.java b/src/main/java/component/resource/reference/path/PathTypeSupplier.java
new file mode 100644
index 0000000..b0b2128
--- /dev/null
+++ b/src/main/java/component/resource/reference/path/PathTypeSupplier.java
@@ -0,0 +1,16 @@
+package component.resource.reference.path;
+
+import java.util.function.Supplier;
+
+public class PathTypeSupplier implements Supplier<PathType> {
+
+    @Override
+    public PathType get() {
+        String operatingSystem = System.getProperty("os.name").toLowerCase();
+        if (operatingSystem.contains("win")) {
+            return PathType.UNC;
+        }
+        
+        return PathType.POSIX;
+    }
+}
diff --git a/src/main/java/component/templating/Context.java b/src/main/java/component/templating/Context.java
new file mode 100644
index 0000000..9b20912
--- /dev/null
+++ b/src/main/java/component/templating/Context.java
@@ -0,0 +1,71 @@
+package component.templating;
+
+import component.converter.ConverterResolver;
+import component.templating.token.TokenStream;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import component.templating.token.Token;
+
+public class Context {
+    
+    private Map<String, Object> model = new HashMap<>();
+    
+    private TokenStream stream;
+    
+    private String name;
+    
+    private List<Token> tokens;
+    
+    private ConverterResolver converter = new ConverterResolver();
+
+    public Context(List<Token> tokens, String name) {
+        this.tokens = tokens;
+        this.name = name;
+    }
+    
+    public <T> Optional<T> evaluate(String expression) {
+        if (Objects.isNull(this.model)) {
+            return Optional.empty();
+        }
+        
+//        expression = expression.trim();
+        Object evaluation = this.converter.resolve(expression);
+        if (null != evaluation) {
+            Optional.of(evaluation);
+        }
+//        System.out.println(evaluation);
+
+        return Optional.ofNullable((T) this.model.get(expression));
+    }
+    
+    public <T> Optional<T> evaluate(String expression, Class<T> c) {
+        return evaluate(expression);
+    }
+
+    public Map<String, Object> getModel() {
+        return model;
+    }
+
+    public void setModel(Map<String, Object> model) {
+        this.model = model;
+    }
+
+    public ConverterResolver getConverter() {
+        return converter;
+    }
+    
+    public TokenStream getStream(boolean force) {
+        if (null == this.stream || force) {
+            this.stream = new TokenStream(tokens, name);
+        }
+        return stream;
+    }
+    
+    public TokenStream getStream() {
+        return getStream(false);
+    }
+    
+}
diff --git a/src/main/java/component/templating/Engine.java b/src/main/java/component/templating/Engine.java
new file mode 100644
index 0000000..773b1a7
--- /dev/null
+++ b/src/main/java/component/templating/Engine.java
@@ -0,0 +1,170 @@
+package component.templating;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+import component.templating.token.Token;
+import java.util.List;
+import java.util.Map;
+import static java.util.regex.Pattern.compile;
+import static java.util.regex.Pattern.quote;
+import component.templating.extention.Extension;
+import component.templating.extention.core.CoreExtension;
+import component.templating.node.Node;
+import component.templating.node.NodeParser;
+import component.templating.node.NodeVisitor;
+import component.templating.token.TokenParser;
+import component.templating.token.TokenParsers;
+import component.templating.token.TokenStream;
+import component.templating.token.Tokenizer;
+
+public class Engine {
+
+    private final Environment environment;
+    
+    private final Map<String, Renderer> renderers;
+    
+    private final Tokenizer tokenizer;
+
+    public Engine(Environment environment, Map<String, Renderer> renderers, Tokenizer tokenizer) {
+        this.environment = environment;
+        this.renderers = renderers;
+        this.tokenizer = tokenizer;
+    }
+
+    public Template load(String path) throws Exception {
+        Source source = getEnvironment().load(path);
+        List<Token> tokens = this.tokenizer.tokenize(source);
+        Context context = new Context(tokens, path);
+        NodeVisitor printer = new NodeVisitor() {
+            @Override
+            public void visit(Node node) {
+                node.accept(this);
+            }
+        };
+        List<Node> nodes = NodeParser.fromTypes().parse(context.getStream());
+        nodes.stream().forEach(printer::visit);
+        return Template.builder().context(context).build();
+    }
+    
+    public void evaluate(Template template) throws Exception {
+        Context context = template.getContext();
+        TokenStream stream = template.getContext().getStream();
+        
+        while (!Token.isEOF(stream.current())) {
+            Token token = stream.current();
+            
+        }
+    }
+
+    public void render(Template template) throws Exception {
+        Context context = template.getContext();
+        TokenStream stream = template.getContext().getStream(true);
+        while (!Token.isEOF(stream.current())) {
+            Token token = stream.current();
+            System.out.println(token.getType() + "(" + token.getValue() + ")");
+            stream.next();
+        }
+    }
+
+    public Environment getEnvironment() {
+        return environment;
+    }
+    
+    public static EngineBuilder builder() {
+        return new EngineBuilder();
+    }
+
+    public static class EngineBuilder {
+        
+        private final static TokenParser n = TokenParser.from("name", compile("^[a-zA-Z_][a-zA-Z0-9_]*"));
+        private final static TokenParser s = TokenParsers.string();
+        private final static TokenParser p = TokenParsers.punctuation();
+        private final static TokenParser nb = TokenParsers.number();
+        private final static TokenParser eof = source -> {
+                if (source.length() == 0) {
+                    return Arrays.asList(Token.EOF());
+                }
+                throw new Exception(String.format("EOF is not reached rest (%s)%n", source));
+            };
+        
+
+        Tokenizer.TokenizerBuilder tokenizerBuilder = Tokenizer.builder();
+        private Environment environment;
+        private List<String> starts = new ArrayList<>();
+        private List<Extension> extensions = new ArrayList<>();
+        private TokenParser execute;
+        private TokenParser comment;
+        private TokenParser print;
+
+        public EngineBuilder environment(Environment environment) {
+            this.environment = environment;
+            return this;
+        }
+        
+        public EngineBuilder extension(Extension extension) {
+            this.extensions.add(extension);
+            return this;
+        }
+        
+        public EngineBuilder extensions(Extension... extensions) {
+            this.extensions.addAll(Arrays.asList(extensions));
+            return this;
+        }
+        
+        public EngineBuilder execute(String open, String close) {
+            TokenParser starter = TokenParser.from("execute_open", compile(quote(open)));
+            TokenParser ender = TokenParser.from("execute_close", compile(quote(close)));
+            
+            TokenParser expression = this.n.or(this.nb).or(this.p).or(this.s).zeroOrMore();
+            
+            this.execute = starter
+                    .then(n)
+                    .then(expression)
+                    .then(ender);
+            this.starts.add(open);
+            return this;
+        }
+
+        public EngineBuilder comment(String open, String close) {
+            TokenParser starter = TokenParser.from("comment_open", compile(quote(open)));
+            TokenParser inner = TokenParser.until("comment", close);
+            TokenParser ender = TokenParser.from("comment_close", compile(quote(close)));
+            
+            this.comment = starter
+                    .then(inner.optional())
+                    .then(ender);
+            this.starts.add(open);
+            return this;
+        }
+        
+        public EngineBuilder print(String open, String close) {
+            TokenParser starter = TokenParser.from("print_open", compile(quote(open)));
+            TokenParser ender = TokenParser.from("print_close", compile(quote(close)));
+            
+            this.print = starter
+                    .then(this.n.or(this.nb).or(this.p).or(this.s).oneOrMore())
+                    .then(ender);
+            this.starts.add(open);
+            return this;
+        }
+        
+        public Engine build() {
+            this.extensions.add(new CoreExtension());
+            
+            TokenParser text = TokenParser.until("text", starts);
+            TokenParser principal = print.or(comment).or(execute).or(text).zeroOrMore().then(eof);
+            this.tokenizerBuilder.parser(principal);
+            Tokenizer tokenizer = this.tokenizerBuilder.build();
+            
+            Map<String, Renderer> renderers = new HashMap<>();
+            this.extensions.forEach(extension -> {
+                renderers.putAll(extension.getRenderers());
+            });
+            
+            Engine engine = new Engine(environment, renderers, tokenizer);
+            return engine;
+        }
+
+    }
+}
diff --git a/src/main/java/component/templating/Environment.java b/src/main/java/component/templating/Environment.java
new file mode 100644
index 0000000..1c90d77
--- /dev/null
+++ b/src/main/java/component/templating/Environment.java
@@ -0,0 +1,73 @@
+package component.templating;
+
+import component.resource.ResourceService;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Optional;
+
+public class Environment {
+    
+    private ResourceService resourceService;
+    
+    private List<Source> sources;
+    
+    public List<Source> getSources() {
+        return sources;
+    }
+    
+    public Source load(String path) {
+        if (null == this.sources) {
+            this.sources = new ArrayList<>();
+        }
+        
+        Optional<Source> result = this.sources.stream()
+                .filter((source) -> source.getName().equals(path)).findFirst();
+        
+        if (!result.isPresent()) {
+            InputStream stream = getResourceService().load(path);
+            Reader reader = new InputStreamReader(stream);
+            Source source = Source.builder(path).read(reader).build();
+            this.sources.add(source);
+            return source;
+        }
+        
+        return result.get();
+    }
+
+    public void setSources(List<Source> sources) {
+        this.sources = sources;
+    }
+    
+    public ResourceService getResourceService() {
+        return resourceService;
+    }
+
+    public void setResourceService(ResourceService resourceService) {
+        this.resourceService = resourceService;
+    }
+
+    public static EnvironmentBuilder builder() {
+        return new EnvironmentBuilder();
+    }
+    
+    public static class EnvironmentBuilder {
+    
+        private ResourceService resourceService;
+        
+        public EnvironmentBuilder resourceService(ResourceService service) {
+            this.resourceService = service;
+            return this;
+        }
+        
+        public Environment build() {
+            Environment env = new Environment();
+            
+            env.setResourceService(resourceService);
+            
+            return env;
+        }
+    }
+}
diff --git a/src/main/java/component/templating/Position.java b/src/main/java/component/templating/Position.java
new file mode 100644
index 0000000..f961aaa
--- /dev/null
+++ b/src/main/java/component/templating/Position.java
@@ -0,0 +1,27 @@
+package component.templating;
+
+public class Position {
+    
+    private final String name;
+    private final int line;
+    private final int column;
+
+    public Position(String name, int line, int column) {
+        this.name = name;
+        this.line = line;
+        this.column = column;
+    }
+
+    public int getLine() {
+        return line;
+    }
+
+    public int getColumn() {
+        return column;
+    }
+
+    @Override
+    public String toString() {
+        return String.format("%s (Line: %d, Column: %d)", name, line, column);
+    }
+}
diff --git a/src/main/java/component/templating/Renderer.java b/src/main/java/component/templating/Renderer.java
new file mode 100644
index 0000000..07c2451
--- /dev/null
+++ b/src/main/java/component/templating/Renderer.java
@@ -0,0 +1,8 @@
+package component.templating;
+
+import component.templating.token.Token;
+
+@FunctionalInterface
+public interface Renderer {
+    void render(Token token, Context context) throws Exception;
+}
diff --git a/src/main/java/component/templating/Source.java b/src/main/java/component/templating/Source.java
new file mode 100644
index 0000000..bf8e94f
--- /dev/null
+++ b/src/main/java/component/templating/Source.java
@@ -0,0 +1,231 @@
+package component.templating;
+
+import java.io.IOException;
+import java.io.Reader;
+import java.io.StringReader;
+import java.util.Arrays;
+import java.util.logging.Level;
+import java.util.logging.Logger;
+
+public class Source implements CharSequence {
+    
+    private Source saved;
+
+    private final String name;
+
+    /**
+     * The characters found within the template.
+     */
+    private final char[] source;
+
+    /**
+     * Number of characters stored in source array remaining to be tokenized
+     */
+    private int size = 0;
+
+    /**
+     * Default capacity
+     */
+    private static final int DEFAULT_CAPACITY = 1024;
+
+    /**
+     * An index of the first character for the remaining un-tokenized source.
+     */
+    private int offset = 0;
+
+    /**
+     * Tracking the line number that we are currently tokenizing.
+     */
+    private int lineNumber = 1;
+    private int columnNumber = 1;
+
+    public Source(String name, char[] source, int size) {
+        this.name = name;
+        this.source = source;
+        this.size = size;
+    }
+    
+    public Source save() {
+        return new Source(name, Arrays.copyOfRange(source, offset, offset + size), size);
+    }
+
+    /**
+     * Moves the start index a certain amount. While traversing this amount we
+     * will count how many newlines have been encountered.
+     *
+     * @param amount Amount of characters to advance by
+     */
+    public void advance(int amount) {
+        int index = 0;
+        while (index < amount) {
+            int sizeOfNewline = advanceThroughNewline(index);
+
+            if (sizeOfNewline > 0) {
+                index += sizeOfNewline;
+            } else {
+                index++;
+            }
+            this.columnNumber++;
+        }
+
+        this.size -= amount;
+        this.offset += amount;
+    }
+
+    public void advanceThroughWhitespace() {
+        int index = 0;
+
+        while (Character.isWhitespace(charAt(index))) {
+            int sizeOfNewline = advanceThroughNewline(index);
+
+            if (sizeOfNewline > 0) {
+                index += sizeOfNewline;
+            } else {
+                index++;
+            }
+            this.columnNumber++;
+        }
+
+        this.size -= index;
+        this.offset += index;
+    }
+
+    /**
+     * Advances through possible newline character and returns how many
+     * characters were used to represent the newline (windows uses two
+     * characters to represent one newline).
+     *
+     * @param index The index of the potential newline character
+     * @return
+     */
+    private int advanceThroughNewline(int index) {
+        char character = this.charAt(index);
+        int numOfCharacters = 0;
+
+        // windows newline
+        if ('\r' == character && '\n' == charAt(index + 1)) {
+
+            this.lineNumber++;
+            this.columnNumber = 0;
+            numOfCharacters = 2;
+
+            // various other newline characters
+        } else if ('\n' == character || '\r' == character 
+                || '\u0085' == character || '\u2028' == character
+                || '\u2029' == character) {
+
+            this.lineNumber++;
+            this.columnNumber = 0;
+            numOfCharacters = 1;
+        }
+        
+        return numOfCharacters;
+    }
+
+    public String substring(int start, int end) {
+        return new String(Arrays.copyOfRange(source, this.offset + start, this.offset + end));
+    }
+
+    public String substring(int end) {
+        return new String(Arrays.copyOfRange(source, offset, offset + end));
+    }
+
+    @Override
+    public int length() {
+        return size;
+    }
+
+    @Override
+    public char charAt(int index) {
+        return source[offset + index];
+    }
+
+    @Override
+    public CharSequence subSequence(int start, int end) {
+        return new String(Arrays.copyOfRange(source, this.offset + start, this.offset + end));
+    }
+
+    @Override
+    public String toString() {
+        return new String(Arrays.copyOfRange(source, offset, offset + size));
+    }
+
+    public int getOffset() {
+        return offset;
+    }
+
+    public void setOffset(int offset) {
+        this.offset = offset;
+    }
+    
+    public Position getPosition() {
+        return new Position(getName(), lineNumber, columnNumber);
+    }
+
+    public int getLineNumber() {
+        return lineNumber;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public static SourceBuilder builder(String name) {
+        return new SourceBuilder(name);
+    }
+
+    public static class SourceBuilder {
+
+        private final String name;
+        private char[] source = new char[DEFAULT_CAPACITY];
+        private int size = 0;
+
+        public SourceBuilder(String name) {
+            this.name = name;
+        }
+        
+        public SourceBuilder read(String string) {
+            return read(new StringReader(string));
+        }
+
+        public SourceBuilder read(Reader reader) {
+            try {
+                char[] buffer = new char[1024 * 4];
+                int amountJustRead = 0;
+                while ((amountJustRead = reader.read(buffer)) != -1) {
+                    ensureCapacity(size + amountJustRead);
+                    append(buffer, amountJustRead);
+                }
+                reader.close();
+            } catch (IOException ex) {
+                Logger.getLogger(Source.class.getName()).log(Level.SEVERE, null, ex);
+            }
+            return this;
+        }
+
+        public SourceBuilder append(char[] characters, int amount) {
+            for (int i = 0; i < amount; ++i) {
+                this.source[size + i] = characters[i];
+            }
+            size += amount;
+            return this;
+        }
+
+        public Source build() {
+            return new Source(this.name, this.source, this.size);
+        }
+
+        private void ensureCapacity(int minCapacity) {
+            if (source.length - minCapacity < 0) {
+                grow(minCapacity);
+            }
+        }
+
+        private void grow(int minCapacity) {
+            int oldCapacity = source.length;
+            int newCapacity = Math.max(oldCapacity << 1, minCapacity);
+
+            this.source = Arrays.copyOf(source, newCapacity);
+        }
+    }
+}
diff --git a/src/main/java/component/templating/Template.java b/src/main/java/component/templating/Template.java
new file mode 100644
index 0000000..6f06f60
--- /dev/null
+++ b/src/main/java/component/templating/Template.java
@@ -0,0 +1,94 @@
+package component.templating;
+
+import component.templating.token.TokenStream;
+import component.templating.token.Token;
+import java.util.ArrayList;
+import java.util.List;
+
+public class Template {
+    
+    private Context context;
+    
+    private String name;
+    
+    private Template extend;
+    
+    private List<Template> imports;
+    
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public Template getExtend() {
+        return extend;
+    }
+
+    public List<Template> getImports() {
+        return imports;
+    }
+
+    public void setExtend(Template extend) {
+        this.extend = extend;
+    }
+
+    public void setImports(List<Template> imports) {
+        this.imports = imports;
+    }
+
+    public void setContext(Context context) {
+        this.context = context;
+    }
+
+    public Context getContext() {
+        return context;
+    }
+
+    public static TemplateBuilder builder() {
+        return new TemplateBuilder();
+    }
+    
+    public static class TemplateBuilder {
+        
+        private String name;
+        
+        private Template extend;
+        
+        private List<Template> imports = new ArrayList<>();
+        
+        private Context context;
+    
+        public TemplateBuilder named(String name) {
+            this.name = name;
+            return this;
+        }
+        
+        public TemplateBuilder importTemplate(Template template) {
+            this.imports.add(template);
+            return this;
+        }
+        
+        public TemplateBuilder extend(Template template) {
+            this.extend = template;
+            return this;
+        }
+        
+        public TemplateBuilder context(Context context) {
+            this.context = context;
+            return this;
+        }
+        
+        public Template build() {
+            Template template = new Template();
+            
+            template.setName(this.name);
+            template.setExtend(extend);
+            template.setImports(imports);
+            template.setContext(context);
+            return template;
+        }
+    }
+}
diff --git a/src/main/java/component/templating/expression/Expression.java b/src/main/java/component/templating/expression/Expression.java
new file mode 100644
index 0000000..65751de
--- /dev/null
+++ b/src/main/java/component/templating/expression/Expression.java
@@ -0,0 +1,120 @@
+package component.templating.expression;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import component.templating.Context;
+import component.templating.token.Token;
+import component.templating.token.TokenStream;
+
+@FunctionalInterface
+public interface Expression<T> {
+
+    T evaluate(Context context);
+    
+    static Expression parse(TokenStream stream) throws Exception {
+        Token token = stream.current();
+        
+        if (token.isA("punctuation", "[")) {
+            return array(stream);
+        }
+        
+        return subParse(stream);
+    }
+    
+    static Expression subParse(TokenStream stream) throws Exception {
+        Token token = stream.current();
+        switch(token.getType()) {
+            case "name":
+                switch(token.getValue()) {
+                    case "true":
+                    case "TRUE":
+                        return literalBoolean(Boolean.TRUE);
+                    case "false":
+                    case "FALSE":
+                        return literalBoolean(Boolean.FALSE);
+                    case "none":
+                    case "NONE":
+                    case "null":
+                    case "NULL":
+                        return literalNull();
+                    default:
+                        if (stream.peek().isA("punctuation", "(")) {
+                            // function call
+                            return functionName(token.getValue());
+                        }
+                        return varName(token.getValue());
+                }
+            case "number":
+                final String numberValue = token.getValue();
+                if (numberValue.contains(".")) {
+                    return literalDouble(numberValue);
+                }
+                return literalLong(numberValue);
+            case "string":
+                return literalString(token.getValue());
+            default:
+                String msg = String.format("Unexpected token \"%s\" of value \"%s\" at %s.", token.getType(), token.getValue(), token.getPosition());
+                throw new Exception(msg);
+        }
+    }
+    
+    static Expression functionName(String value) {
+        return context -> value;
+    }
+    
+    static Expression varName(String value) {
+        return context -> context.evaluate(value);
+    }
+    
+    static Expression<Boolean> literalNull() {
+        return context -> null;
+    }
+    
+    static Expression<Boolean> literalBoolean(Boolean value) {
+        return context -> value;
+    }
+    
+    static Expression<String> literalString(String value) {
+        return context -> value;
+    }
+    
+    static Expression<Double> literalDouble(String value) {
+        return context -> Double.parseDouble(value);
+    }
+    
+    static Expression<Long> literalLong(String value) {
+        return context -> Long.parseLong(value);
+    }
+    
+    static Expression<List> emptyList() {
+        return context -> Collections.emptyList();
+    }
+    
+    static Expression<List> array(TokenStream stream) throws Exception {
+        stream.expect("punctuation", "[");
+        
+        if (stream.current().isA("punctuation", "]")) {
+            stream.next();
+            return emptyList();
+        }
+        List<Expression> expressions = new ArrayList();
+
+        while (!stream.current().isA("punctuation", "]")) {
+            expressions.add(subParse(stream));
+            stream.expect("punctuation", ",");
+        }
+        
+        stream.expect("punctuation", "]");
+            
+        return (context) -> {
+            List<Object> returnValues = new ArrayList<>(expressions.size());
+            expressions.stream()
+                    .map((expr) -> expr == null ? null : expr.evaluate(context))
+                    .forEach((value) -> {
+                returnValues.add(value);
+            });
+            return returnValues;
+        };
+    }
+}
diff --git a/src/main/java/component/templating/extention/Extension.java b/src/main/java/component/templating/extention/Extension.java
new file mode 100644
index 0000000..a0ad996
--- /dev/null
+++ b/src/main/java/component/templating/extention/Extension.java
@@ -0,0 +1,36 @@
+package component.templating.extention;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import component.templating.Renderer;
+import component.templating.node.NodeParser;
+import component.templating.token.TokenParser;
+
+public interface Extension {
+    
+    default List<Test> getTests() {
+        return new ArrayList<>();
+    }
+    
+    default List<Function> getFunctions() {
+        return new ArrayList<>();
+    }
+    
+    default List<Filter> getFilters() {
+        return new ArrayList<>();
+    }
+    
+    default List<TokenParser> getTokenParsers() {
+        return new ArrayList<>();
+    }
+    
+    default Map<String, NodeParser> getNodeParsers() {
+        return new HashMap<>();
+    }
+    
+    default Map<String, Renderer> getRenderers() {
+        return new HashMap<>();
+    }
+}
diff --git a/src/main/java/component/templating/extention/Filter.java b/src/main/java/component/templating/extention/Filter.java
new file mode 100644
index 0000000..0d2a290
--- /dev/null
+++ b/src/main/java/component/templating/extention/Filter.java
@@ -0,0 +1,9 @@
+package component.templating.extention;
+
+import java.util.Map;
+
+@FunctionalInterface
+public interface Filter {
+    
+    <T> T apply(Object input, Map<String, Object> args);
+}
diff --git a/src/main/java/component/templating/extention/Function.java b/src/main/java/component/templating/extention/Function.java
new file mode 100644
index 0000000..420743a
--- /dev/null
+++ b/src/main/java/component/templating/extention/Function.java
@@ -0,0 +1,9 @@
+package component.templating.extention;
+
+import java.util.Map;
+
+@FunctionalInterface
+public interface Function {
+    
+    <T> T apply(Map<String, Object> args);
+}
diff --git a/src/main/java/component/templating/extention/Test.java b/src/main/java/component/templating/extention/Test.java
new file mode 100644
index 0000000..deebc67
--- /dev/null
+++ b/src/main/java/component/templating/extention/Test.java
@@ -0,0 +1,9 @@
+package component.templating.extention;
+
+import java.util.Map;
+
+@FunctionalInterface
+public interface Test {
+    
+    boolean apply(Object input, Map<String, Object> args);
+}
diff --git a/src/main/java/component/templating/extention/core/CoreExtension.java b/src/main/java/component/templating/extention/core/CoreExtension.java
new file mode 100644
index 0000000..7688f75
--- /dev/null
+++ b/src/main/java/component/templating/extention/core/CoreExtension.java
@@ -0,0 +1,167 @@
+package component.templating.extention.core;
+
+import java.util.HashMap;
+import java.util.Map;
+import component.templating.Context;
+import component.templating.Renderer;
+import component.templating.extention.Extension;
+import component.templating.node.NodeParser;
+import component.templating.token.Token;
+import component.templating.token.TokenStream;
+
+public class CoreExtension implements Extension {
+
+//    @Override
+//    public List<TokenParser> getTokenParsers() {
+//        List<TokenParser> parsers = new ArrayList<>();
+////        parsers.add(TokenParser.from("ws_trim", "-"));
+////        parsers.add(TokenParser.group("execute", "{%", "%}"));
+////        parsers.add(TokenParser.group("comment", "{#", "#}"));
+////        parsers.add(TokenParser.group("evaluate", "{{", "}}"));
+////        parsers.add(TokenParser.from("punctuation", "(", ")", "[", "]", "{", "}", "?", ":", ".", ",", "|", "="));
+//        parsers.add(TokenParser.group("execute", "{%", "%}", expression()));
+//        parsers.add(TokenParser.group("comment", "{#", "#}"));
+//        parsers.add(TokenParser.group("evaluate", "{{", "}}"));
+//        return parsers;
+//    }
+    
+//    @Override
+//    public Map<String, NodeParser> getNodeParsers() {
+//        Map<String, NodeParser> parsers = new HashMap<>();
+//        parsers.put("text", test("text"));
+//        parsers.put("evaluate", test("evaluate"));
+//        parsers.put("execute", test("execute"));
+//        parsers.put("comment", test("comment"));
+//        parsers.put("ws-trim", test("ws-trim"));
+//        return parsers;
+//    }
+
+    @Override
+    public Map<String, Renderer> getRenderers() {
+        Map<String, Renderer> renderers = new HashMap<>();
+        renderers.put("text", debug("text"));
+        renderers.put("evaluate", debug("evaluate"));
+        renderers.put("execute_open", debug("execute_open"));
+        renderers.put("execute_close", debug("execute_close"));
+        renderers.put("execute", debug("execute"));
+        renderers.put("comment", debug("comment"));
+        renderers.put("ws-trim", debug("ws-trim"));
+        renderers.put("name", debug("name"));
+        return renderers;
+    }
+    
+    static Renderer debug(String name) {
+        return (Token token, Context context) -> {
+            TokenStream stream = context.getStream();
+            token = stream.expect(name);
+            System.out.println(name + "(" + token.getValue() + ")");
+        };
+    }
+    
+//    static NodeParser test(String name) {
+//        return (Token token, Context context) -> {
+//            TokenStream stream = context.getStream();
+//            token = stream.expect(name);
+//            System.out.println(name + "(" + token.getValue() + ")");
+//        };
+//    }
+    
+//    @Override
+//    public Map<String, Renderer> getRenderers() {
+//        Map<String, Renderer> renderers = new HashMap<>();
+//        renderers.put("text", text());
+//        renderers.put("evaluate", debug("evaluate"));
+//        renderers.put("execute", debug("execute"));
+//        renderers.put("comment", comment());
+//        renderers.put("ws-trim", debug("ws-trim"));
+//        return renderers;
+//    }
+//    
+//    static Renderer text() {
+//        return (Token token, Context context) -> {
+//            TokenStream stream = context.getStream();
+//            token = stream.expect("text");
+//            System.out.println(token.getValue());
+//        };
+//    }
+//    
+//    static Renderer comment() {
+//        return (Token token, Context context) -> {
+//            TokenStream stream = context.getStream();
+//            token = stream.expect("comment");
+//        };
+//    }
+//    
+//    public static Renderer debug() {
+//        return Renderer.builder()
+//                .with("text", debug("text"))
+//                .with("evaluate", debug("evaluate"))
+//                .with("execute", debug("execute"))
+//                .with("comment", debug("comment"))
+////                .with("evaluate_open", eval())
+////                .with("text", text())
+////                .with("execute_open", execute())
+////                .with("comment_open", comment())
+//                .build();
+//        return (template, environment) -> {
+//            Context context = environment.getContext();
+//            TokenStream stream = template.stream();
+//            context.setStream(stream);
+//            Token token = stream.current();
+//            while (!Token.isEOF(token)) {
+//                String value = token.getValue();
+////                System.out.println("token(" + token.getType() + ")");
+//                switch (token.getType()) {
+//                    case "evaluate_open":
+//                        stream.next();
+//                        token = stream.expect("expression");
+//                        String expression = token.getValue();
+//                        System.out.println("evaluate(" + expression + ")");
+//                        // parse evaluation
+//                        stream.expect("evaluate_close");
+//                        token = stream.next();
+//                        break;
+//                    case "execute_open":
+//                        stream.next();
+//                        token = stream.expect("expression");
+//                        expression = token.getValue();
+//                        System.out.println("execute(" + expression + ")");
+//                        token = stream.next();
+//                        break;
+//                    case "comment_open":
+//                        stream.next();
+//                        token = stream.expect("expression");
+//                        expression = token.getValue();
+//                        System.out.println("comment(" + expression + ")");
+//                        stream.expect("comment_close");
+//                        token = stream.next();
+//                        break;
+//                    case "print_open":
+//                        System.out.print("print(" + value + "): ");
+//                        stream.next();
+//                        token = stream.expect("expression");
+//                        expression = token.getValue();
+//                        Optional<Object> evaluated = context.evaluate(expression, Object.class);
+//                        if (evaluated.isPresent()) {
+//                            System.out.print(evaluated.get());
+//                        }
+//                        System.out.println(evaluated.get());
+//                        token = stream.next();
+//                        break;
+//                    case "text":
+//                        System.out.println("text(" + value + ")");
+//                        token = stream.next();
+//                        break;
+//                    case "expression":
+//                        System.out.println("expression(" + value + ")");
+//                        token = stream.next();
+//                        break;
+//                    default:
+////                        System.out.println("skip(" + value + ")");
+//                        token = stream.next();
+//                        break;
+//                }
+//            }
+//        };
+//    }
+}
diff --git a/src/main/java/component/templating/node/BodyNode.java b/src/main/java/component/templating/node/BodyNode.java
new file mode 100644
index 0000000..d75c935
--- /dev/null
+++ b/src/main/java/component/templating/node/BodyNode.java
@@ -0,0 +1,5 @@
+package component.templating.node;
+
+public class BodyNode {
+    
+}
diff --git a/src/main/java/component/templating/node/ExecuteNode.java b/src/main/java/component/templating/node/ExecuteNode.java
new file mode 100644
index 0000000..e8693e2
--- /dev/null
+++ b/src/main/java/component/templating/node/ExecuteNode.java
@@ -0,0 +1,16 @@
+package component.templating.node;
+
+import component.templating.expression.Expression;
+
+public class ExecuteNode extends ExpressionNode {
+    
+    public ExecuteNode(Expression expression) {
+        super(expression);
+    }
+
+    @Override
+    public void accept(NodeVisitor visitor) {
+        System.out.format("Execute : %n");
+        super.accept(visitor);
+    }
+}
diff --git a/src/main/java/component/templating/node/ExpressionNode.java b/src/main/java/component/templating/node/ExpressionNode.java
new file mode 100644
index 0000000..c06b5b0
--- /dev/null
+++ b/src/main/java/component/templating/node/ExpressionNode.java
@@ -0,0 +1,25 @@
+package component.templating.node;
+
+import component.templating.expression.Expression;
+
+public abstract class ExpressionNode implements Node {
+    
+    private Expression expression;
+
+    public ExpressionNode(Expression expression) {
+        this.expression = expression;
+    }
+
+    public Expression getExpression() {
+        return expression;
+    }
+
+    public void setExpression(Expression expression) {
+        this.expression = expression;
+    }
+
+    @Override
+    public void accept(NodeVisitor visitor) {
+        System.out.format("Expression : %s%n", this.expression);
+    }
+}
diff --git a/src/main/java/component/templating/node/Node.java b/src/main/java/component/templating/node/Node.java
new file mode 100644
index 0000000..87d5fa1
--- /dev/null
+++ b/src/main/java/component/templating/node/Node.java
@@ -0,0 +1,7 @@
+package component.templating.node;
+
+public interface Node {
+    default void accept(NodeVisitor visitor) {
+        visitor.visit(this);
+    }
+}
diff --git a/src/main/java/component/templating/node/NodeParser.java b/src/main/java/component/templating/node/NodeParser.java
new file mode 100644
index 0000000..a7a9955
--- /dev/null
+++ b/src/main/java/component/templating/node/NodeParser.java
@@ -0,0 +1,65 @@
+package component.templating.node;
+
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import component.templating.expression.Expression;
+import component.templating.token.Token;
+import component.templating.token.TokenStream;
+
+@FunctionalInterface
+public interface NodeParser {
+    
+    List<Node> parse(TokenStream stream) throws Exception;
+    
+    static NodeParser fromTypes() {
+        
+        Map<String, NodeParser> parsers = new HashMap<>();
+        
+        parsers.put("text", stream -> {
+            Token current = stream.current();
+            List<Node> result = new ArrayList<>();
+            result.add(new TextNode(current.getValue()));
+            return result;
+        });
+        
+        parsers.put("print_open", stream -> {
+            stream.next();
+            List<Node> result = new ArrayList<>();
+            result.add(new PrintNode(Expression.parse(stream)));
+            return result;
+        });
+        
+        parsers.put("execute_open", stream -> {
+            Token token = stream.next();
+            List<Node> result = new ArrayList<>();
+            
+            if (!token.isA("name")) {
+                String msg = String.format("A block must start with a tag name at %s.", token.getPosition());
+                throw new Exception(msg);
+            }
+            
+            result.add(new ExecuteNode(Expression.parse(stream)));
+            return result;
+        });
+        
+        return stream -> {
+            List<Node> result = new LinkedList<>();
+            
+            while (!Token.isEOF(stream.current())) {
+                Token token = stream.current();
+                NodeParser parser = parsers.get(token.getType());
+                
+                if (null != parser) {
+                    result.addAll(parser.parse(stream));
+                }
+                
+                stream.next();
+            }
+            
+            return result;
+        };
+    }
+}
diff --git a/src/main/java/component/templating/node/NodeVisitor.java b/src/main/java/component/templating/node/NodeVisitor.java
new file mode 100644
index 0000000..0665275
--- /dev/null
+++ b/src/main/java/component/templating/node/NodeVisitor.java
@@ -0,0 +1,7 @@
+package component.templating.node;
+
+@FunctionalInterface
+public interface NodeVisitor {
+    
+    void visit(Node node);
+}
diff --git a/src/main/java/component/templating/node/PrintNode.java b/src/main/java/component/templating/node/PrintNode.java
new file mode 100644
index 0000000..bfc1ed3
--- /dev/null
+++ b/src/main/java/component/templating/node/PrintNode.java
@@ -0,0 +1,16 @@
+package component.templating.node;
+
+import component.templating.expression.Expression;
+
+public class PrintNode extends ExpressionNode {
+    
+    public PrintNode(Expression expression) {
+        super(expression);
+    }
+    
+    @Override
+    public void accept(NodeVisitor visitor) {
+        System.out.format("Print");
+        super.accept(visitor);
+    }
+}
diff --git a/src/main/java/component/templating/node/TextNode.java b/src/main/java/component/templating/node/TextNode.java
new file mode 100644
index 0000000..25d79bd
--- /dev/null
+++ b/src/main/java/component/templating/node/TextNode.java
@@ -0,0 +1,16 @@
+package component.templating.node;
+
+public class TextNode implements Node{
+
+    private String value;
+
+    public TextNode(String value) {
+        this.value = value;
+    }
+    
+    @Override
+    public void accept(NodeVisitor visitor) {
+        System.out.format("Text : %s%n", this.value);
+    }
+    
+}
diff --git a/src/main/java/component/templating/token/Token.java b/src/main/java/component/templating/token/Token.java
new file mode 100644
index 0000000..5f91d75
--- /dev/null
+++ b/src/main/java/component/templating/token/Token.java
@@ -0,0 +1,73 @@
+package component.templating.token;
+
+import java.util.Objects;
+import component.templating.Position;
+
+public class Token {
+    
+    private String type;
+    
+    private String value;
+    
+    private Position position;
+
+    public Token(String type) {
+        this.type = type;
+    }
+
+    public Token(String type, String value, Position position) {
+        this.type = type;
+        this.value = value;
+        this.position = position;
+    }
+    
+    public boolean isA(String type) {
+        return this.type.equals(type);
+    }
+    
+    public boolean isA(String type, String value) {
+        return isA(type) && Objects.equals(this.value, value);
+    }
+
+    public Position getPosition() {
+        return position;
+    }
+
+    public void setPosition(Position position) {
+        this.position = position;
+    }
+
+    public String getValue() {
+        return value;
+    }
+
+    public void setValue(String value) {
+        this.value = value;
+    }
+    
+    public String getType() {
+        return type;
+    }
+
+    public void setType(String type) {
+        this.type = type;
+    }
+    
+    public static boolean isEOF(Token token) {
+        return token.isA("EOF");
+    }
+    
+    public static Token EOF() {
+        return new Token("EOF");
+    }
+    
+    public static Token text(String text, Position position) {
+        return new Token("text", text, position);
+    }
+
+    @Override
+    public String toString() {
+        return "Token{" + "type=" + type + ", value=" + value + ", position=" + position + '}';
+    }
+    
+}
diff --git a/src/main/java/component/templating/token/TokenParser.java b/src/main/java/component/templating/token/TokenParser.java
new file mode 100644
index 0000000..135ebbf
--- /dev/null
+++ b/src/main/java/component/templating/token/TokenParser.java
@@ -0,0 +1,193 @@
+package component.templating.token;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import java.util.Optional;
+import java.util.function.Function;
+import java.util.function.Predicate;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+import component.templating.Source;
+
+@FunctionalInterface
+public interface TokenParser {
+    
+    List<Token> parse(Source source) throws Exception;
+    
+    default List<Token> parse(Source source, boolean skipWhiteSpaces) throws Exception{
+        if (skipWhiteSpaces) {
+            source.advanceThroughWhitespace();
+        }
+        return parse(source);
+    }
+    
+    default Optional<List<Token>> tryParse(Source source) {
+        Source saved = source.save();
+//        int offset = source.getOffset();
+        try {
+            return Optional.of(parse(source, true));
+        } catch (Exception exception) {
+            source = saved;
+        }
+        return Optional.empty();
+    };
+    
+    default TokenParser skip(TokenParser skip) {
+        return (source) -> {
+            List<Token> result = parse(source, true);
+            skip.parse(source, true);
+            return result;
+        };
+    }
+    
+    default TokenParser then(TokenParser then) {
+        return (source) -> {
+            List<Token> result = parse(source, true);
+            result.addAll(then.parse(source, true));
+            return result;
+        };
+    }
+    
+    default TokenParser or(TokenParser then) {
+        return (source) -> {
+            int offset = source.getOffset();
+            try {
+                return parse(source, true);
+            } catch(Exception exception) {
+                source.setOffset(offset);
+            }
+            return then.parse(source);
+        };
+    }
+    
+    default TokenParser until(TokenParser end) {
+        return source -> {
+            List<Token> result = new ArrayList<>();
+            while(!end.tryParse(source).isPresent()) {
+                result.addAll(parse(source, true));
+            }
+            
+            return result;
+        };
+    }
+    
+    default TokenParser optional() {
+        return source -> {
+            Optional<List<Token>> result = tryParse(source);
+            if (result.isPresent()) {
+                return result.get();
+            }
+            return Collections.emptyList();
+        };
+    }
+    
+    default TokenParser zeroOrMore() {
+        return source -> {
+            List<Token> result = new ArrayList<>();
+            Optional<List<Token>> element;
+            while((element = tryParse(source)).isPresent()) {
+                result.addAll(element.get());
+            }
+            return result;
+        };
+    }
+    
+    default TokenParser zeroOrMore(TokenParser separator) {
+        return source -> {
+            List<Token> result = new ArrayList<>();
+            Optional<List<Token>> element = tryParse(source);
+            if(element.isPresent()) {
+                result.addAll(element.get());
+                while(separator.tryParse(source).isPresent()) {
+                    result.addAll(parse(source, true));
+                }
+            }
+            return result;
+        };
+    }
+    
+    default TokenParser oneOrMore() {
+        return source -> {
+            List<Token> result = new ArrayList<>();
+            result.addAll(parse(source, true));
+            Optional<List<Token>> element;
+            while((element = tryParse(source)).isPresent()) {
+                result.addAll(element.get());
+            }
+            return result;
+        };
+    }
+    
+    default TokenParser oneOrMore(TokenParser separator) {
+        return source -> {
+            List<Token> result = new ArrayList<>();
+            result.addAll(parse(source, true));
+            while(separator.tryParse(source).isPresent()) {
+                result.addAll(parse(source, true));
+            }
+            return result;
+        };
+    }
+    
+    default TokenParser filter(Predicate predicate) {
+        return source -> {
+            List<Token> result = parse(source, true);
+            
+            if (!predicate.test(result)) {
+                throw new Exception("Does not respect filter");
+            }
+            
+            return result;
+        };
+    }
+    
+    default TokenParser map(Function<List<Token>, List<Token>> function) {
+        return source -> {
+            return function.apply(parse(source, true));
+        };
+    }
+    
+    static TokenParser from(String name, Pattern pattern) {
+        return source -> {
+            Matcher matcher = pattern.matcher(source);
+            if(!matcher.lookingAt()) {
+                String msg = String.format("%s not found at %s", pattern.pattern(), source.getPosition());
+                throw new Exception(msg);
+            }
+            
+            String value = source.substring(matcher.end()).trim();
+            Token token = new Token(name, value, source.getPosition());
+            source.advance(matcher.end());
+            return new ArrayList(Arrays.asList(token));
+        };
+    }
+    
+    static TokenParser until(String name, String... values) {
+        return until(name, Arrays.asList(values));
+    }
+    
+    static TokenParser until(String name, List<String> values) {
+        StringBuilder sb = new StringBuilder("^.*?(?=");
+        sb.append(values.stream().map(Pattern::quote).collect(Collectors.joining("|")));
+        sb.append(")");
+        return from(name, Pattern.compile(sb.toString(), Pattern.DOTALL));
+    }
+    
+    static TokenParser value(String name, String value) {
+        return from(name, Pattern.compile(Pattern.quote(value)));
+    }
+    
+    static TokenParser in(String name, String value) {
+        StringBuilder sb = new StringBuilder();
+        for (char c: value.toCharArray()) {
+            if (sb.length() > 0) {
+                sb.append("|");
+            }
+            sb.append("\\Q").append(c).append("\\E");
+        }
+        return from(name, Pattern.compile(sb.toString()));
+    }
+}
diff --git a/src/main/java/component/templating/token/TokenParsers.java b/src/main/java/component/templating/token/TokenParsers.java
new file mode 100644
index 0000000..213f328
--- /dev/null
+++ b/src/main/java/component/templating/token/TokenParsers.java
@@ -0,0 +1,35 @@
+package component.templating.token;
+
+import java.util.Arrays;
+import java.util.regex.Pattern;
+
+public interface TokenParsers {
+    
+    public static final Pattern REGEX_STRING = Pattern.compile("((\").*?(?<!\\\\)(\"))|((').*?(?<!\\\\)('))", Pattern.DOTALL);
+    
+    public static final Pattern REGEX_NUMBER = Pattern.compile("^[0-9]+(\\.[0-9]+)?");
+        
+    public static final String PUNCTUATION = "()[]{}?:.,|=";
+
+    static TokenParser string() {
+        return TokenParser.from("string", REGEX_STRING);
+    }
+    
+    static TokenParser number() {
+        return TokenParser.from("number", REGEX_NUMBER);
+    }
+    
+    static TokenParser punctuation() {
+        return TokenParser.in("punctuation", PUNCTUATION);
+    }
+    
+    static TokenParser EOF() {
+        return source -> {
+            if (source.length() == 0) {
+                return Arrays.asList(Token.EOF());
+            }
+            throw new Exception();
+        };
+    }
+    
+}
diff --git a/src/main/java/component/templating/token/TokenStream.java b/src/main/java/component/templating/token/TokenStream.java
new file mode 100644
index 0000000..65f6186
--- /dev/null
+++ b/src/main/java/component/templating/token/TokenStream.java
@@ -0,0 +1,115 @@
+package component.templating.token;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Objects;
+
+public class TokenStream {
+
+    private final ArrayList<Token> tokens = new ArrayList<>();
+    private final String filename;
+    private int current;
+
+    /**
+     * Constructor for a Token Stream
+     *
+     * @param tokens A collection of tokens
+     * @param name The filename of the template that these tokens came from
+     */
+    public TokenStream(Collection<Token> tokens, String name) {
+        this.tokens.addAll(tokens);
+        this.current = 0;
+        this.filename = name;
+    }
+
+    /**
+     * Consumes and returns the next token in the stream.
+     *
+     * @return The next token
+     */
+    public Token next() {
+        return tokens.get(++current);
+    }
+
+    /**
+     * Checks the current token to see if it matches the provided type. If it
+     * doesn't match this will throw a SyntaxException. This will consume a
+     * token.
+     *
+     * @param type The type of token that we expect
+     * @return Token The current token
+     */
+    public Token expect(String type) {
+        return expect(type, null);
+    }
+
+    /**
+     * Checks the current token to see if it matches the provided type. If it
+     * doesn't match this will throw a SyntaxException. This will consume a
+     * token.
+     *
+     * @param type The type of token that we expect
+     * @param value The expected value of the token
+     * @return Token The current token
+     */
+    public Token expect(String type, String value) {
+        Token token = tokens.get(current);
+
+        boolean success = Objects.isNull(value) 
+                ? token.isA(type) : token.isA(type, value);
+
+        if (!success) {
+            String message = String.format("Unexpected token of value \"%s\" and type %s, expected token of type %s",
+                    token.getValue(), token.getType().toString(), type);
+            throw new IllegalStateException(message);
+        }
+        this.next();
+        return token;
+    }
+
+    /**
+     * Returns the next token in the stream without consuming it.
+     *
+     * @return The next token
+     */
+    public Token peek() {
+        return peek(1);
+    }
+
+    /**
+     * Returns a future token in the stream without consuming any.
+     *
+     * @param number How many tokens to lookahead
+     * @return The token we are peeking at
+     */
+    public Token peek(int number) {
+        return this.tokens.get(this.current + number);
+    }
+
+    @Override
+    public String toString() {
+        return tokens.toString();
+    }
+
+    /**
+     * Looks at the current token. Does not consume the token.
+     *
+     * @return Token The current token
+     */
+    public Token current() {
+        return this.tokens.get(current);
+    }
+
+    public String getFilename() {
+        return filename;
+    }
+
+    /**
+     * used for testing purposes
+     *
+     * @return List of tokens
+     */
+    public ArrayList<Token> getTokens() {
+        return tokens;
+    }
+}
diff --git a/src/main/java/component/templating/token/TokenVisitor.java b/src/main/java/component/templating/token/TokenVisitor.java
new file mode 100644
index 0000000..536ed3e
--- /dev/null
+++ b/src/main/java/component/templating/token/TokenVisitor.java
@@ -0,0 +1,5 @@
+package component.templating.token;
+
+public interface TokenVisitor {
+    void visit(Token token);
+}
diff --git a/src/main/java/component/templating/token/Tokenizer.java b/src/main/java/component/templating/token/Tokenizer.java
new file mode 100644
index 0000000..2ab86c2
--- /dev/null
+++ b/src/main/java/component/templating/token/Tokenizer.java
@@ -0,0 +1,40 @@
+package component.templating.token;
+
+import java.util.List;
+import component.templating.Source;
+
+public class Tokenizer {
+    
+    private TokenParser tokenParser;
+    
+    public List<Token> tokenize(Source source) throws Exception {
+        return this.tokenParser.parse(source, true);
+    }
+    
+    public TokenParser getTokenParser() {
+        return tokenParser;
+    }
+
+    public void setTokenParser(TokenParser tokenParser) {
+        this.tokenParser = tokenParser;
+    }
+    
+    public static TokenizerBuilder builder() {
+        return new TokenizerBuilder();
+    }
+    
+    public static class TokenizerBuilder {
+        private TokenParser tokenParser;
+        
+        public TokenizerBuilder parser(TokenParser parser) {
+            this.tokenParser = parser;
+            return this;
+        }
+        
+        public Tokenizer build() {
+            Tokenizer tokenizer = new Tokenizer();
+            tokenizer.setTokenParser(tokenParser);
+            return tokenizer;
+        }
+    }
+}
diff --git a/src/main/java/component/util/Assert.java b/src/main/java/component/util/Assert.java
new file mode 100644
index 0000000..9b1903b
--- /dev/null
+++ b/src/main/java/component/util/Assert.java
@@ -0,0 +1,405 @@
+package component.util;
+
+import java.util.Collection;
+import java.util.Map;
+
+public abstract class Assert {
+
+    /**
+     * Assert a boolean expression, throwing {@code IllegalArgumentException} if
+     * the test result is {@code false}.
+     * <pre class="code">Assert.isTrue(i &gt; 0, "The value must be greater than
+     * zero");</pre>
+     *
+     * @param expression a boolean expression
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if expression is {@code false}
+     */
+    public static void isTrue(boolean expression, String message) {
+        if (!expression) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert a boolean expression, throwing {@code IllegalArgumentException} if
+     * the test result is {@code false}.
+     * <pre class="code">Assert.isTrue(i &gt; 0);</pre>
+     *
+     * @param expression a boolean expression
+     * @throws IllegalArgumentException if expression is {@code false}
+     */
+    public static void isTrue(boolean expression) {
+        isTrue(expression, "[Assertion failed] - this expression must be true");
+    }
+
+    /**
+     * Assert that an object is {@code null} .
+     * <pre class="code">Assert.isNull(value, "The value must be null");</pre>
+     *
+     * @param object the object to check
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the object is not {@code null}
+     */
+    public static void isNull(Object object, String message) {
+        if (object != null) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that an object is {@code null} .
+     * <pre class="code">Assert.isNull(value);</pre>
+     *
+     * @param object the object to check
+     * @throws IllegalArgumentException if the object is not {@code null}
+     */
+    public static void isNull(Object object) {
+        isNull(object, "[Assertion failed] - the object argument must be null");
+    }
+
+    /**
+     * Assert that an object is not {@code null} .
+     * <pre class="code">Assert.notNull(clazz, "The class must not be
+     * null");</pre>
+     *
+     * @param object the object to check
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the object is {@code null}
+     */
+    public static void notNull(Object object, String message) {
+        if (object == null) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that an object is not {@code null} .
+     * <pre class="code">Assert.notNull(clazz);</pre>
+     *
+     * @param object the object to check
+     * @throws IllegalArgumentException if the object is {@code null}
+     */
+    public static void notNull(Object object) {
+        notNull(object, "[Assertion failed] - this argument is required; it must not be null");
+    }
+
+    /**
+     * Assert that the given String is not empty; that is, it must not be
+     * {@code null} and not the empty String.
+     * <pre class="code">Assert.hasLength(name, "Name must not be empty");</pre>
+     *
+     * @param text the String to check
+     * @param message the exception message to use if the assertion fails
+     * @see StringUtils#hasLength
+     * @throws IllegalArgumentException if the text is empty
+     */
+    public static void hasLength(String text, String message) {
+        if (!StringUtils.hasLength(text)) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that the given String is not empty; that is, it must not be
+     * {@code null} and not the empty String.
+     * <pre class="code">Assert.hasLength(name);</pre>
+     *
+     * @param text the String to check
+     * @see StringUtils#hasLength
+     * @throws IllegalArgumentException if the text is empty
+     */
+    public static void hasLength(String text) {
+        String msg = "[Assertion failed] - this String argument must have length; it must not be null or empty";
+        hasLength(text, msg);
+    }
+
+    /**
+     * Assert that the given String has valid text content; that is, it must not
+     * be {@code null} and must contain at least one non-whitespace character.
+     * <pre class="code">Assert.hasText(name, "'name' must not be empty");</pre>
+     *
+     * @param text the String to check
+     * @param message the exception message to use if the assertion fails
+     * @see StringUtils#hasText
+     * @throws IllegalArgumentException if the text does not contain valid text
+     * content
+     */
+    public static void hasText(String text, String message) {
+        if (!StringUtils.hasText(text)) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that the given String has valid text content; that is, it must not
+     * be {@code null} and must contain at least one non-whitespace character.
+     * <pre class="code">Assert.hasText(name, "'name' must not be empty");</pre>
+     *
+     * @param text the String to check
+     * @see StringUtils#hasText
+     * @throws IllegalArgumentException if the text does not contain valid text
+     * content
+     */
+    public static void hasText(String text) {
+        hasText(text,
+                "[Assertion failed] - this String argument must have text; it must not be null, empty, or blank");
+    }
+
+    /**
+     * Assert that the given text does not contain the given substring.
+     * <pre class="code">Assert.doesNotContain(name, "rod", "Name must not
+     * contain 'rod'");</pre>
+     *
+     * @param textToSearch the text to search
+     * @param substring the substring to find within the text
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the text contains the substring
+     */
+    public static void doesNotContain(String textToSearch, String substring, String message) {
+        if (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring)
+                && textToSearch.contains(substring)) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that the given text does not contain the given substring.
+     * <pre class="code">Assert.doesNotContain(name, "rod");</pre>
+     *
+     * @param textToSearch the text to search
+     * @param substring the substring to find within the text
+     * @throws IllegalArgumentException if the text contains the substring
+     */
+    public static void doesNotContain(String textToSearch, String substring) {
+        doesNotContain(textToSearch, substring,
+                "[Assertion failed] - this String argument must not contain the substring [" + substring + "]");
+    }
+
+    /**
+     * Assert that an array has elements; that is, it must not be {@code null}
+     * and must have at least one element.
+     * <pre class="code">Assert.notEmpty(array, "The array must have
+     * elements");</pre>
+     *
+     * @param array the array to check
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the object array is {@code null} or
+     * has no elements
+     */
+    public static void notEmpty(Object[] array, String message) {
+        if (ObjectUtils.isEmpty(array)) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that an array has elements; that is, it must not be {@code null}
+     * and must have at least one element.
+     * <pre class="code">Assert.notEmpty(array);</pre>
+     *
+     * @param array the array to check
+     * @throws IllegalArgumentException if the object array is {@code null} or
+     * has no elements
+     */
+    public static void notEmpty(Object[] array) {
+        notEmpty(array, "[Assertion failed] - this array must not be empty: it must contain at least 1 element");
+    }
+
+    /**
+     * Assert that an array has no null elements. Note: Does not complain if the
+     * array is empty!
+     * <pre class="code">Assert.noNullElements(array, "The array must have
+     * non-null elements");</pre>
+     *
+     * @param array the array to check
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the object array contains a
+     * {@code null} element
+     */
+    public static void noNullElements(Object[] array, String message) {
+        if (array != null) {
+            for (Object element : array) {
+                if (element == null) {
+                    throw new IllegalArgumentException(message);
+                }
+            }
+        }
+    }
+
+    /**
+     * Assert that an array has no null elements. Note: Does not complain if the
+     * array is empty!
+     * <pre class="code">Assert.noNullElements(array);</pre>
+     *
+     * @param array the array to check
+     * @throws IllegalArgumentException if the object array contains a
+     * {@code null} element
+     */
+    public static void noNullElements(Object[] array) {
+        noNullElements(array, "[Assertion failed] - this array must not contain any null elements");
+    }
+
+    /**
+     * Assert that a collection has elements; that is, it must not be
+     * {@code null} and must have at least one element.
+     * <pre class="code">Assert.notEmpty(collection, "Collection must have
+     * elements");</pre>
+     *
+     * @param collection the collection to check
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the collection is {@code null} or has
+     * no elements
+     */
+    public static void notEmpty(Collection<?> collection, String message) {
+        if (CollectionUtils.isEmpty(collection)) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that a collection has elements; that is, it must not be
+     * {@code null} and must have at least one element.
+     * <pre class="code">Assert.notEmpty(collection, "Collection must have
+     * elements");</pre>
+     *
+     * @param collection the collection to check
+     * @throws IllegalArgumentException if the collection is {@code null} or has
+     * no elements
+     */
+    public static void notEmpty(Collection<?> collection) {
+        notEmpty(collection,
+                "[Assertion failed] - this collection must not be empty: it must contain at least 1 element");
+    }
+
+    /**
+     * Assert that a Map has entries; that is, it must not be {@code null} and
+     * must have at least one entry.
+     * <pre class="code">Assert.notEmpty(map, "Map must have entries");</pre>
+     *
+     * @param map the map to check
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the map is {@code null} or has no
+     * entries
+     */
+    public static void notEmpty(Map<?, ?> map, String message) {
+        if (CollectionUtils.isEmpty(map)) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that a Map has entries; that is, it must not be {@code null} and
+     * must have at least one entry.
+     * <pre class="code">Assert.notEmpty(map);</pre>
+     *
+     * @param map the map to check
+     * @throws IllegalArgumentException if the map is {@code null} or has no
+     * entries
+     */
+    public static void notEmpty(Map<?, ?> map) {
+        notEmpty(map, "[Assertion failed] - this map must not be empty; it must contain at least one entry");
+    }
+
+    /**
+     * Assert that the provided object is an instance of the provided class.
+     * <pre class="code">Assert.instanceOf(Foo.class, foo);</pre>
+     *
+     * @param clazz the required class
+     * @param obj the object to check
+     * @throws IllegalArgumentException if the object is not an instance of
+     * clazz
+     * @see Class#isInstance
+     */
+    public static void isInstanceOf(Class<?> clazz, Object obj) {
+        isInstanceOf(clazz, obj, "");
+    }
+
+    /**
+     * Assert that the provided object is an instance of the provided class.
+     * <pre class="code">Assert.instanceOf(Foo.class, foo);</pre>
+     *
+     * @param type the type to check against
+     * @param obj the object to check
+     * @param message a message which will be prepended to the message produced
+     * by the function itself, and which may be used to provide context. It
+     * should normally end in ":" or "." so that the generated message looks OK
+     * when appended to it.
+     * @throws IllegalArgumentException if the object is not an instance of
+     * clazz
+     * @see Class#isInstance
+     */
+    public static void isInstanceOf(Class<?> type, Object obj, String message) {
+        notNull(type, "Type to check against must not be null");
+        if (!type.isInstance(obj)) {
+            throw new IllegalArgumentException(
+                    (StringUtils.hasLength(message) ? message + " " : "")
+                    + "Object of class [" + (obj != null ? obj.getClass().getName() : "null")
+                    + "] must be an instance of " + type);
+        }
+    }
+
+    /**
+     * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.
+     * <pre class="code">Assert.isAssignable(Number.class, myClass);</pre>
+     *
+     * @param superType the super type to check
+     * @param subType the sub type to check
+     * @throws IllegalArgumentException if the classes are not assignable
+     */
+    public static void isAssignable(Class<?> superType, Class<?> subType) {
+        isAssignable(superType, subType, "");
+    }
+
+    /**
+     * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.
+     * <pre class="code">Assert.isAssignable(Number.class, myClass);</pre>
+     *
+     * @param superType the super type to check against
+     * @param subType the sub type to check
+     * @param message a message which will be prepended to the message produced
+     * by the function itself, and which may be used to provide context. It
+     * should normally end in ":" or "." so that the generated message looks OK
+     * when appended to it.
+     * @throws IllegalArgumentException if the classes are not assignable
+     */
+    public static void isAssignable(Class<?> superType, Class<?> subType, String message) {
+        notNull(superType, "Type to check against must not be null");
+        if (subType == null || !superType.isAssignableFrom(subType)) {
+            throw new IllegalArgumentException((StringUtils.hasLength(message) ? message + " " : "")
+                    + subType + " is not assignable to " + superType);
+        }
+    }
+
+    /**
+     * Assert a boolean expression, throwing {@code IllegalStateException} if
+     * the test result is {@code false}. Call isTrue if you wish to throw
+     * IllegalArgumentException on an assertion failure.
+     * <pre class="code">Assert.state(id == null, "The id property must not
+     * already be initialized");</pre>
+     *
+     * @param expression a boolean expression
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalStateException if expression is {@code false}
+     */
+    public static void state(boolean expression, String message) {
+        if (!expression) {
+            throw new IllegalStateException(message);
+        }
+    }
+
+    /**
+     * Assert a boolean expression, throwing {@link IllegalStateException} if
+     * the test result is {@code false}.
+     * <p>
+     * Call {@link #isTrue(boolean)} if you wish to throw
+     * {@link IllegalArgumentException} on an assertion failure.
+     * <pre class="code">Assert.state(id == null);</pre>
+     *
+     * @param expression a boolean expression
+     * @throws IllegalStateException if the supplied expression is {@code false}
+     */
+    public static void state(boolean expression) {
+        state(expression, "[Assertion failed] - this state invariant must be true");
+    }
+}
diff --git a/src/main/java/component/util/ClassUtils.java b/src/main/java/component/util/ClassUtils.java
new file mode 100644
index 0000000..11e1aa2
--- /dev/null
+++ b/src/main/java/component/util/ClassUtils.java
@@ -0,0 +1,1313 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package component.util;
+
+import java.beans.Introspector;
+import java.lang.reflect.Array;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.Proxy;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ *
+ * @author cdi305
+ */
+public abstract class ClassUtils {
+
+    /**
+     * Suffix for array class names: "[]"
+     */
+    public static final String ARRAY_SUFFIX = "[]";
+
+    /**
+     * Prefix for internal array class names: "["
+     */
+    private static final String INTERNAL_ARRAY_PREFIX = "[";
+
+    /**
+     * Prefix for internal non-primitive array class names: "[L"
+     */
+    private static final String NON_PRIMITIVE_ARRAY_PREFIX = "[L";
+
+    /**
+     * The package separator character '.'
+     */
+    private static final char PACKAGE_SEPARATOR = '.';
+
+    /**
+     * The path separator character '/'
+     */
+    private static final char PATH_SEPARATOR = '/';
+
+    /**
+     * The inner class separator character '$'
+     */
+    private static final char INNER_CLASS_SEPARATOR = '$';
+
+    /**
+     * The CGLIB class separator character "$$"
+     */
+    public static final String CGLIB_CLASS_SEPARATOR = "$$";
+
+    /**
+     * The ".class" file suffix
+     */
+    public static final String CLASS_FILE_SUFFIX = ".class";
+
+    /**
+     * Map with primitive wrapper type as key and corresponding primitive type
+     * as value, for example: Integer.class -> int.class.
+     */
+    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<>(8);
+
+    /**
+     * Map with primitive type as key and corresponding wrapper type as value,
+     * for example: int.class -> Integer.class.
+     */
+    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<>(8);
+
+    /**
+     * Map with primitive type name as key and corresponding primitive type as
+     * value, for example: "int" -> "int.class".
+     */
+    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<>(32);
+
+    /**
+     * Map with common "java.lang" class name as key and corresponding Class as
+     * value. Primarily for efficient deserialization of remote invocations.
+     */
+    private static final Map<String, Class<?>> commonClassCache = new HashMap<>(32);
+
+    static {
+        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);
+        primitiveWrapperTypeMap.put(Byte.class, byte.class);
+        primitiveWrapperTypeMap.put(Character.class, char.class);
+        primitiveWrapperTypeMap.put(Double.class, double.class);
+        primitiveWrapperTypeMap.put(Float.class, float.class);
+        primitiveWrapperTypeMap.put(Integer.class, int.class);
+        primitiveWrapperTypeMap.put(Long.class, long.class);
+        primitiveWrapperTypeMap.put(Short.class, short.class);
+
+        primitiveWrapperTypeMap.entrySet().stream().map((entry) -> {
+            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());
+            return entry;
+        }).forEach((entry) -> {
+            registerCommonClasses(entry.getKey());
+        });
+
+        Set<Class<?>> primitiveTypes = new HashSet<>(32);
+        primitiveTypes.addAll(primitiveWrapperTypeMap.values());
+        primitiveTypes.addAll(Arrays.asList(new Class<?>[]{
+            boolean[].class, byte[].class, char[].class, double[].class,
+            float[].class, int[].class, long[].class, short[].class}));
+        primitiveTypes.add(void.class);
+        
+        primitiveTypes.stream().forEach((primitiveType) -> {
+            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);
+        });
+
+        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class,
+                Float[].class, Integer[].class, Long[].class, Short[].class);
+        registerCommonClasses(Number.class, Number[].class, String.class, String[].class,
+                Object.class, Object[].class, Class.class, Class[].class);
+        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class,
+                Error.class, StackTraceElement.class, StackTraceElement[].class);
+    }
+
+    /**
+     * Register the given common classes with the ClassUtils cache.
+     */
+    private static void registerCommonClasses(Class<?>... commonClasses) {
+        for (Class<?> clazz : commonClasses) {
+            commonClassCache.put(clazz.getName(), clazz);
+        }
+    }
+
+    /**
+     * Return the default ClassLoader to use: typically the thread context
+     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils
+     * class will be used as fallback.
+     * <p>
+     * Call this method if you intend to use the thread context ClassLoader in a
+     * scenario where you clearly prefer a non-null ClassLoader reference: for
+     * example, for class path resource loading (but not necessarily for
+     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference
+     * as well).
+     *
+     * @return the default ClassLoader (only {@code null} if even the system
+     * ClassLoader isn't accessible)
+     * @see Thread#getContextClassLoader()
+     * @see ClassLoader#getSystemClassLoader()
+     */
+    public static ClassLoader getDefaultClassLoader() {
+        ClassLoader cl = null;
+        try {
+            cl = Thread.currentThread().getContextClassLoader();
+        } catch (Throwable ex) {
+            // Cannot access thread context ClassLoader - falling back...
+        }
+        if (cl == null) {
+            // No thread context class loader -> use class loader of this class.
+            cl = ClassUtils.class.getClassLoader();
+            if (cl == null) {
+                // getClassLoader() returning null indicates the bootstrap ClassLoader
+                try {
+                    cl = ClassLoader.getSystemClassLoader();
+                } catch (Throwable ex) {
+                    // Cannot access system ClassLoader - oh well, maybe the caller can live with null...
+                }
+            }
+        }
+        return cl;
+    }
+
+    /**
+     * Override the thread context ClassLoader with the environment's bean
+     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent
+     * to the thread context ClassLoader already.
+     *
+     * @param classLoaderToUse the actual ClassLoader to use for the thread
+     * context
+     * @return the original thread context ClassLoader, or {@code null} if not
+     * overridden
+     */
+    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {
+        Thread currentThread = Thread.currentThread();
+        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();
+        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {
+            currentThread.setContextClassLoader(classLoaderToUse);
+            return threadContextClassLoader;
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Replacement for {@code Class.forName()} that also returns Class instances
+     * for primitives (e.g. "int") and array class names (e.g. "String[]").
+     * Furthermore, it is also capable of resolving inner class names in Java
+     * source style (e.g. "java.lang.Thread.State" instead of
+     * "java.lang.Thread$State").
+     *
+     * @param name the name of the Class
+     * @param classLoader the class loader to use (may be {@code null}, which
+     * indicates the default class loader)
+     * @return Class instance for the supplied name
+     * @throws ClassNotFoundException if the class was not found
+     * @throws LinkageError if the class file could not be loaded
+     * @see Class#forName(String, boolean, ClassLoader)
+     */
+    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {
+        Assert.notNull(name, "Name must not be null");
+
+        Class<?> clazz = resolvePrimitiveClassName(name);
+        if (clazz == null) {
+            clazz = commonClassCache.get(name);
+        }
+        if (clazz != null) {
+            return clazz;
+        }
+
+        // "java.lang.String[]" style arrays
+        if (name.endsWith(ARRAY_SUFFIX)) {
+            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());
+            Class<?> elementClass = forName(elementClassName, classLoader);
+            return Array.newInstance(elementClass, 0).getClass();
+        }
+
+        // "[Ljava.lang.String;" style arrays
+        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(";")) {
+            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);
+            Class<?> elementClass = forName(elementName, classLoader);
+            return Array.newInstance(elementClass, 0).getClass();
+        }
+
+        // "[[I" or "[[Ljava.lang.String;" style arrays
+        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {
+            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());
+            Class<?> elementClass = forName(elementName, classLoader);
+            return Array.newInstance(elementClass, 0).getClass();
+        }
+
+        ClassLoader clToUse = classLoader;
+        if (clToUse == null) {
+            clToUse = getDefaultClassLoader();
+        }
+        try {
+            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));
+        } catch (ClassNotFoundException ex) {
+            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);
+            if (lastDotIndex != -1) {
+                String innerClassName
+                        = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);
+                try {
+                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));
+                } catch (ClassNotFoundException ex2) {
+                    // Swallow - let original exception get through
+                }
+            }
+            throw ex;
+        }
+    }
+
+    /**
+     * Resolve the given class name into a Class instance. Supports primitives
+     * (like "int") and array class names (like "String[]").
+     * <p>
+     * This is effectively equivalent to the {@code forName} method with the
+     * same arguments, with the only difference being the exceptions thrown in
+     * case of class loading failure.
+     *
+     * @param className the name of the Class
+     * @param classLoader the class loader to use (may be {@code null}, which
+     * indicates the default class loader)
+     * @return Class instance for the supplied name
+     * @throws IllegalArgumentException if the class name was not resolvable
+     * (that is, the class could not be found or the class file could not be
+     * loaded)
+     * @see #forName(String, ClassLoader)
+     */
+    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {
+        try {
+            return forName(className, classLoader);
+        } catch (ClassNotFoundException ex) {
+            throw new IllegalArgumentException("Cannot find class [" + className + "]", ex);
+        } catch (LinkageError ex) {
+            throw new IllegalArgumentException(
+                    "Error loading class [" + className + "]: problem with class file or dependent class.", ex);
+        }
+    }
+
+    /**
+     * Resolve the given class name as primitive class, if appropriate,
+     * according to the JVM's naming rules for primitive classes.
+     * <p>
+     * Also supports the JVM's internal class names for primitive arrays. Does
+     * <i>not</i> support the "[]" suffix notation for primitive arrays; this is
+     * only supported by {@link #forName(String, ClassLoader)}.
+     *
+     * @param name the name of the potentially primitive class
+     * @return the primitive class, or {@code null} if the name does not denote
+     * a primitive class or primitive array class
+     */
+    public static Class<?> resolvePrimitiveClassName(String name) {
+        Class<?> result = null;
+		// Most class names will be quite long, considering that they
+        // SHOULD sit in a package, so a length check is worthwhile.
+        if (name != null && name.length() <= 8) {
+            // Could be a primitive - likely.
+            result = primitiveTypeNameMap.get(name);
+        }
+        return result;
+    }
+
+    /**
+     * Determine whether the {@link Class} identified by the supplied name is
+     * present and can be loaded. Will return {@code false} if either the class
+     * or one of its dependencies is not present or cannot be loaded.
+     *
+     * @param className the name of the class to check
+     * @param classLoader the class loader to use (may be {@code null}, which
+     * indicates the default class loader)
+     * @return whether the specified class is present
+     */
+    public static boolean isPresent(String className, ClassLoader classLoader) {
+        try {
+            forName(className, classLoader);
+            return true;
+        } catch (ClassNotFoundException | LinkageError ex) {
+            // Class or one of its dependencies is not present...
+            return false;
+        }
+    }
+
+    /**
+     * Return the user-defined class for the given instance: usually simply the
+     * class of the given instance, but the original class in case of a
+     * CGLIB-generated subclass.
+     *
+     * @param instance the instance to check
+     * @return the user-defined class
+     */
+    public static Class<?> getUserClass(Object instance) {
+        Assert.notNull(instance, "Instance must not be null");
+        return getUserClass(instance.getClass());
+    }
+
+    /**
+     * Return the user-defined class for the given class: usually simply the
+     * given class, but the original class in case of a CGLIB-generated
+     * subclass.
+     *
+     * @param clazz the class to check
+     * @return the user-defined class
+     */
+    public static Class<?> getUserClass(Class<?> clazz) {
+        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {
+            Class<?> superclass = clazz.getSuperclass();
+            if (superclass != null && Object.class != superclass) {
+                return superclass;
+            }
+        }
+        return clazz;
+    }
+
+    /**
+     * Check whether the given class is cache-safe in the given context, i.e.
+     * whether it is loaded by the given ClassLoader or a parent of it.
+     *
+     * @param clazz the class to analyze
+     * @param classLoader the ClassLoader to potentially cache metadata in
+     * @return 
+     */
+    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {
+        Assert.notNull(clazz, "Class must not be null");
+        try {
+            ClassLoader target = clazz.getClassLoader();
+            if (target == null) {
+                return true;
+            }
+            ClassLoader cur = classLoader;
+            if (cur == target) {
+                return true;
+            }
+            while (cur != null) {
+                cur = cur.getParent();
+                if (cur == target) {
+                    return true;
+                }
+            }
+            return false;
+        } catch (SecurityException ex) {
+            // Probably from the system ClassLoader - let's consider it safe.
+            return true;
+        }
+    }
+
+    /**
+     * Get the class name without the qualified package name.
+     *
+     * @param className the className to get the short name for
+     * @return the class name of the class without the package name
+     * @throws IllegalArgumentException if the className is empty
+     */
+    public static String getShortName(String className) {
+        Assert.hasLength(className, "Class name must not be empty");
+        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);
+        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);
+        if (nameEndIndex == -1) {
+            nameEndIndex = className.length();
+        }
+        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);
+        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);
+        return shortName;
+    }
+
+    /**
+     * Get the class name without the qualified package name.
+     *
+     * @param clazz the class to get the short name for
+     * @return the class name of the class without the package name
+     */
+    public static String getShortName(Class<?> clazz) {
+        return getShortName(getQualifiedName(clazz));
+    }
+
+    /**
+     * Return the short string name of a Java class in uncapitalized JavaBeans
+     * property format. Strips the outer class name in case of an inner class.
+     *
+     * @param clazz the class
+     * @return the short name rendered in a standard JavaBeans property format
+     * @see java.beans.Introspector#decapitalize(String)
+     */
+    public static String getShortNameAsProperty(Class<?> clazz) {
+        String shortName = getShortName(clazz);
+        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);
+        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);
+        return Introspector.decapitalize(shortName);
+    }
+
+    /**
+     * Determine the name of the class file, relative to the containing package:
+     * e.g. "String.class"
+     *
+     * @param clazz the class
+     * @return the file name of the ".class" file
+     */
+    public static String getClassFileName(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        String className = clazz.getName();
+        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);
+        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;
+    }
+
+    /**
+     * Determine the name of the package of the given class, e.g. "java.lang"
+     * for the {@code java.lang.String} class.
+     *
+     * @param clazz the class
+     * @return the package name, or the empty String if the class is defined in
+     * the default package
+     */
+    public static String getPackageName(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        return getPackageName(clazz.getName());
+    }
+
+    /**
+     * Determine the name of the package of the given fully-qualified class
+     * name, e.g. "java.lang" for the {@code java.lang.String} class name.
+     *
+     * @param fqClassName the fully-qualified class name
+     * @return the package name, or the empty String if the class is defined in
+     * the default package
+     */
+    public static String getPackageName(String fqClassName) {
+        Assert.notNull(fqClassName, "Class name must not be null");
+        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);
+        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : "");
+    }
+
+    /**
+     * Return the qualified name of the given class: usually simply the class
+     * name, but component type class name + "[]" for arrays.
+     *
+     * @param clazz the class
+     * @return the qualified name of the class
+     */
+    public static String getQualifiedName(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        if (clazz.isArray()) {
+            return getQualifiedNameForArray(clazz);
+        } else {
+            return clazz.getName();
+        }
+    }
+
+    /**
+     * Build a nice qualified name for an array: component type class name +
+     * "[]".
+     *
+     * @param clazz the array class
+     * @return a qualified name for the array class
+     */
+    private static String getQualifiedNameForArray(Class<?> clazz) {
+        StringBuilder result = new StringBuilder();
+        while (clazz.isArray()) {
+            clazz = clazz.getComponentType();
+            result.append(ARRAY_SUFFIX);
+        }
+        result.insert(0, clazz.getName());
+        return result.toString();
+    }
+
+    /**
+     * Return the qualified name of the given method, consisting of fully
+     * qualified interface/class name + "." + method name.
+     *
+     * @param method the method
+     * @return the qualified name of the method
+     */
+    public static String getQualifiedMethodName(Method method) {
+        Assert.notNull(method, "Method must not be null");
+        return method.getDeclaringClass().getName() + "." + method.getName();
+    }
+
+    /**
+     * Return a descriptive name for the given object's type: usually simply the
+     * class name, but component type class name + "[]" for arrays, and an
+     * appended list of implemented interfaces for JDK proxies.
+     *
+     * @param value the value to introspect
+     * @return the qualified name of the class
+     */
+    public static String getDescriptiveType(Object value) {
+        if (value == null) {
+            return null;
+        }
+        Class<?> clazz = value.getClass();
+        if (Proxy.isProxyClass(clazz)) {
+            StringBuilder result = new StringBuilder(clazz.getName());
+            result.append(" implementing ");
+            Class<?>[] ifcs = clazz.getInterfaces();
+            for (int i = 0; i < ifcs.length; i++) {
+                result.append(ifcs[i].getName());
+                if (i < ifcs.length - 1) {
+                    result.append(',');
+                }
+            }
+            return result.toString();
+        } else if (clazz.isArray()) {
+            return getQualifiedNameForArray(clazz);
+        } else {
+            return clazz.getName();
+        }
+    }
+
+    /**
+     * Check whether the given class matches the user-specified type name.
+     *
+     * @param clazz the class to check
+     * @param typeName the type name to match
+     * @return 
+     */
+    public static boolean matchesTypeName(Class<?> clazz, String typeName) {
+        return (typeName != null
+                && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName())
+                || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));
+    }
+
+    /**
+     * Determine whether the given class has a public constructor with the given
+     * signature.
+     * <p>
+     * Essentially translates {@code NoSuchMethodException} to "false".
+     *
+     * @param clazz the clazz to analyze
+     * @param paramTypes the parameter types of the method
+     * @return whether the class has a corresponding constructor
+     * @see Class#getMethod
+     */
+    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {
+        return (getConstructorIfAvailable(clazz, paramTypes) != null);
+    }
+
+    /**
+     * Determine whether the given class has a public constructor with the given
+     * signature, and return it if available (else return {@code null}).
+     * <p>
+     * Essentially translates {@code NoSuchMethodException} to {@code null}.
+     *
+     * @param <T>
+     * @param clazz the clazz to analyze
+     * @param paramTypes the parameter types of the method
+     * @return the constructor, or {@code null} if not found
+     * @see Class#getConstructor
+     */
+    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {
+        Assert.notNull(clazz, "Class must not be null");
+        try {
+            return clazz.getConstructor(paramTypes);
+        } catch (NoSuchMethodException ex) {
+            return null;
+        }
+    }
+
+    /**
+     * Determine whether the given class has a public method with the given
+     * signature.
+     * <p>
+     * Essentially translates {@code NoSuchMethodException} to "false".
+     *
+     * @param clazz the clazz to analyze
+     * @param methodName the name of the method
+     * @param paramTypes the parameter types of the method
+     * @return whether the class has a corresponding method
+     * @see Class#getMethod
+     */
+    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {
+        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);
+    }
+
+    /**
+     * Determine whether the given class has a public method with the given
+     * signature, and return it if available (else throws an
+     * {@code IllegalStateException}).
+     * <p>
+     * In case of any signature specified, only returns the method if there is a
+     * unique candidate, i.e. a single public method with the specified name.
+     * <p>
+     * Essentially translates {@code NoSuchMethodException} to
+     * {@code IllegalStateException}.
+     *
+     * @param clazz the clazz to analyze
+     * @param methodName the name of the method
+     * @param paramTypes the parameter types of the method (may be {@code null}
+     * to indicate any signature)
+     * @return the method (never {@code null})
+     * @throws IllegalStateException if the method has not been found
+     * @see Class#getMethod
+     */
+    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.notNull(methodName, "Method name must not be null");
+        if (paramTypes != null) {
+            try {
+                return clazz.getMethod(methodName, paramTypes);
+            } catch (NoSuchMethodException ex) {
+                throw new IllegalStateException("Expected method not found: " + ex);
+            }
+        } else {
+            Set<Method> candidates = new HashSet<>(1);
+            Method[] methods = clazz.getMethods();
+            for (Method method : methods) {
+                if (methodName.equals(method.getName())) {
+                    candidates.add(method);
+                }
+            }
+            if (candidates.size() == 1) {
+                return candidates.iterator().next();
+            } else if (candidates.isEmpty()) {
+                throw new IllegalStateException("Expected method not found: " + clazz + "." + methodName);
+            } else {
+                throw new IllegalStateException("No unique method found: " + clazz + "." + methodName);
+            }
+        }
+    }
+
+    /**
+     * Determine whether the given class has a public method with the given
+     * signature, and return it if available (else return {@code null}).
+     * <p>
+     * In case of any signature specified, only returns the method if there is a
+     * unique candidate, i.e. a single public method with the specified name.
+     * <p>
+     * Essentially translates {@code NoSuchMethodException} to {@code null}.
+     *
+     * @param clazz the clazz to analyze
+     * @param methodName the name of the method
+     * @param paramTypes the parameter types of the method (may be {@code null}
+     * to indicate any signature)
+     * @return the method, or {@code null} if not found
+     * @see Class#getMethod
+     */
+    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.notNull(methodName, "Method name must not be null");
+        if (paramTypes != null) {
+            try {
+                return clazz.getMethod(methodName, paramTypes);
+            } catch (NoSuchMethodException ex) {
+                return null;
+            }
+        } else {
+            Set<Method> candidates = new HashSet<>(1);
+            Method[] methods = clazz.getMethods();
+            for (Method method : methods) {
+                if (methodName.equals(method.getName())) {
+                    candidates.add(method);
+                }
+            }
+            if (candidates.size() == 1) {
+                return candidates.iterator().next();
+            }
+            return null;
+        }
+    }
+
+    /**
+     * Return the number of methods with a given name (with any argument types),
+     * for the given class and/or its superclasses. Includes non-public methods.
+     *
+     * @param clazz	the clazz to check
+     * @param methodName the name of the method
+     * @return the number of methods with the given name
+     */
+    public static int getMethodCountForName(Class<?> clazz, String methodName) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.notNull(methodName, "Method name must not be null");
+        int count = 0;
+        Method[] declaredMethods = clazz.getDeclaredMethods();
+        for (Method method : declaredMethods) {
+            if (methodName.equals(method.getName())) {
+                count++;
+            }
+        }
+        Class<?>[] ifcs = clazz.getInterfaces();
+        for (Class<?> ifc : ifcs) {
+            count += getMethodCountForName(ifc, methodName);
+        }
+        if (clazz.getSuperclass() != null) {
+            count += getMethodCountForName(clazz.getSuperclass(), methodName);
+        }
+        return count;
+    }
+
+    /**
+     * Does the given class or one of its superclasses at least have one or more
+     * methods with the supplied name (with any argument types)? Includes
+     * non-public methods.
+     *
+     * @param clazz	the clazz to check
+     * @param methodName the name of the method
+     * @return whether there is at least one method with the given name
+     */
+    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.notNull(methodName, "Method name must not be null");
+        Method[] declaredMethods = clazz.getDeclaredMethods();
+        for (Method method : declaredMethods) {
+            if (method.getName().equals(methodName)) {
+                return true;
+            }
+        }
+        Class<?>[] ifcs = clazz.getInterfaces();
+        for (Class<?> ifc : ifcs) {
+            if (hasAtLeastOneMethodWithName(ifc, methodName)) {
+                return true;
+            }
+        }
+        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));
+    }
+
+    /**
+     * Given a method, which may come from an interface, and a target class used
+     * in the current reflective invocation, find the corresponding target
+     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the
+     * target class may be {@code DefaultFoo}. In this case, the method may be
+     * {@code DefaultFoo.bar()}. This enables attributes on that method to be
+     * found.
+     * <p>
+     * <b>NOTE:</b> In contrast to
+     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},
+     * this method does <i>not</i> resolve Java 5 bridge methods automatically.
+     * Call
+     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}
+     * if bridge method resolution is desirable (e.g. for obtaining metadata
+     * from the original method definition).
+     * <p>
+     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow
+     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,
+     * this implementation will fall back to returning the originally provided
+     * method.
+     *
+     * @param method the method to be invoked, which may come from an interface
+     * @param targetClass the target class for the current invocation. May be
+     * {@code null} or may not even implement the method.
+     * @return the specific target method, or the original method if the
+     * {@code targetClass} doesn't implement it or is {@code null}
+     */
+    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {
+        if (method != null && isOverridable(method, targetClass)
+                && targetClass != null && targetClass != method.getDeclaringClass()) {
+            try {
+                if (Modifier.isPublic(method.getModifiers())) {
+                    try {
+                        return targetClass.getMethod(method.getName(), method.getParameterTypes());
+                    } catch (NoSuchMethodException ex) {
+                        return method;
+                    }
+                } else {
+                    Method specificMethod
+                            = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());
+                    return (specificMethod != null ? specificMethod : method);
+                }
+            } catch (SecurityException ex) {
+                // Security settings are disallowing reflective access; fall back to 'method' below.
+            }
+        }
+        return method;
+    }
+
+    /**
+     * Determine whether the given method is declared by the user or at least
+     * pointing to a user-declared method.
+     * <p>
+     * Checks {@link Method#isSynthetic()} (for implementation methods) as well
+     * as the {@code GroovyObject} interface (for interface methods; on an
+     * implementation class, implementations of the {@code GroovyObject} methods
+     * will be marked as synthetic anyway). Note that, despite being synthetic,
+     * bridge methods ({@link Method#isBridge()}) are considered as user-level
+     * methods since they are eventually pointing to a user-declared generic
+     * method.
+     *
+     * @param method the method to check
+     * @return {@code true} if the method can be considered as user-declared;
+     * [@code false} otherwise
+     */
+    public static boolean isUserLevelMethod(Method method) {
+        Assert.notNull(method, "Method must not be null");
+        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));
+    }
+
+    private static boolean isGroovyObjectMethod(Method method) {
+        return method.getDeclaringClass().getName().equals("groovy.lang.GroovyObject");
+    }
+
+    /**
+     * Determine whether the given method is overridable in the given target
+     * class.
+     *
+     * @param method the method to check
+     * @param targetClass the target class to check against
+     */
+    private static boolean isOverridable(Method method, Class<?> targetClass) {
+        if (Modifier.isPrivate(method.getModifiers())) {
+            return false;
+        }
+        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {
+            return true;
+        }
+        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));
+    }
+
+    /**
+     * Return a public static method of a class.
+     *
+     * @param clazz the class which defines the method
+     * @param methodName the static method name
+     * @param args the parameter types to the method
+     * @return the static method, or {@code null} if no static method was found
+     * @throws IllegalArgumentException if the method name is blank or the clazz
+     * is null
+     */
+    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.notNull(methodName, "Method name must not be null");
+        try {
+            Method method = clazz.getMethod(methodName, args);
+            return Modifier.isStatic(method.getModifiers()) ? method : null;
+        } catch (NoSuchMethodException ex) {
+            return null;
+        }
+    }
+
+    /**
+     * Check if the given class represents a primitive wrapper, i.e. Boolean,
+     * Byte, Character, Short, Integer, Long, Float, or Double.
+     *
+     * @param clazz the class to check
+     * @return whether the given class is a primitive wrapper class
+     */
+    public static boolean isPrimitiveWrapper(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        return primitiveWrapperTypeMap.containsKey(clazz);
+    }
+
+    /**
+     * Check if the given class represents a primitive (i.e. boolean, byte,
+     * char, short, int, long, float, or double) or a primitive wrapper (i.e.
+     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).
+     *
+     * @param clazz the class to check
+     * @return whether the given class is a primitive or primitive wrapper class
+     */
+    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));
+    }
+
+    /**
+     * Check if the given class represents an array of primitives, i.e. boolean,
+     * byte, char, short, int, long, float, or double.
+     *
+     * @param clazz the class to check
+     * @return whether the given class is a primitive array class
+     */
+    public static boolean isPrimitiveArray(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        return (clazz.isArray() && clazz.getComponentType().isPrimitive());
+    }
+
+    /**
+     * Check if the given class represents an array of primitive wrappers, i.e.
+     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.
+     *
+     * @param clazz the class to check
+     * @return whether the given class is a primitive wrapper array class
+     */
+    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));
+    }
+
+    /**
+     * Resolve the given class if it is a primitive class, returning the
+     * corresponding primitive wrapper type instead.
+     *
+     * @param clazz the class to check
+     * @return the original class, or a primitive wrapper for the original
+     * primitive type
+     */
+    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);
+    }
+
+    /**
+     * Check if the right-hand side type may be assigned to the left-hand side
+     * type, assuming setting by reflection. Considers primitive wrapper classes
+     * as assignable to the corresponding primitive types.
+     *
+     * @param lhsType the target type
+     * @param rhsType the value type that should be assigned to the target type
+     * @return if the target type is assignable from the value type
+     * @see TypeUtils#isAssignable
+     */
+    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {
+        Assert.notNull(lhsType, "Left-hand side type must not be null");
+        Assert.notNull(rhsType, "Right-hand side type must not be null");
+        if (lhsType.isAssignableFrom(rhsType)) {
+            return true;
+        }
+        if (lhsType.isPrimitive()) {
+            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);
+            if (lhsType == resolvedPrimitive) {
+                return true;
+            }
+        } else {
+            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);
+            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Determine if the given type is assignable from the given value, assuming
+     * setting by reflection. Considers primitive wrapper classes as assignable
+     * to the corresponding primitive types.
+     *
+     * @param type the target type
+     * @param value the value that should be assigned to the type
+     * @return if the type is assignable from the value
+     */
+    public static boolean isAssignableValue(Class<?> type, Object value) {
+        Assert.notNull(type, "Type must not be null");
+        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());
+    }
+
+    /**
+     * Convert a "/"-based resource path to a "."-based fully qualified class
+     * name.
+     *
+     * @param resourcePath the resource path pointing to a class
+     * @return the corresponding fully qualified class name
+     */
+    public static String convertResourcePathToClassName(String resourcePath) {
+        Assert.notNull(resourcePath, "Resource path must not be null");
+        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);
+    }
+
+    /**
+     * Convert a "."-based fully qualified class name to a "/"-based resource
+     * path.
+     *
+     * @param className the fully qualified class name
+     * @return the corresponding resource path, pointing to the class
+     */
+    public static String convertClassNameToResourcePath(String className) {
+        Assert.notNull(className, "Class name must not be null");
+        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);
+    }
+
+    /**
+     * Return a path suitable for use with {@code ClassLoader.getResource} (also
+     * suitable for use with {@code Class.getResource} by prepending a slash
+     * ('/') to the return value). Built by taking the package of the specified
+     * class file, converting all dots ('.') to slashes ('/'), adding a trailing
+     * slash if necessary, and concatenating the specified resource name to
+     * this.
+     * <br/>As such, this function may be used to build a path suitable for
+     * loading a resource file that is in the same package as a class file,
+     * although {@link org.springframework.core.io.ClassPathResource} is usually
+     * even more convenient.
+     *
+     * @param clazz the Class whose package will be used as the base
+     * @param resourceName the resource name to append. A leading slash is
+     * optional.
+     * @return the built-up resource path
+     * @see ClassLoader#getResource
+     * @see Class#getResource
+     */
+    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {
+        Assert.notNull(resourceName, "Resource name must not be null");
+        if (!resourceName.startsWith("/")) {
+            return classPackageAsResourcePath(clazz) + "/" + resourceName;
+        }
+        return classPackageAsResourcePath(clazz) + resourceName;
+    }
+
+    /**
+     * Given an input class object, return a string which consists of the
+     * class's package name as a pathname, i.e., all dots ('.') are replaced by
+     * slashes ('/'). Neither a leading nor trailing slash is added. The result
+     * could be concatenated with a slash and the name of a resource and fed
+     * directly to {@code ClassLoader.getResource()}. For it to be fed to
+     * {@code Class.getResource} instead, a leading slash would also have to be
+     * prepended to the returned value.
+     *
+     * @param clazz the input class. A {@code null} value or the default (empty)
+     * package will result in an empty string ("") being returned.
+     * @return a path which represents the package name
+     * @see ClassLoader#getResource
+     * @see Class#getResource
+     */
+    public static String classPackageAsResourcePath(Class<?> clazz) {
+        if (clazz == null) {
+            return "";
+        }
+        String className = clazz.getName();
+        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);
+        if (packageEndIndex == -1) {
+            return "";
+        }
+        String packageName = className.substring(0, packageEndIndex);
+        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);
+    }
+
+    /**
+     * Build a String that consists of the names of the classes/interfaces in
+     * the given array.
+     * <p>
+     * Basically like {@code AbstractCollection.toString()}, but stripping the
+     * "class "/"interface " prefix before every class name.
+     *
+     * @param classes a Collection of Class objects (may be {@code null})
+     * @return a String of form "[com.foo.Bar, com.foo.Baz]"
+     * @see java.util.AbstractCollection#toString()
+     */
+    public static String classNamesToString(Class<?>... classes) {
+        return classNamesToString(Arrays.asList(classes));
+    }
+
+    /**
+     * Build a String that consists of the names of the classes/interfaces in
+     * the given collection.
+     * <p>
+     * Basically like {@code AbstractCollection.toString()}, but stripping the
+     * "class "/"interface " prefix before every class name.
+     *
+     * @param classes a Collection of Class objects (may be {@code null})
+     * @return a String of form "[com.foo.Bar, com.foo.Baz]"
+     * @see java.util.AbstractCollection#toString()
+     */
+    public static String classNamesToString(Collection<Class<?>> classes) {
+        if (CollectionUtils.isEmpty(classes)) {
+            return "[]";
+        }
+        StringBuilder sb = new StringBuilder("[");
+        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {
+            Class<?> clazz = it.next();
+            sb.append(clazz.getName());
+            if (it.hasNext()) {
+                sb.append(", ");
+            }
+        }
+        sb.append("]");
+        return sb.toString();
+    }
+
+    /**
+     * Copy the given Collection into a Class array. The Collection must contain
+     * Class elements only.
+     *
+     * @param collection the Collection to copy
+     * @return the Class array ({@code null} if the passed-in Collection was
+     * {@code null})
+     */
+    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {
+        if (collection == null) {
+            return null;
+        }
+        return collection.toArray(new Class<?>[collection.size()]);
+    }
+
+    /**
+     * Return all interfaces that the given instance implements as array,
+     * including ones implemented by superclasses.
+     *
+     * @param instance the instance to analyze for interfaces
+     * @return all interfaces that the given instance implements as array
+     */
+    public static Class<?>[] getAllInterfaces(Object instance) {
+        Assert.notNull(instance, "Instance must not be null");
+        return getAllInterfacesForClass(instance.getClass());
+    }
+
+    /**
+     * Return all interfaces that the given class implements as array, including
+     * ones implemented by superclasses.
+     * <p>
+     * If the class itself is an interface, it gets returned as sole interface.
+     *
+     * @param clazz the class to analyze for interfaces
+     * @return all interfaces that the given object implements as array
+     */
+    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {
+        return getAllInterfacesForClass(clazz, null);
+    }
+
+    /**
+     * Return all interfaces that the given class implements as array, including
+     * ones implemented by superclasses.
+     * <p>
+     * If the class itself is an interface, it gets returned as sole interface.
+     *
+     * @param clazz the class to analyze for interfaces
+     * @param classLoader the ClassLoader that the interfaces need to be visible
+     * in (may be {@code null} when accepting all declared interfaces)
+     * @return all interfaces that the given object implements as array
+     */
+    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {
+        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);
+        return ifcs.toArray(new Class<?>[ifcs.size()]);
+    }
+
+    /**
+     * Return all interfaces that the given instance implements as Set,
+     * including ones implemented by superclasses.
+     *
+     * @param instance the instance to analyze for interfaces
+     * @return all interfaces that the given instance implements as Set
+     */
+    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {
+        Assert.notNull(instance, "Instance must not be null");
+        return getAllInterfacesForClassAsSet(instance.getClass());
+    }
+
+    /**
+     * Return all interfaces that the given class implements as Set, including
+     * ones implemented by superclasses.
+     * <p>
+     * If the class itself is an interface, it gets returned as sole interface.
+     *
+     * @param clazz the class to analyze for interfaces
+     * @return all interfaces that the given object implements as Set
+     */
+    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {
+        return getAllInterfacesForClassAsSet(clazz, null);
+    }
+
+    /**
+     * Return all interfaces that the given class implements as Set, including
+     * ones implemented by superclasses.
+     * <p>
+     * If the class itself is an interface, it gets returned as sole interface.
+     *
+     * @param clazz the class to analyze for interfaces
+     * @param classLoader the ClassLoader that the interfaces need to be visible
+     * in (may be {@code null} when accepting all declared interfaces)
+     * @return all interfaces that the given object implements as Set
+     */
+    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {
+        Assert.notNull(clazz, "Class must not be null");
+        if (clazz.isInterface() && isVisible(clazz, classLoader)) {
+            return Collections.<Class<?>>singleton(clazz);
+        }
+        Set<Class<?>> interfaces = new LinkedHashSet<>();
+        while (clazz != null) {
+            Class<?>[] ifcs = clazz.getInterfaces();
+            for (Class<?> ifc : ifcs) {
+                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));
+            }
+            clazz = clazz.getSuperclass();
+        }
+        return interfaces;
+    }
+
+    /**
+     * Create a composite interface Class for the given interfaces, implementing
+     * the given interfaces in one single Class.
+     * <p>
+     * This implementation builds a JDK proxy class for the given interfaces.
+     *
+     * @param interfaces the interfaces to merge
+     * @param classLoader the ClassLoader to create the composite Class in
+     * @return the merged interface as Class
+     * @see java.lang.reflect.Proxy#getProxyClass
+     */
+    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {
+        Assert.notEmpty(interfaces, "Interfaces must not be empty");
+        Assert.notNull(classLoader, "ClassLoader must not be null");
+        return Proxy.getProxyClass(classLoader, interfaces);
+    }
+
+    /**
+     * Determine the common ancestor of the given classes, if any.
+     *
+     * @param clazz1 the class to introspect
+     * @param clazz2 the other class to introspect
+     * @return the common ancestor (i.e. common superclass, one interface
+     * extending the other), or {@code null} if none found. If any of the given
+     * classes is {@code null}, the other class will be returned.
+     * @since 3.2.6
+     */
+    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {
+        if (clazz1 == null) {
+            return clazz2;
+        }
+        if (clazz2 == null) {
+            return clazz1;
+        }
+        if (clazz1.isAssignableFrom(clazz2)) {
+            return clazz1;
+        }
+        if (clazz2.isAssignableFrom(clazz1)) {
+            return clazz2;
+        }
+        Class<?> ancestor = clazz1;
+        do {
+            ancestor = ancestor.getSuperclass();
+            if (ancestor == null || Object.class == ancestor) {
+                return null;
+            }
+        } while (!ancestor.isAssignableFrom(clazz2));
+        return ancestor;
+    }
+
+    /**
+     * Check whether the given class is visible in the given ClassLoader.
+     *
+     * @param clazz the class to check (typically an interface)
+     * @param classLoader the ClassLoader to check against (may be {@code null},
+     * in which case this method will always return {@code true})
+     */
+    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {
+        if (classLoader == null) {
+            return true;
+        }
+        try {
+            Class<?> actualClass = classLoader.loadClass(clazz.getName());
+            return (clazz == actualClass);
+            // Else: different interface class found...
+        } catch (ClassNotFoundException ex) {
+            // No interface class found...
+            return false;
+        }
+    }
+
+    /**
+     * Check whether the given object is a CGLIB proxy.
+     *
+     * @param object the object to check
+     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)
+     */
+    public static boolean isCglibProxy(Object object) {
+        return isCglibProxyClass(object.getClass());
+    }
+
+    /**
+     * Check whether the specified class is a CGLIB-generated class.
+     *
+     * @param clazz the class to check
+     */
+    public static boolean isCglibProxyClass(Class<?> clazz) {
+        return (clazz != null && isCglibProxyClassName(clazz.getName()));
+    }
+
+    /**
+     * Check whether the specified class name is a CGLIB-generated class.
+     *
+     * @param className the class name to check
+     */
+    public static boolean isCglibProxyClassName(String className) {
+        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));
+    }
+}
diff --git a/src/main/java/component/util/CollectionUtils.java b/src/main/java/component/util/CollectionUtils.java
new file mode 100644
index 0000000..18c8340
--- /dev/null
+++ b/src/main/java/component/util/CollectionUtils.java
@@ -0,0 +1,367 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package component.util;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Enumeration;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
+/**
+ *
+ * @author cdi305
+ */
+public abstract class CollectionUtils {
+
+    /**
+     * Return {@code true} if the supplied Collection is {@code null} or empty.
+     * Otherwise, return {@code false}.
+     *
+     * @param collection the Collection to check
+     * @return whether the given Collection is empty
+     */
+    public static boolean isEmpty(Collection<?> collection) {
+        return (collection == null || collection.isEmpty());
+    }
+
+    /**
+     * Return {@code true} if the supplied Map is {@code null} or empty.
+     * Otherwise, return {@code false}.
+     *
+     * @param map the Map to check
+     * @return whether the given Map is empty
+     */
+    public static boolean isEmpty(Map<?, ?> map) {
+        return (map == null || map.isEmpty());
+    }
+
+    /**
+     * Convert the supplied array into a List. A primitive array gets converted
+     * into a List of the appropriate wrapper type.
+     * <p>
+     * <b>NOTE:</b> Generally prefer the standard {@link Arrays#asList} method.
+     * This {@code arrayToList} method is just meant to deal with an incoming
+     * Object value that might be an {@code Object[]} or a primitive array at
+     * runtime.
+     * <p>
+     * A {@code null} source value will be converted to an empty List.
+     *
+     * @param source the (potentially primitive) array
+     * @return the converted List result
+     * @see ObjectUtils#toObjectArray(Object)
+     * @see Arrays#asList(Object[])
+     */
+    @SuppressWarnings("rawtypes")
+    public static List arrayToList(Object source) {
+        return Arrays.asList(ObjectUtils.toObjectArray(source));
+    }
+
+    /**
+     * Merge the given array into the given Collection.
+     *
+     * @param <E>
+     * @param array the array to merge (may be {@code null})
+     * @param collection the target Collection to merge the array into
+     */
+    @SuppressWarnings("unchecked")
+    public static <E> void mergeArrayIntoCollection(Object array, Collection<E> collection) {
+        if (collection == null) {
+            throw new IllegalArgumentException("Collection must not be null");
+        }
+        Object[] arr = ObjectUtils.toObjectArray(array);
+        for (Object elem : arr) {
+            collection.add((E) elem);
+        }
+    }
+
+    /**
+     * Merge the given Properties instance into the given Map, copying all
+     * properties (key-value pairs) over.
+     * <p>
+     * Uses {@code Properties.propertyNames()} to even catch default properties
+     * linked into the original Properties instance.
+     *
+     * @param <K>
+     * @param <V>
+     * @param props the Properties instance to merge (may be {@code null})
+     * @param map the target Map to merge the properties into
+     */
+    @SuppressWarnings("unchecked")
+    public static <K, V> void mergePropertiesIntoMap(Properties props, Map<K, V> map) {
+        if (map == null) {
+            throw new IllegalArgumentException("Map must not be null");
+        }
+        if (props != null) {
+            for (Enumeration<?> en = props.propertyNames(); en.hasMoreElements();) {
+                String key = (String) en.nextElement();
+                Object value = props.getProperty(key);
+                if (value == null) {
+                    // Potentially a non-String value...
+                    value = props.get(key);
+                }
+                map.put((K) key, (V) value);
+            }
+        }
+    }
+
+    /**
+     * Check whether the given Iterator contains the given element.
+     *
+     * @param iterator the Iterator to check
+     * @param element the element to look for
+     * @return {@code true} if found, {@code false} else
+     */
+    public static boolean contains(Iterator<?> iterator, Object element) {
+        if (iterator != null) {
+            while (iterator.hasNext()) {
+                Object candidate = iterator.next();
+                if (ObjectUtils.nullSafeEquals(candidate, element)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Check whether the given Enumeration contains the given element.
+     *
+     * @param enumeration the Enumeration to check
+     * @param element the element to look for
+     * @return {@code true} if found, {@code false} else
+     */
+    public static boolean contains(Enumeration<?> enumeration, Object element) {
+        if (enumeration != null) {
+            while (enumeration.hasMoreElements()) {
+                Object candidate = enumeration.nextElement();
+                if (ObjectUtils.nullSafeEquals(candidate, element)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Check whether the given Collection contains the given element instance.
+     * <p>
+     * Enforces the given instance to be present, rather than returning
+     * {@code true} for an equal element as well.
+     *
+     * @param collection the Collection to check
+     * @param element the element to look for
+     * @return {@code true} if found, {@code false} else
+     */
+    public static boolean containsInstance(Collection<?> collection, Object element) {
+        if (collection != null) {
+            if (collection.stream().anyMatch((candidate) -> (candidate == element))) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Return {@code true} if any element in '{@code candidates}' is contained
+     * in '{@code source}'; otherwise returns {@code false}.
+     *
+     * @param source the source Collection
+     * @param candidates the candidates to search for
+     * @return whether any of the candidates has been found
+     */
+    public static boolean containsAny(Collection<?> source, Collection<?> candidates) {
+        if (isEmpty(source) || isEmpty(candidates)) {
+            return false;
+        }
+        return candidates.stream().anyMatch((candidate) -> (source.contains(candidate)));
+    }
+
+    /**
+     * Return the first element in '{@code candidates}' that is contained in
+     * '{@code source}'. If no element in '{@code candidates}' is present in
+     * '{@code source}' returns {@code null}. Iteration order is
+     * {@link Collection} implementation specific.
+     *
+     * @param <E>
+     * @param source the source Collection
+     * @param candidates the candidates to search for
+     * @return the first present object, or {@code null} if not found
+     */
+    @SuppressWarnings("unchecked")
+    public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) {
+        if (isEmpty(source) || isEmpty(candidates)) {
+            return null;
+        }
+        for (Object candidate : candidates) {
+            if (source.contains(candidate)) {
+                return (E) candidate;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Find a single value of the given type in the given Collection.
+     *
+     * @param <T>
+     * @param collection the Collection to search
+     * @param type the type to look for
+     * @return a value of the given type found if there is a clear match, or
+     * {@code null} if none or more than one such value found
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> T findValueOfType(Collection<?> collection, Class<T> type) {
+        if (isEmpty(collection)) {
+            return null;
+        }
+        T value = null;
+        for (Object element : collection) {
+            if (type == null || type.isInstance(element)) {
+                if (value != null) {
+                    // More than one value found... no clear single value.
+                    return null;
+                }
+                value = (T) element;
+            }
+        }
+        return value;
+    }
+
+    /**
+     * Find a single value of one of the given types in the given Collection:
+     * searching the Collection for a value of the first type, then searching
+     * for a value of the second type, etc.
+     *
+     * @param collection the collection to search
+     * @param types the types to look for, in prioritized order
+     * @return a value of one of the given types found if there is a clear
+     * match, or {@code null} if none or more than one such value found
+     */
+    public static Object findValueOfType(Collection<?> collection, Class<?>[] types) {
+        if (isEmpty(collection) || ObjectUtils.isEmpty(types)) {
+            return null;
+        }
+        for (Class<?> type : types) {
+            Object value = findValueOfType(collection, type);
+            if (value != null) {
+                return value;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Determine whether the given Collection only contains a single unique
+     * object.
+     *
+     * @param collection the Collection to check
+     * @return {@code true} if the collection contains a single reference or
+     * multiple references to the same instance, {@code false} else
+     */
+    public static boolean hasUniqueObject(Collection<?> collection) {
+        if (isEmpty(collection)) {
+            return false;
+        }
+        boolean hasCandidate = false;
+        Object candidate = null;
+        for (Object elem : collection) {
+            if (!hasCandidate) {
+                hasCandidate = true;
+                candidate = elem;
+            } else if (candidate != elem) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Find the common element type of the given Collection, if any.
+     *
+     * @param collection the Collection to check
+     * @return the common element type, or {@code null} if no clear common type
+     * has been found (or the collection was empty)
+     */
+    public static Class<?> findCommonElementType(Collection<?> collection) {
+        if (isEmpty(collection)) {
+            return null;
+        }
+        Class<?> candidate = null;
+        for (Object val : collection) {
+            if (val != null) {
+                if (candidate == null) {
+                    candidate = val.getClass();
+                } else if (candidate != val.getClass()) {
+                    return null;
+                }
+            }
+        }
+        return candidate;
+    }
+
+    /**
+     * Marshal the elements from the given enumeration into an array of the
+     * given type. Enumeration elements must be assignable to the type of the
+     * given array. The array returned will be a different instance than the
+     * array given.
+     * @param <A>
+     * @param <E>
+     * @param enumeration
+     * @param array
+     * @return 
+     */
+    public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {
+        ArrayList<A> elements = new ArrayList<>();
+        while (enumeration.hasMoreElements()) {
+            elements.add(enumeration.nextElement());
+        }
+        return elements.toArray(array);
+    }
+
+    /**
+     * Adapt an enumeration to an iterator.
+     *
+     * @param <E>
+     * @param enumeration the enumeration
+     * @return the iterator
+     */
+    public static <E> Iterator<E> toIterator(Enumeration<E> enumeration) {
+        return new EnumerationIterator<>(enumeration);
+    }
+
+
+    /**
+     * Iterator wrapping an Enumeration.
+     */
+    private static class EnumerationIterator<E> implements Iterator<E> {
+
+        private final Enumeration<E> enumeration;
+
+        public EnumerationIterator(Enumeration<E> enumeration) {
+            this.enumeration = enumeration;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return this.enumeration.hasMoreElements();
+        }
+
+        @Override
+        public E next() {
+            return this.enumeration.nextElement();
+        }
+
+        @Override
+        public void remove() throws UnsupportedOperationException {
+            throw new UnsupportedOperationException("Not supported");
+        }
+    }
+
+}
diff --git a/src/main/java/component/util/ObjectUtils.java b/src/main/java/component/util/ObjectUtils.java
new file mode 100644
index 0000000..b6e8cb1
--- /dev/null
+++ b/src/main/java/component/util/ObjectUtils.java
@@ -0,0 +1,1013 @@
+package component.util;
+
+import java.lang.reflect.Array;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Optional;
+
+public abstract class ObjectUtils {
+
+    private static final int INITIAL_HASH = 7;
+    private static final int MULTIPLIER = 31;
+
+    private static final String EMPTY_STRING = "";
+    private static final String NULL_STRING = "null";
+    private static final String ARRAY_START = "{";
+    private static final String ARRAY_END = "}";
+    private static final String EMPTY_ARRAY = ARRAY_START + ARRAY_END;
+    private static final String ARRAY_ELEMENT_SEPARATOR = ", ";
+
+    /**
+     * Return whether the given throwable is a checked exception: that is,
+     * neither a RuntimeException nor an Error.
+     *
+     * @param ex the throwable to check
+     * @return whether the throwable is a checked exception
+     * @see java.lang.Exception
+     * @see java.lang.RuntimeException
+     * @see java.lang.Error
+     */
+    public static boolean isCheckedException(Throwable ex) {
+        return !(ex instanceof RuntimeException || ex instanceof Error);
+    }
+
+    /**
+     * Check whether the given exception is compatible with the specified
+     * exception types, as declared in a throws clause.
+     *
+     * @param ex the exception to check
+     * @param declaredExceptions the exception types declared in the throws
+     * clause
+     * @return whether the given exception is compatible
+     */
+    public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions) {
+        if (!isCheckedException(ex)) {
+            return true;
+        }
+        if (declaredExceptions != null) {
+            for (Class<?> declaredException : declaredExceptions) {
+                if (declaredException.isInstance(ex)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Determine whether the given object is an array: either an Object array or
+     * a primitive array.
+     *
+     * @param obj the object to check
+     * @return 
+     */
+    public static boolean isArray(Object obj) {
+        return (obj != null && obj.getClass().isArray());
+    }
+
+    /**
+     * Determine whether the given array is empty: i.e. {@code null} or of zero
+     * length.
+     *
+     * @param array the array to check
+     * @return 
+     * @see #isEmpty(Object)
+     */
+    public static boolean isEmpty(Object[] array) {
+        return (array == null || array.length == 0);
+    }
+
+    /**
+     * Determine whether the given object is empty.
+     * <p>
+     * This method supports the following object types.
+     * <ul>
+     * <li>{@code Optional}: considered empty if {@link Optional#empty()}</li>
+     * <li>{@code Array}: considered empty if its length is zero</li>
+     * <li>{@link CharSequence}: considered empty if its length is zero</li>
+     * <li>{@link Collection}: delegates to {@link Collection#isEmpty()}</li>
+     * <li>{@link Map}: delegates to {@link Map#isEmpty()}</li>
+     * </ul>
+     * <p>
+     * If the given object is non-null and not one of the aforementioned
+     * supported types, this method returns {@code false}.
+     *
+     * @param obj the object to check
+     * @return {@code true} if the object is {@code null} or <em>empty</em>
+     * @since 4.2
+     * @see Optional#isPresent()
+     * @see ObjectUtils#isEmpty(Object[])
+     * @see StringUtils#hasLength(CharSequence)
+     * @see StringUtils#isEmpty(Object)
+     * @see CollectionUtils#isEmpty(java.util.Collection)
+     * @see CollectionUtils#isEmpty(java.util.Map)
+     */
+    @SuppressWarnings("rawtypes")
+    public static boolean isEmpty(Object obj) {
+        if (obj == null) {
+            return true;
+        }
+
+        if (obj instanceof Optional) {
+            return !((Optional) obj).isPresent();
+        }
+        if (obj.getClass().isArray()) {
+            return Array.getLength(obj) == 0;
+        }
+        if (obj instanceof CharSequence) {
+            return ((CharSequence) obj).length() == 0;
+        }
+        if (obj instanceof Collection) {
+            return ((Collection) obj).isEmpty();
+        }
+        if (obj instanceof Map) {
+            return ((Map) obj).isEmpty();
+        }
+
+        // else
+        return false;
+    }
+
+    /**
+     * Unwrap the given object which is potentially a
+     * {@link java.util.Optional}.
+     *
+     * @param obj the candidate object
+     * @return either the value held within the {@code Optional}, {@code null}
+     * if the {@code Optional} is empty, or simply the given object as-is
+     * @since 5.0
+     */
+    public static Object unwrapOptional(Object obj) {
+        if (obj instanceof Optional) {
+            Optional<?> optional = (Optional<?>) obj;
+            if (!optional.isPresent()) {
+                return null;
+            }
+            Object result = optional.get();
+            Assert.isTrue(!(result instanceof Optional), "Multi-level Optional usage not supported");
+            return result;
+        }
+        return obj;
+    }
+
+    /**
+     * Check whether the given array contains the given element.
+     *
+     * @param array the array to check (may be {@code null}, in which case the
+     * return value will always be {@code false})
+     * @param element the element to check for
+     * @return whether the element has been found in the given array
+     */
+    public static boolean containsElement(Object[] array, Object element) {
+        if (array == null) {
+            return false;
+        }
+        for (Object arrayEle : array) {
+            if (nullSafeEquals(arrayEle, element)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Check whether the given array of enum constants contains a constant with
+     * the given name, ignoring case when determining a match.
+     *
+     * @param enumValues the enum values to check, typically the product of a
+     * call to MyEnum.values()
+     * @param constant the constant name to find (must not be null or empty
+     * string)
+     * @return whether the constant has been found in the given array
+     */
+    public static boolean containsConstant(Enum<?>[] enumValues, String constant) {
+        return containsConstant(enumValues, constant, false);
+    }
+
+    /**
+     * Check whether the given array of enum constants contains a constant with
+     * the given name.
+     *
+     * @param enumValues the enum values to check, typically the product of a
+     * call to MyEnum.values()
+     * @param constant the constant name to find (must not be null or empty
+     * string)
+     * @param caseSensitive whether case is significant in determining a match
+     * @return whether the constant has been found in the given array
+     */
+    public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {
+        for (Enum<?> candidate : enumValues) {
+            if (caseSensitive
+                    ? candidate.toString().equals(constant)
+                    : candidate.toString().equalsIgnoreCase(constant)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Case insensitive alternative to {@link Enum#valueOf(Class, String)}.
+     *
+     * @param <E> the concrete Enum type
+     * @param enumValues the array of all Enum constants in question, usually
+     * per Enum.values()
+     * @param constant the constant to get the enum value of
+     * @return 
+     * @throws IllegalArgumentException if the given constant is not found in
+     * the given array of enum values. Use
+     * {@link #containsConstant(Enum[], String)} as a guard to avoid this
+     * exception.
+     */
+    public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant) {
+        for (E candidate : enumValues) {
+            if (candidate.toString().equalsIgnoreCase(constant)) {
+                return candidate;
+            }
+        }
+        throw new IllegalArgumentException(
+                String.format("constant [%s] does not exist in enum type %s",
+                        constant, enumValues.getClass().getComponentType().getName()));
+    }
+
+    /**
+     * Append the given object to the given array, returning a new array
+     * consisting of the input array contents plus the given object.
+     *
+     * @param <A>
+     * @param <O>
+     * @param array the array to append to (can be {@code null})
+     * @param obj the object to append
+     * @return the new array (of the same component type; never {@code null})
+     */
+    public static <A, O extends A> A[] addObjectToArray(A[] array, O obj) {
+        Class<?> compType = Object.class;
+        if (null != array) {
+            compType = array.getClass().getComponentType();
+        } else if (obj != null) {
+            compType = obj.getClass();
+        }
+        int newArrLength = (array != null ? array.length + 1 : 1);
+        @SuppressWarnings("unchecked")
+        A[] newArr = (A[]) Array.newInstance(compType, newArrLength);
+        if (array != null) {
+            System.arraycopy(array, 0, newArr, 0, array.length);
+        }
+        newArr[newArr.length - 1] = obj;
+        return newArr;
+    }
+
+    /**
+     * Convert the given array (which may be a primitive array) to an object
+     * array (if necessary of primitive wrapper objects).
+     * <p>
+     * A {@code null} source value will be converted to an empty Object array.
+     *
+     * @param source the (potentially primitive) array
+     * @return the corresponding object array (never {@code null})
+     * @throws IllegalArgumentException if the parameter is not an array
+     */
+    public static Object[] toObjectArray(Object source) {
+        if (source instanceof Object[]) {
+            return (Object[]) source;
+        }
+        if (source == null) {
+            return new Object[0];
+        }
+        if (!source.getClass().isArray()) {
+            throw new IllegalArgumentException("Source is not an array: " + source);
+        }
+        int length = Array.getLength(source);
+        if (length == 0) {
+            return new Object[0];
+        }
+        Class<?> wrapperType = Array.get(source, 0).getClass();
+        Object[] newArray = (Object[]) Array.newInstance(wrapperType, length);
+        for (int i = 0; i < length; i++) {
+            newArray[i] = Array.get(source, i);
+        }
+        return newArray;
+    }
+
+	//---------------------------------------------------------------------
+    // Convenience methods for content-based equality/hash-code handling
+    //---------------------------------------------------------------------
+    /**
+     * Determine if the given objects are equal, returning {@code true} if both
+     * are {@code null} or {@code false} if only one is {@code null}.
+     * <p>
+     * Compares arrays with {@code Arrays.equals}, performing an equality check
+     * based on the array elements rather than the array reference.
+     *
+     * @param o1 first Object to compare
+     * @param o2 second Object to compare
+     * @return whether the given objects are equal
+     * @see Object#equals(Object)
+     * @see java.util.Arrays#equals
+     */
+    public static boolean nullSafeEquals(Object o1, Object o2) {
+        if (o1 == o2) {
+            return true;
+        }
+        if (o1 == null || o2 == null) {
+            return false;
+        }
+        if (o1.equals(o2)) {
+            return true;
+        }
+        if (o1.getClass().isArray() && o2.getClass().isArray()) {
+            return arrayEquals(o1, o2);
+        }
+        return false;
+    }
+
+    /**
+     * Compare the given arrays with {@code Arrays.equals}, performing an
+     * equality check based on the array elements rather than the array
+     * reference.
+     *
+     * @param o1 first array to compare
+     * @param o2 second array to compare
+     * @return whether the given objects are equal
+     * @see #nullSafeEquals(Object, Object)
+     * @see java.util.Arrays#equals
+     */
+    private static boolean arrayEquals(Object o1, Object o2) {
+        if (o1 instanceof Object[] && o2 instanceof Object[]) {
+            return Arrays.equals((Object[]) o1, (Object[]) o2);
+        }
+        if (o1 instanceof boolean[] && o2 instanceof boolean[]) {
+            return Arrays.equals((boolean[]) o1, (boolean[]) o2);
+        }
+        if (o1 instanceof byte[] && o2 instanceof byte[]) {
+            return Arrays.equals((byte[]) o1, (byte[]) o2);
+        }
+        if (o1 instanceof char[] && o2 instanceof char[]) {
+            return Arrays.equals((char[]) o1, (char[]) o2);
+        }
+        if (o1 instanceof double[] && o2 instanceof double[]) {
+            return Arrays.equals((double[]) o1, (double[]) o2);
+        }
+        if (o1 instanceof float[] && o2 instanceof float[]) {
+            return Arrays.equals((float[]) o1, (float[]) o2);
+        }
+        if (o1 instanceof int[] && o2 instanceof int[]) {
+            return Arrays.equals((int[]) o1, (int[]) o2);
+        }
+        if (o1 instanceof long[] && o2 instanceof long[]) {
+            return Arrays.equals((long[]) o1, (long[]) o2);
+        }
+        if (o1 instanceof short[] && o2 instanceof short[]) {
+            return Arrays.equals((short[]) o1, (short[]) o2);
+        }
+        return false;
+    }
+
+    /**
+     * Return as hash code for the given object; typically the value of
+     * {@code Object#hashCode()}}. If the object is an array, this method will
+     * delegate to any of the {@code nullSafeHashCode} methods for arrays in
+     * this class. If the object is {@code null}, this method returns 0.
+     *
+     * @param obj
+     * @return 
+     * @see Object#hashCode()
+     * @see #nullSafeHashCode(Object[])
+     * @see #nullSafeHashCode(boolean[])
+     * @see #nullSafeHashCode(byte[])
+     * @see #nullSafeHashCode(char[])
+     * @see #nullSafeHashCode(double[])
+     * @see #nullSafeHashCode(float[])
+     * @see #nullSafeHashCode(int[])
+     * @see #nullSafeHashCode(long[])
+     * @see #nullSafeHashCode(short[])
+     */
+    public static int nullSafeHashCode(Object obj) {
+        if (obj == null) {
+            return 0;
+        }
+        if (obj.getClass().isArray()) {
+            if (obj instanceof Object[]) {
+                return nullSafeHashCode((Object[]) obj);
+            }
+            if (obj instanceof boolean[]) {
+                return nullSafeHashCode((boolean[]) obj);
+            }
+            if (obj instanceof byte[]) {
+                return nullSafeHashCode((byte[]) obj);
+            }
+            if (obj instanceof char[]) {
+                return nullSafeHashCode((char[]) obj);
+            }
+            if (obj instanceof double[]) {
+                return nullSafeHashCode((double[]) obj);
+            }
+            if (obj instanceof float[]) {
+                return nullSafeHashCode((float[]) obj);
+            }
+            if (obj instanceof int[]) {
+                return nullSafeHashCode((int[]) obj);
+            }
+            if (obj instanceof long[]) {
+                return nullSafeHashCode((long[]) obj);
+            }
+            if (obj instanceof short[]) {
+                return nullSafeHashCode((short[]) obj);
+            }
+        }
+        return obj.hashCode();
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(Object[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (Object element : array) {
+            hash = MULTIPLIER * hash + nullSafeHashCode(element);
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(boolean[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (boolean element : array) {
+            hash = MULTIPLIER * hash + hashCode(element);
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(byte[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (byte element : array) {
+            hash = MULTIPLIER * hash + element;
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(char[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (char element : array) {
+            hash = MULTIPLIER * hash + element;
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(double[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (double element : array) {
+            hash = MULTIPLIER * hash + hashCode(element);
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(float[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (float element : array) {
+            hash = MULTIPLIER * hash + hashCode(element);
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(int[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (int element : array) {
+            hash = MULTIPLIER * hash + element;
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(long[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (long element : array) {
+            hash = MULTIPLIER * hash + hashCode(element);
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(short[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (short element : array) {
+            hash = MULTIPLIER * hash + element;
+        }
+        return hash;
+    }
+
+    /**
+     * Return the same value as {@link Boolean#hashCode()}}.
+     *
+     * @param bool
+     * @return 
+     * @see Boolean#hashCode()
+     */
+    public static int hashCode(boolean bool) {
+        return (bool ? 1231 : 1237);
+    }
+
+    /**
+     * Return the same value as {@link Double#hashCode()}}.
+     *
+     * @param dbl
+     * @return 
+     * @see Double#hashCode()
+     */
+    public static int hashCode(double dbl) {
+        return hashCode(Double.doubleToLongBits(dbl));
+    }
+
+    /**
+     * Return the same value as {@link Float#hashCode()}}.
+     *
+     * @param flt
+     * @return 
+     * @see Float#hashCode()
+     */
+    public static int hashCode(float flt) {
+        return Float.floatToIntBits(flt);
+    }
+
+    /**
+     * Return the same value as {@link Long#hashCode()}}.
+     *
+     * @param lng
+     * @return 
+     * @see Long#hashCode()
+     */
+    public static int hashCode(long lng) {
+        return (int) (lng ^ (lng >>> 32));
+    }
+
+	//---------------------------------------------------------------------
+    // Convenience methods for toString output
+    //---------------------------------------------------------------------
+    /**
+     * Return a String representation of an object's overall identity.
+     *
+     * @param obj the object (may be {@code null})
+     * @return the object's identity as String representation, or an empty
+     * String if the object was {@code null}
+     */
+    public static String identityToString(Object obj) {
+        if (obj == null) {
+            return EMPTY_STRING;
+        }
+        return obj.getClass().getName() + "@" + getIdentityHexString(obj);
+    }
+
+    /**
+     * Return a hex String form of an object's identity hash code.
+     *
+     * @param obj the object
+     * @return the object's identity code in hex notation
+     */
+    public static String getIdentityHexString(Object obj) {
+        return Integer.toHexString(System.identityHashCode(obj));
+    }
+
+    /**
+     * Return a content-based String representation if {@code obj} is not
+     * {@code null}; otherwise returns an empty String.
+     * <p>
+     * Differs from {@link #nullSafeToString(Object)} in that it returns an
+     * empty String rather than "null" for a {@code null} value.
+     *
+     * @param obj the object to build a display String for
+     * @return a display String representation of {@code obj}
+     * @see #nullSafeToString(Object)
+     */
+    public static String getDisplayString(Object obj) {
+        if (obj == null) {
+            return EMPTY_STRING;
+        }
+        return nullSafeToString(obj);
+    }
+
+    /**
+     * Determine the class name for the given object.
+     * <p>
+     * Returns {@code "null"} if {@code obj} is {@code null}.
+     *
+     * @param obj the object to introspect (may be {@code null})
+     * @return the corresponding class name
+     */
+    public static String nullSafeClassName(Object obj) {
+        return (obj != null ? obj.getClass().getName() : NULL_STRING);
+    }
+
+    /**
+     * Return a String representation of the specified Object.
+     * <p>
+     * Builds a String representation of the contents in case of an array.
+     * Returns {@code "null"} if {@code obj} is {@code null}.
+     *
+     * @param obj the object to build a String representation for
+     * @return a String representation of {@code obj}
+     */
+    public static String nullSafeToString(Object obj) {
+        if (obj == null) {
+            return NULL_STRING;
+        }
+        if (obj instanceof String) {
+            return (String) obj;
+        }
+        if (obj instanceof Object[]) {
+            return nullSafeToString((Object[]) obj);
+        }
+        if (obj instanceof boolean[]) {
+            return nullSafeToString((boolean[]) obj);
+        }
+        if (obj instanceof byte[]) {
+            return nullSafeToString((byte[]) obj);
+        }
+        if (obj instanceof char[]) {
+            return nullSafeToString((char[]) obj);
+        }
+        if (obj instanceof double[]) {
+            return nullSafeToString((double[]) obj);
+        }
+        if (obj instanceof float[]) {
+            return nullSafeToString((float[]) obj);
+        }
+        if (obj instanceof int[]) {
+            return nullSafeToString((int[]) obj);
+        }
+        if (obj instanceof long[]) {
+            return nullSafeToString((long[]) obj);
+        }
+        if (obj instanceof short[]) {
+            return nullSafeToString((short[]) obj);
+        }
+        String str = obj.toString();
+        return (str != null ? str : EMPTY_STRING);
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(Object[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+            sb.append(String.valueOf(array[i]));
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(boolean[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(byte[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(char[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+            sb.append("'").append(array[i]).append("'");
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(double[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(float[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(int[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(long[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(short[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+}
diff --git a/src/main/java/component/util/PathUtils.java b/src/main/java/component/util/PathUtils.java
new file mode 100644
index 0000000..48a28d5
--- /dev/null
+++ b/src/main/java/component/util/PathUtils.java
@@ -0,0 +1,92 @@
+package component.util;
+
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public abstract class PathUtils {
+
+    private static final Pattern separatorRegex = Pattern.compile("\\\\|/");
+
+    /**
+     * Resolves the given {@code relativePath} based on the given
+     * {@code anchorPath}.
+     *
+     * @param relativePath      the relative path which should be resolved.
+     * @param anchorPath        the anchor path based on which the relative path should be
+     *                          resolved on.
+     * @param expectedSeparator The character expected to be used as a separator; dictated by the Loader.
+     * @return the resolved path or {@code null} when the path could not be
+     * resolved.
+     */
+    public static String resolveRelativePath(String relativePath, String anchorPath, char expectedSeparator) {
+        if (relativePath == null || relativePath.isEmpty()) {
+            return null;
+        }
+
+        // ensure both paths use the same separator character
+        relativePath = sanitize(relativePath, expectedSeparator);
+        anchorPath = sanitize(anchorPath, expectedSeparator);
+
+        if (relativePath.startsWith(".." + expectedSeparator) || relativePath.startsWith("." + expectedSeparator)) {
+            return resolvePathInner(relativePath, anchorPath, expectedSeparator);
+        }
+
+        return null;
+    }
+
+    private static String sanitize(String path, char expectedSeparator){
+        return separatorRegex.matcher(path).replaceAll(Matcher.quoteReplacement(String.valueOf(expectedSeparator)));
+    }
+
+    private static String resolvePathInner(String relativePath, String anchorPath, char separator) {
+        StringBuilder resultingPath = new StringBuilder();
+
+        resolvePathSegments(determineAnchorPathSegments(anchorPath, separator),
+                splitBySeparator(relativePath, separator)).stream().forEach((segment) -> {
+                    resultingPath.append(segment).append(separator);
+        });
+
+        // remove the erroneous separator added at the end
+        return resultingPath.substring(0, resultingPath.length() - 1);
+    }
+
+    private static Collection<String> determineAnchorPathSegments(String anchorPath, char separator) {
+        if (anchorPath == null || anchorPath.isEmpty()) {
+            return new ArrayList<>();
+        }
+        ArrayDeque<String> anchorPathSegments = new ArrayDeque<>(splitBySeparator(anchorPath, separator));
+        if (anchorPath.charAt(anchorPath.length() - 1) != separator) {
+            anchorPathSegments.pollLast();
+        }
+        return anchorPathSegments;
+    }
+
+    private static Collection<String> resolvePathSegments(Collection<String> anchorSegments,
+            Collection<String> relativeSegments) {
+        ArrayDeque<String> result = new ArrayDeque<>(anchorSegments);
+        relativeSegments.stream().forEach((String segment) -> {
+            switch (segment) {
+                case ".": // do nothing
+                    break;
+                case "..":
+                    result.pollLast();
+                    break;
+                default:
+                    result.add(segment);
+                    break;
+            }
+        });
+
+        return result;
+    }
+
+    private static List<String> splitBySeparator(String path, char separator) {
+        return Arrays.asList(path.split(Pattern.quote(String.valueOf(separator))));
+    }
+
+    private PathUtils() {
+        throw new IllegalAccessError();
+    }
+
+}
diff --git a/src/main/java/component/util/ReflectionUtils.java b/src/main/java/component/util/ReflectionUtils.java
new file mode 100644
index 0000000..094d60d
--- /dev/null
+++ b/src/main/java/component/util/ReflectionUtils.java
@@ -0,0 +1,877 @@
+package component.util;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.UndeclaredThrowableException;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Simple utility class for working with the reflection API and handling
+ * reflection exceptions.
+ *
+ * <p>
+ * Only intended for internal use.
+ *
+ */
+public abstract class ReflectionUtils {
+
+    /**
+     * Naming prefix for CGLIB-renamed methods.
+     *
+     * @see #isCglibRenamedMethod
+     */
+    private static final String CGLIB_RENAMED_METHOD_PREFIX = "CGLIB$";
+
+    private static final Method[] NO_METHODS = {};
+
+    private static final Field[] NO_FIELDS = {};
+
+    /**
+     * Cache for {@link Class#getDeclaredMethods()} plus equivalent default
+     * methods from Java 8 based interfaces, allowing for fast iteration.
+     */
+    private static final Map<Class<?>, Method[]> declaredMethodsCache
+            = new ConcurrentHashMap<>(256);
+
+    /**
+     * Cache for {@link Class#getDeclaredFields()}, allowing for fast iteration.
+     */
+    private static final Map<Class<?>, Field[]> declaredFieldsCache
+            = new ConcurrentHashMap<>(256);
+
+    /**
+     * Attempt to find a {@link Field field} on the supplied {@link Class} with
+     * the supplied {@code name}. Searches all superclasses up to
+     * {@link Object}.
+     *
+     * @param clazz the class to introspect
+     * @param name the name of the field
+     * @return the corresponding Field object, or {@code null} if not found
+     */
+    public static Field findField(Class<?> clazz, String name) {
+        return findField(clazz, name, null);
+    }
+
+    /**
+     * Attempt to find a {@link Field field} on the supplied {@link Class} with
+     * the supplied {@code name} and/or {@link Class type}. Searches all
+     * superclasses up to {@link Object}.
+     *
+     * @param clazz the class to introspect
+     * @param name the name of the field (may be {@code null} if type is
+     * specified)
+     * @param type the type of the field (may be {@code null} if name is
+     * specified)
+     * @return the corresponding Field object, or {@code null} if not found
+     */
+    public static Field findField(Class<?> clazz, String name, Class<?> type) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.isTrue(name != null || type != null, "Either name or type of the field must be specified");
+        Class<?> searchType = clazz;
+        while (Object.class != searchType && searchType != null) {
+            Field[] fields = getDeclaredFields(searchType);
+            for (Field field : fields) {
+                if ((name == null || name.equals(field.getName()))
+                        && (type == null || type.equals(field.getType()))) {
+                    return field;
+                }
+            }
+            searchType = searchType.getSuperclass();
+        }
+        return null;
+    }
+
+    /**
+     * Set the field represented by the supplied {@link Field field object} on
+     * the specified {@link Object target object} to the specified
+     * {@code value}. In accordance with {@link Field#set(Object, Object)}
+     * semantics, the new value is automatically unwrapped if the underlying
+     * field has a primitive type.
+     * <p>
+     * Thrown exceptions are handled via a call to
+     * {@link #handleReflectionException(Exception)}.
+     *
+     * @param field the field to set
+     * @param target the target object on which to set the field
+     * @param value the value to set (may be {@code null})
+     */
+    public static void setField(Field field, Object target, Object value) {
+        try {
+            field.set(target, value);
+        } catch (IllegalAccessException ex) {
+            handleReflectionException(ex);
+            throw new IllegalStateException(
+                    "Unexpected reflection exception - " + ex.getClass().getName() + ": " + ex.getMessage());
+        }
+    }
+
+    /**
+     * Get the field represented by the supplied {@link Field field object} on
+     * the specified {@link Object target object}. In accordance with
+     * {@link Field#get(Object)} semantics, the returned value is automatically
+     * wrapped if the underlying field has a primitive type.
+     * <p>
+     * Thrown exceptions are handled via a call to
+     * {@link #handleReflectionException(Exception)}.
+     *
+     * @param field the field to get
+     * @param target the target object from which to get the field
+     * @return the field's current value
+     */
+    public static Object getField(Field field, Object target) {
+        try {
+            return field.get(target);
+        } catch (IllegalAccessException ex) {
+            handleReflectionException(ex);
+            throw new IllegalStateException(
+                    "Unexpected reflection exception - " + ex.getClass().getName() + ": " + ex.getMessage());
+        }
+    }
+
+    /**
+     * Attempt to find a {@link Method} on the supplied class with the supplied
+     * name and no parameters. Searches all superclasses up to {@code Object}.
+     * <p>
+     * Returns {@code null} if no {@link Method} can be found.
+     *
+     * @param clazz the class to introspect
+     * @param name the name of the method
+     * @return the Method object, or {@code null} if none found
+     */
+    public static Method findMethod(Class<?> clazz, String name) {
+        return findMethod(clazz, name, new Class<?>[0]);
+    }
+
+    /**
+     * Attempt to find a {@link Method} on the supplied class with the supplied
+     * name and parameter types. Searches all superclasses up to {@code Object}.
+     * <p>
+     * Returns {@code null} if no {@link Method} can be found.
+     *
+     * @param clazz the class to introspect
+     * @param name the name of the method
+     * @param paramTypes the parameter types of the method (may be {@code null}
+     * to indicate any signature)
+     * @return the Method object, or {@code null} if none found
+     */
+    public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.notNull(name, "Method name must not be null");
+        Class<?> searchType = clazz;
+        while (searchType != null) {
+            Method[] methods = (searchType.isInterface() ? searchType.getMethods() : getDeclaredMethods(searchType));
+            for (Method method : methods) {
+                if (name.equals(method.getName())
+                        && (paramTypes == null || Arrays.equals(paramTypes, method.getParameterTypes()))) {
+                    return method;
+                }
+            }
+            searchType = searchType.getSuperclass();
+        }
+        return null;
+    }
+
+    /**
+     * Invoke the specified {@link Method} against the supplied target object
+     * with no arguments. The target object can be {@code null} when invoking a
+     * static {@link Method}.
+     * <p>
+     * Thrown exceptions are handled via a call to
+     * {@link #handleReflectionException}.
+     *
+     * @param method the method to invoke
+     * @param target the target object to invoke the method on
+     * @return the invocation result, if any
+     * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])
+     */
+    public static Object invokeMethod(Method method, Object target) {
+        return invokeMethod(method, target, new Object[0]);
+    }
+
+    /**
+     * Invoke the specified {@link Method} against the supplied target object
+     * with the supplied arguments. The target object can be {@code null} when
+     * invoking a static {@link Method}.
+     * <p>
+     * Thrown exceptions are handled via a call to
+     * {@link #handleReflectionException}.
+     *
+     * @param method the method to invoke
+     * @param target the target object to invoke the method on
+     * @param args the invocation arguments (may be {@code null})
+     * @return the invocation result, if any
+     */
+    public static Object invokeMethod(Method method, Object target, Object... args) {
+        try {
+            return method.invoke(target, args);
+        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
+            handleReflectionException(ex);
+        }
+        throw new IllegalStateException("Should never get here");
+    }
+
+    /**
+     * Invoke the specified JDBC API {@link Method} against the supplied target
+     * object with no arguments.
+     *
+     * @param method the method to invoke
+     * @param target the target object to invoke the method on
+     * @return the invocation result, if any
+     * @throws SQLException the JDBC API SQLException to rethrow (if any)
+     * @see #invokeJdbcMethod(java.lang.reflect.Method, Object, Object[])
+     */
+    public static Object invokeJdbcMethod(Method method, Object target) throws SQLException {
+        return invokeJdbcMethod(method, target, new Object[0]);
+    }
+
+    /**
+     * Invoke the specified JDBC API {@link Method} against the supplied target
+     * object with the supplied arguments.
+     *
+     * @param method the method to invoke
+     * @param target the target object to invoke the method on
+     * @param args the invocation arguments (may be {@code null})
+     * @return the invocation result, if any
+     * @throws SQLException the JDBC API SQLException to rethrow (if any)
+     * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])
+     */
+    public static Object invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException {
+        try {
+            return method.invoke(target, args);
+        } catch (IllegalAccessException ex) {
+            handleReflectionException(ex);
+        } catch (InvocationTargetException ex) {
+            if (ex.getTargetException() instanceof SQLException) {
+                throw (SQLException) ex.getTargetException();
+            }
+            handleInvocationTargetException(ex);
+        }
+        throw new IllegalStateException("Should never get here");
+    }
+
+    /**
+     * Handle the given reflection exception. Should only be called if no
+     * checked exception is expected to be thrown by the target method.
+     * <p>
+     * Throws the underlying RuntimeException or Error in case of an
+     * InvocationTargetException with such a root cause. Throws an
+     * IllegalStateException with an appropriate message or
+     * UndeclaredThrowableException otherwise.
+     *
+     * @param ex the reflection exception to handle
+     */
+    public static void handleReflectionException(Exception ex) {
+        if (ex instanceof NoSuchMethodException) {
+            throw new IllegalStateException("Method not found: " + ex.getMessage());
+        }
+        if (ex instanceof IllegalAccessException) {
+            throw new IllegalStateException("Could not access method: " + ex.getMessage());
+        }
+        if (ex instanceof InvocationTargetException) {
+            handleInvocationTargetException((InvocationTargetException) ex);
+        }
+        if (ex instanceof RuntimeException) {
+            throw (RuntimeException) ex;
+        }
+        throw new UndeclaredThrowableException(ex);
+    }
+
+    /**
+     * Handle the given invocation target exception. Should only be called if no
+     * checked exception is expected to be thrown by the target method.
+     * <p>
+     * Throws the underlying RuntimeException or Error in case of such a root
+     * cause. Throws an UndeclaredThrowableException otherwise.
+     *
+     * @param ex the invocation target exception to handle
+     */
+    public static void handleInvocationTargetException(InvocationTargetException ex) {
+        rethrowRuntimeException(ex.getTargetException());
+    }
+
+    /**
+     * Rethrow the given {@link Throwable exception}, which is presumably the
+     * <em>target exception</em> of an {@link InvocationTargetException}. Should
+     * only be called if no checked exception is expected to be thrown by the
+     * target method.
+     * <p>
+     * Rethrows the underlying exception cast to a {@link RuntimeException} or
+     * {@link Error} if appropriate; otherwise, throws an
+     * {@link UndeclaredThrowableException}.
+     *
+     * @param ex the exception to rethrow
+     * @throws RuntimeException the rethrown exception
+     */
+    public static void rethrowRuntimeException(Throwable ex) {
+        if (ex instanceof RuntimeException) {
+            throw (RuntimeException) ex;
+        }
+        if (ex instanceof Error) {
+            throw (Error) ex;
+        }
+        throw new UndeclaredThrowableException(ex);
+    }
+
+    /**
+     * Rethrow the given {@link Throwable exception}, which is presumably the
+     * <em>target exception</em> of an {@link InvocationTargetException}. Should
+     * only be called if no checked exception is expected to be thrown by the
+     * target method.
+     * <p>
+     * Rethrows the underlying exception cast to an {@link Exception} or
+     * {@link Error} if appropriate; otherwise, throws an
+     * {@link UndeclaredThrowableException}.
+     *
+     * @param ex the exception to rethrow
+     * @throws Exception the rethrown exception (in case of a checked exception)
+     */
+    public static void rethrowException(Throwable ex) throws Exception {
+        if (ex instanceof Exception) {
+            throw (Exception) ex;
+        }
+        if (ex instanceof Error) {
+            throw (Error) ex;
+        }
+        throw new UndeclaredThrowableException(ex);
+    }
+
+    /**
+     * Determine whether the given method explicitly declares the given
+     * exception or one of its superclasses, which means that an exception of
+     * that type can be propagated as-is within a reflective invocation.
+     *
+     * @param method the declaring method
+     * @param exceptionType the exception to throw
+     * @return {@code true} if the exception can be thrown as-is; {@code false}
+     * if it needs to be wrapped
+     */
+    public static boolean declaresException(Method method, Class<?> exceptionType) {
+        Assert.notNull(method, "Method must not be null");
+        Class<?>[] declaredExceptions = method.getExceptionTypes();
+        for (Class<?> declaredException : declaredExceptions) {
+            if (declaredException.isAssignableFrom(exceptionType)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Determine whether the given field is a "public static final" constant.
+     *
+     * @param field the field to check
+     * @return
+     */
+    public static boolean isPublicStaticFinal(Field field) {
+        int modifiers = field.getModifiers();
+        return (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers));
+    }
+
+    /**
+     * Determine whether the given method is an "equals" method.
+     *
+     * @param method
+     * @return
+     * @see java.lang.Object#equals(Object)
+     */
+    public static boolean isEqualsMethod(Method method) {
+        if (method == null || !method.getName().equals("equals")) {
+            return false;
+        }
+        Class<?>[] paramTypes = method.getParameterTypes();
+        return (paramTypes.length == 1 && paramTypes[0] == Object.class);
+    }
+
+    /**
+     * Determine whether the given method is a "hashCode" method.
+     *
+     * @param method
+     * @return
+     * @see java.lang.Object#hashCode()
+     */
+    public static boolean isHashCodeMethod(Method method) {
+        return (method != null && method.getName().equals("hashCode") && method.getParameterCount() == 0);
+    }
+
+    /**
+     * Determine whether the given method is a "toString" method.
+     *
+     * @param method
+     * @return
+     * @see java.lang.Object#toString()
+     */
+    public static boolean isToStringMethod(Method method) {
+        return (method != null && method.getName().equals("toString") && method.getParameterCount() == 0);
+    }
+
+    /**
+     * Determine whether the given method is originally declared by
+     * {@link java.lang.Object}.
+     *
+     * @param method
+     * @return
+     */
+    public static boolean isObjectMethod(Method method) {
+        if (method == null) {
+            return false;
+        }
+        try {
+            Object.class.getDeclaredMethod(method.getName(), method.getParameterTypes());
+            return true;
+        } catch (NoSuchMethodException | SecurityException ex) {
+            return false;
+        }
+    }
+
+    /**
+     * Determine whether the given method is a CGLIB 'renamed' method, following
+     * the pattern "CGLIB$methodName$0".
+     *
+     * @param renamedMethod the method to check
+     * @return
+     * @see org.springframework.cglib.proxy.Enhancer#rename
+     */
+    public static boolean isCglibRenamedMethod(Method renamedMethod) {
+        String name = renamedMethod.getName();
+        if (name.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {
+            int i = name.length() - 1;
+            while (i >= 0 && Character.isDigit(name.charAt(i))) {
+                i--;
+            }
+            return ((i > CGLIB_RENAMED_METHOD_PREFIX.length())
+                    && (i < name.length() - 1) && name.charAt(i) == '$');
+        }
+        return false;
+    }
+
+    /**
+     * Make the given field accessible, explicitly setting it accessible if
+     * necessary. The {@code setAccessible(true)} method is only called when
+     * actually necessary, to avoid unnecessary conflicts with a JVM
+     * SecurityManager (if active).
+     *
+     * @param field the field to make accessible
+     * @see java.lang.reflect.Field#setAccessible
+     */
+    public static void makeAccessible(Field field) {
+        if ((!Modifier.isPublic(field.getModifiers())
+                || !Modifier.isPublic(field.getDeclaringClass().getModifiers())
+                || Modifier.isFinal(field.getModifiers())) && !field.isAccessible()) {
+            field.setAccessible(true);
+        }
+    }
+
+    /**
+     * Make the given method accessible, explicitly setting it accessible if
+     * necessary. The {@code setAccessible(true)} method is only called when
+     * actually necessary, to avoid unnecessary conflicts with a JVM
+     * SecurityManager (if active).
+     *
+     * @param method the method to make accessible
+     * @see java.lang.reflect.Method#setAccessible
+     */
+    public static void makeAccessible(Method method) {
+        if ((!Modifier.isPublic(method.getModifiers())
+                || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible()) {
+            method.setAccessible(true);
+        }
+    }
+
+    /**
+     * Make the given constructor accessible, explicitly setting it accessible
+     * if necessary. The {@code setAccessible(true)} method is only called when
+     * actually necessary, to avoid unnecessary conflicts with a JVM
+     * SecurityManager (if active).
+     *
+     * @param ctor the constructor to make accessible
+     * @see java.lang.reflect.Constructor#setAccessible
+     */
+    public static void makeAccessible(Constructor<?> ctor) {
+        if ((!Modifier.isPublic(ctor.getModifiers())
+                || !Modifier.isPublic(ctor.getDeclaringClass().getModifiers())) && !ctor.isAccessible()) {
+            ctor.setAccessible(true);
+        }
+    }
+
+    /**
+     * Obtain an accessible constructor for the given class and parameters.
+     *
+     * @param clazz the clazz to check
+     * @param parameterTypes the parameter types of the desired constructor
+     * @return the constructor reference
+     * @throws NoSuchMethodException if no such constructor exists
+     * @since 5.0
+     */
+    public static <T> Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes)
+            throws NoSuchMethodException {
+
+        Constructor<T> ctor = clazz.getDeclaredConstructor(parameterTypes);
+        makeAccessible(ctor);
+        return ctor;
+    }
+
+    /**
+     * Perform the given callback operation on all matching methods of the given
+     * class, as locally declared or equivalent thereof (such as default methods
+     * on Java 8 based interfaces that the given class implements).
+     *
+     * @param clazz the class to introspect
+     * @param mc the callback to invoke for each method
+     * @since 4.2
+     * @see #doWithMethods
+     */
+    public static void doWithLocalMethods(Class<?> clazz, MethodCallback mc) {
+        Method[] methods = getDeclaredMethods(clazz);
+        for (Method method : methods) {
+            try {
+                mc.doWith(method);
+            } catch (IllegalAccessException ex) {
+                throw new IllegalStateException("Not allowed to access method '" + method.getName() + "': " + ex);
+            }
+        }
+    }
+
+    /**
+     * Perform the given callback operation on all matching methods of the given
+     * class and superclasses.
+     * <p>
+     * The same named method occurring on subclass and superclass will appear
+     * twice, unless excluded by a {@link MethodFilter}.
+     *
+     * @param clazz the class to introspect
+     * @param mc the callback to invoke for each method
+     * @see #doWithMethods(Class, MethodCallback, MethodFilter)
+     */
+    public static void doWithMethods(Class<?> clazz, MethodCallback mc) {
+        doWithMethods(clazz, mc, null);
+    }
+
+    /**
+     * Perform the given callback operation on all matching methods of the given
+     * class and superclasses (or given interface and super-interfaces).
+     * <p>
+     * The same named method occurring on subclass and superclass will appear
+     * twice, unless excluded by the specified {@link MethodFilter}.
+     *
+     * @param clazz the class to introspect
+     * @param mc the callback to invoke for each method
+     * @param mf the filter that determines the methods to apply the callback to
+     */
+    public static void doWithMethods(Class<?> clazz, MethodCallback mc, MethodFilter mf) {
+        // Keep backing up the inheritance hierarchy.
+        Method[] methods = getDeclaredMethods(clazz);
+        for (Method method : methods) {
+            if (mf != null && !mf.matches(method)) {
+                continue;
+            }
+            try {
+                mc.doWith(method);
+            } catch (IllegalAccessException ex) {
+                throw new IllegalStateException("Not allowed to access method '" + method.getName() + "': " + ex);
+            }
+        }
+        if (clazz.getSuperclass() != null) {
+            doWithMethods(clazz.getSuperclass(), mc, mf);
+        } else if (clazz.isInterface()) {
+            for (Class<?> superIfc : clazz.getInterfaces()) {
+                doWithMethods(superIfc, mc, mf);
+            }
+        }
+    }
+
+    /**
+     * Get all declared methods on the leaf class and all superclasses. Leaf
+     * class methods are included first.
+     *
+     * @param leafClass the class to introspect
+     * @return
+     */
+    public static Method[] getAllDeclaredMethods(Class<?> leafClass) {
+        final List<Method> methods = new ArrayList<>(32);
+        doWithMethods(leafClass, methods::add);
+        return methods.toArray(new Method[methods.size()]);
+    }
+
+    /**
+     * Get the unique set of declared methods on the leaf class and all
+     * superclasses. Leaf class methods are included first and while traversing
+     * the superclass hierarchy any methods found with signatures matching a
+     * method already included are filtered out.
+     *
+     * @param leafClass the class to introspect
+     * @return
+     */
+    public static Method[] getUniqueDeclaredMethods(Class<?> leafClass) {
+        final List<Method> methods = new ArrayList<>(32);
+        doWithMethods(leafClass, (Method method) -> {
+            boolean knownSignature = false;
+            Method methodBeingOverriddenWithCovariantReturnType = null;
+            for (Method existingMethod : methods) {
+                if (method.getName().equals(existingMethod.getName())
+                        && Arrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {
+                    // Is this a covariant return type situation?
+                    if (existingMethod.getReturnType() != method.getReturnType()
+                            && existingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {
+                        methodBeingOverriddenWithCovariantReturnType = existingMethod;
+                    } else {
+                        knownSignature = true;
+                    }
+                    break;
+                }
+            }
+            if (methodBeingOverriddenWithCovariantReturnType != null) {
+                methods.remove(methodBeingOverriddenWithCovariantReturnType);
+            }
+            if (!knownSignature && !isCglibRenamedMethod(method)) {
+                methods.add(method);
+            }
+        });
+        return methods.toArray(new Method[methods.size()]);
+    }
+
+    /**
+     * This variant retrieves {@link Class#getDeclaredMethods()} from a local
+     * cache in order to avoid the JVM's SecurityManager check and defensive
+     * array copying. In addition, it also includes Java 8 default methods from
+     * locally implemented interfaces, since those are effectively to be treated
+     * just like declared methods.
+     *
+     * @param clazz the class to introspect
+     * @return the cached array of methods
+     * @see Class#getDeclaredMethods()
+     */
+    private static Method[] getDeclaredMethods(Class<?> clazz) {
+        Method[] result = declaredMethodsCache.get(clazz);
+        if (result == null) {
+            Method[] declaredMethods = clazz.getDeclaredMethods();
+            List<Method> defaultMethods = findConcreteMethodsOnInterfaces(clazz);
+            if (defaultMethods != null) {
+                result = new Method[declaredMethods.length + defaultMethods.size()];
+                System.arraycopy(declaredMethods, 0, result, 0, declaredMethods.length);
+                int index = declaredMethods.length;
+                for (Method defaultMethod : defaultMethods) {
+                    result[index] = defaultMethod;
+                    index++;
+                }
+            } else {
+                result = declaredMethods;
+            }
+            declaredMethodsCache.put(clazz, (result.length == 0 ? NO_METHODS : result));
+        }
+        return result;
+    }
+
+    private static List<Method> findConcreteMethodsOnInterfaces(Class<?> clazz) {
+        List<Method> result = null;
+        for (Class<?> ifc : clazz.getInterfaces()) {
+            for (Method ifcMethod : ifc.getMethods()) {
+                if (!Modifier.isAbstract(ifcMethod.getModifiers())) {
+                    if (result == null) {
+                        result = new LinkedList<>();
+                    }
+                    result.add(ifcMethod);
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Invoke the given callback on all fields in the target class, going up the
+     * class hierarchy to get all declared fields.
+     *
+     * @param clazz the target class to analyze
+     * @param fc the callback to invoke for each field
+     * @since 4.2
+     * @see #doWithFields
+     */
+    public static void doWithLocalFields(Class<?> clazz, FieldCallback fc) {
+        for (Field field : getDeclaredFields(clazz)) {
+            try {
+                fc.doWith(field);
+            } catch (IllegalAccessException ex) {
+                throw new IllegalStateException("Not allowed to access field '" + field.getName() + "': " + ex);
+            }
+        }
+    }
+
+    /**
+     * Invoke the given callback on all fields in the target class, going up the
+     * class hierarchy to get all declared fields.
+     *
+     * @param clazz the target class to analyze
+     * @param fc the callback to invoke for each field
+     */
+    public static void doWithFields(Class<?> clazz, FieldCallback fc) {
+        doWithFields(clazz, fc, null);
+    }
+
+    /**
+     * Invoke the given callback on all fields in the target class, going up the
+     * class hierarchy to get all declared fields.
+     *
+     * @param clazz the target class to analyze
+     * @param fc the callback to invoke for each field
+     * @param ff the filter that determines the fields to apply the callback to
+     */
+    public static void doWithFields(Class<?> clazz, FieldCallback fc, FieldFilter ff) {
+        // Keep backing up the inheritance hierarchy.
+        Class<?> targetClass = clazz;
+        do {
+            Field[] fields = getDeclaredFields(targetClass);
+            for (Field field : fields) {
+                if (ff != null && !ff.matches(field)) {
+                    continue;
+                }
+                try {
+                    fc.doWith(field);
+                } catch (IllegalAccessException ex) {
+                    throw new IllegalStateException("Not allowed to access field '" + field.getName() + "': " + ex);
+                }
+            }
+            targetClass = targetClass.getSuperclass();
+        } while (targetClass != null && targetClass != Object.class);
+    }
+
+    /**
+     * This variant retrieves {@link Class#getDeclaredFields()} from a local
+     * cache in order to avoid the JVM's SecurityManager check and defensive
+     * array copying.
+     *
+     * @param clazz the class to introspect
+     * @return the cached array of fields
+     * @see Class#getDeclaredFields()
+     */
+    private static Field[] getDeclaredFields(Class<?> clazz) {
+        Field[] result = declaredFieldsCache.get(clazz);
+        if (result == null) {
+            result = clazz.getDeclaredFields();
+            declaredFieldsCache.put(clazz, (result.length == 0 ? NO_FIELDS : result));
+        }
+        return result;
+    }
+
+    /**
+     * Given the source object and the destination, which must be the same class
+     * or a subclass, copy all fields, including inherited fields. Designed to
+     * work on objects with public no-arg constructors.
+     *
+     * @param src
+     * @param dest
+     */
+    public static void shallowCopyFieldState(final Object src, final Object dest) {
+        if (src == null) {
+            throw new IllegalArgumentException("Source for field copy cannot be null");
+        }
+        if (dest == null) {
+            throw new IllegalArgumentException("Destination for field copy cannot be null");
+        }
+        if (!src.getClass().isAssignableFrom(dest.getClass())) {
+            throw new IllegalArgumentException("Destination class [" + dest.getClass().getName()
+                    + "] must be same or subclass as source class [" + src.getClass().getName() + "]");
+        }
+        doWithFields(src.getClass(), (Field field) -> {
+            makeAccessible(field);
+            Object srcValue = field.get(src);
+            field.set(dest, srcValue);
+        }, COPYABLE_FIELDS);
+    }
+
+    /**
+     * Clear the internal method/field cache.
+     *
+     * @since 4.2.4
+     */
+    public static void clearCache() {
+        declaredMethodsCache.clear();
+        declaredFieldsCache.clear();
+    }
+
+    /**
+     * Action to take on each method.
+     */
+    @FunctionalInterface
+    public interface MethodCallback {
+
+        /**
+         * Perform an operation using the given method.
+         *
+         * @param method the method to operate on
+         * @throws java.lang.IllegalAccessException
+         */
+        void doWith(Method method) throws IllegalArgumentException, IllegalAccessException;
+    }
+
+    /**
+     * Callback optionally used to filter methods to be operated on by a method
+     * callback.
+     */
+    @FunctionalInterface
+    public interface MethodFilter {
+
+        /**
+         * Determine whether the given method matches.
+         *
+         * @param method the method to check
+         * @return
+         */
+        boolean matches(Method method);
+    }
+
+    /**
+     * Callback interface invoked on each field in the hierarchy.
+     */
+    @FunctionalInterface
+    public interface FieldCallback {
+
+        /**
+         * Perform an operation using the given field.
+         *
+         * @param field the field to operate on
+         * @throws java.lang.IllegalAccessException
+         */
+        void doWith(Field field) throws IllegalArgumentException, IllegalAccessException;
+    }
+
+    /**
+     * Callback optionally used to filter fields to be operated on by a field
+     * callback.
+     */
+    @FunctionalInterface
+    public interface FieldFilter {
+
+        /**
+         * Determine whether the given field matches.
+         *
+         * @param field the field to check
+         * @return
+         */
+        boolean matches(Field field);
+    }
+
+    /**
+     * Pre-built FieldFilter that matches all non-static, non-final fields.
+     */
+    public static final FieldFilter COPYABLE_FIELDS = (Field field) -> !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));
+
+    /**
+     * Pre-built MethodFilter that matches all non-bridge methods.
+     */
+    public static final MethodFilter NON_BRIDGED_METHODS = (Method method) -> !method.isBridge();
+
+    /**
+     * Pre-built MethodFilter that matches all non-bridge methods which are not
+     * declared on {@code java.lang.Object}.
+     */
+    public static final MethodFilter USER_DECLARED_METHODS = (Method method) -> (!method.isBridge() && method.getDeclaringClass() != Object.class);
+
+}
diff --git a/src/main/java/component/util/ResourceUtils.java b/src/main/java/component/util/ResourceUtils.java
new file mode 100644
index 0000000..3556c55
--- /dev/null
+++ b/src/main/java/component/util/ResourceUtils.java
@@ -0,0 +1,432 @@
+/*
+ * Copyright 2002-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package component.util;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLConnection;
+
+/**
+ * Utility methods for resolving resource locations to files in the file system.
+ * Mainly for internal use within the framework.
+ *
+ * <p>
+ * Consider using Spring's Resource abstraction in the core package for handling
+ * all kinds of file resources in a uniform manner.
+ * {@link org.springframework.core.io.ResourceLoader}'s {@code getResource()}
+ * method can resolve any location to a
+ * {@link org.springframework.core.io.Resource} object, which in turn allows one
+ * to obtain a {@code java.io.File} in the file system through its
+ * {@code getFile()} method.
+ *
+ * <p>
+ * The main reason for these utility methods for resource location handling is
+ * to support {@link Log4jConfigurer}, which must be able to resolve resource
+ * locations <i>before the logging system has been initialized</i>. Spring's
+ * {@code Resource} abstraction in the core package, on the other hand, already
+ * expects the logging system to be available.
+ *
+ * @author Juergen Hoeller
+ * @since 1.1.5
+ * @see org.springframework.core.io.Resource
+ * @see org.springframework.core.io.ClassPathResource
+ * @see org.springframework.core.io.FileSystemResource
+ * @see org.springframework.core.io.UrlResource
+ * @see org.springframework.core.io.ResourceLoader
+ */
+public abstract class ResourceUtils {
+
+    /**
+     * Pseudo URL prefix for loading from the class path: "classpath:"
+     */
+    public static final String CLASSPATH_URL_PREFIX = "classpath:";
+
+    /**
+     * URL prefix for loading from the file system: "file:"
+     */
+    public static final String FILE_URL_PREFIX = "file:";
+
+    /**
+     * URL prefix for loading from a jar file: "jar:"
+     */
+    public static final String JAR_URL_PREFIX = "jar:";
+
+    /**
+     * URL prefix for loading from a war file on Tomcat: "war:"
+     */
+    public static final String WAR_URL_PREFIX = "war:";
+
+    /**
+     * URL protocol for a file in the file system: "file"
+     */
+    public static final String URL_PROTOCOL_FILE = "file";
+
+    /**
+     * URL protocol for an entry from a jar file: "jar"
+     */
+    public static final String URL_PROTOCOL_JAR = "jar";
+
+    /**
+     * URL protocol for an entry from a zip file: "zip"
+     */
+    public static final String URL_PROTOCOL_ZIP = "zip";
+
+    /**
+     * URL protocol for an entry from a WebSphere jar file: "wsjar"
+     */
+    public static final String URL_PROTOCOL_WSJAR = "wsjar";
+
+    /**
+     * URL protocol for an entry from a JBoss jar file: "vfszip"
+     */
+    public static final String URL_PROTOCOL_VFSZIP = "vfszip";
+
+    /**
+     * URL protocol for a JBoss file system resource: "vfsfile"
+     */
+    public static final String URL_PROTOCOL_VFSFILE = "vfsfile";
+
+    /**
+     * URL protocol for a general JBoss VFS resource: "vfs"
+     */
+    public static final String URL_PROTOCOL_VFS = "vfs";
+
+    /**
+     * File extension for a regular jar file: ".jar"
+     */
+    public static final String JAR_FILE_EXTENSION = ".jar";
+
+    /**
+     * Separator between JAR URL and file path within the JAR: "!/"
+     */
+    public static final String JAR_URL_SEPARATOR = "!/";
+
+    /**
+     * Special separator between WAR URL and jar part on Tomcat
+     */
+    public static final String WAR_URL_SEPARATOR = "*/";
+
+    /**
+     * Return whether the given resource location is a URL: either a special
+     * "classpath" pseudo URL or a standard URL.
+     *
+     * @param resourceLocation the location String to check
+     * @return whether the location qualifies as a URL
+     * @see #CLASSPATH_URL_PREFIX
+     * @see java.net.URL
+     */
+    public static boolean isUrl(String resourceLocation) {
+        if (resourceLocation == null) {
+            return false;
+        }
+        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
+            return true;
+        }
+        try {
+            URL url = new URL(resourceLocation);
+            return true;
+        } catch (MalformedURLException ex) {
+            return false;
+        }
+    }
+
+    /**
+     * Resolve the given resource location to a {@code java.net.URL}.
+     * <p>
+     * Does not check whether the URL actually exists; simply returns the URL
+     * that the given location would correspond to.
+     *
+     * @param resourceLocation the resource location to resolve: either a
+     * "classpath:" pseudo URL, a "file:" URL, or a plain file path
+     * @return a corresponding URL object
+     * @throws FileNotFoundException if the resource cannot be resolved to a URL
+     */
+    public static URL getURL(String resourceLocation) throws FileNotFoundException {
+        Assert.notNull(resourceLocation, "Resource location must not be null");
+        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
+            String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());
+            ClassLoader cl = ClassUtils.getDefaultClassLoader();
+            URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));
+            if (url == null) {
+                String description = "class path resource [" + path + "]";
+                throw new FileNotFoundException(description
+                        + " cannot be resolved to URL because it does not exist");
+            }
+            return url;
+        }
+        try {
+            // try URL
+            return new URL(resourceLocation);
+        } catch (MalformedURLException ex) {
+            // no URL -> treat as file path
+            try {
+                return new File(resourceLocation).toURI().toURL();
+            } catch (MalformedURLException ex2) {
+                throw new FileNotFoundException("Resource location [" + resourceLocation
+                        + "] is neither a URL not a well-formed file path");
+            }
+        }
+    }
+
+    /**
+     * Resolve the given resource location to a {@code java.io.File}, i.e. to a
+     * file in the file system.
+     * <p>
+     * Does not check whether the file actually exists; simply returns the File
+     * that the given location would correspond to.
+     *
+     * @param resourceLocation the resource location to resolve: either a
+     * "classpath:" pseudo URL, a "file:" URL, or a plain file path
+     * @return a corresponding File object
+     * @throws FileNotFoundException if the resource cannot be resolved to a
+     * file in the file system
+     */
+    public static File getFile(String resourceLocation) throws FileNotFoundException {
+        Assert.notNull(resourceLocation, "Resource location must not be null");
+        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
+            String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());
+            String description = "class path resource [" + path + "]";
+            ClassLoader cl = ClassUtils.getDefaultClassLoader();
+            URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));
+            if (url == null) {
+                throw new FileNotFoundException(description
+                        + " cannot be resolved to absolute file path because it does not exist");
+            }
+            return getFile(url, description);
+        }
+        try {
+            // try URL
+            return getFile(new URL(resourceLocation));
+        } catch (MalformedURLException ex) {
+            // no URL -> treat as file path
+            return new File(resourceLocation);
+        }
+    }
+
+    /**
+     * Resolve the given resource URL to a {@code java.io.File}, i.e. to a file
+     * in the file system.
+     *
+     * @param resourceUrl the resource URL to resolve
+     * @return a corresponding File object
+     * @throws FileNotFoundException if the URL cannot be resolved to a file in
+     * the file system
+     */
+    public static File getFile(URL resourceUrl) throws FileNotFoundException {
+        return getFile(resourceUrl, "URL");
+    }
+
+    /**
+     * Resolve the given resource URL to a {@code java.io.File}, i.e. to a file
+     * in the file system.
+     *
+     * @param resourceUrl the resource URL to resolve
+     * @param description a description of the original resource that the URL
+     * was created for (for example, a class path location)
+     * @return a corresponding File object
+     * @throws FileNotFoundException if the URL cannot be resolved to a file in
+     * the file system
+     */
+    public static File getFile(URL resourceUrl, String description) throws FileNotFoundException {
+        Assert.notNull(resourceUrl, "Resource URL must not be null");
+        if (!URL_PROTOCOL_FILE.equals(resourceUrl.getProtocol())) {
+            throw new FileNotFoundException(
+                    description + " cannot be resolved to absolute file path "
+                    + "because it does not reside in the file system: " + resourceUrl);
+        }
+        try {
+            return new File(toURI(resourceUrl).getSchemeSpecificPart());
+        } catch (URISyntaxException ex) {
+            // Fallback for URLs that are not valid URIs (should hardly ever happen).
+            return new File(resourceUrl.getFile());
+        }
+    }
+
+    /**
+     * Resolve the given resource URI to a {@code java.io.File}, i.e. to a file
+     * in the file system.
+     *
+     * @param resourceUri the resource URI to resolve
+     * @return a corresponding File object
+     * @throws FileNotFoundException if the URL cannot be resolved to a file in
+     * the file system
+     */
+    public static File getFile(URI resourceUri) throws FileNotFoundException {
+        return getFile(resourceUri, "URI");
+    }
+
+    /**
+     * Resolve the given resource URI to a {@code java.io.File}, i.e. to a file
+     * in the file system.
+     *
+     * @param resourceUri the resource URI to resolve
+     * @param description a description of the original resource that the URI
+     * was created for (for example, a class path location)
+     * @return a corresponding File object
+     * @throws FileNotFoundException if the URL cannot be resolved to a file in
+     * the file system
+     */
+    public static File getFile(URI resourceUri, String description) throws FileNotFoundException {
+        Assert.notNull(resourceUri, "Resource URI must not be null");
+        if (!URL_PROTOCOL_FILE.equals(resourceUri.getScheme())) {
+            throw new FileNotFoundException(
+                    description + " cannot be resolved to absolute file path "
+                    + "because it does not reside in the file system: " + resourceUri);
+        }
+        return new File(resourceUri.getSchemeSpecificPart());
+    }
+
+    /**
+     * Determine whether the given URL points to a resource in the file system,
+     * that is, has protocol "file", "vfsfile" or "vfs".
+     *
+     * @param url the URL to check
+     * @return whether the URL has been identified as a file system URL
+     */
+    public static boolean isFileURL(URL url) {
+        String protocol = url.getProtocol();
+        return (URL_PROTOCOL_FILE.equals(protocol) || URL_PROTOCOL_VFSFILE.equals(protocol)
+                || URL_PROTOCOL_VFS.equals(protocol));
+    }
+
+    /**
+     * Determine whether the given URL points to a resource in a jar file, that
+     * is, has protocol "jar", "zip", "vfszip" or "wsjar".
+     *
+     * @param url the URL to check
+     * @return whether the URL has been identified as a JAR URL
+     */
+    public static boolean isJarURL(URL url) {
+        String protocol = url.getProtocol();
+        return (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_ZIP.equals(protocol)
+                || URL_PROTOCOL_VFSZIP.equals(protocol) || URL_PROTOCOL_WSJAR.equals(protocol));
+    }
+
+    /**
+     * Determine whether the given URL points to a jar file itself, that is, has
+     * protocol "file" and ends with the ".jar" extension.
+     *
+     * @param url the URL to check
+     * @return whether the URL has been identified as a JAR file URL
+     * @since 4.1
+     */
+    public static boolean isJarFileURL(URL url) {
+        return (URL_PROTOCOL_FILE.equals(url.getProtocol())
+                && url.getPath().toLowerCase().endsWith(JAR_FILE_EXTENSION));
+    }
+
+    /**
+     * Extract the URL for the actual jar file from the given URL (which may
+     * point to a resource in a jar file or to a jar file itself).
+     *
+     * @param jarUrl the original URL
+     * @return the URL for the actual jar file
+     * @throws MalformedURLException if no valid jar file URL could be extracted
+     */
+    public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException {
+        String urlFile = jarUrl.getFile();
+        int separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR);
+        if (separatorIndex != -1) {
+            String jarFile = urlFile.substring(0, separatorIndex);
+            try {
+                return new URL(jarFile);
+            } catch (MalformedURLException ex) {
+				// Probably no protocol in original jar URL, like "jar:C:/mypath/myjar.jar".
+                // This usually indicates that the jar file resides in the file system.
+                if (!jarFile.startsWith("/")) {
+                    jarFile = "/" + jarFile;
+                }
+                return new URL(FILE_URL_PREFIX + jarFile);
+            }
+        } else {
+            return jarUrl;
+        }
+    }
+
+    /**
+     * Extract the URL for the outermost archive from the given jar/war URL
+     * (which may point to a resource in a jar file or to a jar file itself).
+     * <p>
+     * In the case of a jar file nested within a war file, this will return a
+     * URL to the war file since that is the one resolvable in the file system.
+     *
+     * @param jarUrl the original URL
+     * @return the URL for the actual jar file
+     * @throws MalformedURLException if no valid jar file URL could be extracted
+     * @since 4.1.8
+     * @see #extractJarFileURL(URL)
+     */
+    public static URL extractArchiveURL(URL jarUrl) throws MalformedURLException {
+        String urlFile = jarUrl.getFile();
+
+        int endIndex = urlFile.indexOf(WAR_URL_SEPARATOR);
+        if (endIndex != -1) {
+            // Tomcat's "jar:war:file:...mywar.war*/WEB-INF/lib/myjar.jar!/myentry.txt"
+            String warFile = urlFile.substring(0, endIndex);
+            int startIndex = warFile.indexOf(WAR_URL_PREFIX);
+            if (startIndex != -1) {
+                return new URL(warFile.substring(startIndex + WAR_URL_PREFIX.length()));
+            }
+        }
+
+        // Regular "jar:file:...myjar.jar!/myentry.txt"
+        return extractJarFileURL(jarUrl);
+    }
+
+    /**
+     * Create a URI instance for the given URL, replacing spaces with "%20" URI
+     * encoding first.
+     * <p>
+     * Furthermore, this method works on JDK 1.4 as well, in contrast to the
+     * {@code URL.toURI()} method.
+     *
+     * @param url the URL to convert into a URI instance
+     * @return the URI instance
+     * @throws URISyntaxException if the URL wasn't a valid URI
+     * @see java.net.URL#toURI()
+     */
+    public static URI toURI(URL url) throws URISyntaxException {
+        return toURI(url.toString());
+    }
+
+    /**
+     * Create a URI instance for the given location String, replacing spaces
+     * with "%20" URI encoding first.
+     *
+     * @param location the location String to convert into a URI instance
+     * @return the URI instance
+     * @throws URISyntaxException if the location wasn't a valid URI
+     */
+    public static URI toURI(String location) throws URISyntaxException {
+        return new URI(StringUtils.replace(location, " ", "%20"));
+    }
+
+    /**
+     * Set the {@link URLConnection#setUseCaches "useCaches"} flag on the given
+     * connection, preferring {@code false} but leaving the flag at {@code true}
+     * for JNLP based resources.
+     *
+     * @param con the URLConnection to set the flag on
+     */
+    public static void useCachesIfNecessary(URLConnection con) {
+        con.setUseCaches(con.getClass().getSimpleName().startsWith("JNLP"));
+    }
+
+}
diff --git a/src/main/java/component/util/StringUtils.java b/src/main/java/component/util/StringUtils.java
new file mode 100644
index 0000000..4c564a2
--- /dev/null
+++ b/src/main/java/component/util/StringUtils.java
@@ -0,0 +1,1304 @@
+package component.util;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Properties;
+import java.util.Set;
+import java.util.StringTokenizer;
+import java.util.TimeZone;
+
+/**
+ *
+ * @author cdi305
+ */
+public abstract class StringUtils {
+
+    private static final String FOLDER_SEPARATOR = "/";
+
+    private static final String WINDOWS_FOLDER_SEPARATOR = "\\";
+
+    private static final String TOP_PATH = "..";
+
+    private static final String CURRENT_PATH = ".";
+
+    private static final char EXTENSION_SEPARATOR = '.';
+    
+
+    //---------------------------------------------------------------------
+    // General convenience methods for working with Strings
+    //---------------------------------------------------------------------
+    
+    
+    /**
+     * Check whether the given {@code String} is empty.
+     * <p>
+     * This method accepts any Object as an argument, comparing it to
+     * {@code null} and the empty String. As a consequence, this method will
+     * never return {@code true} for a non-null non-String object.
+     * <p>
+     * The Object signature is useful for general attribute handling code that
+     * commonly deals with Strings but generally has to iterate over Objects
+     * since attributes may e.g. be primitive value objects as well.
+     *
+     * @param str the candidate String
+     * @return 
+     * @since 3.2.1
+     */
+    public static boolean isEmpty(Object str) {
+        return (str == null || "".equals(str));
+    }
+
+    /**
+     * Check that the given {@code CharSequence} is neither {@code null} nor of
+     * length 0.
+     * <p>
+     * Note: this method returns {@code true} for a {@code CharSequence} that
+     * purely consists of whitespace.
+     * <p>
+     * <pre class="code">
+     * StringUtils.hasLength(null) = false StringUtils.hasLength("") = false
+     * StringUtils.hasLength(" ") = true StringUtils.hasLength("Hello") = true
+     * </pre>
+     *
+     * @param str the {@code CharSequence} to check (may be {@code null})
+     * @return {@code true} if the {@code CharSequence} is not {@code null} and
+     * has length
+     * @see #hasText(String)
+     */
+    public static boolean hasLength(CharSequence str) {
+        return (str != null && str.length() > 0);
+    }
+
+    /**
+     * Check that the given {@code String} is neither {@code null} nor of length
+     * 0.
+     * <p>
+     * Note: this method returns {@code true} for a {@code String} that purely
+     * consists of whitespace.
+     *
+     * @param str the {@code String} to check (may be {@code null})
+     * @return {@code true} if the {@code String} is not {@code null} and has
+     * length
+     * @see #hasLength(CharSequence)
+     * @see #hasText(String)
+     */
+    public static boolean hasLength(String str) {
+        return hasLength((CharSequence) str);
+    }
+
+    /**
+     * Check whether the given {@code CharSequence} contains actual
+     * <em>text</em>.
+     * <p>
+     * More specifically, this method returns {@code true} if the
+     * {@code CharSequence} is not {@code null}, its length is greater than 0,
+     * and it contains at least one non-whitespace character.
+     * <p>
+     * <pre class="code">
+     * StringUtils.hasText(null) = false StringUtils.hasText("") = false
+     * StringUtils.hasText(" ") = false StringUtils.hasText("12345") = true
+     * StringUtils.hasText(" 12345 ") = true
+     * </pre>
+     *
+     * @param str the {@code CharSequence} to check (may be {@code null})
+     * @return {@code true} if the {@code CharSequence} is not {@code null}, its
+     * length is greater than 0, and it does not contain whitespace only
+     * @see Character#isWhitespace
+     */
+    public static boolean hasText(CharSequence str) {
+        if (!hasLength(str)) {
+            return false;
+        }
+        int strLen = str.length();
+        for (int i = 0; i < strLen; i++) {
+            if (!Character.isWhitespace(str.charAt(i))) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Check whether the given {@code String} contains actual <em>text</em>.
+     * <p>
+     * More specifically, this method returns {@code true} if the {@code String}
+     * is not {@code null}, its length is greater than 0, and it contains at
+     * least one non-whitespace character.
+     *
+     * @param str the {@code String} to check (may be {@code null})
+     * @return {@code true} if the {@code String} is not {@code null}, its
+     * length is greater than 0, and it does not contain whitespace only
+     * @see #hasText(CharSequence)
+     */
+    public static boolean hasText(String str) {
+        return hasText((CharSequence) str);
+    }
+
+    /**
+     * Check whether the given {@code CharSequence} contains any whitespace
+     * characters.
+     *
+     * @param str the {@code CharSequence} to check (may be {@code null})
+     * @return {@code true} if the {@code CharSequence} is not empty and
+     * contains at least 1 whitespace character
+     * @see Character#isWhitespace
+     */
+    public static boolean containsWhitespace(CharSequence str) {
+        if (!hasLength(str)) {
+            return false;
+        }
+        int strLen = str.length();
+        for (int i = 0; i < strLen; i++) {
+            if (Character.isWhitespace(str.charAt(i))) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Check whether the given {@code String} contains any whitespace
+     * characters.
+     *
+     * @param str the {@code String} to check (may be {@code null})
+     * @return {@code true} if the {@code String} is not empty and contains at
+     * least 1 whitespace character
+     * @see #containsWhitespace(CharSequence)
+     */
+    public static boolean containsWhitespace(String str) {
+        return containsWhitespace((CharSequence) str);
+    }
+
+    /**
+     * Trim leading and trailing whitespace from the given {@code String}.
+     *
+     * @param str the {@code String} to check
+     * @return the trimmed {@code String}
+     * @see java.lang.Character#isWhitespace
+     */
+    public static String trimWhitespace(String str) {
+        if (!hasLength(str)) {
+            return str;
+        }
+        StringBuilder sb = new StringBuilder(str);
+        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
+            sb.deleteCharAt(0);
+        }
+        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {
+            sb.deleteCharAt(sb.length() - 1);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Trim <i>all</i> whitespace from the given {@code String}: leading,
+     * trailing, and in between characters.
+     *
+     * @param str the {@code String} to check
+     * @return the trimmed {@code String}
+     * @see java.lang.Character#isWhitespace
+     */
+    public static String trimAllWhitespace(String str) {
+        if (!hasLength(str)) {
+            return str;
+        }
+        int len = str.length();
+        StringBuilder sb = new StringBuilder(str.length());
+        for (int i = 0; i < len; i++) {
+            char c = str.charAt(i);
+            if (!Character.isWhitespace(c)) {
+                sb.append(c);
+            }
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Trim leading whitespace from the given {@code String}.
+     *
+     * @param str the {@code String} to check
+     * @return the trimmed {@code String}
+     * @see java.lang.Character#isWhitespace
+     */
+    public static String trimLeadingWhitespace(String str) {
+        if (!hasLength(str)) {
+            return str;
+        }
+        StringBuilder sb = new StringBuilder(str);
+        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
+            sb.deleteCharAt(0);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Trim trailing whitespace from the given {@code String}.
+     *
+     * @param str the {@code String} to check
+     * @return the trimmed {@code String}
+     * @see java.lang.Character#isWhitespace
+     */
+    public static String trimTrailingWhitespace(String str) {
+        if (!hasLength(str)) {
+            return str;
+        }
+        StringBuilder sb = new StringBuilder(str);
+        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {
+            sb.deleteCharAt(sb.length() - 1);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Trim all occurrences of the supplied leading character from the given
+     * {@code String}.
+     *
+     * @param str the {@code String} to check
+     * @param leadingCharacter the leading character to be trimmed
+     * @return the trimmed {@code String}
+     */
+    public static String trimLeadingCharacter(String str, char leadingCharacter) {
+        if (!hasLength(str)) {
+            return str;
+        }
+        StringBuilder sb = new StringBuilder(str);
+        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {
+            sb.deleteCharAt(0);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Trim all occurrences of the supplied trailing character from the given
+     * {@code String}.
+     *
+     * @param str the {@code String} to check
+     * @param trailingCharacter the trailing character to be trimmed
+     * @return the trimmed {@code String}
+     */
+    public static String trimTrailingCharacter(String str, char trailingCharacter) {
+        if (!hasLength(str)) {
+            return str;
+        }
+        StringBuilder sb = new StringBuilder(str);
+        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {
+            sb.deleteCharAt(sb.length() - 1);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Test if the given {@code String} starts with the specified prefix,
+     * ignoring upper/lower case.
+     *
+     * @param str the {@code String} to check
+     * @param prefix the prefix to look for
+     * @see java.lang.String#startsWith
+     */
+    public static boolean startsWithIgnoreCase(String str, String prefix) {
+        if (str == null || prefix == null) {
+            return false;
+        }
+        if (str.startsWith(prefix)) {
+            return true;
+        }
+        if (str.length() < prefix.length()) {
+            return false;
+        }
+        String lcStr = str.substring(0, prefix.length()).toLowerCase();
+        String lcPrefix = prefix.toLowerCase();
+        return lcStr.equals(lcPrefix);
+    }
+
+    /**
+     * Test if the given {@code String} ends with the specified suffix, ignoring
+     * upper/lower case.
+     *
+     * @param str the {@code String} to check
+     * @param suffix the suffix to look for
+     * @see java.lang.String#endsWith
+     */
+    public static boolean endsWithIgnoreCase(String str, String suffix) {
+        if (str == null || suffix == null) {
+            return false;
+        }
+        if (str.endsWith(suffix)) {
+            return true;
+        }
+        if (str.length() < suffix.length()) {
+            return false;
+        }
+
+        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();
+        String lcSuffix = suffix.toLowerCase();
+        return lcStr.equals(lcSuffix);
+    }
+
+    /**
+     * Test whether the given string matches the given substring at the given
+     * index.
+     *
+     * @param str the original string (or StringBuilder)
+     * @param index the index in the original string to start matching against
+     * @param substring the substring to match at the given index
+     */
+    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {
+        for (int j = 0; j < substring.length(); j++) {
+            int i = index + j;
+            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Count the occurrences of the substring {@code sub} in string {@code str}.
+     *
+     * @param str string to search in. Return 0 if this is {@code null}.
+     * @param sub string to search for. Return 0 if this is {@code null}.
+     */
+    public static int countOccurrencesOf(String str, String sub) {
+        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {
+            return 0;
+        }
+        int count = 0;
+        int pos = 0;
+        int idx;
+        while ((idx = str.indexOf(sub, pos)) != -1) {
+            ++count;
+            pos = idx + sub.length();
+        }
+        return count;
+    }
+
+    /**
+     * Replace all occurrences of a substring within a string with another
+     * string.
+     *
+     * @param inString {@code String} to examine
+     * @param oldPattern {@code String} to replace
+     * @param newPattern {@code String} to insert
+     * @return a {@code String} with the replacements
+     */
+    public static String replace(String inString, String oldPattern, String newPattern) {
+        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {
+            return inString;
+        }
+        StringBuilder sb = new StringBuilder();
+        int pos = 0; // our position in the old string
+        int index = inString.indexOf(oldPattern);
+        // the index of an occurrence we've found, or -1
+        int patLen = oldPattern.length();
+        while (index >= 0) {
+            sb.append(inString.substring(pos, index));
+            sb.append(newPattern);
+            pos = index + patLen;
+            index = inString.indexOf(oldPattern, pos);
+        }
+        sb.append(inString.substring(pos));
+        // remember to append any characters to the right of a match
+        return sb.toString();
+    }
+
+    /**
+     * Delete all occurrences of the given substring.
+     *
+     * @param inString the original {@code String}
+     * @param pattern the pattern to delete all occurrences of
+     * @return the resulting {@code String}
+     */
+    public static String delete(String inString, String pattern) {
+        return replace(inString, pattern, "");
+    }
+
+    /**
+     * Delete any character in a given {@code String}.
+     *
+     * @param inString the original {@code String}
+     * @param charsToDelete a set of characters to delete. E.g. "az\n" will
+     * delete 'a's, 'z's and new lines.
+     * @return the resulting {@code String}
+     */
+    public static String deleteAny(String inString, String charsToDelete) {
+        if (!hasLength(inString) || !hasLength(charsToDelete)) {
+            return inString;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < inString.length(); i++) {
+            char c = inString.charAt(i);
+            if (charsToDelete.indexOf(c) == -1) {
+                sb.append(c);
+            }
+        }
+        return sb.toString();
+    }
+
+	//---------------------------------------------------------------------
+    // Convenience methods for working with formatted Strings
+    //---------------------------------------------------------------------
+    /**
+     * Quote the given {@code String} with single quotes.
+     *
+     * @param str the input {@code String} (e.g. "myString")
+     * @return the quoted {@code String} (e.g. "'myString'"), or {@code null} if
+     * the input was {@code null}
+     */
+    public static String quote(String str) {
+        return (str != null ? "'" + str + "'" : null);
+    }
+
+    /**
+     * Turn the given Object into a {@code String} with single quotes if it is a
+     * {@code String}; keeping the Object as-is else.
+     *
+     * @param obj the input Object (e.g. "myString")
+     * @return the quoted {@code String} (e.g. "'myString'"), or the input
+     * object as-is if not a {@code String}
+     */
+    public static Object quoteIfString(Object obj) {
+        return (obj instanceof String ? quote((String) obj) : obj);
+    }
+
+    /**
+     * Unqualify a string qualified by a '.' dot character. For example,
+     * "this.name.is.qualified", returns "qualified".
+     *
+     * @param qualifiedName the qualified name
+     * @return 
+     */
+    public static String unqualify(String qualifiedName) {
+        return unqualify(qualifiedName, '.');
+    }
+
+    /**
+     * Unqualify a string qualified by a separator character. For example,
+     * "this:name:is:qualified" returns "qualified" if using a ':' separator.
+     *
+     * @param qualifiedName the qualified name
+     * @param separator the separator
+     * @return 
+     */
+    public static String unqualify(String qualifiedName, char separator) {
+        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);
+    }
+
+    /**
+     * Capitalize a {@code String}, changing the first letter to upper case as
+     * per {@link Character#toUpperCase(char)}. No other letters are changed.
+     *
+     * @param str the {@code String} to capitalize, may be {@code null}
+     * @return the capitalized {@code String}, or {@code null} if the supplied
+     * string is {@code null}
+     */
+    public static String capitalize(String str) {
+        return changeFirstCharacterCase(str, true);
+    }
+
+    /**
+     * Uncapitalize a {@code String}, changing the first letter to lower case as
+     * per {@link Character#toLowerCase(char)}. No other letters are changed.
+     *
+     * @param str the {@code String} to uncapitalize, may be {@code null}
+     * @return the uncapitalized {@code String}, or {@code null} if the supplied
+     * string is {@code null}
+     */
+    public static String uncapitalize(String str) {
+        return changeFirstCharacterCase(str, false);
+    }
+
+    private static String changeFirstCharacterCase(String str, boolean capitalize) {
+        if (str == null || str.length() == 0) {
+            return str;
+        }
+        StringBuilder sb = new StringBuilder(str.length());
+        if (capitalize) {
+            sb.append(Character.toUpperCase(str.charAt(0)));
+        } else {
+            sb.append(Character.toLowerCase(str.charAt(0)));
+        }
+        sb.append(str.substring(1));
+        return sb.toString();
+    }
+
+    /**
+     * Extract the filename from the given Java resource path, e.g.
+     * {@code "mypath/myfile.txt" -> "myfile.txt"}.
+     *
+     * @param path the file path (may be {@code null})
+     * @return the extracted filename, or {@code null} if none
+     */
+    public static String getFilename(String path) {
+        if (path == null) {
+            return null;
+        }
+        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);
+        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);
+    }
+
+    /**
+     * Extract the filename extension from the given Java resource path, e.g.
+     * "mypath/myfile.txt" -> "txt".
+     *
+     * @param path the file path (may be {@code null})
+     * @return the extracted filename extension, or {@code null} if none
+     */
+    public static String getFilenameExtension(String path) {
+        if (path == null) {
+            return null;
+        }
+        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);
+        if (extIndex == -1) {
+            return null;
+        }
+        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);
+        if (folderIndex > extIndex) {
+            return null;
+        }
+        return path.substring(extIndex + 1);
+    }
+
+    /**
+     * Strip the filename extension from the given Java resource path, e.g.
+     * "mypath/myfile.txt" -> "mypath/myfile".
+     *
+     * @param path the file path (may be {@code null})
+     * @return the path with stripped filename extension, or {@code null} if
+     * none
+     */
+    public static String stripFilenameExtension(String path) {
+        if (path == null) {
+            return null;
+        }
+        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);
+        if (extIndex == -1) {
+            return path;
+        }
+        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);
+        if (folderIndex > extIndex) {
+            return path;
+        }
+        return path.substring(0, extIndex);
+    }
+
+    /**
+     * Apply the given relative path to the given Java resource path, assuming
+     * standard Java folder separation (i.e. "/" separators).
+     *
+     * @param path the path to start from (usually a full file path)
+     * @param relativePath the relative path to apply (relative to the full file
+     * path above)
+     * @return the full file path that results from applying the relative path
+     */
+    public static String applyRelativePath(String path, String relativePath) {
+        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);
+        if (separatorIndex != -1) {
+            String newPath = path.substring(0, separatorIndex);
+            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {
+                newPath += FOLDER_SEPARATOR;
+            }
+            return newPath + relativePath;
+        } else {
+            return relativePath;
+        }
+    }
+
+    /**
+     * Normalize the path by suppressing sequences like "path/.." and inner
+     * simple dots.
+     * <p>
+     * The result is convenient for path comparison. For other uses, notice that
+     * Windows separators ("\") are replaced by simple slashes.
+     *
+     * @param path the original path
+     * @return the normalized path
+     */
+    public static String cleanPath(String path) {
+        if (path == null) {
+            return null;
+        }
+        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);
+
+		// Strip prefix from path to analyze, to not treat it as part of the
+        // first path element. This is necessary to correctly parse paths like
+        // "file:core/../core/io/Resource.class", where the ".." should just
+        // strip the first "core" directory while keeping the "file:" prefix.
+        int prefixIndex = pathToUse.indexOf(":");
+        String prefix = "";
+        if (prefixIndex != -1) {
+            prefix = pathToUse.substring(0, prefixIndex + 1);
+            if (prefix.contains("/")) {
+                prefix = "";
+            } else {
+                pathToUse = pathToUse.substring(prefixIndex + 1);
+            }
+        }
+        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {
+            prefix = prefix + FOLDER_SEPARATOR;
+            pathToUse = pathToUse.substring(1);
+        }
+
+        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);
+        List<String> pathElements = new LinkedList<>();
+        int tops = 0;
+
+        for (int i = pathArray.length - 1; i >= 0; i--) {
+            String element = pathArray[i];
+            if (null != element) switch (element) {
+                case CURRENT_PATH:
+                    break;
+                case TOP_PATH:
+                    // Registering top path found.
+                    tops++;
+                    break;
+                default:
+                    if (tops > 0) {
+                        // Merging path element with element corresponding to top path.
+                        tops--;
+                    } else {
+                        // Normal path element found.
+                        pathElements.add(0, element);
+                    }   break;
+            }
+        }
+
+        // Remaining top paths need to be retained.
+        for (int i = 0; i < tops; i++) {
+            pathElements.add(0, TOP_PATH);
+        }
+
+        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);
+    }
+
+    /**
+     * Compare two paths after normalization of them.
+     *
+     * @param path1 first path for comparison
+     * @param path2 second path for comparison
+     * @return whether the two paths are equivalent after normalization
+     */
+    public static boolean pathEquals(String path1, String path2) {
+        return cleanPath(path1).equals(cleanPath(path2));
+    }
+
+    /**
+     * Parse the given {@code localeString} value into a {@link Locale}.
+     * <p>
+     * This is the inverse operation of
+     * {@link Locale#toString Locale's toString}.
+     *
+     * @param localeString the locale {@code String}, following {@code Locale's}
+     * {@code toString()} format ("en", "en_UK", etc); also accepts spaces as
+     * separators, as an alternative to underscores
+     * @return a corresponding {@code Locale} instance
+     * @throws IllegalArgumentException in case of an invalid locale
+     * specification
+     */
+    public static Locale parseLocaleString(String localeString) {
+        String[] parts = tokenizeToStringArray(localeString, "_ ", false, false);
+        String language = (parts.length > 0 ? parts[0] : "");
+        String country = (parts.length > 1 ? parts[1] : "");
+        validateLocalePart(language);
+        validateLocalePart(country);
+        String variant = "";
+        if (parts.length > 2) {
+			// There is definitely a variant, and it is everything after the country
+            // code sans the separator between the country code and the variant.
+            int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length();
+            // Strip off any leading '_' and whitespace, what's left is the variant.
+            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));
+            if (variant.startsWith("_")) {
+                variant = trimLeadingCharacter(variant, '_');
+            }
+        }
+        return (language.length() > 0 ? new Locale(language, country, variant) : null);
+    }
+
+    private static void validateLocalePart(String localePart) {
+        for (int i = 0; i < localePart.length(); i++) {
+            char ch = localePart.charAt(i);
+            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {
+                throw new IllegalArgumentException(
+                        "Locale part \"" + localePart + "\" contains invalid characters");
+            }
+        }
+    }
+
+    /**
+     * Determine the RFC 3066 compliant language tag, as used for the HTTP
+     * "Accept-Language" header.
+     *
+     * @param locale the Locale to transform to a language tag
+     * @return the RFC 3066 compliant language tag as {@code String}
+     */
+    public static String toLanguageTag(Locale locale) {
+        return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "");
+    }
+
+    /**
+     * Parse the given {@code timeZoneString} value into a {@link TimeZone}.
+     *
+     * @param timeZoneString the time zone {@code String}, following
+     * {@link TimeZone#getTimeZone(String)} but throwing
+     * {@link IllegalArgumentException} in case of an invalid time zone
+     * specification
+     * @return a corresponding {@link TimeZone} instance
+     * @throws IllegalArgumentException in case of an invalid time zone
+     * specification
+     */
+    public static TimeZone parseTimeZoneString(String timeZoneString) {
+        TimeZone timeZone = TimeZone.getTimeZone(timeZoneString);
+        if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {
+            // We don't want that GMT fallback...
+            throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'");
+        }
+        return timeZone;
+    }
+
+	//---------------------------------------------------------------------
+    // Convenience methods for working with String arrays
+    //---------------------------------------------------------------------
+    /**
+     * Append the given {@code String} to the given {@code String} array,
+     * returning a new array consisting of the input array contents plus the
+     * given {@code String}.
+     *
+     * @param array the array to append to (can be {@code null})
+     * @param str the {@code String} to append
+     * @return the new array (never {@code null})
+     */
+    public static String[] addStringToArray(String[] array, String str) {
+        if (ObjectUtils.isEmpty(array)) {
+            return new String[]{str};
+        }
+        String[] newArr = new String[array.length + 1];
+        System.arraycopy(array, 0, newArr, 0, array.length);
+        newArr[array.length] = str;
+        return newArr;
+    }
+
+    /**
+     * Concatenate the given {@code String} arrays into one, with overlapping
+     * array elements included twice.
+     * <p>
+     * The order of elements in the original arrays is preserved.
+     *
+     * @param array1 the first array (can be {@code null})
+     * @param array2 the second array (can be {@code null})
+     * @return the new array ({@code null} if both given arrays were
+     * {@code null})
+     */
+    public static String[] concatenateStringArrays(String[] array1, String[] array2) {
+        if (ObjectUtils.isEmpty(array1)) {
+            return array2;
+        }
+        if (ObjectUtils.isEmpty(array2)) {
+            return array1;
+        }
+        String[] newArr = new String[array1.length + array2.length];
+        System.arraycopy(array1, 0, newArr, 0, array1.length);
+        System.arraycopy(array2, 0, newArr, array1.length, array2.length);
+        return newArr;
+    }
+
+    /**
+     * Merge the given {@code String} arrays into one, with overlapping array
+     * elements only included once.
+     * <p>
+     * The order of elements in the original arrays is preserved (with the
+     * exception of overlapping elements, which are only included on their first
+     * occurrence).
+     *
+     * @param array1 the first array (can be {@code null})
+     * @param array2 the second array (can be {@code null})
+     * @return the new array ({@code null} if both given arrays were
+     * {@code null})
+     */
+    public static String[] mergeStringArrays(String[] array1, String[] array2) {
+        if (ObjectUtils.isEmpty(array1)) {
+            return array2;
+        }
+        if (ObjectUtils.isEmpty(array2)) {
+            return array1;
+        }
+        List<String> result = new ArrayList<>();
+        result.addAll(Arrays.asList(array1));
+        for (String str : array2) {
+            if (!result.contains(str)) {
+                result.add(str);
+            }
+        }
+        return toStringArray(result);
+    }
+
+    /**
+     * Turn given source {@code String} array into sorted array.
+     *
+     * @param array the source array
+     * @return the sorted array (never {@code null})
+     */
+    public static String[] sortStringArray(String[] array) {
+        if (ObjectUtils.isEmpty(array)) {
+            return new String[0];
+        }
+        Arrays.sort(array);
+        return array;
+    }
+
+    /**
+     * Copy the given {@code Collection} into a {@code String} array.
+     * <p>
+     * The {@code Collection} must contain {@code String} elements only.
+     *
+     * @param collection the {@code Collection} to copy
+     * @return the {@code String} array ({@code null} if the supplied
+     * {@code Collection} was {@code null})
+     */
+    public static String[] toStringArray(Collection<String> collection) {
+        if (collection == null) {
+            return null;
+        }
+        return collection.toArray(new String[collection.size()]);
+    }
+
+    /**
+     * Copy the given Enumeration into a {@code String} array. The Enumeration
+     * must contain {@code String} elements only.
+     *
+     * @param enumeration the Enumeration to copy
+     * @return the {@code String} array ({@code null} if the passed-in
+     * Enumeration was {@code null})
+     */
+    public static String[] toStringArray(Enumeration<String> enumeration) {
+        if (enumeration == null) {
+            return null;
+        }
+        List<String> list = Collections.list(enumeration);
+        return list.toArray(new String[list.size()]);
+    }
+
+    /**
+     * Trim the elements of the given {@code String} array, calling
+     * {@code String.trim()} on each of them.
+     *
+     * @param array the original {@code String} array
+     * @return the resulting array (of the same size) with trimmed elements
+     */
+    public static String[] trimArrayElements(String[] array) {
+        if (ObjectUtils.isEmpty(array)) {
+            return new String[0];
+        }
+        String[] result = new String[array.length];
+        for (int i = 0; i < array.length; i++) {
+            String element = array[i];
+            result[i] = (element != null ? element.trim() : null);
+        }
+        return result;
+    }
+
+    /**
+     * Remove duplicate strings from the given array.
+     * <p>
+     * As of 4.2, it preserves the original order, as it uses a
+     * {@link LinkedHashSet}.
+     *
+     * @param array the {@code String} array
+     * @return an array without duplicates, in natural sort order
+     */
+    public static String[] removeDuplicateStrings(String[] array) {
+        if (ObjectUtils.isEmpty(array)) {
+            return array;
+        }
+        Set<String> set = new LinkedHashSet<>();
+        set.addAll(Arrays.asList(array));
+        return toStringArray(set);
+    }
+
+    /**
+     * Split a {@code String} at the first occurrence of the delimiter. Does not
+     * include the delimiter in the result.
+     *
+     * @param toSplit the string to split
+     * @param delimiter to split the string up with
+     * @return a two element array with index 0 being before the delimiter, and
+     * index 1 being after the delimiter (neither element includes the
+     * delimiter); or {@code null} if the delimiter wasn't found in the given
+     * input {@code String}
+     */
+    public static String[] split(String toSplit, String delimiter) {
+        if (!hasLength(toSplit) || !hasLength(delimiter)) {
+            return null;
+        }
+        int offset = toSplit.indexOf(delimiter);
+        if (offset < 0) {
+            return null;
+        }
+        String beforeDelimiter = toSplit.substring(0, offset);
+        String afterDelimiter = toSplit.substring(offset + delimiter.length());
+        return new String[]{beforeDelimiter, afterDelimiter};
+    }
+
+    /**
+     * Take an array of strings and split each element based on the given
+     * delimiter. A {@code Properties} instance is then generated, with the left
+     * of the delimiter providing the key, and the right of the delimiter
+     * providing the value.
+     * <p>
+     * Will trim both the key and value before adding them to the
+     * {@code Properties} instance.
+     *
+     * @param array the array to process
+     * @param delimiter to split each element using (typically the equals
+     * symbol)
+     * @return a {@code Properties} instance representing the array contents, or
+     * {@code null} if the array to process was {@code null} or empty
+     */
+    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {
+        return splitArrayElementsIntoProperties(array, delimiter, null);
+    }
+
+    /**
+     * Take an array of strings and split each element based on the given
+     * delimiter. A {@code Properties} instance is then generated, with the left
+     * of the delimiter providing the key, and the right of the delimiter
+     * providing the value.
+     * <p>
+     * Will trim both the key and value before adding them to the
+     * {@code Properties} instance.
+     *
+     * @param array the array to process
+     * @param delimiter to split each element using (typically the equals
+     * symbol)
+     * @param charsToDelete one or more characters to remove from each element
+     * prior to attempting the split operation (typically the quotation mark
+     * symbol), or {@code null} if no removal should occur
+     * @return a {@code Properties} instance representing the array contents, or
+     * {@code null} if the array to process was {@code null} or empty
+     */
+    public static Properties splitArrayElementsIntoProperties(
+            String[] array, String delimiter, String charsToDelete) {
+
+        if (ObjectUtils.isEmpty(array)) {
+            return null;
+        }
+        Properties result = new Properties();
+        for (String element : array) {
+            if (charsToDelete != null) {
+                element = deleteAny(element, charsToDelete);
+            }
+            String[] splittedElement = split(element, delimiter);
+            if (splittedElement == null) {
+                continue;
+            }
+            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());
+        }
+        return result;
+    }
+
+    /**
+     * Tokenize the given {@code String} into a {@code String} array via a
+     * {@link StringTokenizer}.
+     * <p>
+     * Trims tokens and omits empty tokens.
+     * <p>
+     * The given {@code delimiters} string can consist of any number of
+     * delimiter characters. Each of those characters can be used to separate
+     * tokens. A delimiter is always a single character; for multi-character
+     * delimiters, consider using {@link #delimitedListToStringArray}.
+     *
+     * @param str the {@code String} to tokenize
+     * @param delimiters the delimiter characters, assembled as a {@code String}
+     * (each of the characters is individually considered as a delimiter)
+     * @return an array of the tokens
+     * @see java.util.StringTokenizer
+     * @see String#trim()
+     * @see #delimitedListToStringArray
+     */
+    public static String[] tokenizeToStringArray(String str, String delimiters) {
+        return tokenizeToStringArray(str, delimiters, true, true);
+    }
+
+    /**
+     * Tokenize the given {@code String} into a {@code String} array via a
+     * {@link StringTokenizer}.
+     * <p>
+     * The given {@code delimiters} string can consist of any number of
+     * delimiter characters. Each of those characters can be used to separate
+     * tokens. A delimiter is always a single character; for multi-character
+     * delimiters, consider using {@link #delimitedListToStringArray}.
+     *
+     * @param str the {@code String} to tokenize
+     * @param delimiters the delimiter characters, assembled as a {@code String}
+     * (each of the characters is individually considered as a delimiter)
+     * @param trimTokens trim the tokens via {@link String#trim()}
+     * @param ignoreEmptyTokens omit empty tokens from the result array (only
+     * applies to tokens that are empty after trimming; StringTokenizer will not
+     * consider subsequent delimiters as token in the first place).
+     * @return an array of the tokens ({@code null} if the input {@code String}
+     * was {@code null})
+     * @see java.util.StringTokenizer
+     * @see String#trim()
+     * @see #delimitedListToStringArray
+     */
+    public static String[] tokenizeToStringArray(
+            String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {
+
+        if (str == null) {
+            return null;
+        }
+        StringTokenizer st = new StringTokenizer(str, delimiters);
+        List<String> tokens = new ArrayList<>();
+        while (st.hasMoreTokens()) {
+            String token = st.nextToken();
+            if (trimTokens) {
+                token = token.trim();
+            }
+            if (!ignoreEmptyTokens || token.length() > 0) {
+                tokens.add(token);
+            }
+        }
+        return toStringArray(tokens);
+    }
+
+    /**
+     * Take a {@code String} that is a delimited list and convert it into a
+     * {@code String} array.
+     * <p>
+     * A single {@code delimiter} may consist of more than one character, but it
+     * will still be considered as a single delimiter string, rather than as
+     * bunch of potential delimiter characters, in contrast to
+     * {@link #tokenizeToStringArray}.
+     *
+     * @param str the input {@code String}
+     * @param delimiter the delimiter between elements (this is a single
+     * delimiter, rather than a bunch individual delimiter characters)
+     * @return an array of the tokens in the list
+     * @see #tokenizeToStringArray
+     */
+    public static String[] delimitedListToStringArray(String str, String delimiter) {
+        return delimitedListToStringArray(str, delimiter, null);
+    }
+
+    /**
+     * Take a {@code String} that is a delimited list and convert it into a
+     * {@code String} array.
+     * <p>
+     * A single {@code delimiter} may consist of more than one character, but it
+     * will still be considered as a single delimiter string, rather than as
+     * bunch of potential delimiter characters, in contrast to
+     * {@link #tokenizeToStringArray}.
+     *
+     * @param str the input {@code String}
+     * @param delimiter the delimiter between elements (this is a single
+     * delimiter, rather than a bunch individual delimiter characters)
+     * @param charsToDelete a set of characters to delete; useful for deleting
+     * unwanted line breaks: e.g. "\r\n\f" will delete all new lines and line
+     * feeds in a {@code String}
+     * @return an array of the tokens in the list
+     * @see #tokenizeToStringArray
+     */
+    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {
+        if (str == null) {
+            return new String[0];
+        }
+        if (delimiter == null) {
+            return new String[]{str};
+        }
+        List<String> result = new ArrayList<>();
+        if ("".equals(delimiter)) {
+            for (int i = 0; i < str.length(); i++) {
+                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));
+            }
+        } else {
+            int pos = 0;
+            int delPos;
+            while ((delPos = str.indexOf(delimiter, pos)) != -1) {
+                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));
+                pos = delPos + delimiter.length();
+            }
+            if (str.length() > 0 && pos <= str.length()) {
+                // Add rest of String, but not in case of empty input.
+                result.add(deleteAny(str.substring(pos), charsToDelete));
+            }
+        }
+        return toStringArray(result);
+    }
+
+    /**
+     * Convert a comma delimited list (e.g., a row from a CSV file) into an
+     * array of strings.
+     *
+     * @param str the input {@code String}
+     * @return an array of strings, or the empty array in case of empty input
+     */
+    public static String[] commaDelimitedListToStringArray(String str) {
+        return delimitedListToStringArray(str, ",");
+    }
+
+    /**
+     * Convert a comma delimited list (e.g., a row from a CSV file) into a set.
+     * <p>
+     * Note that this will suppress duplicates, and as of 4.2, the elements in
+     * the returned set will preserve the original order in a
+     * {@link LinkedHashSet}.
+     *
+     * @param str the input {@code String}
+     * @return a set of {@code String} entries in the list
+     * @see #removeDuplicateStrings(String[])
+     */
+    public static Set<String> commaDelimitedListToSet(String str) {
+        Set<String> set = new LinkedHashSet<>();
+        String[] tokens = commaDelimitedListToStringArray(str);
+        set.addAll(Arrays.asList(tokens));
+        return set;
+    }
+
+    /**
+     * Convert a {@link Collection} to a delimited {@code String} (e.g. CSV).
+     * <p>
+     * Useful for {@code toString()} implementations.
+     *
+     * @param coll the {@code Collection} to convert
+     * @param delim the delimiter to use (typically a ",")
+     * @param prefix the {@code String} to start each element with
+     * @param suffix the {@code String} to end each element with
+     * @return the delimited {@code String}
+     */
+    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {
+        if (CollectionUtils.isEmpty(coll)) {
+            return "";
+        }
+        StringBuilder sb = new StringBuilder();
+        Iterator<?> it = coll.iterator();
+        while (it.hasNext()) {
+            sb.append(prefix).append(it.next()).append(suffix);
+            if (it.hasNext()) {
+                sb.append(delim);
+            }
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Convert a {@code Collection} into a delimited {@code String} (e.g. CSV).
+     * <p>
+     * Useful for {@code toString()} implementations.
+     *
+     * @param coll the {@code Collection} to convert
+     * @param delim the delimiter to use (typically a ",")
+     * @return the delimited {@code String}
+     */
+    public static String collectionToDelimitedString(Collection<?> coll, String delim) {
+        return collectionToDelimitedString(coll, delim, "", "");
+    }
+
+    /**
+     * Convert a {@code Collection} into a delimited {@code String} (e.g., CSV).
+     * <p>
+     * Useful for {@code toString()} implementations.
+     *
+     * @param coll the {@code Collection} to convert
+     * @return the delimited {@code String}
+     */
+    public static String collectionToCommaDelimitedString(Collection<?> coll) {
+        return collectionToDelimitedString(coll, ",");
+    }
+
+    /**
+     * Convert a {@code String} array into a delimited {@code String} (e.g.
+     * CSV).
+     * <p>
+     * Useful for {@code toString()} implementations.
+     *
+     * @param arr the array to display
+     * @param delim the delimiter to use (typically a ",")
+     * @return the delimited {@code String}
+     */
+    public static String arrayToDelimitedString(Object[] arr, String delim) {
+        if (ObjectUtils.isEmpty(arr)) {
+            return "";
+        }
+        if (arr.length == 1) {
+            return ObjectUtils.nullSafeToString(arr[0]);
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < arr.length; i++) {
+            if (i > 0) {
+                sb.append(delim);
+            }
+            sb.append(arr[i]);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Convert a {@code String} array into a comma delimited {@code String}
+     * (i.e., CSV).
+     * <p>
+     * Useful for {@code toString()} implementations.
+     *
+     * @param arr the array to display
+     * @return the delimited {@code String}
+     */
+    public static String arrayToCommaDelimitedString(Object[] arr) {
+        return arrayToDelimitedString(arr, ",");
+    }
+    
+    public static int levenshtein(CharSequence lhs, CharSequence rhs) {      
+        int[][] distance = new int[lhs.length() + 1][rhs.length() + 1];        
+                                                                                 
+        for (int i = 0; i <= lhs.length(); i++) {                                 
+            distance[i][0] = i;                   
+        }
+        
+        for (int j = 1; j <= rhs.length(); j++) {        
+            distance[0][j] = j;   
+        }                                                                       
+                                                   
+        for (int i = 1; i <= lhs.length(); i++) {
+            for (int j = 1; j <= rhs.length(); j++){                 
+                distance[i][j] = Math.min(
+                    Math.min(
+                            distance[i - 1][j] + 1,
+                            distance[i][j - 1] + 1
+                    ) , distance[i - 1][j - 1] + ((lhs.charAt(i - 1) == rhs.charAt(j - 1)) ? 0 : 1)
+                );
+            }  
+        }     
+        
+        return distance[lhs.length()][rhs.length()];                           
+    }
+    
+    public static String findAlternative(String nonExistant, Collection<String> candidates){
+        return findAlternative(nonExistant, candidates, 3);
+    }
+    
+    public static String findAlternative(String nonExistant, Collection<String> candidates, int force){
+        String alternative = null;
+        Integer shortest = null;
+        for (String name : candidates) {
+            if(name.contains(nonExistant)) {
+                // there is a partial match return it !
+                return name;
+            }
+            
+            int lev = levenshtein(nonExistant, name);
+            
+            if(lev <= nonExistant.length() / force && (alternative == null || lev < shortest)) {
+                alternative = name;
+                shortest = lev;
+            }
+            
+        }
+        
+        return alternative;
+    }
+}
diff --git a/src/main/java/component/utils/Assert.java b/src/main/java/component/utils/Assert.java
new file mode 100644
index 0000000..336b74e
--- /dev/null
+++ b/src/main/java/component/utils/Assert.java
@@ -0,0 +1,405 @@
+package component.utils;
+
+import java.util.Collection;
+import java.util.Map;
+
+public abstract class Assert {
+
+    /**
+     * Assert a boolean expression, throwing {@code IllegalArgumentException} if
+     * the test result is {@code false}.
+     * <pre class="code">Assert.isTrue(i &gt; 0, "The value must be greater than
+     * zero");</pre>
+     *
+     * @param expression a boolean expression
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if expression is {@code false}
+     */
+    public static void isTrue(boolean expression, String message) {
+        if (!expression) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert a boolean expression, throwing {@code IllegalArgumentException} if
+     * the test result is {@code false}.
+     * <pre class="code">Assert.isTrue(i &gt; 0);</pre>
+     *
+     * @param expression a boolean expression
+     * @throws IllegalArgumentException if expression is {@code false}
+     */
+    public static void isTrue(boolean expression) {
+        isTrue(expression, "[Assertion failed] - this expression must be true");
+    }
+
+    /**
+     * Assert that an object is {@code null} .
+     * <pre class="code">Assert.isNull(value, "The value must be null");</pre>
+     *
+     * @param object the object to check
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the object is not {@code null}
+     */
+    public static void isNull(Object object, String message) {
+        if (object != null) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that an object is {@code null} .
+     * <pre class="code">Assert.isNull(value);</pre>
+     *
+     * @param object the object to check
+     * @throws IllegalArgumentException if the object is not {@code null}
+     */
+    public static void isNull(Object object) {
+        isNull(object, "[Assertion failed] - the object argument must be null");
+    }
+
+    /**
+     * Assert that an object is not {@code null} .
+     * <pre class="code">Assert.notNull(clazz, "The class must not be
+     * null");</pre>
+     *
+     * @param object the object to check
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the object is {@code null}
+     */
+    public static void notNull(Object object, String message) {
+        if (object == null) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that an object is not {@code null} .
+     * <pre class="code">Assert.notNull(clazz);</pre>
+     *
+     * @param object the object to check
+     * @throws IllegalArgumentException if the object is {@code null}
+     */
+    public static void notNull(Object object) {
+        notNull(object, "[Assertion failed] - this argument is required; it must not be null");
+    }
+
+    /**
+     * Assert that the given String is not empty; that is, it must not be
+     * {@code null} and not the empty String.
+     * <pre class="code">Assert.hasLength(name, "Name must not be empty");</pre>
+     *
+     * @param text the String to check
+     * @param message the exception message to use if the assertion fails
+     * @see StringUtils#hasLength
+     * @throws IllegalArgumentException if the text is empty
+     */
+    public static void hasLength(String text, String message) {
+        if (!StringUtils.hasLength(text)) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that the given String is not empty; that is, it must not be
+     * {@code null} and not the empty String.
+     * <pre class="code">Assert.hasLength(name);</pre>
+     *
+     * @param text the String to check
+     * @see StringUtils#hasLength
+     * @throws IllegalArgumentException if the text is empty
+     */
+    public static void hasLength(String text) {
+        String msg = "[Assertion failed] - this String argument must have length; it must not be null or empty";
+        hasLength(text, msg);
+    }
+
+    /**
+     * Assert that the given String has valid text content; that is, it must not
+     * be {@code null} and must contain at least one non-whitespace character.
+     * <pre class="code">Assert.hasText(name, "'name' must not be empty");</pre>
+     *
+     * @param text the String to check
+     * @param message the exception message to use if the assertion fails
+     * @see StringUtils#hasText
+     * @throws IllegalArgumentException if the text does not contain valid text
+     * content
+     */
+    public static void hasText(String text, String message) {
+        if (!StringUtils.hasText(text)) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that the given String has valid text content; that is, it must not
+     * be {@code null} and must contain at least one non-whitespace character.
+     * <pre class="code">Assert.hasText(name, "'name' must not be empty");</pre>
+     *
+     * @param text the String to check
+     * @see StringUtils#hasText
+     * @throws IllegalArgumentException if the text does not contain valid text
+     * content
+     */
+    public static void hasText(String text) {
+        hasText(text,
+                "[Assertion failed] - this String argument must have text; it must not be null, empty, or blank");
+    }
+
+    /**
+     * Assert that the given text does not contain the given substring.
+     * <pre class="code">Assert.doesNotContain(name, "rod", "Name must not
+     * contain 'rod'");</pre>
+     *
+     * @param textToSearch the text to search
+     * @param substring the substring to find within the text
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the text contains the substring
+     */
+    public static void doesNotContain(String textToSearch, String substring, String message) {
+        if (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring)
+                && textToSearch.contains(substring)) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that the given text does not contain the given substring.
+     * <pre class="code">Assert.doesNotContain(name, "rod");</pre>
+     *
+     * @param textToSearch the text to search
+     * @param substring the substring to find within the text
+     * @throws IllegalArgumentException if the text contains the substring
+     */
+    public static void doesNotContain(String textToSearch, String substring) {
+        doesNotContain(textToSearch, substring,
+                "[Assertion failed] - this String argument must not contain the substring [" + substring + "]");
+    }
+
+    /**
+     * Assert that an array has elements; that is, it must not be {@code null}
+     * and must have at least one element.
+     * <pre class="code">Assert.notEmpty(array, "The array must have
+     * elements");</pre>
+     *
+     * @param array the array to check
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the object array is {@code null} or
+     * has no elements
+     */
+    public static void notEmpty(Object[] array, String message) {
+        if (ObjectUtils.isEmpty(array)) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that an array has elements; that is, it must not be {@code null}
+     * and must have at least one element.
+     * <pre class="code">Assert.notEmpty(array);</pre>
+     *
+     * @param array the array to check
+     * @throws IllegalArgumentException if the object array is {@code null} or
+     * has no elements
+     */
+    public static void notEmpty(Object[] array) {
+        notEmpty(array, "[Assertion failed] - this array must not be empty: it must contain at least 1 element");
+    }
+
+    /**
+     * Assert that an array has no null elements. Note: Does not complain if the
+     * array is empty!
+     * <pre class="code">Assert.noNullElements(array, "The array must have
+     * non-null elements");</pre>
+     *
+     * @param array the array to check
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the object array contains a
+     * {@code null} element
+     */
+    public static void noNullElements(Object[] array, String message) {
+        if (array != null) {
+            for (Object element : array) {
+                if (element == null) {
+                    throw new IllegalArgumentException(message);
+                }
+            }
+        }
+    }
+
+    /**
+     * Assert that an array has no null elements. Note: Does not complain if the
+     * array is empty!
+     * <pre class="code">Assert.noNullElements(array);</pre>
+     *
+     * @param array the array to check
+     * @throws IllegalArgumentException if the object array contains a
+     * {@code null} element
+     */
+    public static void noNullElements(Object[] array) {
+        noNullElements(array, "[Assertion failed] - this array must not contain any null elements");
+    }
+
+    /**
+     * Assert that a collection has elements; that is, it must not be
+     * {@code null} and must have at least one element.
+     * <pre class="code">Assert.notEmpty(collection, "Collection must have
+     * elements");</pre>
+     *
+     * @param collection the collection to check
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the collection is {@code null} or has
+     * no elements
+     */
+    public static void notEmpty(Collection<?> collection, String message) {
+        if (CollectionUtils.isEmpty(collection)) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that a collection has elements; that is, it must not be
+     * {@code null} and must have at least one element.
+     * <pre class="code">Assert.notEmpty(collection, "Collection must have
+     * elements");</pre>
+     *
+     * @param collection the collection to check
+     * @throws IllegalArgumentException if the collection is {@code null} or has
+     * no elements
+     */
+    public static void notEmpty(Collection<?> collection) {
+        notEmpty(collection,
+                "[Assertion failed] - this collection must not be empty: it must contain at least 1 element");
+    }
+
+    /**
+     * Assert that a Map has entries; that is, it must not be {@code null} and
+     * must have at least one entry.
+     * <pre class="code">Assert.notEmpty(map, "Map must have entries");</pre>
+     *
+     * @param map the map to check
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalArgumentException if the map is {@code null} or has no
+     * entries
+     */
+    public static void notEmpty(Map<?, ?> map, String message) {
+        if (CollectionUtils.isEmpty(map)) {
+            throw new IllegalArgumentException(message);
+        }
+    }
+
+    /**
+     * Assert that a Map has entries; that is, it must not be {@code null} and
+     * must have at least one entry.
+     * <pre class="code">Assert.notEmpty(map);</pre>
+     *
+     * @param map the map to check
+     * @throws IllegalArgumentException if the map is {@code null} or has no
+     * entries
+     */
+    public static void notEmpty(Map<?, ?> map) {
+        notEmpty(map, "[Assertion failed] - this map must not be empty; it must contain at least one entry");
+    }
+
+    /**
+     * Assert that the provided object is an instance of the provided class.
+     * <pre class="code">Assert.instanceOf(Foo.class, foo);</pre>
+     *
+     * @param clazz the required class
+     * @param obj the object to check
+     * @throws IllegalArgumentException if the object is not an instance of
+     * clazz
+     * @see Class#isInstance
+     */
+    public static void isInstanceOf(Class<?> clazz, Object obj) {
+        isInstanceOf(clazz, obj, "");
+    }
+
+    /**
+     * Assert that the provided object is an instance of the provided class.
+     * <pre class="code">Assert.instanceOf(Foo.class, foo);</pre>
+     *
+     * @param type the type to check against
+     * @param obj the object to check
+     * @param message a message which will be prepended to the message produced
+     * by the function itself, and which may be used to provide context. It
+     * should normally end in ":" or "." so that the generated message looks OK
+     * when appended to it.
+     * @throws IllegalArgumentException if the object is not an instance of
+     * clazz
+     * @see Class#isInstance
+     */
+    public static void isInstanceOf(Class<?> type, Object obj, String message) {
+        notNull(type, "Type to check against must not be null");
+        if (!type.isInstance(obj)) {
+            throw new IllegalArgumentException(
+                    (StringUtils.hasLength(message) ? message + " " : "")
+                    + "Object of class [" + (obj != null ? obj.getClass().getName() : "null")
+                    + "] must be an instance of " + type);
+        }
+    }
+
+    /**
+     * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.
+     * <pre class="code">Assert.isAssignable(Number.class, myClass);</pre>
+     *
+     * @param superType the super type to check
+     * @param subType the sub type to check
+     * @throws IllegalArgumentException if the classes are not assignable
+     */
+    public static void isAssignable(Class<?> superType, Class<?> subType) {
+        isAssignable(superType, subType, "");
+    }
+
+    /**
+     * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.
+     * <pre class="code">Assert.isAssignable(Number.class, myClass);</pre>
+     *
+     * @param superType the super type to check against
+     * @param subType the sub type to check
+     * @param message a message which will be prepended to the message produced
+     * by the function itself, and which may be used to provide context. It
+     * should normally end in ":" or "." so that the generated message looks OK
+     * when appended to it.
+     * @throws IllegalArgumentException if the classes are not assignable
+     */
+    public static void isAssignable(Class<?> superType, Class<?> subType, String message) {
+        notNull(superType, "Type to check against must not be null");
+        if (subType == null || !superType.isAssignableFrom(subType)) {
+            throw new IllegalArgumentException((StringUtils.hasLength(message) ? message + " " : "")
+                    + subType + " is not assignable to " + superType);
+        }
+    }
+
+    /**
+     * Assert a boolean expression, throwing {@code IllegalStateException} if
+     * the test result is {@code false}. Call isTrue if you wish to throw
+     * IllegalArgumentException on an assertion failure.
+     * <pre class="code">Assert.state(id == null, "The id property must not
+     * already be initialized");</pre>
+     *
+     * @param expression a boolean expression
+     * @param message the exception message to use if the assertion fails
+     * @throws IllegalStateException if expression is {@code false}
+     */
+    public static void state(boolean expression, String message) {
+        if (!expression) {
+            throw new IllegalStateException(message);
+        }
+    }
+
+    /**
+     * Assert a boolean expression, throwing {@link IllegalStateException} if
+     * the test result is {@code false}.
+     * <p>
+     * Call {@link #isTrue(boolean)} if you wish to throw
+     * {@link IllegalArgumentException} on an assertion failure.
+     * <pre class="code">Assert.state(id == null);</pre>
+     *
+     * @param expression a boolean expression
+     * @throws IllegalStateException if the supplied expression is {@code false}
+     */
+    public static void state(boolean expression) {
+        state(expression, "[Assertion failed] - this state invariant must be true");
+    }
+}
diff --git a/src/main/java/component/utils/ClassUtils.java b/src/main/java/component/utils/ClassUtils.java
new file mode 100644
index 0000000..efaf1b5
--- /dev/null
+++ b/src/main/java/component/utils/ClassUtils.java
@@ -0,0 +1,1313 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package component.utils;
+
+import java.beans.Introspector;
+import java.lang.reflect.Array;
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.Proxy;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.IdentityHashMap;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.Map;
+import java.util.Set;
+
+/**
+ *
+ * @author cdi305
+ */
+public abstract class ClassUtils {
+
+    /**
+     * Suffix for array class names: "[]"
+     */
+    public static final String ARRAY_SUFFIX = "[]";
+
+    /**
+     * Prefix for internal array class names: "["
+     */
+    private static final String INTERNAL_ARRAY_PREFIX = "[";
+
+    /**
+     * Prefix for internal non-primitive array class names: "[L"
+     */
+    private static final String NON_PRIMITIVE_ARRAY_PREFIX = "[L";
+
+    /**
+     * The package separator character '.'
+     */
+    private static final char PACKAGE_SEPARATOR = '.';
+
+    /**
+     * The path separator character '/'
+     */
+    private static final char PATH_SEPARATOR = '/';
+
+    /**
+     * The inner class separator character '$'
+     */
+    private static final char INNER_CLASS_SEPARATOR = '$';
+
+    /**
+     * The CGLIB class separator character "$$"
+     */
+    public static final String CGLIB_CLASS_SEPARATOR = "$$";
+
+    /**
+     * The ".class" file suffix
+     */
+    public static final String CLASS_FILE_SUFFIX = ".class";
+
+    /**
+     * Map with primitive wrapper type as key and corresponding primitive type
+     * as value, for example: Integer.class -> int.class.
+     */
+    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<>(8);
+
+    /**
+     * Map with primitive type as key and corresponding wrapper type as value,
+     * for example: int.class -> Integer.class.
+     */
+    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<>(8);
+
+    /**
+     * Map with primitive type name as key and corresponding primitive type as
+     * value, for example: "int" -> "int.class".
+     */
+    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<>(32);
+
+    /**
+     * Map with common "java.lang" class name as key and corresponding Class as
+     * value. Primarily for efficient deserialization of remote invocations.
+     */
+    private static final Map<String, Class<?>> commonClassCache = new HashMap<>(32);
+
+    static {
+        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);
+        primitiveWrapperTypeMap.put(Byte.class, byte.class);
+        primitiveWrapperTypeMap.put(Character.class, char.class);
+        primitiveWrapperTypeMap.put(Double.class, double.class);
+        primitiveWrapperTypeMap.put(Float.class, float.class);
+        primitiveWrapperTypeMap.put(Integer.class, int.class);
+        primitiveWrapperTypeMap.put(Long.class, long.class);
+        primitiveWrapperTypeMap.put(Short.class, short.class);
+
+        primitiveWrapperTypeMap.entrySet().stream().map((entry) -> {
+            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());
+            return entry;
+        }).forEach((entry) -> {
+            registerCommonClasses(entry.getKey());
+        });
+
+        Set<Class<?>> primitiveTypes = new HashSet<>(32);
+        primitiveTypes.addAll(primitiveWrapperTypeMap.values());
+        primitiveTypes.addAll(Arrays.asList(new Class<?>[]{
+            boolean[].class, byte[].class, char[].class, double[].class,
+            float[].class, int[].class, long[].class, short[].class}));
+        primitiveTypes.add(void.class);
+        
+        primitiveTypes.stream().forEach((primitiveType) -> {
+            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);
+        });
+
+        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class,
+                Float[].class, Integer[].class, Long[].class, Short[].class);
+        registerCommonClasses(Number.class, Number[].class, String.class, String[].class,
+                Object.class, Object[].class, Class.class, Class[].class);
+        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class,
+                Error.class, StackTraceElement.class, StackTraceElement[].class);
+    }
+
+    /**
+     * Register the given common classes with the ClassUtils cache.
+     */
+    private static void registerCommonClasses(Class<?>... commonClasses) {
+        for (Class<?> clazz : commonClasses) {
+            commonClassCache.put(clazz.getName(), clazz);
+        }
+    }
+
+    /**
+     * Return the default ClassLoader to use: typically the thread context
+     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils
+     * class will be used as fallback.
+     * <p>
+     * Call this method if you intend to use the thread context ClassLoader in a
+     * scenario where you clearly prefer a non-null ClassLoader reference: for
+     * example, for class path resource loading (but not necessarily for
+     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference
+     * as well).
+     *
+     * @return the default ClassLoader (only {@code null} if even the system
+     * ClassLoader isn't accessible)
+     * @see Thread#getContextClassLoader()
+     * @see ClassLoader#getSystemClassLoader()
+     */
+    public static ClassLoader getDefaultClassLoader() {
+        ClassLoader cl = null;
+        try {
+            cl = Thread.currentThread().getContextClassLoader();
+        } catch (Throwable ex) {
+            // Cannot access thread context ClassLoader - falling back...
+        }
+        if (cl == null) {
+            // No thread context class loader -> use class loader of this class.
+            cl = ClassUtils.class.getClassLoader();
+            if (cl == null) {
+                // getClassLoader() returning null indicates the bootstrap ClassLoader
+                try {
+                    cl = ClassLoader.getSystemClassLoader();
+                } catch (Throwable ex) {
+                    // Cannot access system ClassLoader - oh well, maybe the caller can live with null...
+                }
+            }
+        }
+        return cl;
+    }
+
+    /**
+     * Override the thread context ClassLoader with the environment's bean
+     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent
+     * to the thread context ClassLoader already.
+     *
+     * @param classLoaderToUse the actual ClassLoader to use for the thread
+     * context
+     * @return the original thread context ClassLoader, or {@code null} if not
+     * overridden
+     */
+    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {
+        Thread currentThread = Thread.currentThread();
+        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();
+        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {
+            currentThread.setContextClassLoader(classLoaderToUse);
+            return threadContextClassLoader;
+        } else {
+            return null;
+        }
+    }
+
+    /**
+     * Replacement for {@code Class.forName()} that also returns Class instances
+     * for primitives (e.g. "int") and array class names (e.g. "String[]").
+     * Furthermore, it is also capable of resolving inner class names in Java
+     * source style (e.g. "java.lang.Thread.State" instead of
+     * "java.lang.Thread$State").
+     *
+     * @param name the name of the Class
+     * @param classLoader the class loader to use (may be {@code null}, which
+     * indicates the default class loader)
+     * @return Class instance for the supplied name
+     * @throws ClassNotFoundException if the class was not found
+     * @throws LinkageError if the class file could not be loaded
+     * @see Class#forName(String, boolean, ClassLoader)
+     */
+    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {
+        Assert.notNull(name, "Name must not be null");
+
+        Class<?> clazz = resolvePrimitiveClassName(name);
+        if (clazz == null) {
+            clazz = commonClassCache.get(name);
+        }
+        if (clazz != null) {
+            return clazz;
+        }
+
+        // "java.lang.String[]" style arrays
+        if (name.endsWith(ARRAY_SUFFIX)) {
+            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());
+            Class<?> elementClass = forName(elementClassName, classLoader);
+            return Array.newInstance(elementClass, 0).getClass();
+        }
+
+        // "[Ljava.lang.String;" style arrays
+        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(";")) {
+            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);
+            Class<?> elementClass = forName(elementName, classLoader);
+            return Array.newInstance(elementClass, 0).getClass();
+        }
+
+        // "[[I" or "[[Ljava.lang.String;" style arrays
+        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {
+            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());
+            Class<?> elementClass = forName(elementName, classLoader);
+            return Array.newInstance(elementClass, 0).getClass();
+        }
+
+        ClassLoader clToUse = classLoader;
+        if (clToUse == null) {
+            clToUse = getDefaultClassLoader();
+        }
+        try {
+            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));
+        } catch (ClassNotFoundException ex) {
+            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);
+            if (lastDotIndex != -1) {
+                String innerClassName
+                        = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);
+                try {
+                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));
+                } catch (ClassNotFoundException ex2) {
+                    // Swallow - let original exception get through
+                }
+            }
+            throw ex;
+        }
+    }
+
+    /**
+     * Resolve the given class name into a Class instance. Supports primitives
+     * (like "int") and array class names (like "String[]").
+     * <p>
+     * This is effectively equivalent to the {@code forName} method with the
+     * same arguments, with the only difference being the exceptions thrown in
+     * case of class loading failure.
+     *
+     * @param className the name of the Class
+     * @param classLoader the class loader to use (may be {@code null}, which
+     * indicates the default class loader)
+     * @return Class instance for the supplied name
+     * @throws IllegalArgumentException if the class name was not resolvable
+     * (that is, the class could not be found or the class file could not be
+     * loaded)
+     * @see #forName(String, ClassLoader)
+     */
+    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {
+        try {
+            return forName(className, classLoader);
+        } catch (ClassNotFoundException ex) {
+            throw new IllegalArgumentException("Cannot find class [" + className + "]", ex);
+        } catch (LinkageError ex) {
+            throw new IllegalArgumentException(
+                    "Error loading class [" + className + "]: problem with class file or dependent class.", ex);
+        }
+    }
+
+    /**
+     * Resolve the given class name as primitive class, if appropriate,
+     * according to the JVM's naming rules for primitive classes.
+     * <p>
+     * Also supports the JVM's internal class names for primitive arrays. Does
+     * <i>not</i> support the "[]" suffix notation for primitive arrays; this is
+     * only supported by {@link #forName(String, ClassLoader)}.
+     *
+     * @param name the name of the potentially primitive class
+     * @return the primitive class, or {@code null} if the name does not denote
+     * a primitive class or primitive array class
+     */
+    public static Class<?> resolvePrimitiveClassName(String name) {
+        Class<?> result = null;
+		// Most class names will be quite long, considering that they
+        // SHOULD sit in a package, so a length check is worthwhile.
+        if (name != null && name.length() <= 8) {
+            // Could be a primitive - likely.
+            result = primitiveTypeNameMap.get(name);
+        }
+        return result;
+    }
+
+    /**
+     * Determine whether the {@link Class} identified by the supplied name is
+     * present and can be loaded. Will return {@code false} if either the class
+     * or one of its dependencies is not present or cannot be loaded.
+     *
+     * @param className the name of the class to check
+     * @param classLoader the class loader to use (may be {@code null}, which
+     * indicates the default class loader)
+     * @return whether the specified class is present
+     */
+    public static boolean isPresent(String className, ClassLoader classLoader) {
+        try {
+            forName(className, classLoader);
+            return true;
+        } catch (ClassNotFoundException | LinkageError ex) {
+            // Class or one of its dependencies is not present...
+            return false;
+        }
+    }
+
+    /**
+     * Return the user-defined class for the given instance: usually simply the
+     * class of the given instance, but the original class in case of a
+     * CGLIB-generated subclass.
+     *
+     * @param instance the instance to check
+     * @return the user-defined class
+     */
+    public static Class<?> getUserClass(Object instance) {
+        Assert.notNull(instance, "Instance must not be null");
+        return getUserClass(instance.getClass());
+    }
+
+    /**
+     * Return the user-defined class for the given class: usually simply the
+     * given class, but the original class in case of a CGLIB-generated
+     * subclass.
+     *
+     * @param clazz the class to check
+     * @return the user-defined class
+     */
+    public static Class<?> getUserClass(Class<?> clazz) {
+        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {
+            Class<?> superclass = clazz.getSuperclass();
+            if (superclass != null && Object.class != superclass) {
+                return superclass;
+            }
+        }
+        return clazz;
+    }
+
+    /**
+     * Check whether the given class is cache-safe in the given context, i.e.
+     * whether it is loaded by the given ClassLoader or a parent of it.
+     *
+     * @param clazz the class to analyze
+     * @param classLoader the ClassLoader to potentially cache metadata in
+     * @return 
+     */
+    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {
+        Assert.notNull(clazz, "Class must not be null");
+        try {
+            ClassLoader target = clazz.getClassLoader();
+            if (target == null) {
+                return true;
+            }
+            ClassLoader cur = classLoader;
+            if (cur == target) {
+                return true;
+            }
+            while (cur != null) {
+                cur = cur.getParent();
+                if (cur == target) {
+                    return true;
+                }
+            }
+            return false;
+        } catch (SecurityException ex) {
+            // Probably from the system ClassLoader - let's consider it safe.
+            return true;
+        }
+    }
+
+    /**
+     * Get the class name without the qualified package name.
+     *
+     * @param className the className to get the short name for
+     * @return the class name of the class without the package name
+     * @throws IllegalArgumentException if the className is empty
+     */
+    public static String getShortName(String className) {
+        Assert.hasLength(className, "Class name must not be empty");
+        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);
+        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);
+        if (nameEndIndex == -1) {
+            nameEndIndex = className.length();
+        }
+        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);
+        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);
+        return shortName;
+    }
+
+    /**
+     * Get the class name without the qualified package name.
+     *
+     * @param clazz the class to get the short name for
+     * @return the class name of the class without the package name
+     */
+    public static String getShortName(Class<?> clazz) {
+        return getShortName(getQualifiedName(clazz));
+    }
+
+    /**
+     * Return the short string name of a Java class in uncapitalized JavaBeans
+     * property format. Strips the outer class name in case of an inner class.
+     *
+     * @param clazz the class
+     * @return the short name rendered in a standard JavaBeans property format
+     * @see java.beans.Introspector#decapitalize(String)
+     */
+    public static String getShortNameAsProperty(Class<?> clazz) {
+        String shortName = getShortName(clazz);
+        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);
+        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);
+        return Introspector.decapitalize(shortName);
+    }
+
+    /**
+     * Determine the name of the class file, relative to the containing package:
+     * e.g. "String.class"
+     *
+     * @param clazz the class
+     * @return the file name of the ".class" file
+     */
+    public static String getClassFileName(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        String className = clazz.getName();
+        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);
+        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;
+    }
+
+    /**
+     * Determine the name of the package of the given class, e.g. "java.lang"
+     * for the {@code java.lang.String} class.
+     *
+     * @param clazz the class
+     * @return the package name, or the empty String if the class is defined in
+     * the default package
+     */
+    public static String getPackageName(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        return getPackageName(clazz.getName());
+    }
+
+    /**
+     * Determine the name of the package of the given fully-qualified class
+     * name, e.g. "java.lang" for the {@code java.lang.String} class name.
+     *
+     * @param fqClassName the fully-qualified class name
+     * @return the package name, or the empty String if the class is defined in
+     * the default package
+     */
+    public static String getPackageName(String fqClassName) {
+        Assert.notNull(fqClassName, "Class name must not be null");
+        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);
+        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : "");
+    }
+
+    /**
+     * Return the qualified name of the given class: usually simply the class
+     * name, but component type class name + "[]" for arrays.
+     *
+     * @param clazz the class
+     * @return the qualified name of the class
+     */
+    public static String getQualifiedName(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        if (clazz.isArray()) {
+            return getQualifiedNameForArray(clazz);
+        } else {
+            return clazz.getName();
+        }
+    }
+
+    /**
+     * Build a nice qualified name for an array: component type class name +
+     * "[]".
+     *
+     * @param clazz the array class
+     * @return a qualified name for the array class
+     */
+    private static String getQualifiedNameForArray(Class<?> clazz) {
+        StringBuilder result = new StringBuilder();
+        while (clazz.isArray()) {
+            clazz = clazz.getComponentType();
+            result.append(ARRAY_SUFFIX);
+        }
+        result.insert(0, clazz.getName());
+        return result.toString();
+    }
+
+    /**
+     * Return the qualified name of the given method, consisting of fully
+     * qualified interface/class name + "." + method name.
+     *
+     * @param method the method
+     * @return the qualified name of the method
+     */
+    public static String getQualifiedMethodName(Method method) {
+        Assert.notNull(method, "Method must not be null");
+        return method.getDeclaringClass().getName() + "." + method.getName();
+    }
+
+    /**
+     * Return a descriptive name for the given object's type: usually simply the
+     * class name, but component type class name + "[]" for arrays, and an
+     * appended list of implemented interfaces for JDK proxies.
+     *
+     * @param value the value to introspect
+     * @return the qualified name of the class
+     */
+    public static String getDescriptiveType(Object value) {
+        if (value == null) {
+            return null;
+        }
+        Class<?> clazz = value.getClass();
+        if (Proxy.isProxyClass(clazz)) {
+            StringBuilder result = new StringBuilder(clazz.getName());
+            result.append(" implementing ");
+            Class<?>[] ifcs = clazz.getInterfaces();
+            for (int i = 0; i < ifcs.length; i++) {
+                result.append(ifcs[i].getName());
+                if (i < ifcs.length - 1) {
+                    result.append(',');
+                }
+            }
+            return result.toString();
+        } else if (clazz.isArray()) {
+            return getQualifiedNameForArray(clazz);
+        } else {
+            return clazz.getName();
+        }
+    }
+
+    /**
+     * Check whether the given class matches the user-specified type name.
+     *
+     * @param clazz the class to check
+     * @param typeName the type name to match
+     * @return 
+     */
+    public static boolean matchesTypeName(Class<?> clazz, String typeName) {
+        return (typeName != null
+                && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName())
+                || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));
+    }
+
+    /**
+     * Determine whether the given class has a public constructor with the given
+     * signature.
+     * <p>
+     * Essentially translates {@code NoSuchMethodException} to "false".
+     *
+     * @param clazz the clazz to analyze
+     * @param paramTypes the parameter types of the method
+     * @return whether the class has a corresponding constructor
+     * @see Class#getMethod
+     */
+    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {
+        return (getConstructorIfAvailable(clazz, paramTypes) != null);
+    }
+
+    /**
+     * Determine whether the given class has a public constructor with the given
+     * signature, and return it if available (else return {@code null}).
+     * <p>
+     * Essentially translates {@code NoSuchMethodException} to {@code null}.
+     *
+     * @param <T>
+     * @param clazz the clazz to analyze
+     * @param paramTypes the parameter types of the method
+     * @return the constructor, or {@code null} if not found
+     * @see Class#getConstructor
+     */
+    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {
+        Assert.notNull(clazz, "Class must not be null");
+        try {
+            return clazz.getConstructor(paramTypes);
+        } catch (NoSuchMethodException ex) {
+            return null;
+        }
+    }
+
+    /**
+     * Determine whether the given class has a public method with the given
+     * signature.
+     * <p>
+     * Essentially translates {@code NoSuchMethodException} to "false".
+     *
+     * @param clazz the clazz to analyze
+     * @param methodName the name of the method
+     * @param paramTypes the parameter types of the method
+     * @return whether the class has a corresponding method
+     * @see Class#getMethod
+     */
+    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {
+        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);
+    }
+
+    /**
+     * Determine whether the given class has a public method with the given
+     * signature, and return it if available (else throws an
+     * {@code IllegalStateException}).
+     * <p>
+     * In case of any signature specified, only returns the method if there is a
+     * unique candidate, i.e. a single public method with the specified name.
+     * <p>
+     * Essentially translates {@code NoSuchMethodException} to
+     * {@code IllegalStateException}.
+     *
+     * @param clazz the clazz to analyze
+     * @param methodName the name of the method
+     * @param paramTypes the parameter types of the method (may be {@code null}
+     * to indicate any signature)
+     * @return the method (never {@code null})
+     * @throws IllegalStateException if the method has not been found
+     * @see Class#getMethod
+     */
+    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.notNull(methodName, "Method name must not be null");
+        if (paramTypes != null) {
+            try {
+                return clazz.getMethod(methodName, paramTypes);
+            } catch (NoSuchMethodException ex) {
+                throw new IllegalStateException("Expected method not found: " + ex);
+            }
+        } else {
+            Set<Method> candidates = new HashSet<>(1);
+            Method[] methods = clazz.getMethods();
+            for (Method method : methods) {
+                if (methodName.equals(method.getName())) {
+                    candidates.add(method);
+                }
+            }
+            if (candidates.size() == 1) {
+                return candidates.iterator().next();
+            } else if (candidates.isEmpty()) {
+                throw new IllegalStateException("Expected method not found: " + clazz + "." + methodName);
+            } else {
+                throw new IllegalStateException("No unique method found: " + clazz + "." + methodName);
+            }
+        }
+    }
+
+    /**
+     * Determine whether the given class has a public method with the given
+     * signature, and return it if available (else return {@code null}).
+     * <p>
+     * In case of any signature specified, only returns the method if there is a
+     * unique candidate, i.e. a single public method with the specified name.
+     * <p>
+     * Essentially translates {@code NoSuchMethodException} to {@code null}.
+     *
+     * @param clazz the clazz to analyze
+     * @param methodName the name of the method
+     * @param paramTypes the parameter types of the method (may be {@code null}
+     * to indicate any signature)
+     * @return the method, or {@code null} if not found
+     * @see Class#getMethod
+     */
+    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.notNull(methodName, "Method name must not be null");
+        if (paramTypes != null) {
+            try {
+                return clazz.getMethod(methodName, paramTypes);
+            } catch (NoSuchMethodException ex) {
+                return null;
+            }
+        } else {
+            Set<Method> candidates = new HashSet<>(1);
+            Method[] methods = clazz.getMethods();
+            for (Method method : methods) {
+                if (methodName.equals(method.getName())) {
+                    candidates.add(method);
+                }
+            }
+            if (candidates.size() == 1) {
+                return candidates.iterator().next();
+            }
+            return null;
+        }
+    }
+
+    /**
+     * Return the number of methods with a given name (with any argument types),
+     * for the given class and/or its superclasses. Includes non-public methods.
+     *
+     * @param clazz	the clazz to check
+     * @param methodName the name of the method
+     * @return the number of methods with the given name
+     */
+    public static int getMethodCountForName(Class<?> clazz, String methodName) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.notNull(methodName, "Method name must not be null");
+        int count = 0;
+        Method[] declaredMethods = clazz.getDeclaredMethods();
+        for (Method method : declaredMethods) {
+            if (methodName.equals(method.getName())) {
+                count++;
+            }
+        }
+        Class<?>[] ifcs = clazz.getInterfaces();
+        for (Class<?> ifc : ifcs) {
+            count += getMethodCountForName(ifc, methodName);
+        }
+        if (clazz.getSuperclass() != null) {
+            count += getMethodCountForName(clazz.getSuperclass(), methodName);
+        }
+        return count;
+    }
+
+    /**
+     * Does the given class or one of its superclasses at least have one or more
+     * methods with the supplied name (with any argument types)? Includes
+     * non-public methods.
+     *
+     * @param clazz	the clazz to check
+     * @param methodName the name of the method
+     * @return whether there is at least one method with the given name
+     */
+    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.notNull(methodName, "Method name must not be null");
+        Method[] declaredMethods = clazz.getDeclaredMethods();
+        for (Method method : declaredMethods) {
+            if (method.getName().equals(methodName)) {
+                return true;
+            }
+        }
+        Class<?>[] ifcs = clazz.getInterfaces();
+        for (Class<?> ifc : ifcs) {
+            if (hasAtLeastOneMethodWithName(ifc, methodName)) {
+                return true;
+            }
+        }
+        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));
+    }
+
+    /**
+     * Given a method, which may come from an interface, and a target class used
+     * in the current reflective invocation, find the corresponding target
+     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the
+     * target class may be {@code DefaultFoo}. In this case, the method may be
+     * {@code DefaultFoo.bar()}. This enables attributes on that method to be
+     * found.
+     * <p>
+     * <b>NOTE:</b> In contrast to
+     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},
+     * this method does <i>not</i> resolve Java 5 bridge methods automatically.
+     * Call
+     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}
+     * if bridge method resolution is desirable (e.g. for obtaining metadata
+     * from the original method definition).
+     * <p>
+     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow
+     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,
+     * this implementation will fall back to returning the originally provided
+     * method.
+     *
+     * @param method the method to be invoked, which may come from an interface
+     * @param targetClass the target class for the current invocation. May be
+     * {@code null} or may not even implement the method.
+     * @return the specific target method, or the original method if the
+     * {@code targetClass} doesn't implement it or is {@code null}
+     */
+    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {
+        if (method != null && isOverridable(method, targetClass)
+                && targetClass != null && targetClass != method.getDeclaringClass()) {
+            try {
+                if (Modifier.isPublic(method.getModifiers())) {
+                    try {
+                        return targetClass.getMethod(method.getName(), method.getParameterTypes());
+                    } catch (NoSuchMethodException ex) {
+                        return method;
+                    }
+                } else {
+                    Method specificMethod
+                            = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());
+                    return (specificMethod != null ? specificMethod : method);
+                }
+            } catch (SecurityException ex) {
+                // Security settings are disallowing reflective access; fall back to 'method' below.
+            }
+        }
+        return method;
+    }
+
+    /**
+     * Determine whether the given method is declared by the user or at least
+     * pointing to a user-declared method.
+     * <p>
+     * Checks {@link Method#isSynthetic()} (for implementation methods) as well
+     * as the {@code GroovyObject} interface (for interface methods; on an
+     * implementation class, implementations of the {@code GroovyObject} methods
+     * will be marked as synthetic anyway). Note that, despite being synthetic,
+     * bridge methods ({@link Method#isBridge()}) are considered as user-level
+     * methods since they are eventually pointing to a user-declared generic
+     * method.
+     *
+     * @param method the method to check
+     * @return {@code true} if the method can be considered as user-declared;
+     * [@code false} otherwise
+     */
+    public static boolean isUserLevelMethod(Method method) {
+        Assert.notNull(method, "Method must not be null");
+        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));
+    }
+
+    private static boolean isGroovyObjectMethod(Method method) {
+        return method.getDeclaringClass().getName().equals("groovy.lang.GroovyObject");
+    }
+
+    /**
+     * Determine whether the given method is overridable in the given target
+     * class.
+     *
+     * @param method the method to check
+     * @param targetClass the target class to check against
+     */
+    private static boolean isOverridable(Method method, Class<?> targetClass) {
+        if (Modifier.isPrivate(method.getModifiers())) {
+            return false;
+        }
+        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {
+            return true;
+        }
+        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));
+    }
+
+    /**
+     * Return a public static method of a class.
+     *
+     * @param clazz the class which defines the method
+     * @param methodName the static method name
+     * @param args the parameter types to the method
+     * @return the static method, or {@code null} if no static method was found
+     * @throws IllegalArgumentException if the method name is blank or the clazz
+     * is null
+     */
+    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.notNull(methodName, "Method name must not be null");
+        try {
+            Method method = clazz.getMethod(methodName, args);
+            return Modifier.isStatic(method.getModifiers()) ? method : null;
+        } catch (NoSuchMethodException ex) {
+            return null;
+        }
+    }
+
+    /**
+     * Check if the given class represents a primitive wrapper, i.e. Boolean,
+     * Byte, Character, Short, Integer, Long, Float, or Double.
+     *
+     * @param clazz the class to check
+     * @return whether the given class is a primitive wrapper class
+     */
+    public static boolean isPrimitiveWrapper(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        return primitiveWrapperTypeMap.containsKey(clazz);
+    }
+
+    /**
+     * Check if the given class represents a primitive (i.e. boolean, byte,
+     * char, short, int, long, float, or double) or a primitive wrapper (i.e.
+     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).
+     *
+     * @param clazz the class to check
+     * @return whether the given class is a primitive or primitive wrapper class
+     */
+    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));
+    }
+
+    /**
+     * Check if the given class represents an array of primitives, i.e. boolean,
+     * byte, char, short, int, long, float, or double.
+     *
+     * @param clazz the class to check
+     * @return whether the given class is a primitive array class
+     */
+    public static boolean isPrimitiveArray(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        return (clazz.isArray() && clazz.getComponentType().isPrimitive());
+    }
+
+    /**
+     * Check if the given class represents an array of primitive wrappers, i.e.
+     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.
+     *
+     * @param clazz the class to check
+     * @return whether the given class is a primitive wrapper array class
+     */
+    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));
+    }
+
+    /**
+     * Resolve the given class if it is a primitive class, returning the
+     * corresponding primitive wrapper type instead.
+     *
+     * @param clazz the class to check
+     * @return the original class, or a primitive wrapper for the original
+     * primitive type
+     */
+    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {
+        Assert.notNull(clazz, "Class must not be null");
+        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);
+    }
+
+    /**
+     * Check if the right-hand side type may be assigned to the left-hand side
+     * type, assuming setting by reflection. Considers primitive wrapper classes
+     * as assignable to the corresponding primitive types.
+     *
+     * @param lhsType the target type
+     * @param rhsType the value type that should be assigned to the target type
+     * @return if the target type is assignable from the value type
+     * @see TypeUtils#isAssignable
+     */
+    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {
+        Assert.notNull(lhsType, "Left-hand side type must not be null");
+        Assert.notNull(rhsType, "Right-hand side type must not be null");
+        if (lhsType.isAssignableFrom(rhsType)) {
+            return true;
+        }
+        if (lhsType.isPrimitive()) {
+            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);
+            if (lhsType == resolvedPrimitive) {
+                return true;
+            }
+        } else {
+            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);
+            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Determine if the given type is assignable from the given value, assuming
+     * setting by reflection. Considers primitive wrapper classes as assignable
+     * to the corresponding primitive types.
+     *
+     * @param type the target type
+     * @param value the value that should be assigned to the type
+     * @return if the type is assignable from the value
+     */
+    public static boolean isAssignableValue(Class<?> type, Object value) {
+        Assert.notNull(type, "Type must not be null");
+        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());
+    }
+
+    /**
+     * Convert a "/"-based resource path to a "."-based fully qualified class
+     * name.
+     *
+     * @param resourcePath the resource path pointing to a class
+     * @return the corresponding fully qualified class name
+     */
+    public static String convertResourcePathToClassName(String resourcePath) {
+        Assert.notNull(resourcePath, "Resource path must not be null");
+        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);
+    }
+
+    /**
+     * Convert a "."-based fully qualified class name to a "/"-based resource
+     * path.
+     *
+     * @param className the fully qualified class name
+     * @return the corresponding resource path, pointing to the class
+     */
+    public static String convertClassNameToResourcePath(String className) {
+        Assert.notNull(className, "Class name must not be null");
+        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);
+    }
+
+    /**
+     * Return a path suitable for use with {@code ClassLoader.getResource} (also
+     * suitable for use with {@code Class.getResource} by prepending a slash
+     * ('/') to the return value). Built by taking the package of the specified
+     * class file, converting all dots ('.') to slashes ('/'), adding a trailing
+     * slash if necessary, and concatenating the specified resource name to
+     * this.
+     * <br/>As such, this function may be used to build a path suitable for
+     * loading a resource file that is in the same package as a class file,
+     * although {@link org.springframework.core.io.ClassPathResource} is usually
+     * even more convenient.
+     *
+     * @param clazz the Class whose package will be used as the base
+     * @param resourceName the resource name to append. A leading slash is
+     * optional.
+     * @return the built-up resource path
+     * @see ClassLoader#getResource
+     * @see Class#getResource
+     */
+    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {
+        Assert.notNull(resourceName, "Resource name must not be null");
+        if (!resourceName.startsWith("/")) {
+            return classPackageAsResourcePath(clazz) + "/" + resourceName;
+        }
+        return classPackageAsResourcePath(clazz) + resourceName;
+    }
+
+    /**
+     * Given an input class object, return a string which consists of the
+     * class's package name as a pathname, i.e., all dots ('.') are replaced by
+     * slashes ('/'). Neither a leading nor trailing slash is added. The result
+     * could be concatenated with a slash and the name of a resource and fed
+     * directly to {@code ClassLoader.getResource()}. For it to be fed to
+     * {@code Class.getResource} instead, a leading slash would also have to be
+     * prepended to the returned value.
+     *
+     * @param clazz the input class. A {@code null} value or the default (empty)
+     * package will result in an empty string ("") being returned.
+     * @return a path which represents the package name
+     * @see ClassLoader#getResource
+     * @see Class#getResource
+     */
+    public static String classPackageAsResourcePath(Class<?> clazz) {
+        if (clazz == null) {
+            return "";
+        }
+        String className = clazz.getName();
+        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);
+        if (packageEndIndex == -1) {
+            return "";
+        }
+        String packageName = className.substring(0, packageEndIndex);
+        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);
+    }
+
+    /**
+     * Build a String that consists of the names of the classes/interfaces in
+     * the given array.
+     * <p>
+     * Basically like {@code AbstractCollection.toString()}, but stripping the
+     * "class "/"interface " prefix before every class name.
+     *
+     * @param classes a Collection of Class objects (may be {@code null})
+     * @return a String of form "[com.foo.Bar, com.foo.Baz]"
+     * @see java.util.AbstractCollection#toString()
+     */
+    public static String classNamesToString(Class<?>... classes) {
+        return classNamesToString(Arrays.asList(classes));
+    }
+
+    /**
+     * Build a String that consists of the names of the classes/interfaces in
+     * the given collection.
+     * <p>
+     * Basically like {@code AbstractCollection.toString()}, but stripping the
+     * "class "/"interface " prefix before every class name.
+     *
+     * @param classes a Collection of Class objects (may be {@code null})
+     * @return a String of form "[com.foo.Bar, com.foo.Baz]"
+     * @see java.util.AbstractCollection#toString()
+     */
+    public static String classNamesToString(Collection<Class<?>> classes) {
+        if (CollectionUtils.isEmpty(classes)) {
+            return "[]";
+        }
+        StringBuilder sb = new StringBuilder("[");
+        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {
+            Class<?> clazz = it.next();
+            sb.append(clazz.getName());
+            if (it.hasNext()) {
+                sb.append(", ");
+            }
+        }
+        sb.append("]");
+        return sb.toString();
+    }
+
+    /**
+     * Copy the given Collection into a Class array. The Collection must contain
+     * Class elements only.
+     *
+     * @param collection the Collection to copy
+     * @return the Class array ({@code null} if the passed-in Collection was
+     * {@code null})
+     */
+    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {
+        if (collection == null) {
+            return null;
+        }
+        return collection.toArray(new Class<?>[collection.size()]);
+    }
+
+    /**
+     * Return all interfaces that the given instance implements as array,
+     * including ones implemented by superclasses.
+     *
+     * @param instance the instance to analyze for interfaces
+     * @return all interfaces that the given instance implements as array
+     */
+    public static Class<?>[] getAllInterfaces(Object instance) {
+        Assert.notNull(instance, "Instance must not be null");
+        return getAllInterfacesForClass(instance.getClass());
+    }
+
+    /**
+     * Return all interfaces that the given class implements as array, including
+     * ones implemented by superclasses.
+     * <p>
+     * If the class itself is an interface, it gets returned as sole interface.
+     *
+     * @param clazz the class to analyze for interfaces
+     * @return all interfaces that the given object implements as array
+     */
+    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {
+        return getAllInterfacesForClass(clazz, null);
+    }
+
+    /**
+     * Return all interfaces that the given class implements as array, including
+     * ones implemented by superclasses.
+     * <p>
+     * If the class itself is an interface, it gets returned as sole interface.
+     *
+     * @param clazz the class to analyze for interfaces
+     * @param classLoader the ClassLoader that the interfaces need to be visible
+     * in (may be {@code null} when accepting all declared interfaces)
+     * @return all interfaces that the given object implements as array
+     */
+    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {
+        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);
+        return ifcs.toArray(new Class<?>[ifcs.size()]);
+    }
+
+    /**
+     * Return all interfaces that the given instance implements as Set,
+     * including ones implemented by superclasses.
+     *
+     * @param instance the instance to analyze for interfaces
+     * @return all interfaces that the given instance implements as Set
+     */
+    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {
+        Assert.notNull(instance, "Instance must not be null");
+        return getAllInterfacesForClassAsSet(instance.getClass());
+    }
+
+    /**
+     * Return all interfaces that the given class implements as Set, including
+     * ones implemented by superclasses.
+     * <p>
+     * If the class itself is an interface, it gets returned as sole interface.
+     *
+     * @param clazz the class to analyze for interfaces
+     * @return all interfaces that the given object implements as Set
+     */
+    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {
+        return getAllInterfacesForClassAsSet(clazz, null);
+    }
+
+    /**
+     * Return all interfaces that the given class implements as Set, including
+     * ones implemented by superclasses.
+     * <p>
+     * If the class itself is an interface, it gets returned as sole interface.
+     *
+     * @param clazz the class to analyze for interfaces
+     * @param classLoader the ClassLoader that the interfaces need to be visible
+     * in (may be {@code null} when accepting all declared interfaces)
+     * @return all interfaces that the given object implements as Set
+     */
+    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {
+        Assert.notNull(clazz, "Class must not be null");
+        if (clazz.isInterface() && isVisible(clazz, classLoader)) {
+            return Collections.<Class<?>>singleton(clazz);
+        }
+        Set<Class<?>> interfaces = new LinkedHashSet<>();
+        while (clazz != null) {
+            Class<?>[] ifcs = clazz.getInterfaces();
+            for (Class<?> ifc : ifcs) {
+                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));
+            }
+            clazz = clazz.getSuperclass();
+        }
+        return interfaces;
+    }
+
+    /**
+     * Create a composite interface Class for the given interfaces, implementing
+     * the given interfaces in one single Class.
+     * <p>
+     * This implementation builds a JDK proxy class for the given interfaces.
+     *
+     * @param interfaces the interfaces to merge
+     * @param classLoader the ClassLoader to create the composite Class in
+     * @return the merged interface as Class
+     * @see java.lang.reflect.Proxy#getProxyClass
+     */
+    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {
+        Assert.notEmpty(interfaces, "Interfaces must not be empty");
+        Assert.notNull(classLoader, "ClassLoader must not be null");
+        return Proxy.getProxyClass(classLoader, interfaces);
+    }
+
+    /**
+     * Determine the common ancestor of the given classes, if any.
+     *
+     * @param clazz1 the class to introspect
+     * @param clazz2 the other class to introspect
+     * @return the common ancestor (i.e. common superclass, one interface
+     * extending the other), or {@code null} if none found. If any of the given
+     * classes is {@code null}, the other class will be returned.
+     * @since 3.2.6
+     */
+    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {
+        if (clazz1 == null) {
+            return clazz2;
+        }
+        if (clazz2 == null) {
+            return clazz1;
+        }
+        if (clazz1.isAssignableFrom(clazz2)) {
+            return clazz1;
+        }
+        if (clazz2.isAssignableFrom(clazz1)) {
+            return clazz2;
+        }
+        Class<?> ancestor = clazz1;
+        do {
+            ancestor = ancestor.getSuperclass();
+            if (ancestor == null || Object.class == ancestor) {
+                return null;
+            }
+        } while (!ancestor.isAssignableFrom(clazz2));
+        return ancestor;
+    }
+
+    /**
+     * Check whether the given class is visible in the given ClassLoader.
+     *
+     * @param clazz the class to check (typically an interface)
+     * @param classLoader the ClassLoader to check against (may be {@code null},
+     * in which case this method will always return {@code true})
+     */
+    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {
+        if (classLoader == null) {
+            return true;
+        }
+        try {
+            Class<?> actualClass = classLoader.loadClass(clazz.getName());
+            return (clazz == actualClass);
+            // Else: different interface class found...
+        } catch (ClassNotFoundException ex) {
+            // No interface class found...
+            return false;
+        }
+    }
+
+    /**
+     * Check whether the given object is a CGLIB proxy.
+     *
+     * @param object the object to check
+     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)
+     */
+    public static boolean isCglibProxy(Object object) {
+        return isCglibProxyClass(object.getClass());
+    }
+
+    /**
+     * Check whether the specified class is a CGLIB-generated class.
+     *
+     * @param clazz the class to check
+     */
+    public static boolean isCglibProxyClass(Class<?> clazz) {
+        return (clazz != null && isCglibProxyClassName(clazz.getName()));
+    }
+
+    /**
+     * Check whether the specified class name is a CGLIB-generated class.
+     *
+     * @param className the class name to check
+     */
+    public static boolean isCglibProxyClassName(String className) {
+        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));
+    }
+}
diff --git a/src/main/java/component/utils/CollectionUtils.java b/src/main/java/component/utils/CollectionUtils.java
new file mode 100644
index 0000000..3b7a68a
--- /dev/null
+++ b/src/main/java/component/utils/CollectionUtils.java
@@ -0,0 +1,367 @@
+/*
+ * To change this license header, choose License Headers in Project Properties.
+ * To change this template file, choose Tools | Templates
+ * and open the template in the editor.
+ */
+package component.utils;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Enumeration;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+
+/**
+ *
+ * @author cdi305
+ */
+public abstract class CollectionUtils {
+
+    /**
+     * Return {@code true} if the supplied Collection is {@code null} or empty.
+     * Otherwise, return {@code false}.
+     *
+     * @param collection the Collection to check
+     * @return whether the given Collection is empty
+     */
+    public static boolean isEmpty(Collection<?> collection) {
+        return (collection == null || collection.isEmpty());
+    }
+
+    /**
+     * Return {@code true} if the supplied Map is {@code null} or empty.
+     * Otherwise, return {@code false}.
+     *
+     * @param map the Map to check
+     * @return whether the given Map is empty
+     */
+    public static boolean isEmpty(Map<?, ?> map) {
+        return (map == null || map.isEmpty());
+    }
+
+    /**
+     * Convert the supplied array into a List. A primitive array gets converted
+     * into a List of the appropriate wrapper type.
+     * <p>
+     * <b>NOTE:</b> Generally prefer the standard {@link Arrays#asList} method.
+     * This {@code arrayToList} method is just meant to deal with an incoming
+     * Object value that might be an {@code Object[]} or a primitive array at
+     * runtime.
+     * <p>
+     * A {@code null} source value will be converted to an empty List.
+     *
+     * @param source the (potentially primitive) array
+     * @return the converted List result
+     * @see ObjectUtils#toObjectArray(Object)
+     * @see Arrays#asList(Object[])
+     */
+    @SuppressWarnings("rawtypes")
+    public static List arrayToList(Object source) {
+        return Arrays.asList(ObjectUtils.toObjectArray(source));
+    }
+
+    /**
+     * Merge the given array into the given Collection.
+     *
+     * @param <E>
+     * @param array the array to merge (may be {@code null})
+     * @param collection the target Collection to merge the array into
+     */
+    @SuppressWarnings("unchecked")
+    public static <E> void mergeArrayIntoCollection(Object array, Collection<E> collection) {
+        if (collection == null) {
+            throw new IllegalArgumentException("Collection must not be null");
+        }
+        Object[] arr = ObjectUtils.toObjectArray(array);
+        for (Object elem : arr) {
+            collection.add((E) elem);
+        }
+    }
+
+    /**
+     * Merge the given Properties instance into the given Map, copying all
+     * properties (key-value pairs) over.
+     * <p>
+     * Uses {@code Properties.propertyNames()} to even catch default properties
+     * linked into the original Properties instance.
+     *
+     * @param <K>
+     * @param <V>
+     * @param props the Properties instance to merge (may be {@code null})
+     * @param map the target Map to merge the properties into
+     */
+    @SuppressWarnings("unchecked")
+    public static <K, V> void mergePropertiesIntoMap(Properties props, Map<K, V> map) {
+        if (map == null) {
+            throw new IllegalArgumentException("Map must not be null");
+        }
+        if (props != null) {
+            for (Enumeration<?> en = props.propertyNames(); en.hasMoreElements();) {
+                String key = (String) en.nextElement();
+                Object value = props.getProperty(key);
+                if (value == null) {
+                    // Potentially a non-String value...
+                    value = props.get(key);
+                }
+                map.put((K) key, (V) value);
+            }
+        }
+    }
+
+    /**
+     * Check whether the given Iterator contains the given element.
+     *
+     * @param iterator the Iterator to check
+     * @param element the element to look for
+     * @return {@code true} if found, {@code false} else
+     */
+    public static boolean contains(Iterator<?> iterator, Object element) {
+        if (iterator != null) {
+            while (iterator.hasNext()) {
+                Object candidate = iterator.next();
+                if (ObjectUtils.nullSafeEquals(candidate, element)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Check whether the given Enumeration contains the given element.
+     *
+     * @param enumeration the Enumeration to check
+     * @param element the element to look for
+     * @return {@code true} if found, {@code false} else
+     */
+    public static boolean contains(Enumeration<?> enumeration, Object element) {
+        if (enumeration != null) {
+            while (enumeration.hasMoreElements()) {
+                Object candidate = enumeration.nextElement();
+                if (ObjectUtils.nullSafeEquals(candidate, element)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Check whether the given Collection contains the given element instance.
+     * <p>
+     * Enforces the given instance to be present, rather than returning
+     * {@code true} for an equal element as well.
+     *
+     * @param collection the Collection to check
+     * @param element the element to look for
+     * @return {@code true} if found, {@code false} else
+     */
+    public static boolean containsInstance(Collection<?> collection, Object element) {
+        if (collection != null) {
+            if (collection.stream().anyMatch((candidate) -> (candidate == element))) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Return {@code true} if any element in '{@code candidates}' is contained
+     * in '{@code source}'; otherwise returns {@code false}.
+     *
+     * @param source the source Collection
+     * @param candidates the candidates to search for
+     * @return whether any of the candidates has been found
+     */
+    public static boolean containsAny(Collection<?> source, Collection<?> candidates) {
+        if (isEmpty(source) || isEmpty(candidates)) {
+            return false;
+        }
+        return candidates.stream().anyMatch((candidate) -> (source.contains(candidate)));
+    }
+
+    /**
+     * Return the first element in '{@code candidates}' that is contained in
+     * '{@code source}'. If no element in '{@code candidates}' is present in
+     * '{@code source}' returns {@code null}. Iteration order is
+     * {@link Collection} implementation specific.
+     *
+     * @param <E>
+     * @param source the source Collection
+     * @param candidates the candidates to search for
+     * @return the first present object, or {@code null} if not found
+     */
+    @SuppressWarnings("unchecked")
+    public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) {
+        if (isEmpty(source) || isEmpty(candidates)) {
+            return null;
+        }
+        for (Object candidate : candidates) {
+            if (source.contains(candidate)) {
+                return (E) candidate;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Find a single value of the given type in the given Collection.
+     *
+     * @param <T>
+     * @param collection the Collection to search
+     * @param type the type to look for
+     * @return a value of the given type found if there is a clear match, or
+     * {@code null} if none or more than one such value found
+     */
+    @SuppressWarnings("unchecked")
+    public static <T> T findValueOfType(Collection<?> collection, Class<T> type) {
+        if (isEmpty(collection)) {
+            return null;
+        }
+        T value = null;
+        for (Object element : collection) {
+            if (type == null || type.isInstance(element)) {
+                if (value != null) {
+                    // More than one value found... no clear single value.
+                    return null;
+                }
+                value = (T) element;
+            }
+        }
+        return value;
+    }
+
+    /**
+     * Find a single value of one of the given types in the given Collection:
+     * searching the Collection for a value of the first type, then searching
+     * for a value of the second type, etc.
+     *
+     * @param collection the collection to search
+     * @param types the types to look for, in prioritized order
+     * @return a value of one of the given types found if there is a clear
+     * match, or {@code null} if none or more than one such value found
+     */
+    public static Object findValueOfType(Collection<?> collection, Class<?>[] types) {
+        if (isEmpty(collection) || ObjectUtils.isEmpty(types)) {
+            return null;
+        }
+        for (Class<?> type : types) {
+            Object value = findValueOfType(collection, type);
+            if (value != null) {
+                return value;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Determine whether the given Collection only contains a single unique
+     * object.
+     *
+     * @param collection the Collection to check
+     * @return {@code true} if the collection contains a single reference or
+     * multiple references to the same instance, {@code false} else
+     */
+    public static boolean hasUniqueObject(Collection<?> collection) {
+        if (isEmpty(collection)) {
+            return false;
+        }
+        boolean hasCandidate = false;
+        Object candidate = null;
+        for (Object elem : collection) {
+            if (!hasCandidate) {
+                hasCandidate = true;
+                candidate = elem;
+            } else if (candidate != elem) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Find the common element type of the given Collection, if any.
+     *
+     * @param collection the Collection to check
+     * @return the common element type, or {@code null} if no clear common type
+     * has been found (or the collection was empty)
+     */
+    public static Class<?> findCommonElementType(Collection<?> collection) {
+        if (isEmpty(collection)) {
+            return null;
+        }
+        Class<?> candidate = null;
+        for (Object val : collection) {
+            if (val != null) {
+                if (candidate == null) {
+                    candidate = val.getClass();
+                } else if (candidate != val.getClass()) {
+                    return null;
+                }
+            }
+        }
+        return candidate;
+    }
+
+    /**
+     * Marshal the elements from the given enumeration into an array of the
+     * given type. Enumeration elements must be assignable to the type of the
+     * given array. The array returned will be a different instance than the
+     * array given.
+     * @param <A>
+     * @param <E>
+     * @param enumeration
+     * @param array
+     * @return 
+     */
+    public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {
+        ArrayList<A> elements = new ArrayList<>();
+        while (enumeration.hasMoreElements()) {
+            elements.add(enumeration.nextElement());
+        }
+        return elements.toArray(array);
+    }
+
+    /**
+     * Adapt an enumeration to an iterator.
+     *
+     * @param <E>
+     * @param enumeration the enumeration
+     * @return the iterator
+     */
+    public static <E> Iterator<E> toIterator(Enumeration<E> enumeration) {
+        return new EnumerationIterator<>(enumeration);
+    }
+
+
+    /**
+     * Iterator wrapping an Enumeration.
+     */
+    private static class EnumerationIterator<E> implements Iterator<E> {
+
+        private final Enumeration<E> enumeration;
+
+        public EnumerationIterator(Enumeration<E> enumeration) {
+            this.enumeration = enumeration;
+        }
+
+        @Override
+        public boolean hasNext() {
+            return this.enumeration.hasMoreElements();
+        }
+
+        @Override
+        public E next() {
+            return this.enumeration.nextElement();
+        }
+
+        @Override
+        public void remove() throws UnsupportedOperationException {
+            throw new UnsupportedOperationException("Not supported");
+        }
+    }
+
+}
diff --git a/src/main/java/component/utils/ObjectUtils.java b/src/main/java/component/utils/ObjectUtils.java
new file mode 100644
index 0000000..aaf5da4
--- /dev/null
+++ b/src/main/java/component/utils/ObjectUtils.java
@@ -0,0 +1,1013 @@
+package component.utils;
+
+import java.lang.reflect.Array;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Map;
+import java.util.Optional;
+
+public abstract class ObjectUtils {
+
+    private static final int INITIAL_HASH = 7;
+    private static final int MULTIPLIER = 31;
+
+    private static final String EMPTY_STRING = "";
+    private static final String NULL_STRING = "null";
+    private static final String ARRAY_START = "{";
+    private static final String ARRAY_END = "}";
+    private static final String EMPTY_ARRAY = ARRAY_START + ARRAY_END;
+    private static final String ARRAY_ELEMENT_SEPARATOR = ", ";
+
+    /**
+     * Return whether the given throwable is a checked exception: that is,
+     * neither a RuntimeException nor an Error.
+     *
+     * @param ex the throwable to check
+     * @return whether the throwable is a checked exception
+     * @see java.lang.Exception
+     * @see java.lang.RuntimeException
+     * @see java.lang.Error
+     */
+    public static boolean isCheckedException(Throwable ex) {
+        return !(ex instanceof RuntimeException || ex instanceof Error);
+    }
+
+    /**
+     * Check whether the given exception is compatible with the specified
+     * exception types, as declared in a throws clause.
+     *
+     * @param ex the exception to check
+     * @param declaredExceptions the exception types declared in the throws
+     * clause
+     * @return whether the given exception is compatible
+     */
+    public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions) {
+        if (!isCheckedException(ex)) {
+            return true;
+        }
+        if (declaredExceptions != null) {
+            for (Class<?> declaredException : declaredExceptions) {
+                if (declaredException.isInstance(ex)) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Determine whether the given object is an array: either an Object array or
+     * a primitive array.
+     *
+     * @param obj the object to check
+     * @return 
+     */
+    public static boolean isArray(Object obj) {
+        return (obj != null && obj.getClass().isArray());
+    }
+
+    /**
+     * Determine whether the given array is empty: i.e. {@code null} or of zero
+     * length.
+     *
+     * @param array the array to check
+     * @return 
+     * @see #isEmpty(Object)
+     */
+    public static boolean isEmpty(Object[] array) {
+        return (array == null || array.length == 0);
+    }
+
+    /**
+     * Determine whether the given object is empty.
+     * <p>
+     * This method supports the following object types.
+     * <ul>
+     * <li>{@code Optional}: considered empty if {@link Optional#empty()}</li>
+     * <li>{@code Array}: considered empty if its length is zero</li>
+     * <li>{@link CharSequence}: considered empty if its length is zero</li>
+     * <li>{@link Collection}: delegates to {@link Collection#isEmpty()}</li>
+     * <li>{@link Map}: delegates to {@link Map#isEmpty()}</li>
+     * </ul>
+     * <p>
+     * If the given object is non-null and not one of the aforementioned
+     * supported types, this method returns {@code false}.
+     *
+     * @param obj the object to check
+     * @return {@code true} if the object is {@code null} or <em>empty</em>
+     * @since 4.2
+     * @see Optional#isPresent()
+     * @see ObjectUtils#isEmpty(Object[])
+     * @see StringUtils#hasLength(CharSequence)
+     * @see StringUtils#isEmpty(Object)
+     * @see CollectionUtils#isEmpty(java.util.Collection)
+     * @see CollectionUtils#isEmpty(java.util.Map)
+     */
+    @SuppressWarnings("rawtypes")
+    public static boolean isEmpty(Object obj) {
+        if (obj == null) {
+            return true;
+        }
+
+        if (obj instanceof Optional) {
+            return !((Optional) obj).isPresent();
+        }
+        if (obj.getClass().isArray()) {
+            return Array.getLength(obj) == 0;
+        }
+        if (obj instanceof CharSequence) {
+            return ((CharSequence) obj).length() == 0;
+        }
+        if (obj instanceof Collection) {
+            return ((Collection) obj).isEmpty();
+        }
+        if (obj instanceof Map) {
+            return ((Map) obj).isEmpty();
+        }
+
+        // else
+        return false;
+    }
+
+    /**
+     * Unwrap the given object which is potentially a
+     * {@link java.util.Optional}.
+     *
+     * @param obj the candidate object
+     * @return either the value held within the {@code Optional}, {@code null}
+     * if the {@code Optional} is empty, or simply the given object as-is
+     * @since 5.0
+     */
+    public static Object unwrapOptional(Object obj) {
+        if (obj instanceof Optional) {
+            Optional<?> optional = (Optional<?>) obj;
+            if (!optional.isPresent()) {
+                return null;
+            }
+            Object result = optional.get();
+            Assert.isTrue(!(result instanceof Optional), "Multi-level Optional usage not supported");
+            return result;
+        }
+        return obj;
+    }
+
+    /**
+     * Check whether the given array contains the given element.
+     *
+     * @param array the array to check (may be {@code null}, in which case the
+     * return value will always be {@code false})
+     * @param element the element to check for
+     * @return whether the element has been found in the given array
+     */
+    public static boolean containsElement(Object[] array, Object element) {
+        if (array == null) {
+            return false;
+        }
+        for (Object arrayEle : array) {
+            if (nullSafeEquals(arrayEle, element)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Check whether the given array of enum constants contains a constant with
+     * the given name, ignoring case when determining a match.
+     *
+     * @param enumValues the enum values to check, typically the product of a
+     * call to MyEnum.values()
+     * @param constant the constant name to find (must not be null or empty
+     * string)
+     * @return whether the constant has been found in the given array
+     */
+    public static boolean containsConstant(Enum<?>[] enumValues, String constant) {
+        return containsConstant(enumValues, constant, false);
+    }
+
+    /**
+     * Check whether the given array of enum constants contains a constant with
+     * the given name.
+     *
+     * @param enumValues the enum values to check, typically the product of a
+     * call to MyEnum.values()
+     * @param constant the constant name to find (must not be null or empty
+     * string)
+     * @param caseSensitive whether case is significant in determining a match
+     * @return whether the constant has been found in the given array
+     */
+    public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {
+        for (Enum<?> candidate : enumValues) {
+            if (caseSensitive
+                    ? candidate.toString().equals(constant)
+                    : candidate.toString().equalsIgnoreCase(constant)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Case insensitive alternative to {@link Enum#valueOf(Class, String)}.
+     *
+     * @param <E> the concrete Enum type
+     * @param enumValues the array of all Enum constants in question, usually
+     * per Enum.values()
+     * @param constant the constant to get the enum value of
+     * @return 
+     * @throws IllegalArgumentException if the given constant is not found in
+     * the given array of enum values. Use
+     * {@link #containsConstant(Enum[], String)} as a guard to avoid this
+     * exception.
+     */
+    public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant) {
+        for (E candidate : enumValues) {
+            if (candidate.toString().equalsIgnoreCase(constant)) {
+                return candidate;
+            }
+        }
+        throw new IllegalArgumentException(
+                String.format("constant [%s] does not exist in enum type %s",
+                        constant, enumValues.getClass().getComponentType().getName()));
+    }
+
+    /**
+     * Append the given object to the given array, returning a new array
+     * consisting of the input array contents plus the given object.
+     *
+     * @param <A>
+     * @param <O>
+     * @param array the array to append to (can be {@code null})
+     * @param obj the object to append
+     * @return the new array (of the same component type; never {@code null})
+     */
+    public static <A, O extends A> A[] addObjectToArray(A[] array, O obj) {
+        Class<?> compType = Object.class;
+        if (null != array) {
+            compType = array.getClass().getComponentType();
+        } else if (obj != null) {
+            compType = obj.getClass();
+        }
+        int newArrLength = (array != null ? array.length + 1 : 1);
+        @SuppressWarnings("unchecked")
+        A[] newArr = (A[]) Array.newInstance(compType, newArrLength);
+        if (array != null) {
+            System.arraycopy(array, 0, newArr, 0, array.length);
+        }
+        newArr[newArr.length - 1] = obj;
+        return newArr;
+    }
+
+    /**
+     * Convert the given array (which may be a primitive array) to an object
+     * array (if necessary of primitive wrapper objects).
+     * <p>
+     * A {@code null} source value will be converted to an empty Object array.
+     *
+     * @param source the (potentially primitive) array
+     * @return the corresponding object array (never {@code null})
+     * @throws IllegalArgumentException if the parameter is not an array
+     */
+    public static Object[] toObjectArray(Object source) {
+        if (source instanceof Object[]) {
+            return (Object[]) source;
+        }
+        if (source == null) {
+            return new Object[0];
+        }
+        if (!source.getClass().isArray()) {
+            throw new IllegalArgumentException("Source is not an array: " + source);
+        }
+        int length = Array.getLength(source);
+        if (length == 0) {
+            return new Object[0];
+        }
+        Class<?> wrapperType = Array.get(source, 0).getClass();
+        Object[] newArray = (Object[]) Array.newInstance(wrapperType, length);
+        for (int i = 0; i < length; i++) {
+            newArray[i] = Array.get(source, i);
+        }
+        return newArray;
+    }
+
+	//---------------------------------------------------------------------
+    // Convenience methods for content-based equality/hash-code handling
+    //---------------------------------------------------------------------
+    /**
+     * Determine if the given objects are equal, returning {@code true} if both
+     * are {@code null} or {@code false} if only one is {@code null}.
+     * <p>
+     * Compares arrays with {@code Arrays.equals}, performing an equality check
+     * based on the array elements rather than the array reference.
+     *
+     * @param o1 first Object to compare
+     * @param o2 second Object to compare
+     * @return whether the given objects are equal
+     * @see Object#equals(Object)
+     * @see java.util.Arrays#equals
+     */
+    public static boolean nullSafeEquals(Object o1, Object o2) {
+        if (o1 == o2) {
+            return true;
+        }
+        if (o1 == null || o2 == null) {
+            return false;
+        }
+        if (o1.equals(o2)) {
+            return true;
+        }
+        if (o1.getClass().isArray() && o2.getClass().isArray()) {
+            return arrayEquals(o1, o2);
+        }
+        return false;
+    }
+
+    /**
+     * Compare the given arrays with {@code Arrays.equals}, performing an
+     * equality check based on the array elements rather than the array
+     * reference.
+     *
+     * @param o1 first array to compare
+     * @param o2 second array to compare
+     * @return whether the given objects are equal
+     * @see #nullSafeEquals(Object, Object)
+     * @see java.util.Arrays#equals
+     */
+    private static boolean arrayEquals(Object o1, Object o2) {
+        if (o1 instanceof Object[] && o2 instanceof Object[]) {
+            return Arrays.equals((Object[]) o1, (Object[]) o2);
+        }
+        if (o1 instanceof boolean[] && o2 instanceof boolean[]) {
+            return Arrays.equals((boolean[]) o1, (boolean[]) o2);
+        }
+        if (o1 instanceof byte[] && o2 instanceof byte[]) {
+            return Arrays.equals((byte[]) o1, (byte[]) o2);
+        }
+        if (o1 instanceof char[] && o2 instanceof char[]) {
+            return Arrays.equals((char[]) o1, (char[]) o2);
+        }
+        if (o1 instanceof double[] && o2 instanceof double[]) {
+            return Arrays.equals((double[]) o1, (double[]) o2);
+        }
+        if (o1 instanceof float[] && o2 instanceof float[]) {
+            return Arrays.equals((float[]) o1, (float[]) o2);
+        }
+        if (o1 instanceof int[] && o2 instanceof int[]) {
+            return Arrays.equals((int[]) o1, (int[]) o2);
+        }
+        if (o1 instanceof long[] && o2 instanceof long[]) {
+            return Arrays.equals((long[]) o1, (long[]) o2);
+        }
+        if (o1 instanceof short[] && o2 instanceof short[]) {
+            return Arrays.equals((short[]) o1, (short[]) o2);
+        }
+        return false;
+    }
+
+    /**
+     * Return as hash code for the given object; typically the value of
+     * {@code Object#hashCode()}}. If the object is an array, this method will
+     * delegate to any of the {@code nullSafeHashCode} methods for arrays in
+     * this class. If the object is {@code null}, this method returns 0.
+     *
+     * @param obj
+     * @return 
+     * @see Object#hashCode()
+     * @see #nullSafeHashCode(Object[])
+     * @see #nullSafeHashCode(boolean[])
+     * @see #nullSafeHashCode(byte[])
+     * @see #nullSafeHashCode(char[])
+     * @see #nullSafeHashCode(double[])
+     * @see #nullSafeHashCode(float[])
+     * @see #nullSafeHashCode(int[])
+     * @see #nullSafeHashCode(long[])
+     * @see #nullSafeHashCode(short[])
+     */
+    public static int nullSafeHashCode(Object obj) {
+        if (obj == null) {
+            return 0;
+        }
+        if (obj.getClass().isArray()) {
+            if (obj instanceof Object[]) {
+                return nullSafeHashCode((Object[]) obj);
+            }
+            if (obj instanceof boolean[]) {
+                return nullSafeHashCode((boolean[]) obj);
+            }
+            if (obj instanceof byte[]) {
+                return nullSafeHashCode((byte[]) obj);
+            }
+            if (obj instanceof char[]) {
+                return nullSafeHashCode((char[]) obj);
+            }
+            if (obj instanceof double[]) {
+                return nullSafeHashCode((double[]) obj);
+            }
+            if (obj instanceof float[]) {
+                return nullSafeHashCode((float[]) obj);
+            }
+            if (obj instanceof int[]) {
+                return nullSafeHashCode((int[]) obj);
+            }
+            if (obj instanceof long[]) {
+                return nullSafeHashCode((long[]) obj);
+            }
+            if (obj instanceof short[]) {
+                return nullSafeHashCode((short[]) obj);
+            }
+        }
+        return obj.hashCode();
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(Object[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (Object element : array) {
+            hash = MULTIPLIER * hash + nullSafeHashCode(element);
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(boolean[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (boolean element : array) {
+            hash = MULTIPLIER * hash + hashCode(element);
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(byte[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (byte element : array) {
+            hash = MULTIPLIER * hash + element;
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(char[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (char element : array) {
+            hash = MULTIPLIER * hash + element;
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(double[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (double element : array) {
+            hash = MULTIPLIER * hash + hashCode(element);
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(float[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (float element : array) {
+            hash = MULTIPLIER * hash + hashCode(element);
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(int[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (int element : array) {
+            hash = MULTIPLIER * hash + element;
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(long[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (long element : array) {
+            hash = MULTIPLIER * hash + hashCode(element);
+        }
+        return hash;
+    }
+
+    /**
+     * Return a hash code based on the contents of the specified array. If
+     * {@code array} is {@code null}, this method returns 0.
+     * @param array
+     * @return 
+     */
+    public static int nullSafeHashCode(short[] array) {
+        if (array == null) {
+            return 0;
+        }
+        int hash = INITIAL_HASH;
+        for (short element : array) {
+            hash = MULTIPLIER * hash + element;
+        }
+        return hash;
+    }
+
+    /**
+     * Return the same value as {@link Boolean#hashCode()}}.
+     *
+     * @param bool
+     * @return 
+     * @see Boolean#hashCode()
+     */
+    public static int hashCode(boolean bool) {
+        return (bool ? 1231 : 1237);
+    }
+
+    /**
+     * Return the same value as {@link Double#hashCode()}}.
+     *
+     * @param dbl
+     * @return 
+     * @see Double#hashCode()
+     */
+    public static int hashCode(double dbl) {
+        return hashCode(Double.doubleToLongBits(dbl));
+    }
+
+    /**
+     * Return the same value as {@link Float#hashCode()}}.
+     *
+     * @param flt
+     * @return 
+     * @see Float#hashCode()
+     */
+    public static int hashCode(float flt) {
+        return Float.floatToIntBits(flt);
+    }
+
+    /**
+     * Return the same value as {@link Long#hashCode()}}.
+     *
+     * @param lng
+     * @return 
+     * @see Long#hashCode()
+     */
+    public static int hashCode(long lng) {
+        return (int) (lng ^ (lng >>> 32));
+    }
+
+	//---------------------------------------------------------------------
+    // Convenience methods for toString output
+    //---------------------------------------------------------------------
+    /**
+     * Return a String representation of an object's overall identity.
+     *
+     * @param obj the object (may be {@code null})
+     * @return the object's identity as String representation, or an empty
+     * String if the object was {@code null}
+     */
+    public static String identityToString(Object obj) {
+        if (obj == null) {
+            return EMPTY_STRING;
+        }
+        return obj.getClass().getName() + "@" + getIdentityHexString(obj);
+    }
+
+    /**
+     * Return a hex String form of an object's identity hash code.
+     *
+     * @param obj the object
+     * @return the object's identity code in hex notation
+     */
+    public static String getIdentityHexString(Object obj) {
+        return Integer.toHexString(System.identityHashCode(obj));
+    }
+
+    /**
+     * Return a content-based String representation if {@code obj} is not
+     * {@code null}; otherwise returns an empty String.
+     * <p>
+     * Differs from {@link #nullSafeToString(Object)} in that it returns an
+     * empty String rather than "null" for a {@code null} value.
+     *
+     * @param obj the object to build a display String for
+     * @return a display String representation of {@code obj}
+     * @see #nullSafeToString(Object)
+     */
+    public static String getDisplayString(Object obj) {
+        if (obj == null) {
+            return EMPTY_STRING;
+        }
+        return nullSafeToString(obj);
+    }
+
+    /**
+     * Determine the class name for the given object.
+     * <p>
+     * Returns {@code "null"} if {@code obj} is {@code null}.
+     *
+     * @param obj the object to introspect (may be {@code null})
+     * @return the corresponding class name
+     */
+    public static String nullSafeClassName(Object obj) {
+        return (obj != null ? obj.getClass().getName() : NULL_STRING);
+    }
+
+    /**
+     * Return a String representation of the specified Object.
+     * <p>
+     * Builds a String representation of the contents in case of an array.
+     * Returns {@code "null"} if {@code obj} is {@code null}.
+     *
+     * @param obj the object to build a String representation for
+     * @return a String representation of {@code obj}
+     */
+    public static String nullSafeToString(Object obj) {
+        if (obj == null) {
+            return NULL_STRING;
+        }
+        if (obj instanceof String) {
+            return (String) obj;
+        }
+        if (obj instanceof Object[]) {
+            return nullSafeToString((Object[]) obj);
+        }
+        if (obj instanceof boolean[]) {
+            return nullSafeToString((boolean[]) obj);
+        }
+        if (obj instanceof byte[]) {
+            return nullSafeToString((byte[]) obj);
+        }
+        if (obj instanceof char[]) {
+            return nullSafeToString((char[]) obj);
+        }
+        if (obj instanceof double[]) {
+            return nullSafeToString((double[]) obj);
+        }
+        if (obj instanceof float[]) {
+            return nullSafeToString((float[]) obj);
+        }
+        if (obj instanceof int[]) {
+            return nullSafeToString((int[]) obj);
+        }
+        if (obj instanceof long[]) {
+            return nullSafeToString((long[]) obj);
+        }
+        if (obj instanceof short[]) {
+            return nullSafeToString((short[]) obj);
+        }
+        String str = obj.toString();
+        return (str != null ? str : EMPTY_STRING);
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(Object[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+            sb.append(String.valueOf(array[i]));
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(boolean[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(byte[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(char[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+            sb.append("'").append(array[i]).append("'");
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(double[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(float[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(int[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(long[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+
+    /**
+     * Return a String representation of the contents of the specified array.
+     * <p>
+     * The String representation consists of a list of the array's elements,
+     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
+     * by the characters {@code ", "} (a comma followed by a space). Returns
+     * {@code "null"} if {@code array} is {@code null}.
+     *
+     * @param array the array to build a String representation for
+     * @return a String representation of {@code array}
+     */
+    public static String nullSafeToString(short[] array) {
+        if (array == null) {
+            return NULL_STRING;
+        }
+        int length = array.length;
+        if (length == 0) {
+            return EMPTY_ARRAY;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < length; i++) {
+            if (i == 0) {
+                sb.append(ARRAY_START);
+            } else {
+                sb.append(ARRAY_ELEMENT_SEPARATOR);
+            }
+            sb.append(array[i]);
+        }
+        sb.append(ARRAY_END);
+        return sb.toString();
+    }
+}
diff --git a/src/main/java/component/utils/PathUtils.java b/src/main/java/component/utils/PathUtils.java
new file mode 100644
index 0000000..73c3f8a
--- /dev/null
+++ b/src/main/java/component/utils/PathUtils.java
@@ -0,0 +1,92 @@
+package component.utils;
+
+import java.util.*;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+public abstract class PathUtils {
+
+    private static final Pattern separatorRegex = Pattern.compile("\\\\|/");
+
+    /**
+     * Resolves the given {@code relativePath} based on the given
+     * {@code anchorPath}.
+     *
+     * @param relativePath      the relative path which should be resolved.
+     * @param anchorPath        the anchor path based on which the relative path should be
+     *                          resolved on.
+     * @param expectedSeparator The character expected to be used as a separator; dictated by the Loader.
+     * @return the resolved path or {@code null} when the path could not be
+     * resolved.
+     */
+    public static String resolveRelativePath(String relativePath, String anchorPath, char expectedSeparator) {
+        if (relativePath == null || relativePath.isEmpty()) {
+            return null;
+        }
+
+        // ensure both paths use the same separator character
+        relativePath = sanitize(relativePath, expectedSeparator);
+        anchorPath = sanitize(anchorPath, expectedSeparator);
+
+        if (relativePath.startsWith(".." + expectedSeparator) || relativePath.startsWith("." + expectedSeparator)) {
+            return resolvePathInner(relativePath, anchorPath, expectedSeparator);
+        }
+
+        return null;
+    }
+
+    private static String sanitize(String path, char expectedSeparator){
+        return separatorRegex.matcher(path).replaceAll(Matcher.quoteReplacement(String.valueOf(expectedSeparator)));
+    }
+
+    private static String resolvePathInner(String relativePath, String anchorPath, char separator) {
+        StringBuilder resultingPath = new StringBuilder();
+
+        resolvePathSegments(determineAnchorPathSegments(anchorPath, separator),
+                splitBySeparator(relativePath, separator)).stream().forEach((segment) -> {
+                    resultingPath.append(segment).append(separator);
+        });
+
+        // remove the erroneous separator added at the end
+        return resultingPath.substring(0, resultingPath.length() - 1);
+    }
+
+    private static Collection<String> determineAnchorPathSegments(String anchorPath, char separator) {
+        if (anchorPath == null || anchorPath.isEmpty()) {
+            return new ArrayList<>();
+        }
+        ArrayDeque<String> anchorPathSegments = new ArrayDeque<>(splitBySeparator(anchorPath, separator));
+        if (anchorPath.charAt(anchorPath.length() - 1) != separator) {
+            anchorPathSegments.pollLast();
+        }
+        return anchorPathSegments;
+    }
+
+    private static Collection<String> resolvePathSegments(Collection<String> anchorSegments,
+            Collection<String> relativeSegments) {
+        ArrayDeque<String> result = new ArrayDeque<>(anchorSegments);
+        relativeSegments.stream().forEach((String segment) -> {
+            switch (segment) {
+                case ".": // do nothing
+                    break;
+                case "..":
+                    result.pollLast();
+                    break;
+                default:
+                    result.add(segment);
+                    break;
+            }
+        });
+
+        return result;
+    }
+
+    private static List<String> splitBySeparator(String path, char separator) {
+        return Arrays.asList(path.split(Pattern.quote(String.valueOf(separator))));
+    }
+
+    private PathUtils() {
+        throw new IllegalAccessError();
+    }
+
+}
diff --git a/src/main/java/component/utils/ReflectionUtils.java b/src/main/java/component/utils/ReflectionUtils.java
new file mode 100644
index 0000000..c17f753
--- /dev/null
+++ b/src/main/java/component/utils/ReflectionUtils.java
@@ -0,0 +1,877 @@
+package component.utils;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.lang.reflect.UndeclaredThrowableException;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Simple utility class for working with the reflection API and handling
+ * reflection exceptions.
+ *
+ * <p>
+ * Only intended for internal use.
+ *
+ */
+public abstract class ReflectionUtils {
+
+    /**
+     * Naming prefix for CGLIB-renamed methods.
+     *
+     * @see #isCglibRenamedMethod
+     */
+    private static final String CGLIB_RENAMED_METHOD_PREFIX = "CGLIB$";
+
+    private static final Method[] NO_METHODS = {};
+
+    private static final Field[] NO_FIELDS = {};
+
+    /**
+     * Cache for {@link Class#getDeclaredMethods()} plus equivalent default
+     * methods from Java 8 based interfaces, allowing for fast iteration.
+     */
+    private static final Map<Class<?>, Method[]> declaredMethodsCache
+            = new ConcurrentHashMap<>(256);
+
+    /**
+     * Cache for {@link Class#getDeclaredFields()}, allowing for fast iteration.
+     */
+    private static final Map<Class<?>, Field[]> declaredFieldsCache
+            = new ConcurrentHashMap<>(256);
+
+    /**
+     * Attempt to find a {@link Field field} on the supplied {@link Class} with
+     * the supplied {@code name}. Searches all superclasses up to
+     * {@link Object}.
+     *
+     * @param clazz the class to introspect
+     * @param name the name of the field
+     * @return the corresponding Field object, or {@code null} if not found
+     */
+    public static Field findField(Class<?> clazz, String name) {
+        return findField(clazz, name, null);
+    }
+
+    /**
+     * Attempt to find a {@link Field field} on the supplied {@link Class} with
+     * the supplied {@code name} and/or {@link Class type}. Searches all
+     * superclasses up to {@link Object}.
+     *
+     * @param clazz the class to introspect
+     * @param name the name of the field (may be {@code null} if type is
+     * specified)
+     * @param type the type of the field (may be {@code null} if name is
+     * specified)
+     * @return the corresponding Field object, or {@code null} if not found
+     */
+    public static Field findField(Class<?> clazz, String name, Class<?> type) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.isTrue(name != null || type != null, "Either name or type of the field must be specified");
+        Class<?> searchType = clazz;
+        while (Object.class != searchType && searchType != null) {
+            Field[] fields = getDeclaredFields(searchType);
+            for (Field field : fields) {
+                if ((name == null || name.equals(field.getName()))
+                        && (type == null || type.equals(field.getType()))) {
+                    return field;
+                }
+            }
+            searchType = searchType.getSuperclass();
+        }
+        return null;
+    }
+
+    /**
+     * Set the field represented by the supplied {@link Field field object} on
+     * the specified {@link Object target object} to the specified
+     * {@code value}. In accordance with {@link Field#set(Object, Object)}
+     * semantics, the new value is automatically unwrapped if the underlying
+     * field has a primitive type.
+     * <p>
+     * Thrown exceptions are handled via a call to
+     * {@link #handleReflectionException(Exception)}.
+     *
+     * @param field the field to set
+     * @param target the target object on which to set the field
+     * @param value the value to set (may be {@code null})
+     */
+    public static void setField(Field field, Object target, Object value) {
+        try {
+            field.set(target, value);
+        } catch (IllegalAccessException ex) {
+            handleReflectionException(ex);
+            throw new IllegalStateException(
+                    "Unexpected reflection exception - " + ex.getClass().getName() + ": " + ex.getMessage());
+        }
+    }
+
+    /**
+     * Get the field represented by the supplied {@link Field field object} on
+     * the specified {@link Object target object}. In accordance with
+     * {@link Field#get(Object)} semantics, the returned value is automatically
+     * wrapped if the underlying field has a primitive type.
+     * <p>
+     * Thrown exceptions are handled via a call to
+     * {@link #handleReflectionException(Exception)}.
+     *
+     * @param field the field to get
+     * @param target the target object from which to get the field
+     * @return the field's current value
+     */
+    public static Object getField(Field field, Object target) {
+        try {
+            return field.get(target);
+        } catch (IllegalAccessException ex) {
+            handleReflectionException(ex);
+            throw new IllegalStateException(
+                    "Unexpected reflection exception - " + ex.getClass().getName() + ": " + ex.getMessage());
+        }
+    }
+
+    /**
+     * Attempt to find a {@link Method} on the supplied class with the supplied
+     * name and no parameters. Searches all superclasses up to {@code Object}.
+     * <p>
+     * Returns {@code null} if no {@link Method} can be found.
+     *
+     * @param clazz the class to introspect
+     * @param name the name of the method
+     * @return the Method object, or {@code null} if none found
+     */
+    public static Method findMethod(Class<?> clazz, String name) {
+        return findMethod(clazz, name, new Class<?>[0]);
+    }
+
+    /**
+     * Attempt to find a {@link Method} on the supplied class with the supplied
+     * name and parameter types. Searches all superclasses up to {@code Object}.
+     * <p>
+     * Returns {@code null} if no {@link Method} can be found.
+     *
+     * @param clazz the class to introspect
+     * @param name the name of the method
+     * @param paramTypes the parameter types of the method (may be {@code null}
+     * to indicate any signature)
+     * @return the Method object, or {@code null} if none found
+     */
+    public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes) {
+        Assert.notNull(clazz, "Class must not be null");
+        Assert.notNull(name, "Method name must not be null");
+        Class<?> searchType = clazz;
+        while (searchType != null) {
+            Method[] methods = (searchType.isInterface() ? searchType.getMethods() : getDeclaredMethods(searchType));
+            for (Method method : methods) {
+                if (name.equals(method.getName())
+                        && (paramTypes == null || Arrays.equals(paramTypes, method.getParameterTypes()))) {
+                    return method;
+                }
+            }
+            searchType = searchType.getSuperclass();
+        }
+        return null;
+    }
+
+    /**
+     * Invoke the specified {@link Method} against the supplied target object
+     * with no arguments. The target object can be {@code null} when invoking a
+     * static {@link Method}.
+     * <p>
+     * Thrown exceptions are handled via a call to
+     * {@link #handleReflectionException}.
+     *
+     * @param method the method to invoke
+     * @param target the target object to invoke the method on
+     * @return the invocation result, if any
+     * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])
+     */
+    public static Object invokeMethod(Method method, Object target) {
+        return invokeMethod(method, target, new Object[0]);
+    }
+
+    /**
+     * Invoke the specified {@link Method} against the supplied target object
+     * with the supplied arguments. The target object can be {@code null} when
+     * invoking a static {@link Method}.
+     * <p>
+     * Thrown exceptions are handled via a call to
+     * {@link #handleReflectionException}.
+     *
+     * @param method the method to invoke
+     * @param target the target object to invoke the method on
+     * @param args the invocation arguments (may be {@code null})
+     * @return the invocation result, if any
+     */
+    public static Object invokeMethod(Method method, Object target, Object... args) {
+        try {
+            return method.invoke(target, args);
+        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
+            handleReflectionException(ex);
+        }
+        throw new IllegalStateException("Should never get here");
+    }
+
+    /**
+     * Invoke the specified JDBC API {@link Method} against the supplied target
+     * object with no arguments.
+     *
+     * @param method the method to invoke
+     * @param target the target object to invoke the method on
+     * @return the invocation result, if any
+     * @throws SQLException the JDBC API SQLException to rethrow (if any)
+     * @see #invokeJdbcMethod(java.lang.reflect.Method, Object, Object[])
+     */
+    public static Object invokeJdbcMethod(Method method, Object target) throws SQLException {
+        return invokeJdbcMethod(method, target, new Object[0]);
+    }
+
+    /**
+     * Invoke the specified JDBC API {@link Method} against the supplied target
+     * object with the supplied arguments.
+     *
+     * @param method the method to invoke
+     * @param target the target object to invoke the method on
+     * @param args the invocation arguments (may be {@code null})
+     * @return the invocation result, if any
+     * @throws SQLException the JDBC API SQLException to rethrow (if any)
+     * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])
+     */
+    public static Object invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException {
+        try {
+            return method.invoke(target, args);
+        } catch (IllegalAccessException ex) {
+            handleReflectionException(ex);
+        } catch (InvocationTargetException ex) {
+            if (ex.getTargetException() instanceof SQLException) {
+                throw (SQLException) ex.getTargetException();
+            }
+            handleInvocationTargetException(ex);
+        }
+        throw new IllegalStateException("Should never get here");
+    }
+
+    /**
+     * Handle the given reflection exception. Should only be called if no
+     * checked exception is expected to be thrown by the target method.
+     * <p>
+     * Throws the underlying RuntimeException or Error in case of an
+     * InvocationTargetException with such a root cause. Throws an
+     * IllegalStateException with an appropriate message or
+     * UndeclaredThrowableException otherwise.
+     *
+     * @param ex the reflection exception to handle
+     */
+    public static void handleReflectionException(Exception ex) {
+        if (ex instanceof NoSuchMethodException) {
+            throw new IllegalStateException("Method not found: " + ex.getMessage());
+        }
+        if (ex instanceof IllegalAccessException) {
+            throw new IllegalStateException("Could not access method: " + ex.getMessage());
+        }
+        if (ex instanceof InvocationTargetException) {
+            handleInvocationTargetException((InvocationTargetException) ex);
+        }
+        if (ex instanceof RuntimeException) {
+            throw (RuntimeException) ex;
+        }
+        throw new UndeclaredThrowableException(ex);
+    }
+
+    /**
+     * Handle the given invocation target exception. Should only be called if no
+     * checked exception is expected to be thrown by the target method.
+     * <p>
+     * Throws the underlying RuntimeException or Error in case of such a root
+     * cause. Throws an UndeclaredThrowableException otherwise.
+     *
+     * @param ex the invocation target exception to handle
+     */
+    public static void handleInvocationTargetException(InvocationTargetException ex) {
+        rethrowRuntimeException(ex.getTargetException());
+    }
+
+    /**
+     * Rethrow the given {@link Throwable exception}, which is presumably the
+     * <em>target exception</em> of an {@link InvocationTargetException}. Should
+     * only be called if no checked exception is expected to be thrown by the
+     * target method.
+     * <p>
+     * Rethrows the underlying exception cast to a {@link RuntimeException} or
+     * {@link Error} if appropriate; otherwise, throws an
+     * {@link UndeclaredThrowableException}.
+     *
+     * @param ex the exception to rethrow
+     * @throws RuntimeException the rethrown exception
+     */
+    public static void rethrowRuntimeException(Throwable ex) {
+        if (ex instanceof RuntimeException) {
+            throw (RuntimeException) ex;
+        }
+        if (ex instanceof Error) {
+            throw (Error) ex;
+        }
+        throw new UndeclaredThrowableException(ex);
+    }
+
+    /**
+     * Rethrow the given {@link Throwable exception}, which is presumably the
+     * <em>target exception</em> of an {@link InvocationTargetException}. Should
+     * only be called if no checked exception is expected to be thrown by the
+     * target method.
+     * <p>
+     * Rethrows the underlying exception cast to an {@link Exception} or
+     * {@link Error} if appropriate; otherwise, throws an
+     * {@link UndeclaredThrowableException}.
+     *
+     * @param ex the exception to rethrow
+     * @throws Exception the rethrown exception (in case of a checked exception)
+     */
+    public static void rethrowException(Throwable ex) throws Exception {
+        if (ex instanceof Exception) {
+            throw (Exception) ex;
+        }
+        if (ex instanceof Error) {
+            throw (Error) ex;
+        }
+        throw new UndeclaredThrowableException(ex);
+    }
+
+    /**
+     * Determine whether the given method explicitly declares the given
+     * exception or one of its superclasses, which means that an exception of
+     * that type can be propagated as-is within a reflective invocation.
+     *
+     * @param method the declaring method
+     * @param exceptionType the exception to throw
+     * @return {@code true} if the exception can be thrown as-is; {@code false}
+     * if it needs to be wrapped
+     */
+    public static boolean declaresException(Method method, Class<?> exceptionType) {
+        Assert.notNull(method, "Method must not be null");
+        Class<?>[] declaredExceptions = method.getExceptionTypes();
+        for (Class<?> declaredException : declaredExceptions) {
+            if (declaredException.isAssignableFrom(exceptionType)) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Determine whether the given field is a "public static final" constant.
+     *
+     * @param field the field to check
+     * @return
+     */
+    public static boolean isPublicStaticFinal(Field field) {
+        int modifiers = field.getModifiers();
+        return (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers));
+    }
+
+    /**
+     * Determine whether the given method is an "equals" method.
+     *
+     * @param method
+     * @return
+     * @see java.lang.Object#equals(Object)
+     */
+    public static boolean isEqualsMethod(Method method) {
+        if (method == null || !method.getName().equals("equals")) {
+            return false;
+        }
+        Class<?>[] paramTypes = method.getParameterTypes();
+        return (paramTypes.length == 1 && paramTypes[0] == Object.class);
+    }
+
+    /**
+     * Determine whether the given method is a "hashCode" method.
+     *
+     * @param method
+     * @return
+     * @see java.lang.Object#hashCode()
+     */
+    public static boolean isHashCodeMethod(Method method) {
+        return (method != null && method.getName().equals("hashCode") && method.getParameterCount() == 0);
+    }
+
+    /**
+     * Determine whether the given method is a "toString" method.
+     *
+     * @param method
+     * @return
+     * @see java.lang.Object#toString()
+     */
+    public static boolean isToStringMethod(Method method) {
+        return (method != null && method.getName().equals("toString") && method.getParameterCount() == 0);
+    }
+
+    /**
+     * Determine whether the given method is originally declared by
+     * {@link java.lang.Object}.
+     *
+     * @param method
+     * @return
+     */
+    public static boolean isObjectMethod(Method method) {
+        if (method == null) {
+            return false;
+        }
+        try {
+            Object.class.getDeclaredMethod(method.getName(), method.getParameterTypes());
+            return true;
+        } catch (NoSuchMethodException | SecurityException ex) {
+            return false;
+        }
+    }
+
+    /**
+     * Determine whether the given method is a CGLIB 'renamed' method, following
+     * the pattern "CGLIB$methodName$0".
+     *
+     * @param renamedMethod the method to check
+     * @return
+     * @see org.springframework.cglib.proxy.Enhancer#rename
+     */
+    public static boolean isCglibRenamedMethod(Method renamedMethod) {
+        String name = renamedMethod.getName();
+        if (name.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {
+            int i = name.length() - 1;
+            while (i >= 0 && Character.isDigit(name.charAt(i))) {
+                i--;
+            }
+            return ((i > CGLIB_RENAMED_METHOD_PREFIX.length())
+                    && (i < name.length() - 1) && name.charAt(i) == '$');
+        }
+        return false;
+    }
+
+    /**
+     * Make the given field accessible, explicitly setting it accessible if
+     * necessary. The {@code setAccessible(true)} method is only called when
+     * actually necessary, to avoid unnecessary conflicts with a JVM
+     * SecurityManager (if active).
+     *
+     * @param field the field to make accessible
+     * @see java.lang.reflect.Field#setAccessible
+     */
+    public static void makeAccessible(Field field) {
+        if ((!Modifier.isPublic(field.getModifiers())
+                || !Modifier.isPublic(field.getDeclaringClass().getModifiers())
+                || Modifier.isFinal(field.getModifiers())) && !field.isAccessible()) {
+            field.setAccessible(true);
+        }
+    }
+
+    /**
+     * Make the given method accessible, explicitly setting it accessible if
+     * necessary. The {@code setAccessible(true)} method is only called when
+     * actually necessary, to avoid unnecessary conflicts with a JVM
+     * SecurityManager (if active).
+     *
+     * @param method the method to make accessible
+     * @see java.lang.reflect.Method#setAccessible
+     */
+    public static void makeAccessible(Method method) {
+        if ((!Modifier.isPublic(method.getModifiers())
+                || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible()) {
+            method.setAccessible(true);
+        }
+    }
+
+    /**
+     * Make the given constructor accessible, explicitly setting it accessible
+     * if necessary. The {@code setAccessible(true)} method is only called when
+     * actually necessary, to avoid unnecessary conflicts with a JVM
+     * SecurityManager (if active).
+     *
+     * @param ctor the constructor to make accessible
+     * @see java.lang.reflect.Constructor#setAccessible
+     */
+    public static void makeAccessible(Constructor<?> ctor) {
+        if ((!Modifier.isPublic(ctor.getModifiers())
+                || !Modifier.isPublic(ctor.getDeclaringClass().getModifiers())) && !ctor.isAccessible()) {
+            ctor.setAccessible(true);
+        }
+    }
+
+    /**
+     * Obtain an accessible constructor for the given class and parameters.
+     *
+     * @param clazz the clazz to check
+     * @param parameterTypes the parameter types of the desired constructor
+     * @return the constructor reference
+     * @throws NoSuchMethodException if no such constructor exists
+     * @since 5.0
+     */
+    public static <T> Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes)
+            throws NoSuchMethodException {
+
+        Constructor<T> ctor = clazz.getDeclaredConstructor(parameterTypes);
+        makeAccessible(ctor);
+        return ctor;
+    }
+
+    /**
+     * Perform the given callback operation on all matching methods of the given
+     * class, as locally declared or equivalent thereof (such as default methods
+     * on Java 8 based interfaces that the given class implements).
+     *
+     * @param clazz the class to introspect
+     * @param mc the callback to invoke for each method
+     * @since 4.2
+     * @see #doWithMethods
+     */
+    public static void doWithLocalMethods(Class<?> clazz, MethodCallback mc) {
+        Method[] methods = getDeclaredMethods(clazz);
+        for (Method method : methods) {
+            try {
+                mc.doWith(method);
+            } catch (IllegalAccessException ex) {
+                throw new IllegalStateException("Not allowed to access method '" + method.getName() + "': " + ex);
+            }
+        }
+    }
+
+    /**
+     * Perform the given callback operation on all matching methods of the given
+     * class and superclasses.
+     * <p>
+     * The same named method occurring on subclass and superclass will appear
+     * twice, unless excluded by a {@link MethodFilter}.
+     *
+     * @param clazz the class to introspect
+     * @param mc the callback to invoke for each method
+     * @see #doWithMethods(Class, MethodCallback, MethodFilter)
+     */
+    public static void doWithMethods(Class<?> clazz, MethodCallback mc) {
+        doWithMethods(clazz, mc, null);
+    }
+
+    /**
+     * Perform the given callback operation on all matching methods of the given
+     * class and superclasses (or given interface and super-interfaces).
+     * <p>
+     * The same named method occurring on subclass and superclass will appear
+     * twice, unless excluded by the specified {@link MethodFilter}.
+     *
+     * @param clazz the class to introspect
+     * @param mc the callback to invoke for each method
+     * @param mf the filter that determines the methods to apply the callback to
+     */
+    public static void doWithMethods(Class<?> clazz, MethodCallback mc, MethodFilter mf) {
+        // Keep backing up the inheritance hierarchy.
+        Method[] methods = getDeclaredMethods(clazz);
+        for (Method method : methods) {
+            if (mf != null && !mf.matches(method)) {
+                continue;
+            }
+            try {
+                mc.doWith(method);
+            } catch (IllegalAccessException ex) {
+                throw new IllegalStateException("Not allowed to access method '" + method.getName() + "': " + ex);
+            }
+        }
+        if (clazz.getSuperclass() != null) {
+            doWithMethods(clazz.getSuperclass(), mc, mf);
+        } else if (clazz.isInterface()) {
+            for (Class<?> superIfc : clazz.getInterfaces()) {
+                doWithMethods(superIfc, mc, mf);
+            }
+        }
+    }
+
+    /**
+     * Get all declared methods on the leaf class and all superclasses. Leaf
+     * class methods are included first.
+     *
+     * @param leafClass the class to introspect
+     * @return
+     */
+    public static Method[] getAllDeclaredMethods(Class<?> leafClass) {
+        final List<Method> methods = new ArrayList<>(32);
+        doWithMethods(leafClass, methods::add);
+        return methods.toArray(new Method[methods.size()]);
+    }
+
+    /**
+     * Get the unique set of declared methods on the leaf class and all
+     * superclasses. Leaf class methods are included first and while traversing
+     * the superclass hierarchy any methods found with signatures matching a
+     * method already included are filtered out.
+     *
+     * @param leafClass the class to introspect
+     * @return
+     */
+    public static Method[] getUniqueDeclaredMethods(Class<?> leafClass) {
+        final List<Method> methods = new ArrayList<>(32);
+        doWithMethods(leafClass, (Method method) -> {
+            boolean knownSignature = false;
+            Method methodBeingOverriddenWithCovariantReturnType = null;
+            for (Method existingMethod : methods) {
+                if (method.getName().equals(existingMethod.getName())
+                        && Arrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {
+                    // Is this a covariant return type situation?
+                    if (existingMethod.getReturnType() != method.getReturnType()
+                            && existingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {
+                        methodBeingOverriddenWithCovariantReturnType = existingMethod;
+                    } else {
+                        knownSignature = true;
+                    }
+                    break;
+                }
+            }
+            if (methodBeingOverriddenWithCovariantReturnType != null) {
+                methods.remove(methodBeingOverriddenWithCovariantReturnType);
+            }
+            if (!knownSignature && !isCglibRenamedMethod(method)) {
+                methods.add(method);
+            }
+        });
+        return methods.toArray(new Method[methods.size()]);
+    }
+
+    /**
+     * This variant retrieves {@link Class#getDeclaredMethods()} from a local
+     * cache in order to avoid the JVM's SecurityManager check and defensive
+     * array copying. In addition, it also includes Java 8 default methods from
+     * locally implemented interfaces, since those are effectively to be treated
+     * just like declared methods.
+     *
+     * @param clazz the class to introspect
+     * @return the cached array of methods
+     * @see Class#getDeclaredMethods()
+     */
+    private static Method[] getDeclaredMethods(Class<?> clazz) {
+        Method[] result = declaredMethodsCache.get(clazz);
+        if (result == null) {
+            Method[] declaredMethods = clazz.getDeclaredMethods();
+            List<Method> defaultMethods = findConcreteMethodsOnInterfaces(clazz);
+            if (defaultMethods != null) {
+                result = new Method[declaredMethods.length + defaultMethods.size()];
+                System.arraycopy(declaredMethods, 0, result, 0, declaredMethods.length);
+                int index = declaredMethods.length;
+                for (Method defaultMethod : defaultMethods) {
+                    result[index] = defaultMethod;
+                    index++;
+                }
+            } else {
+                result = declaredMethods;
+            }
+            declaredMethodsCache.put(clazz, (result.length == 0 ? NO_METHODS : result));
+        }
+        return result;
+    }
+
+    private static List<Method> findConcreteMethodsOnInterfaces(Class<?> clazz) {
+        List<Method> result = null;
+        for (Class<?> ifc : clazz.getInterfaces()) {
+            for (Method ifcMethod : ifc.getMethods()) {
+                if (!Modifier.isAbstract(ifcMethod.getModifiers())) {
+                    if (result == null) {
+                        result = new LinkedList<>();
+                    }
+                    result.add(ifcMethod);
+                }
+            }
+        }
+        return result;
+    }
+
+    /**
+     * Invoke the given callback on all fields in the target class, going up the
+     * class hierarchy to get all declared fields.
+     *
+     * @param clazz the target class to analyze
+     * @param fc the callback to invoke for each field
+     * @since 4.2
+     * @see #doWithFields
+     */
+    public static void doWithLocalFields(Class<?> clazz, FieldCallback fc) {
+        for (Field field : getDeclaredFields(clazz)) {
+            try {
+                fc.doWith(field);
+            } catch (IllegalAccessException ex) {
+                throw new IllegalStateException("Not allowed to access field '" + field.getName() + "': " + ex);
+            }
+        }
+    }
+
+    /**
+     * Invoke the given callback on all fields in the target class, going up the
+     * class hierarchy to get all declared fields.
+     *
+     * @param clazz the target class to analyze
+     * @param fc the callback to invoke for each field
+     */
+    public static void doWithFields(Class<?> clazz, FieldCallback fc) {
+        doWithFields(clazz, fc, null);
+    }
+
+    /**
+     * Invoke the given callback on all fields in the target class, going up the
+     * class hierarchy to get all declared fields.
+     *
+     * @param clazz the target class to analyze
+     * @param fc the callback to invoke for each field
+     * @param ff the filter that determines the fields to apply the callback to
+     */
+    public static void doWithFields(Class<?> clazz, FieldCallback fc, FieldFilter ff) {
+        // Keep backing up the inheritance hierarchy.
+        Class<?> targetClass = clazz;
+        do {
+            Field[] fields = getDeclaredFields(targetClass);
+            for (Field field : fields) {
+                if (ff != null && !ff.matches(field)) {
+                    continue;
+                }
+                try {
+                    fc.doWith(field);
+                } catch (IllegalAccessException ex) {
+                    throw new IllegalStateException("Not allowed to access field '" + field.getName() + "': " + ex);
+                }
+            }
+            targetClass = targetClass.getSuperclass();
+        } while (targetClass != null && targetClass != Object.class);
+    }
+
+    /**
+     * This variant retrieves {@link Class#getDeclaredFields()} from a local
+     * cache in order to avoid the JVM's SecurityManager check and defensive
+     * array copying.
+     *
+     * @param clazz the class to introspect
+     * @return the cached array of fields
+     * @see Class#getDeclaredFields()
+     */
+    private static Field[] getDeclaredFields(Class<?> clazz) {
+        Field[] result = declaredFieldsCache.get(clazz);
+        if (result == null) {
+            result = clazz.getDeclaredFields();
+            declaredFieldsCache.put(clazz, (result.length == 0 ? NO_FIELDS : result));
+        }
+        return result;
+    }
+
+    /**
+     * Given the source object and the destination, which must be the same class
+     * or a subclass, copy all fields, including inherited fields. Designed to
+     * work on objects with public no-arg constructors.
+     *
+     * @param src
+     * @param dest
+     */
+    public static void shallowCopyFieldState(final Object src, final Object dest) {
+        if (src == null) {
+            throw new IllegalArgumentException("Source for field copy cannot be null");
+        }
+        if (dest == null) {
+            throw new IllegalArgumentException("Destination for field copy cannot be null");
+        }
+        if (!src.getClass().isAssignableFrom(dest.getClass())) {
+            throw new IllegalArgumentException("Destination class [" + dest.getClass().getName()
+                    + "] must be same or subclass as source class [" + src.getClass().getName() + "]");
+        }
+        doWithFields(src.getClass(), (Field field) -> {
+            makeAccessible(field);
+            Object srcValue = field.get(src);
+            field.set(dest, srcValue);
+        }, COPYABLE_FIELDS);
+    }
+
+    /**
+     * Clear the internal method/field cache.
+     *
+     * @since 4.2.4
+     */
+    public static void clearCache() {
+        declaredMethodsCache.clear();
+        declaredFieldsCache.clear();
+    }
+
+    /**
+     * Action to take on each method.
+     */
+    @FunctionalInterface
+    public interface MethodCallback {
+
+        /**
+         * Perform an operation using the given method.
+         *
+         * @param method the method to operate on
+         * @throws java.lang.IllegalAccessException
+         */
+        void doWith(Method method) throws IllegalArgumentException, IllegalAccessException;
+    }
+
+    /**
+     * Callback optionally used to filter methods to be operated on by a method
+     * callback.
+     */
+    @FunctionalInterface
+    public interface MethodFilter {
+
+        /**
+         * Determine whether the given method matches.
+         *
+         * @param method the method to check
+         * @return
+         */
+        boolean matches(Method method);
+    }
+
+    /**
+     * Callback interface invoked on each field in the hierarchy.
+     */
+    @FunctionalInterface
+    public interface FieldCallback {
+
+        /**
+         * Perform an operation using the given field.
+         *
+         * @param field the field to operate on
+         * @throws java.lang.IllegalAccessException
+         */
+        void doWith(Field field) throws IllegalArgumentException, IllegalAccessException;
+    }
+
+    /**
+     * Callback optionally used to filter fields to be operated on by a field
+     * callback.
+     */
+    @FunctionalInterface
+    public interface FieldFilter {
+
+        /**
+         * Determine whether the given field matches.
+         *
+         * @param field the field to check
+         * @return
+         */
+        boolean matches(Field field);
+    }
+
+    /**
+     * Pre-built FieldFilter that matches all non-static, non-final fields.
+     */
+    public static final FieldFilter COPYABLE_FIELDS = (Field field) -> !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));
+
+    /**
+     * Pre-built MethodFilter that matches all non-bridge methods.
+     */
+    public static final MethodFilter NON_BRIDGED_METHODS = (Method method) -> !method.isBridge();
+
+    /**
+     * Pre-built MethodFilter that matches all non-bridge methods which are not
+     * declared on {@code java.lang.Object}.
+     */
+    public static final MethodFilter USER_DECLARED_METHODS = (Method method) -> (!method.isBridge() && method.getDeclaringClass() != Object.class);
+
+}
diff --git a/src/main/java/component/utils/ResourceUtils.java b/src/main/java/component/utils/ResourceUtils.java
new file mode 100644
index 0000000..b495855
--- /dev/null
+++ b/src/main/java/component/utils/ResourceUtils.java
@@ -0,0 +1,432 @@
+/*
+ * Copyright 2002-2015 the original author or authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package component.utils;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.net.MalformedURLException;
+import java.net.URI;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.net.URLConnection;
+
+/**
+ * Utility methods for resolving resource locations to files in the file system.
+ * Mainly for internal use within the framework.
+ *
+ * <p>
+ * Consider using Spring's Resource abstraction in the core package for handling
+ * all kinds of file resources in a uniform manner.
+ * {@link org.springframework.core.io.ResourceLoader}'s {@code getResource()}
+ * method can resolve any location to a
+ * {@link org.springframework.core.io.Resource} object, which in turn allows one
+ * to obtain a {@code java.io.File} in the file system through its
+ * {@code getFile()} method.
+ *
+ * <p>
+ * The main reason for these utility methods for resource location handling is
+ * to support {@link Log4jConfigurer}, which must be able to resolve resource
+ * locations <i>before the logging system has been initialized</i>. Spring's
+ * {@code Resource} abstraction in the core package, on the other hand, already
+ * expects the logging system to be available.
+ *
+ * @author Juergen Hoeller
+ * @since 1.1.5
+ * @see org.springframework.core.io.Resource
+ * @see org.springframework.core.io.ClassPathResource
+ * @see org.springframework.core.io.FileSystemResource
+ * @see org.springframework.core.io.UrlResource
+ * @see org.springframework.core.io.ResourceLoader
+ */
+public abstract class ResourceUtils {
+
+    /**
+     * Pseudo URL prefix for loading from the class path: "classpath:"
+     */
+    public static final String CLASSPATH_URL_PREFIX = "classpath:";
+
+    /**
+     * URL prefix for loading from the file system: "file:"
+     */
+    public static final String FILE_URL_PREFIX = "file:";
+
+    /**
+     * URL prefix for loading from a jar file: "jar:"
+     */
+    public static final String JAR_URL_PREFIX = "jar:";
+
+    /**
+     * URL prefix for loading from a war file on Tomcat: "war:"
+     */
+    public static final String WAR_URL_PREFIX = "war:";
+
+    /**
+     * URL protocol for a file in the file system: "file"
+     */
+    public static final String URL_PROTOCOL_FILE = "file";
+
+    /**
+     * URL protocol for an entry from a jar file: "jar"
+     */
+    public static final String URL_PROTOCOL_JAR = "jar";
+
+    /**
+     * URL protocol for an entry from a zip file: "zip"
+     */
+    public static final String URL_PROTOCOL_ZIP = "zip";
+
+    /**
+     * URL protocol for an entry from a WebSphere jar file: "wsjar"
+     */
+    public static final String URL_PROTOCOL_WSJAR = "wsjar";
+
+    /**
+     * URL protocol for an entry from a JBoss jar file: "vfszip"
+     */
+    public static final String URL_PROTOCOL_VFSZIP = "vfszip";
+
+    /**
+     * URL protocol for a JBoss file system resource: "vfsfile"
+     */
+    public static final String URL_PROTOCOL_VFSFILE = "vfsfile";
+
+    /**
+     * URL protocol for a general JBoss VFS resource: "vfs"
+     */
+    public static final String URL_PROTOCOL_VFS = "vfs";
+
+    /**
+     * File extension for a regular jar file: ".jar"
+     */
+    public static final String JAR_FILE_EXTENSION = ".jar";
+
+    /**
+     * Separator between JAR URL and file path within the JAR: "!/"
+     */
+    public static final String JAR_URL_SEPARATOR = "!/";
+
+    /**
+     * Special separator between WAR URL and jar part on Tomcat
+     */
+    public static final String WAR_URL_SEPARATOR = "*/";
+
+    /**
+     * Return whether the given resource location is a URL: either a special
+     * "classpath" pseudo URL or a standard URL.
+     *
+     * @param resourceLocation the location String to check
+     * @return whether the location qualifies as a URL
+     * @see #CLASSPATH_URL_PREFIX
+     * @see java.net.URL
+     */
+    public static boolean isUrl(String resourceLocation) {
+        if (resourceLocation == null) {
+            return false;
+        }
+        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
+            return true;
+        }
+        try {
+            URL url = new URL(resourceLocation);
+            return true;
+        } catch (MalformedURLException ex) {
+            return false;
+        }
+    }
+
+    /**
+     * Resolve the given resource location to a {@code java.net.URL}.
+     * <p>
+     * Does not check whether the URL actually exists; simply returns the URL
+     * that the given location would correspond to.
+     *
+     * @param resourceLocation the resource location to resolve: either a
+     * "classpath:" pseudo URL, a "file:" URL, or a plain file path
+     * @return a corresponding URL object
+     * @throws FileNotFoundException if the resource cannot be resolved to a URL
+     */
+    public static URL getURL(String resourceLocation) throws FileNotFoundException {
+        Assert.notNull(resourceLocation, "Resource location must not be null");
+        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
+            String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());
+            ClassLoader cl = ClassUtils.getDefaultClassLoader();
+            URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));
+            if (url == null) {
+                String description = "class path resource [" + path + "]";
+                throw new FileNotFoundException(description
+                        + " cannot be resolved to URL because it does not exist");
+            }
+            return url;
+        }
+        try {
+            // try URL
+            return new URL(resourceLocation);
+        } catch (MalformedURLException ex) {
+            // no URL -> treat as file path
+            try {
+                return new File(resourceLocation).toURI().toURL();
+            } catch (MalformedURLException ex2) {
+                throw new FileNotFoundException("Resource location [" + resourceLocation
+                        + "] is neither a URL not a well-formed file path");
+            }
+        }
+    }
+
+    /**
+     * Resolve the given resource location to a {@code java.io.File}, i.e. to a
+     * file in the file system.
+     * <p>
+     * Does not check whether the file actually exists; simply returns the File
+     * that the given location would correspond to.
+     *
+     * @param resourceLocation the resource location to resolve: either a
+     * "classpath:" pseudo URL, a "file:" URL, or a plain file path
+     * @return a corresponding File object
+     * @throws FileNotFoundException if the resource cannot be resolved to a
+     * file in the file system
+     */
+    public static File getFile(String resourceLocation) throws FileNotFoundException {
+        Assert.notNull(resourceLocation, "Resource location must not be null");
+        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
+            String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());
+            String description = "class path resource [" + path + "]";
+            ClassLoader cl = ClassUtils.getDefaultClassLoader();
+            URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));
+            if (url == null) {
+                throw new FileNotFoundException(description
+                        + " cannot be resolved to absolute file path because it does not exist");
+            }
+            return getFile(url, description);
+        }
+        try {
+            // try URL
+            return getFile(new URL(resourceLocation));
+        } catch (MalformedURLException ex) {
+            // no URL -> treat as file path
+            return new File(resourceLocation);
+        }
+    }
+
+    /**
+     * Resolve the given resource URL to a {@code java.io.File}, i.e. to a file
+     * in the file system.
+     *
+     * @param resourceUrl the resource URL to resolve
+     * @return a corresponding File object
+     * @throws FileNotFoundException if the URL cannot be resolved to a file in
+     * the file system
+     */
+    public static File getFile(URL resourceUrl) throws FileNotFoundException {
+        return getFile(resourceUrl, "URL");
+    }
+
+    /**
+     * Resolve the given resource URL to a {@code java.io.File}, i.e. to a file
+     * in the file system.
+     *
+     * @param resourceUrl the resource URL to resolve
+     * @param description a description of the original resource that the URL
+     * was created for (for example, a class path location)
+     * @return a corresponding File object
+     * @throws FileNotFoundException if the URL cannot be resolved to a file in
+     * the file system
+     */
+    public static File getFile(URL resourceUrl, String description) throws FileNotFoundException {
+        Assert.notNull(resourceUrl, "Resource URL must not be null");
+        if (!URL_PROTOCOL_FILE.equals(resourceUrl.getProtocol())) {
+            throw new FileNotFoundException(
+                    description + " cannot be resolved to absolute file path "
+                    + "because it does not reside in the file system: " + resourceUrl);
+        }
+        try {
+            return new File(toURI(resourceUrl).getSchemeSpecificPart());
+        } catch (URISyntaxException ex) {
+            // Fallback for URLs that are not valid URIs (should hardly ever happen).
+            return new File(resourceUrl.getFile());
+        }
+    }
+
+    /**
+     * Resolve the given resource URI to a {@code java.io.File}, i.e. to a file
+     * in the file system.
+     *
+     * @param resourceUri the resource URI to resolve
+     * @return a corresponding File object
+     * @throws FileNotFoundException if the URL cannot be resolved to a file in
+     * the file system
+     */
+    public static File getFile(URI resourceUri) throws FileNotFoundException {
+        return getFile(resourceUri, "URI");
+    }
+
+    /**
+     * Resolve the given resource URI to a {@code java.io.File}, i.e. to a file
+     * in the file system.
+     *
+     * @param resourceUri the resource URI to resolve
+     * @param description a description of the original resource that the URI
+     * was created for (for example, a class path location)
+     * @return a corresponding File object
+     * @throws FileNotFoundException if the URL cannot be resolved to a file in
+     * the file system
+     */
+    public static File getFile(URI resourceUri, String description) throws FileNotFoundException {
+        Assert.notNull(resourceUri, "Resource URI must not be null");
+        if (!URL_PROTOCOL_FILE.equals(resourceUri.getScheme())) {
+            throw new FileNotFoundException(
+                    description + " cannot be resolved to absolute file path "
+                    + "because it does not reside in the file system: " + resourceUri);
+        }
+        return new File(resourceUri.getSchemeSpecificPart());
+    }
+
+    /**
+     * Determine whether the given URL points to a resource in the file system,
+     * that is, has protocol "file", "vfsfile" or "vfs".
+     *
+     * @param url the URL to check
+     * @return whether the URL has been identified as a file system URL
+     */
+    public static boolean isFileURL(URL url) {
+        String protocol = url.getProtocol();
+        return (URL_PROTOCOL_FILE.equals(protocol) || URL_PROTOCOL_VFSFILE.equals(protocol)
+                || URL_PROTOCOL_VFS.equals(protocol));
+    }
+
+    /**
+     * Determine whether the given URL points to a resource in a jar file, that
+     * is, has protocol "jar", "zip", "vfszip" or "wsjar".
+     *
+     * @param url the URL to check
+     * @return whether the URL has been identified as a JAR URL
+     */
+    public static boolean isJarURL(URL url) {
+        String protocol = url.getProtocol();
+        return (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_ZIP.equals(protocol)
+                || URL_PROTOCOL_VFSZIP.equals(protocol) || URL_PROTOCOL_WSJAR.equals(protocol));
+    }
+
+    /**
+     * Determine whether the given URL points to a jar file itself, that is, has
+     * protocol "file" and ends with the ".jar" extension.
+     *
+     * @param url the URL to check
+     * @return whether the URL has been identified as a JAR file URL
+     * @since 4.1
+     */
+    public static boolean isJarFileURL(URL url) {
+        return (URL_PROTOCOL_FILE.equals(url.getProtocol())
+                && url.getPath().toLowerCase().endsWith(JAR_FILE_EXTENSION));
+    }
+
+    /**
+     * Extract the URL for the actual jar file from the given URL (which may
+     * point to a resource in a jar file or to a jar file itself).
+     *
+     * @param jarUrl the original URL
+     * @return the URL for the actual jar file
+     * @throws MalformedURLException if no valid jar file URL could be extracted
+     */
+    public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException {
+        String urlFile = jarUrl.getFile();
+        int separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR);
+        if (separatorIndex != -1) {
+            String jarFile = urlFile.substring(0, separatorIndex);
+            try {
+                return new URL(jarFile);
+            } catch (MalformedURLException ex) {
+				// Probably no protocol in original jar URL, like "jar:C:/mypath/myjar.jar".
+                // This usually indicates that the jar file resides in the file system.
+                if (!jarFile.startsWith("/")) {
+                    jarFile = "/" + jarFile;
+                }
+                return new URL(FILE_URL_PREFIX + jarFile);
+            }
+        } else {
+            return jarUrl;
+        }
+    }
+
+    /**
+     * Extract the URL for the outermost archive from the given jar/war URL
+     * (which may point to a resource in a jar file or to a jar file itself).
+     * <p>
+     * In the case of a jar file nested within a war file, this will return a
+     * URL to the war file since that is the one resolvable in the file system.
+     *
+     * @param jarUrl the original URL
+     * @return the URL for the actual jar file
+     * @throws MalformedURLException if no valid jar file URL could be extracted
+     * @since 4.1.8
+     * @see #extractJarFileURL(URL)
+     */
+    public static URL extractArchiveURL(URL jarUrl) throws MalformedURLException {
+        String urlFile = jarUrl.getFile();
+
+        int endIndex = urlFile.indexOf(WAR_URL_SEPARATOR);
+        if (endIndex != -1) {
+            // Tomcat's "jar:war:file:...mywar.war*/WEB-INF/lib/myjar.jar!/myentry.txt"
+            String warFile = urlFile.substring(0, endIndex);
+            int startIndex = warFile.indexOf(WAR_URL_PREFIX);
+            if (startIndex != -1) {
+                return new URL(warFile.substring(startIndex + WAR_URL_PREFIX.length()));
+            }
+        }
+
+        // Regular "jar:file:...myjar.jar!/myentry.txt"
+        return extractJarFileURL(jarUrl);
+    }
+
+    /**
+     * Create a URI instance for the given URL, replacing spaces with "%20" URI
+     * encoding first.
+     * <p>
+     * Furthermore, this method works on JDK 1.4 as well, in contrast to the
+     * {@code URL.toURI()} method.
+     *
+     * @param url the URL to convert into a URI instance
+     * @return the URI instance
+     * @throws URISyntaxException if the URL wasn't a valid URI
+     * @see java.net.URL#toURI()
+     */
+    public static URI toURI(URL url) throws URISyntaxException {
+        return toURI(url.toString());
+    }
+
+    /**
+     * Create a URI instance for the given location String, replacing spaces
+     * with "%20" URI encoding first.
+     *
+     * @param location the location String to convert into a URI instance
+     * @return the URI instance
+     * @throws URISyntaxException if the location wasn't a valid URI
+     */
+    public static URI toURI(String location) throws URISyntaxException {
+        return new URI(StringUtils.replace(location, " ", "%20"));
+    }
+
+    /**
+     * Set the {@link URLConnection#setUseCaches "useCaches"} flag on the given
+     * connection, preferring {@code false} but leaving the flag at {@code true}
+     * for JNLP based resources.
+     *
+     * @param con the URLConnection to set the flag on
+     */
+    public static void useCachesIfNecessary(URLConnection con) {
+        con.setUseCaches(con.getClass().getSimpleName().startsWith("JNLP"));
+    }
+
+}
diff --git a/src/main/java/component/utils/StringUtils.java b/src/main/java/component/utils/StringUtils.java
new file mode 100644
index 0000000..a3a12cd
--- /dev/null
+++ b/src/main/java/component/utils/StringUtils.java
@@ -0,0 +1,1304 @@
+package component.utils;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Enumeration;
+import java.util.Iterator;
+import java.util.LinkedHashSet;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Locale;
+import java.util.Properties;
+import java.util.Set;
+import java.util.StringTokenizer;
+import java.util.TimeZone;
+
+/**
+ *
+ * @author cdi305
+ */
+public abstract class StringUtils {
+
+    private static final String FOLDER_SEPARATOR = "/";
+
+    private static final String WINDOWS_FOLDER_SEPARATOR = "\\";
+
+    private static final String TOP_PATH = "..";
+
+    private static final String CURRENT_PATH = ".";
+
+    private static final char EXTENSION_SEPARATOR = '.';
+    
+
+    //---------------------------------------------------------------------
+    // General convenience methods for working with Strings
+    //---------------------------------------------------------------------
+    
+    
+    /**
+     * Check whether the given {@code String} is empty.
+     * <p>
+     * This method accepts any Object as an argument, comparing it to
+     * {@code null} and the empty String. As a consequence, this method will
+     * never return {@code true} for a non-null non-String object.
+     * <p>
+     * The Object signature is useful for general attribute handling code that
+     * commonly deals with Strings but generally has to iterate over Objects
+     * since attributes may e.g. be primitive value objects as well.
+     *
+     * @param str the candidate String
+     * @return 
+     * @since 3.2.1
+     */
+    public static boolean isEmpty(Object str) {
+        return (str == null || "".equals(str));
+    }
+
+    /**
+     * Check that the given {@code CharSequence} is neither {@code null} nor of
+     * length 0.
+     * <p>
+     * Note: this method returns {@code true} for a {@code CharSequence} that
+     * purely consists of whitespace.
+     * <p>
+     * <pre class="code">
+     * StringUtils.hasLength(null) = false StringUtils.hasLength("") = false
+     * StringUtils.hasLength(" ") = true StringUtils.hasLength("Hello") = true
+     * </pre>
+     *
+     * @param str the {@code CharSequence} to check (may be {@code null})
+     * @return {@code true} if the {@code CharSequence} is not {@code null} and
+     * has length
+     * @see #hasText(String)
+     */
+    public static boolean hasLength(CharSequence str) {
+        return (str != null && str.length() > 0);
+    }
+
+    /**
+     * Check that the given {@code String} is neither {@code null} nor of length
+     * 0.
+     * <p>
+     * Note: this method returns {@code true} for a {@code String} that purely
+     * consists of whitespace.
+     *
+     * @param str the {@code String} to check (may be {@code null})
+     * @return {@code true} if the {@code String} is not {@code null} and has
+     * length
+     * @see #hasLength(CharSequence)
+     * @see #hasText(String)
+     */
+    public static boolean hasLength(String str) {
+        return hasLength((CharSequence) str);
+    }
+
+    /**
+     * Check whether the given {@code CharSequence} contains actual
+     * <em>text</em>.
+     * <p>
+     * More specifically, this method returns {@code true} if the
+     * {@code CharSequence} is not {@code null}, its length is greater than 0,
+     * and it contains at least one non-whitespace character.
+     * <p>
+     * <pre class="code">
+     * StringUtils.hasText(null) = false StringUtils.hasText("") = false
+     * StringUtils.hasText(" ") = false StringUtils.hasText("12345") = true
+     * StringUtils.hasText(" 12345 ") = true
+     * </pre>
+     *
+     * @param str the {@code CharSequence} to check (may be {@code null})
+     * @return {@code true} if the {@code CharSequence} is not {@code null}, its
+     * length is greater than 0, and it does not contain whitespace only
+     * @see Character#isWhitespace
+     */
+    public static boolean hasText(CharSequence str) {
+        if (!hasLength(str)) {
+            return false;
+        }
+        int strLen = str.length();
+        for (int i = 0; i < strLen; i++) {
+            if (!Character.isWhitespace(str.charAt(i))) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Check whether the given {@code String} contains actual <em>text</em>.
+     * <p>
+     * More specifically, this method returns {@code true} if the {@code String}
+     * is not {@code null}, its length is greater than 0, and it contains at
+     * least one non-whitespace character.
+     *
+     * @param str the {@code String} to check (may be {@code null})
+     * @return {@code true} if the {@code String} is not {@code null}, its
+     * length is greater than 0, and it does not contain whitespace only
+     * @see #hasText(CharSequence)
+     */
+    public static boolean hasText(String str) {
+        return hasText((CharSequence) str);
+    }
+
+    /**
+     * Check whether the given {@code CharSequence} contains any whitespace
+     * characters.
+     *
+     * @param str the {@code CharSequence} to check (may be {@code null})
+     * @return {@code true} if the {@code CharSequence} is not empty and
+     * contains at least 1 whitespace character
+     * @see Character#isWhitespace
+     */
+    public static boolean containsWhitespace(CharSequence str) {
+        if (!hasLength(str)) {
+            return false;
+        }
+        int strLen = str.length();
+        for (int i = 0; i < strLen; i++) {
+            if (Character.isWhitespace(str.charAt(i))) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+    /**
+     * Check whether the given {@code String} contains any whitespace
+     * characters.
+     *
+     * @param str the {@code String} to check (may be {@code null})
+     * @return {@code true} if the {@code String} is not empty and contains at
+     * least 1 whitespace character
+     * @see #containsWhitespace(CharSequence)
+     */
+    public static boolean containsWhitespace(String str) {
+        return containsWhitespace((CharSequence) str);
+    }
+
+    /**
+     * Trim leading and trailing whitespace from the given {@code String}.
+     *
+     * @param str the {@code String} to check
+     * @return the trimmed {@code String}
+     * @see java.lang.Character#isWhitespace
+     */
+    public static String trimWhitespace(String str) {
+        if (!hasLength(str)) {
+            return str;
+        }
+        StringBuilder sb = new StringBuilder(str);
+        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
+            sb.deleteCharAt(0);
+        }
+        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {
+            sb.deleteCharAt(sb.length() - 1);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Trim <i>all</i> whitespace from the given {@code String}: leading,
+     * trailing, and in between characters.
+     *
+     * @param str the {@code String} to check
+     * @return the trimmed {@code String}
+     * @see java.lang.Character#isWhitespace
+     */
+    public static String trimAllWhitespace(String str) {
+        if (!hasLength(str)) {
+            return str;
+        }
+        int len = str.length();
+        StringBuilder sb = new StringBuilder(str.length());
+        for (int i = 0; i < len; i++) {
+            char c = str.charAt(i);
+            if (!Character.isWhitespace(c)) {
+                sb.append(c);
+            }
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Trim leading whitespace from the given {@code String}.
+     *
+     * @param str the {@code String} to check
+     * @return the trimmed {@code String}
+     * @see java.lang.Character#isWhitespace
+     */
+    public static String trimLeadingWhitespace(String str) {
+        if (!hasLength(str)) {
+            return str;
+        }
+        StringBuilder sb = new StringBuilder(str);
+        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
+            sb.deleteCharAt(0);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Trim trailing whitespace from the given {@code String}.
+     *
+     * @param str the {@code String} to check
+     * @return the trimmed {@code String}
+     * @see java.lang.Character#isWhitespace
+     */
+    public static String trimTrailingWhitespace(String str) {
+        if (!hasLength(str)) {
+            return str;
+        }
+        StringBuilder sb = new StringBuilder(str);
+        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {
+            sb.deleteCharAt(sb.length() - 1);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Trim all occurrences of the supplied leading character from the given
+     * {@code String}.
+     *
+     * @param str the {@code String} to check
+     * @param leadingCharacter the leading character to be trimmed
+     * @return the trimmed {@code String}
+     */
+    public static String trimLeadingCharacter(String str, char leadingCharacter) {
+        if (!hasLength(str)) {
+            return str;
+        }
+        StringBuilder sb = new StringBuilder(str);
+        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {
+            sb.deleteCharAt(0);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Trim all occurrences of the supplied trailing character from the given
+     * {@code String}.
+     *
+     * @param str the {@code String} to check
+     * @param trailingCharacter the trailing character to be trimmed
+     * @return the trimmed {@code String}
+     */
+    public static String trimTrailingCharacter(String str, char trailingCharacter) {
+        if (!hasLength(str)) {
+            return str;
+        }
+        StringBuilder sb = new StringBuilder(str);
+        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {
+            sb.deleteCharAt(sb.length() - 1);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Test if the given {@code String} starts with the specified prefix,
+     * ignoring upper/lower case.
+     *
+     * @param str the {@code String} to check
+     * @param prefix the prefix to look for
+     * @see java.lang.String#startsWith
+     */
+    public static boolean startsWithIgnoreCase(String str, String prefix) {
+        if (str == null || prefix == null) {
+            return false;
+        }
+        if (str.startsWith(prefix)) {
+            return true;
+        }
+        if (str.length() < prefix.length()) {
+            return false;
+        }
+        String lcStr = str.substring(0, prefix.length()).toLowerCase();
+        String lcPrefix = prefix.toLowerCase();
+        return lcStr.equals(lcPrefix);
+    }
+
+    /**
+     * Test if the given {@code String} ends with the specified suffix, ignoring
+     * upper/lower case.
+     *
+     * @param str the {@code String} to check
+     * @param suffix the suffix to look for
+     * @see java.lang.String#endsWith
+     */
+    public static boolean endsWithIgnoreCase(String str, String suffix) {
+        if (str == null || suffix == null) {
+            return false;
+        }
+        if (str.endsWith(suffix)) {
+            return true;
+        }
+        if (str.length() < suffix.length()) {
+            return false;
+        }
+
+        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();
+        String lcSuffix = suffix.toLowerCase();
+        return lcStr.equals(lcSuffix);
+    }
+
+    /**
+     * Test whether the given string matches the given substring at the given
+     * index.
+     *
+     * @param str the original string (or StringBuilder)
+     * @param index the index in the original string to start matching against
+     * @param substring the substring to match at the given index
+     */
+    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {
+        for (int j = 0; j < substring.length(); j++) {
+            int i = index + j;
+            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Count the occurrences of the substring {@code sub} in string {@code str}.
+     *
+     * @param str string to search in. Return 0 if this is {@code null}.
+     * @param sub string to search for. Return 0 if this is {@code null}.
+     */
+    public static int countOccurrencesOf(String str, String sub) {
+        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {
+            return 0;
+        }
+        int count = 0;
+        int pos = 0;
+        int idx;
+        while ((idx = str.indexOf(sub, pos)) != -1) {
+            ++count;
+            pos = idx + sub.length();
+        }
+        return count;
+    }
+
+    /**
+     * Replace all occurrences of a substring within a string with another
+     * string.
+     *
+     * @param inString {@code String} to examine
+     * @param oldPattern {@code String} to replace
+     * @param newPattern {@code String} to insert
+     * @return a {@code String} with the replacements
+     */
+    public static String replace(String inString, String oldPattern, String newPattern) {
+        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {
+            return inString;
+        }
+        StringBuilder sb = new StringBuilder();
+        int pos = 0; // our position in the old string
+        int index = inString.indexOf(oldPattern);
+        // the index of an occurrence we've found, or -1
+        int patLen = oldPattern.length();
+        while (index >= 0) {
+            sb.append(inString.substring(pos, index));
+            sb.append(newPattern);
+            pos = index + patLen;
+            index = inString.indexOf(oldPattern, pos);
+        }
+        sb.append(inString.substring(pos));
+        // remember to append any characters to the right of a match
+        return sb.toString();
+    }
+
+    /**
+     * Delete all occurrences of the given substring.
+     *
+     * @param inString the original {@code String}
+     * @param pattern the pattern to delete all occurrences of
+     * @return the resulting {@code String}
+     */
+    public static String delete(String inString, String pattern) {
+        return replace(inString, pattern, "");
+    }
+
+    /**
+     * Delete any character in a given {@code String}.
+     *
+     * @param inString the original {@code String}
+     * @param charsToDelete a set of characters to delete. E.g. "az\n" will
+     * delete 'a's, 'z's and new lines.
+     * @return the resulting {@code String}
+     */
+    public static String deleteAny(String inString, String charsToDelete) {
+        if (!hasLength(inString) || !hasLength(charsToDelete)) {
+            return inString;
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < inString.length(); i++) {
+            char c = inString.charAt(i);
+            if (charsToDelete.indexOf(c) == -1) {
+                sb.append(c);
+            }
+        }
+        return sb.toString();
+    }
+
+	//---------------------------------------------------------------------
+    // Convenience methods for working with formatted Strings
+    //---------------------------------------------------------------------
+    /**
+     * Quote the given {@code String} with single quotes.
+     *
+     * @param str the input {@code String} (e.g. "myString")
+     * @return the quoted {@code String} (e.g. "'myString'"), or {@code null} if
+     * the input was {@code null}
+     */
+    public static String quote(String str) {
+        return (str != null ? "'" + str + "'" : null);
+    }
+
+    /**
+     * Turn the given Object into a {@code String} with single quotes if it is a
+     * {@code String}; keeping the Object as-is else.
+     *
+     * @param obj the input Object (e.g. "myString")
+     * @return the quoted {@code String} (e.g. "'myString'"), or the input
+     * object as-is if not a {@code String}
+     */
+    public static Object quoteIfString(Object obj) {
+        return (obj instanceof String ? quote((String) obj) : obj);
+    }
+
+    /**
+     * Unqualify a string qualified by a '.' dot character. For example,
+     * "this.name.is.qualified", returns "qualified".
+     *
+     * @param qualifiedName the qualified name
+     * @return 
+     */
+    public static String unqualify(String qualifiedName) {
+        return unqualify(qualifiedName, '.');
+    }
+
+    /**
+     * Unqualify a string qualified by a separator character. For example,
+     * "this:name:is:qualified" returns "qualified" if using a ':' separator.
+     *
+     * @param qualifiedName the qualified name
+     * @param separator the separator
+     * @return 
+     */
+    public static String unqualify(String qualifiedName, char separator) {
+        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);
+    }
+
+    /**
+     * Capitalize a {@code String}, changing the first letter to upper case as
+     * per {@link Character#toUpperCase(char)}. No other letters are changed.
+     *
+     * @param str the {@code String} to capitalize, may be {@code null}
+     * @return the capitalized {@code String}, or {@code null} if the supplied
+     * string is {@code null}
+     */
+    public static String capitalize(String str) {
+        return changeFirstCharacterCase(str, true);
+    }
+
+    /**
+     * Uncapitalize a {@code String}, changing the first letter to lower case as
+     * per {@link Character#toLowerCase(char)}. No other letters are changed.
+     *
+     * @param str the {@code String} to uncapitalize, may be {@code null}
+     * @return the uncapitalized {@code String}, or {@code null} if the supplied
+     * string is {@code null}
+     */
+    public static String uncapitalize(String str) {
+        return changeFirstCharacterCase(str, false);
+    }
+
+    private static String changeFirstCharacterCase(String str, boolean capitalize) {
+        if (str == null || str.length() == 0) {
+            return str;
+        }
+        StringBuilder sb = new StringBuilder(str.length());
+        if (capitalize) {
+            sb.append(Character.toUpperCase(str.charAt(0)));
+        } else {
+            sb.append(Character.toLowerCase(str.charAt(0)));
+        }
+        sb.append(str.substring(1));
+        return sb.toString();
+    }
+
+    /**
+     * Extract the filename from the given Java resource path, e.g.
+     * {@code "mypath/myfile.txt" -> "myfile.txt"}.
+     *
+     * @param path the file path (may be {@code null})
+     * @return the extracted filename, or {@code null} if none
+     */
+    public static String getFilename(String path) {
+        if (path == null) {
+            return null;
+        }
+        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);
+        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);
+    }
+
+    /**
+     * Extract the filename extension from the given Java resource path, e.g.
+     * "mypath/myfile.txt" -> "txt".
+     *
+     * @param path the file path (may be {@code null})
+     * @return the extracted filename extension, or {@code null} if none
+     */
+    public static String getFilenameExtension(String path) {
+        if (path == null) {
+            return null;
+        }
+        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);
+        if (extIndex == -1) {
+            return null;
+        }
+        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);
+        if (folderIndex > extIndex) {
+            return null;
+        }
+        return path.substring(extIndex + 1);
+    }
+
+    /**
+     * Strip the filename extension from the given Java resource path, e.g.
+     * "mypath/myfile.txt" -> "mypath/myfile".
+     *
+     * @param path the file path (may be {@code null})
+     * @return the path with stripped filename extension, or {@code null} if
+     * none
+     */
+    public static String stripFilenameExtension(String path) {
+        if (path == null) {
+            return null;
+        }
+        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);
+        if (extIndex == -1) {
+            return path;
+        }
+        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);
+        if (folderIndex > extIndex) {
+            return path;
+        }
+        return path.substring(0, extIndex);
+    }
+
+    /**
+     * Apply the given relative path to the given Java resource path, assuming
+     * standard Java folder separation (i.e. "/" separators).
+     *
+     * @param path the path to start from (usually a full file path)
+     * @param relativePath the relative path to apply (relative to the full file
+     * path above)
+     * @return the full file path that results from applying the relative path
+     */
+    public static String applyRelativePath(String path, String relativePath) {
+        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);
+        if (separatorIndex != -1) {
+            String newPath = path.substring(0, separatorIndex);
+            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {
+                newPath += FOLDER_SEPARATOR;
+            }
+            return newPath + relativePath;
+        } else {
+            return relativePath;
+        }
+    }
+
+    /**
+     * Normalize the path by suppressing sequences like "path/.." and inner
+     * simple dots.
+     * <p>
+     * The result is convenient for path comparison. For other uses, notice that
+     * Windows separators ("\") are replaced by simple slashes.
+     *
+     * @param path the original path
+     * @return the normalized path
+     */
+    public static String cleanPath(String path) {
+        if (path == null) {
+            return null;
+        }
+        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);
+
+		// Strip prefix from path to analyze, to not treat it as part of the
+        // first path element. This is necessary to correctly parse paths like
+        // "file:core/../core/io/Resource.class", where the ".." should just
+        // strip the first "core" directory while keeping the "file:" prefix.
+        int prefixIndex = pathToUse.indexOf(":");
+        String prefix = "";
+        if (prefixIndex != -1) {
+            prefix = pathToUse.substring(0, prefixIndex + 1);
+            if (prefix.contains("/")) {
+                prefix = "";
+            } else {
+                pathToUse = pathToUse.substring(prefixIndex + 1);
+            }
+        }
+        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {
+            prefix = prefix + FOLDER_SEPARATOR;
+            pathToUse = pathToUse.substring(1);
+        }
+
+        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);
+        List<String> pathElements = new LinkedList<>();
+        int tops = 0;
+
+        for (int i = pathArray.length - 1; i >= 0; i--) {
+            String element = pathArray[i];
+            if (null != element) switch (element) {
+                case CURRENT_PATH:
+                    break;
+                case TOP_PATH:
+                    // Registering top path found.
+                    tops++;
+                    break;
+                default:
+                    if (tops > 0) {
+                        // Merging path element with element corresponding to top path.
+                        tops--;
+                    } else {
+                        // Normal path element found.
+                        pathElements.add(0, element);
+                    }   break;
+            }
+        }
+
+        // Remaining top paths need to be retained.
+        for (int i = 0; i < tops; i++) {
+            pathElements.add(0, TOP_PATH);
+        }
+
+        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);
+    }
+
+    /**
+     * Compare two paths after normalization of them.
+     *
+     * @param path1 first path for comparison
+     * @param path2 second path for comparison
+     * @return whether the two paths are equivalent after normalization
+     */
+    public static boolean pathEquals(String path1, String path2) {
+        return cleanPath(path1).equals(cleanPath(path2));
+    }
+
+    /**
+     * Parse the given {@code localeString} value into a {@link Locale}.
+     * <p>
+     * This is the inverse operation of
+     * {@link Locale#toString Locale's toString}.
+     *
+     * @param localeString the locale {@code String}, following {@code Locale's}
+     * {@code toString()} format ("en", "en_UK", etc); also accepts spaces as
+     * separators, as an alternative to underscores
+     * @return a corresponding {@code Locale} instance
+     * @throws IllegalArgumentException in case of an invalid locale
+     * specification
+     */
+    public static Locale parseLocaleString(String localeString) {
+        String[] parts = tokenizeToStringArray(localeString, "_ ", false, false);
+        String language = (parts.length > 0 ? parts[0] : "");
+        String country = (parts.length > 1 ? parts[1] : "");
+        validateLocalePart(language);
+        validateLocalePart(country);
+        String variant = "";
+        if (parts.length > 2) {
+			// There is definitely a variant, and it is everything after the country
+            // code sans the separator between the country code and the variant.
+            int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length();
+            // Strip off any leading '_' and whitespace, what's left is the variant.
+            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));
+            if (variant.startsWith("_")) {
+                variant = trimLeadingCharacter(variant, '_');
+            }
+        }
+        return (language.length() > 0 ? new Locale(language, country, variant) : null);
+    }
+
+    private static void validateLocalePart(String localePart) {
+        for (int i = 0; i < localePart.length(); i++) {
+            char ch = localePart.charAt(i);
+            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {
+                throw new IllegalArgumentException(
+                        "Locale part \"" + localePart + "\" contains invalid characters");
+            }
+        }
+    }
+
+    /**
+     * Determine the RFC 3066 compliant language tag, as used for the HTTP
+     * "Accept-Language" header.
+     *
+     * @param locale the Locale to transform to a language tag
+     * @return the RFC 3066 compliant language tag as {@code String}
+     */
+    public static String toLanguageTag(Locale locale) {
+        return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "");
+    }
+
+    /**
+     * Parse the given {@code timeZoneString} value into a {@link TimeZone}.
+     *
+     * @param timeZoneString the time zone {@code String}, following
+     * {@link TimeZone#getTimeZone(String)} but throwing
+     * {@link IllegalArgumentException} in case of an invalid time zone
+     * specification
+     * @return a corresponding {@link TimeZone} instance
+     * @throws IllegalArgumentException in case of an invalid time zone
+     * specification
+     */
+    public static TimeZone parseTimeZoneString(String timeZoneString) {
+        TimeZone timeZone = TimeZone.getTimeZone(timeZoneString);
+        if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {
+            // We don't want that GMT fallback...
+            throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'");
+        }
+        return timeZone;
+    }
+
+	//---------------------------------------------------------------------
+    // Convenience methods for working with String arrays
+    //---------------------------------------------------------------------
+    /**
+     * Append the given {@code String} to the given {@code String} array,
+     * returning a new array consisting of the input array contents plus the
+     * given {@code String}.
+     *
+     * @param array the array to append to (can be {@code null})
+     * @param str the {@code String} to append
+     * @return the new array (never {@code null})
+     */
+    public static String[] addStringToArray(String[] array, String str) {
+        if (ObjectUtils.isEmpty(array)) {
+            return new String[]{str};
+        }
+        String[] newArr = new String[array.length + 1];
+        System.arraycopy(array, 0, newArr, 0, array.length);
+        newArr[array.length] = str;
+        return newArr;
+    }
+
+    /**
+     * Concatenate the given {@code String} arrays into one, with overlapping
+     * array elements included twice.
+     * <p>
+     * The order of elements in the original arrays is preserved.
+     *
+     * @param array1 the first array (can be {@code null})
+     * @param array2 the second array (can be {@code null})
+     * @return the new array ({@code null} if both given arrays were
+     * {@code null})
+     */
+    public static String[] concatenateStringArrays(String[] array1, String[] array2) {
+        if (ObjectUtils.isEmpty(array1)) {
+            return array2;
+        }
+        if (ObjectUtils.isEmpty(array2)) {
+            return array1;
+        }
+        String[] newArr = new String[array1.length + array2.length];
+        System.arraycopy(array1, 0, newArr, 0, array1.length);
+        System.arraycopy(array2, 0, newArr, array1.length, array2.length);
+        return newArr;
+    }
+
+    /**
+     * Merge the given {@code String} arrays into one, with overlapping array
+     * elements only included once.
+     * <p>
+     * The order of elements in the original arrays is preserved (with the
+     * exception of overlapping elements, which are only included on their first
+     * occurrence).
+     *
+     * @param array1 the first array (can be {@code null})
+     * @param array2 the second array (can be {@code null})
+     * @return the new array ({@code null} if both given arrays were
+     * {@code null})
+     */
+    public static String[] mergeStringArrays(String[] array1, String[] array2) {
+        if (ObjectUtils.isEmpty(array1)) {
+            return array2;
+        }
+        if (ObjectUtils.isEmpty(array2)) {
+            return array1;
+        }
+        List<String> result = new ArrayList<>();
+        result.addAll(Arrays.asList(array1));
+        for (String str : array2) {
+            if (!result.contains(str)) {
+                result.add(str);
+            }
+        }
+        return toStringArray(result);
+    }
+
+    /**
+     * Turn given source {@code String} array into sorted array.
+     *
+     * @param array the source array
+     * @return the sorted array (never {@code null})
+     */
+    public static String[] sortStringArray(String[] array) {
+        if (ObjectUtils.isEmpty(array)) {
+            return new String[0];
+        }
+        Arrays.sort(array);
+        return array;
+    }
+
+    /**
+     * Copy the given {@code Collection} into a {@code String} array.
+     * <p>
+     * The {@code Collection} must contain {@code String} elements only.
+     *
+     * @param collection the {@code Collection} to copy
+     * @return the {@code String} array ({@code null} if the supplied
+     * {@code Collection} was {@code null})
+     */
+    public static String[] toStringArray(Collection<String> collection) {
+        if (collection == null) {
+            return null;
+        }
+        return collection.toArray(new String[collection.size()]);
+    }
+
+    /**
+     * Copy the given Enumeration into a {@code String} array. The Enumeration
+     * must contain {@code String} elements only.
+     *
+     * @param enumeration the Enumeration to copy
+     * @return the {@code String} array ({@code null} if the passed-in
+     * Enumeration was {@code null})
+     */
+    public static String[] toStringArray(Enumeration<String> enumeration) {
+        if (enumeration == null) {
+            return null;
+        }
+        List<String> list = Collections.list(enumeration);
+        return list.toArray(new String[list.size()]);
+    }
+
+    /**
+     * Trim the elements of the given {@code String} array, calling
+     * {@code String.trim()} on each of them.
+     *
+     * @param array the original {@code String} array
+     * @return the resulting array (of the same size) with trimmed elements
+     */
+    public static String[] trimArrayElements(String[] array) {
+        if (ObjectUtils.isEmpty(array)) {
+            return new String[0];
+        }
+        String[] result = new String[array.length];
+        for (int i = 0; i < array.length; i++) {
+            String element = array[i];
+            result[i] = (element != null ? element.trim() : null);
+        }
+        return result;
+    }
+
+    /**
+     * Remove duplicate strings from the given array.
+     * <p>
+     * As of 4.2, it preserves the original order, as it uses a
+     * {@link LinkedHashSet}.
+     *
+     * @param array the {@code String} array
+     * @return an array without duplicates, in natural sort order
+     */
+    public static String[] removeDuplicateStrings(String[] array) {
+        if (ObjectUtils.isEmpty(array)) {
+            return array;
+        }
+        Set<String> set = new LinkedHashSet<>();
+        set.addAll(Arrays.asList(array));
+        return toStringArray(set);
+    }
+
+    /**
+     * Split a {@code String} at the first occurrence of the delimiter. Does not
+     * include the delimiter in the result.
+     *
+     * @param toSplit the string to split
+     * @param delimiter to split the string up with
+     * @return a two element array with index 0 being before the delimiter, and
+     * index 1 being after the delimiter (neither element includes the
+     * delimiter); or {@code null} if the delimiter wasn't found in the given
+     * input {@code String}
+     */
+    public static String[] split(String toSplit, String delimiter) {
+        if (!hasLength(toSplit) || !hasLength(delimiter)) {
+            return null;
+        }
+        int offset = toSplit.indexOf(delimiter);
+        if (offset < 0) {
+            return null;
+        }
+        String beforeDelimiter = toSplit.substring(0, offset);
+        String afterDelimiter = toSplit.substring(offset + delimiter.length());
+        return new String[]{beforeDelimiter, afterDelimiter};
+    }
+
+    /**
+     * Take an array of strings and split each element based on the given
+     * delimiter. A {@code Properties} instance is then generated, with the left
+     * of the delimiter providing the key, and the right of the delimiter
+     * providing the value.
+     * <p>
+     * Will trim both the key and value before adding them to the
+     * {@code Properties} instance.
+     *
+     * @param array the array to process
+     * @param delimiter to split each element using (typically the equals
+     * symbol)
+     * @return a {@code Properties} instance representing the array contents, or
+     * {@code null} if the array to process was {@code null} or empty
+     */
+    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {
+        return splitArrayElementsIntoProperties(array, delimiter, null);
+    }
+
+    /**
+     * Take an array of strings and split each element based on the given
+     * delimiter. A {@code Properties} instance is then generated, with the left
+     * of the delimiter providing the key, and the right of the delimiter
+     * providing the value.
+     * <p>
+     * Will trim both the key and value before adding them to the
+     * {@code Properties} instance.
+     *
+     * @param array the array to process
+     * @param delimiter to split each element using (typically the equals
+     * symbol)
+     * @param charsToDelete one or more characters to remove from each element
+     * prior to attempting the split operation (typically the quotation mark
+     * symbol), or {@code null} if no removal should occur
+     * @return a {@code Properties} instance representing the array contents, or
+     * {@code null} if the array to process was {@code null} or empty
+     */
+    public static Properties splitArrayElementsIntoProperties(
+            String[] array, String delimiter, String charsToDelete) {
+
+        if (ObjectUtils.isEmpty(array)) {
+            return null;
+        }
+        Properties result = new Properties();
+        for (String element : array) {
+            if (charsToDelete != null) {
+                element = deleteAny(element, charsToDelete);
+            }
+            String[] splittedElement = split(element, delimiter);
+            if (splittedElement == null) {
+                continue;
+            }
+            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());
+        }
+        return result;
+    }
+
+    /**
+     * Tokenize the given {@code String} into a {@code String} array via a
+     * {@link StringTokenizer}.
+     * <p>
+     * Trims tokens and omits empty tokens.
+     * <p>
+     * The given {@code delimiters} string can consist of any number of
+     * delimiter characters. Each of those characters can be used to separate
+     * tokens. A delimiter is always a single character; for multi-character
+     * delimiters, consider using {@link #delimitedListToStringArray}.
+     *
+     * @param str the {@code String} to tokenize
+     * @param delimiters the delimiter characters, assembled as a {@code String}
+     * (each of the characters is individually considered as a delimiter)
+     * @return an array of the tokens
+     * @see java.util.StringTokenizer
+     * @see String#trim()
+     * @see #delimitedListToStringArray
+     */
+    public static String[] tokenizeToStringArray(String str, String delimiters) {
+        return tokenizeToStringArray(str, delimiters, true, true);
+    }
+
+    /**
+     * Tokenize the given {@code String} into a {@code String} array via a
+     * {@link StringTokenizer}.
+     * <p>
+     * The given {@code delimiters} string can consist of any number of
+     * delimiter characters. Each of those characters can be used to separate
+     * tokens. A delimiter is always a single character; for multi-character
+     * delimiters, consider using {@link #delimitedListToStringArray}.
+     *
+     * @param str the {@code String} to tokenize
+     * @param delimiters the delimiter characters, assembled as a {@code String}
+     * (each of the characters is individually considered as a delimiter)
+     * @param trimTokens trim the tokens via {@link String#trim()}
+     * @param ignoreEmptyTokens omit empty tokens from the result array (only
+     * applies to tokens that are empty after trimming; StringTokenizer will not
+     * consider subsequent delimiters as token in the first place).
+     * @return an array of the tokens ({@code null} if the input {@code String}
+     * was {@code null})
+     * @see java.util.StringTokenizer
+     * @see String#trim()
+     * @see #delimitedListToStringArray
+     */
+    public static String[] tokenizeToStringArray(
+            String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {
+
+        if (str == null) {
+            return null;
+        }
+        StringTokenizer st = new StringTokenizer(str, delimiters);
+        List<String> tokens = new ArrayList<>();
+        while (st.hasMoreTokens()) {
+            String token = st.nextToken();
+            if (trimTokens) {
+                token = token.trim();
+            }
+            if (!ignoreEmptyTokens || token.length() > 0) {
+                tokens.add(token);
+            }
+        }
+        return toStringArray(tokens);
+    }
+
+    /**
+     * Take a {@code String} that is a delimited list and convert it into a
+     * {@code String} array.
+     * <p>
+     * A single {@code delimiter} may consist of more than one character, but it
+     * will still be considered as a single delimiter string, rather than as
+     * bunch of potential delimiter characters, in contrast to
+     * {@link #tokenizeToStringArray}.
+     *
+     * @param str the input {@code String}
+     * @param delimiter the delimiter between elements (this is a single
+     * delimiter, rather than a bunch individual delimiter characters)
+     * @return an array of the tokens in the list
+     * @see #tokenizeToStringArray
+     */
+    public static String[] delimitedListToStringArray(String str, String delimiter) {
+        return delimitedListToStringArray(str, delimiter, null);
+    }
+
+    /**
+     * Take a {@code String} that is a delimited list and convert it into a
+     * {@code String} array.
+     * <p>
+     * A single {@code delimiter} may consist of more than one character, but it
+     * will still be considered as a single delimiter string, rather than as
+     * bunch of potential delimiter characters, in contrast to
+     * {@link #tokenizeToStringArray}.
+     *
+     * @param str the input {@code String}
+     * @param delimiter the delimiter between elements (this is a single
+     * delimiter, rather than a bunch individual delimiter characters)
+     * @param charsToDelete a set of characters to delete; useful for deleting
+     * unwanted line breaks: e.g. "\r\n\f" will delete all new lines and line
+     * feeds in a {@code String}
+     * @return an array of the tokens in the list
+     * @see #tokenizeToStringArray
+     */
+    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {
+        if (str == null) {
+            return new String[0];
+        }
+        if (delimiter == null) {
+            return new String[]{str};
+        }
+        List<String> result = new ArrayList<>();
+        if ("".equals(delimiter)) {
+            for (int i = 0; i < str.length(); i++) {
+                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));
+            }
+        } else {
+            int pos = 0;
+            int delPos;
+            while ((delPos = str.indexOf(delimiter, pos)) != -1) {
+                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));
+                pos = delPos + delimiter.length();
+            }
+            if (str.length() > 0 && pos <= str.length()) {
+                // Add rest of String, but not in case of empty input.
+                result.add(deleteAny(str.substring(pos), charsToDelete));
+            }
+        }
+        return toStringArray(result);
+    }
+
+    /**
+     * Convert a comma delimited list (e.g., a row from a CSV file) into an
+     * array of strings.
+     *
+     * @param str the input {@code String}
+     * @return an array of strings, or the empty array in case of empty input
+     */
+    public static String[] commaDelimitedListToStringArray(String str) {
+        return delimitedListToStringArray(str, ",");
+    }
+
+    /**
+     * Convert a comma delimited list (e.g., a row from a CSV file) into a set.
+     * <p>
+     * Note that this will suppress duplicates, and as of 4.2, the elements in
+     * the returned set will preserve the original order in a
+     * {@link LinkedHashSet}.
+     *
+     * @param str the input {@code String}
+     * @return a set of {@code String} entries in the list
+     * @see #removeDuplicateStrings(String[])
+     */
+    public static Set<String> commaDelimitedListToSet(String str) {
+        Set<String> set = new LinkedHashSet<>();
+        String[] tokens = commaDelimitedListToStringArray(str);
+        set.addAll(Arrays.asList(tokens));
+        return set;
+    }
+
+    /**
+     * Convert a {@link Collection} to a delimited {@code String} (e.g. CSV).
+     * <p>
+     * Useful for {@code toString()} implementations.
+     *
+     * @param coll the {@code Collection} to convert
+     * @param delim the delimiter to use (typically a ",")
+     * @param prefix the {@code String} to start each element with
+     * @param suffix the {@code String} to end each element with
+     * @return the delimited {@code String}
+     */
+    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {
+        if (CollectionUtils.isEmpty(coll)) {
+            return "";
+        }
+        StringBuilder sb = new StringBuilder();
+        Iterator<?> it = coll.iterator();
+        while (it.hasNext()) {
+            sb.append(prefix).append(it.next()).append(suffix);
+            if (it.hasNext()) {
+                sb.append(delim);
+            }
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Convert a {@code Collection} into a delimited {@code String} (e.g. CSV).
+     * <p>
+     * Useful for {@code toString()} implementations.
+     *
+     * @param coll the {@code Collection} to convert
+     * @param delim the delimiter to use (typically a ",")
+     * @return the delimited {@code String}
+     */
+    public static String collectionToDelimitedString(Collection<?> coll, String delim) {
+        return collectionToDelimitedString(coll, delim, "", "");
+    }
+
+    /**
+     * Convert a {@code Collection} into a delimited {@code String} (e.g., CSV).
+     * <p>
+     * Useful for {@code toString()} implementations.
+     *
+     * @param coll the {@code Collection} to convert
+     * @return the delimited {@code String}
+     */
+    public static String collectionToCommaDelimitedString(Collection<?> coll) {
+        return collectionToDelimitedString(coll, ",");
+    }
+
+    /**
+     * Convert a {@code String} array into a delimited {@code String} (e.g.
+     * CSV).
+     * <p>
+     * Useful for {@code toString()} implementations.
+     *
+     * @param arr the array to display
+     * @param delim the delimiter to use (typically a ",")
+     * @return the delimited {@code String}
+     */
+    public static String arrayToDelimitedString(Object[] arr, String delim) {
+        if (ObjectUtils.isEmpty(arr)) {
+            return "";
+        }
+        if (arr.length == 1) {
+            return ObjectUtils.nullSafeToString(arr[0]);
+        }
+        StringBuilder sb = new StringBuilder();
+        for (int i = 0; i < arr.length; i++) {
+            if (i > 0) {
+                sb.append(delim);
+            }
+            sb.append(arr[i]);
+        }
+        return sb.toString();
+    }
+
+    /**
+     * Convert a {@code String} array into a comma delimited {@code String}
+     * (i.e., CSV).
+     * <p>
+     * Useful for {@code toString()} implementations.
+     *
+     * @param arr the array to display
+     * @return the delimited {@code String}
+     */
+    public static String arrayToCommaDelimitedString(Object[] arr) {
+        return arrayToDelimitedString(arr, ",");
+    }
+    
+    public static int levenshtein(CharSequence lhs, CharSequence rhs) {      
+        int[][] distance = new int[lhs.length() + 1][rhs.length() + 1];        
+                                                                                 
+        for (int i = 0; i <= lhs.length(); i++) {                                 
+            distance[i][0] = i;                   
+        }
+        
+        for (int j = 1; j <= rhs.length(); j++) {        
+            distance[0][j] = j;   
+        }                                                                       
+                                                   
+        for (int i = 1; i <= lhs.length(); i++) {
+            for (int j = 1; j <= rhs.length(); j++){                 
+                distance[i][j] = Math.min(
+                    Math.min(
+                            distance[i - 1][j] + 1,
+                            distance[i][j - 1] + 1
+                    ) , distance[i - 1][j - 1] + ((lhs.charAt(i - 1) == rhs.charAt(j - 1)) ? 0 : 1)
+                );
+            }  
+        }     
+        
+        return distance[lhs.length()][rhs.length()];                           
+    }
+    
+    public static String findAlternative(String nonExistant, Collection<String> candidates){
+        return findAlternative(nonExistant, candidates, 3);
+    }
+    
+    public static String findAlternative(String nonExistant, Collection<String> candidates, int force){
+        String alternative = null;
+        Integer shortest = null;
+        for (String name : candidates) {
+            if(name.contains(nonExistant)) {
+                // there is a partial match return it !
+                return name;
+            }
+            
+            int lev = levenshtein(nonExistant, name);
+            
+            if(lev <= nonExistant.length() / force && (alternative == null || lev < shortest)) {
+                alternative = name;
+                shortest = lev;
+            }
+            
+        }
+        
+        return alternative;
+    }
+}
diff --git a/src/main/java/demo/event/EventDemo.java b/src/main/java/demo/event/EventDemo.java
new file mode 100644
index 0000000..ecd8390
--- /dev/null
+++ b/src/main/java/demo/event/EventDemo.java
@@ -0,0 +1,172 @@
+package demo.event;
+
+import component.event.Event;
+import component.event.dispatcher.EventDispatcher;
+import demo.event.crud.CreateEvent;
+import demo.event.crud.UpdateEvent;
+import component.event.dispatcher.DispatcherInterface;
+import component.event.handler.Handler;
+import demo.event.model.Role;
+import demo.event.model.User;
+import component.event.subscriber.Subscriber;
+
+public class EventDemo {
+    
+    public static void main(String[] args) throws Exception {
+        
+        EventDispatcher.builder()
+                .register("update", 90, (Event event) -> {
+                    System.out.println("builder handle Event ".concat(event.toString()));
+                })
+                .subscribe(new RepositorySubscriber())
+                .subscribe(new Subscriber() {
+                    @Override
+                    public void subscribe(DispatcherInterface dispatcher) {
+                        dispatcher.register("create", (Event event) -> {
+                            System.out.println("builder handle Event ".concat(event.toString()));
+                        });
+                    }
+                })
+                .subscribe(new Subscriber<Event>() {
+                    @Override
+                    public void subscribe(DispatcherInterface<Event> dispatcher) {
+                        dispatcher.of(UpdateEvent.class).register("update", (UpdateEvent event) -> {
+                            System.out.println("builder handle Event ".concat(event.getObject().toString()));
+                        });
+                    }
+                })
+                .subscribe((DispatcherInterface<Event> dispatcher) -> {
+                    dispatcher.of(UpdateEvent.class).register("update", (UpdateEvent event) -> {
+                        System.out.println("builder handle Event ".concat(event.getObject().toString()));
+                    });
+                })
+                .build()
+                .dispatch("create", new CreateEvent("qsd"))
+                .dispatch("update", new UpdateEvent("qsd"))
+                .dispatch("terminate", new UpdateEvent("qsd"));
+        
+        EventDispatcher dispatcher = new EventDispatcher();
+        Subscriber repoSubscriber = new RepositorySubscriber();
+        repoSubscriber.subscribe(dispatcher);
+        Subscriber userSubscriber = new UserSubscriber();
+        userSubscriber.subscribe(dispatcher);
+        Subscriber roleSubscriber = new RoleSubscriber();
+        roleSubscriber.subscribe(dispatcher);
+        
+        dispatcher.register("create", (Event event) -> {
+            System.out.println("handle CreateEvent");
+        });
+        
+        dispatcher.of(CreateEvent.class).register("create", (CreateEvent event) -> {
+            System.out.println("Annon handle CreateEvent".concat(event.getObject().toString()));
+        });
+        dispatcher.of(UpdateEvent.class).register("update", 60, (UpdateEvent event) -> {
+            System.out.println("Annon handle Event".concat(event.toString()));
+        });
+        
+        User user = new User("bernard");
+        
+        dispatcher.dispatch("create", new CreateEvent(user));
+        dispatcher.dispatch("update", new UpdateEvent(user));
+        
+//        dispatcher.dispatch("create", new UserCreatedEvent(user));
+//        dispatcher.dispatch("update", new UserUpdatedEvent(user));
+        
+        Role admin = new Role("admin");
+        
+        dispatcher.dispatch("create", new CreateEvent(admin));
+        dispatcher.dispatch("update", new UpdateEvent(admin));
+        
+//        dispatcher.register("create", UserSubscriber::onCreate);
+        
+//        EventDispatcher dispatcher = new EventDispatcher();
+//        dispatcher.register("user_created", (UserCreatedEvent event) -> {
+//            event.getObject().getUsername();
+//        });
+////        dispatcher.addSubscriber(sub);
+    }
+    
+    public static class RepositorySubscriber implements Subscriber {
+        
+        public Handler<CreateEvent> onCreate() {
+            return u -> {
+//                u.stopEventPropagation();
+                System.out.println("handle RepositorySubscriber CreateEvent".concat(u.getObject().toString()));
+            };
+        }
+        
+        public Handler<UpdateEvent> onUpdate() {
+            return u -> System.out.println("handle RepositorySubscriber UpdateEvent".concat(u.getObject().toString()));
+        }
+
+        @Override
+        public void subscribe(DispatcherInterface dispatcher) {
+            dispatcher.register("create", 1, onCreate());
+            dispatcher.register("update", 1, onUpdate());
+        }
+    }
+    
+    public static class UserSubscriber implements Subscriber {
+        
+        public Handler<CreateEvent> onCreate() {
+            return u -> {
+                if (!(u.getObject() instanceof User)) {
+                    return;
+                }
+                
+                System.out.println("handle UserSubscriber CreateEvent".concat(u.getObject().toString()));
+            };
+        }
+        
+        public Handler<UpdateEvent> onUpdate() {
+            return u -> {
+                if (!(u.getObject() instanceof User)) {
+                    return;
+                }
+                
+                System.out.println("handle UserSubscriber UpdateEvent".concat(u.getObject().toString()));
+            };
+        }
+        
+        public void onUpdate2(Event event) {
+            System.out.println("handle UserSubscriber onUpdate2".concat(event.toString()));
+        }
+
+        @Override
+        public void subscribe(DispatcherInterface dispatcher) {
+            dispatcher.register("create", 5, onCreate());
+            dispatcher.register("update", 5, onUpdate());
+            dispatcher.register("update", 99, this::onUpdate2);
+        }
+    }
+        
+    public static class RoleSubscriber implements Subscriber {
+        
+        public Handler<CreateEvent> onCreate() {
+            return u -> {
+                if (!(u.getObject() instanceof Role)) {
+                    return;
+                }
+                
+                System.out.println("handle RoleSubscriber CreateEvent".concat(u.getObject().toString()));
+            };
+        }
+        
+        public Handler<UpdateEvent> onUpdate() {
+            return u -> {
+                if (!(u.getObject() instanceof Role)) {
+                    return;
+                }
+                
+                System.out.println("handle RoleSubscriber UpdateEvent".concat(u.getObject().toString()));
+            };
+        }
+
+        @Override
+        public void subscribe(DispatcherInterface dispatcher) {
+            dispatcher.register("create", 10, onCreate());
+            dispatcher.register("update", 10, onUpdate());
+        }
+    }
+    
+}
diff --git a/src/main/java/demo/event/crud/CRUDEvent.java b/src/main/java/demo/event/crud/CRUDEvent.java
new file mode 100644
index 0000000..b24491e
--- /dev/null
+++ b/src/main/java/demo/event/crud/CRUDEvent.java
@@ -0,0 +1,20 @@
+package demo.event.crud;
+
+import component.event.Event;
+
+public class CRUDEvent<O> extends Event {
+    
+    private O object;
+
+    public CRUDEvent(O object) {
+        this.object = object;
+    }
+
+    public O getObject() {
+        return object;
+    }
+
+    public void setObject(O object) {
+        this.object = object;
+    }
+}
diff --git a/src/main/java/demo/event/crud/CreateEvent.java b/src/main/java/demo/event/crud/CreateEvent.java
new file mode 100644
index 0000000..b24775e
--- /dev/null
+++ b/src/main/java/demo/event/crud/CreateEvent.java
@@ -0,0 +1,9 @@
+package demo.event.crud;
+
+public class CreateEvent<O> extends CRUDEvent<O> {
+    
+    public CreateEvent(O object) {
+        super(object);
+    }
+    
+}
diff --git a/src/main/java/demo/event/crud/UpdateEvent.java b/src/main/java/demo/event/crud/UpdateEvent.java
new file mode 100644
index 0000000..6f31223
--- /dev/null
+++ b/src/main/java/demo/event/crud/UpdateEvent.java
@@ -0,0 +1,9 @@
+package demo.event.crud;
+
+public class UpdateEvent<O> extends CRUDEvent<O> {
+    
+    public UpdateEvent(O object) {
+        super(object);
+    }
+    
+}
diff --git a/src/main/java/demo/event/event/UserCreatedEvent.java b/src/main/java/demo/event/event/UserCreatedEvent.java
new file mode 100644
index 0000000..17903e1
--- /dev/null
+++ b/src/main/java/demo/event/event/UserCreatedEvent.java
@@ -0,0 +1,12 @@
+package demo.event.event;
+
+import demo.event.crud.CreateEvent;
+import demo.event.model.User;
+
+public class UserCreatedEvent extends CreateEvent<User>{
+    
+    public UserCreatedEvent(User object) {
+        super(object);
+    }
+    
+}
diff --git a/src/main/java/demo/event/event/UserUpdatedEvent.java b/src/main/java/demo/event/event/UserUpdatedEvent.java
new file mode 100644
index 0000000..04d3ec3
--- /dev/null
+++ b/src/main/java/demo/event/event/UserUpdatedEvent.java
@@ -0,0 +1,12 @@
+package demo.event.event;
+
+import demo.event.crud.CreateEvent;
+import demo.event.model.User;
+
+public class UserUpdatedEvent extends CreateEvent<User>{
+    
+    public UserUpdatedEvent(User object) {
+        super(object);
+    }
+    
+}
diff --git a/src/main/java/demo/event/model/Role.java b/src/main/java/demo/event/model/Role.java
new file mode 100644
index 0000000..d877712
--- /dev/null
+++ b/src/main/java/demo/event/model/Role.java
@@ -0,0 +1,19 @@
+package demo.event.model;
+
+public class Role {
+
+    private String name;
+
+    public Role(String name) {
+        this.name = name;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    @Override
+    public String toString() {
+        return "Role{" + "name=" + name + '}';
+    }
+}
diff --git a/src/main/java/demo/event/model/User.java b/src/main/java/demo/event/model/User.java
new file mode 100644
index 0000000..cc96f3c
--- /dev/null
+++ b/src/main/java/demo/event/model/User.java
@@ -0,0 +1,20 @@
+package demo.event.model;
+
+public class User {
+
+    private String username;
+
+    public User(String username) {
+        this.username = username;
+    }
+
+    public String getUsername() {
+        return username;
+    }
+
+    @Override
+    public String toString() {
+        return "User{" + "username=" + username + '}';
+    }
+
+}
diff --git a/src/main/java/demo/expressionLanguage/ExpressionLanguageDemo.java b/src/main/java/demo/expressionLanguage/ExpressionLanguageDemo.java
new file mode 100644
index 0000000..d7a3714
--- /dev/null
+++ b/src/main/java/demo/expressionLanguage/ExpressionLanguageDemo.java
@@ -0,0 +1,79 @@
+package demo.expressionLanguage;
+
+import component.expressionLanguage.Engine;
+import component.expressionLanguage.extension.ExtensionRegistry;
+import component.expressionLanguage.extension.core.CoreExtension;
+import component.expressionLanguage.lexer.Lexer;
+import component.expressionLanguage.lexer.Syntax;
+import component.expressionLanguage.model.template.Template;
+import component.expressionLanguage.token.parser.Parser;
+import component.expressionLanguage.token.parser.TokenStreamParser;
+import java.io.File;
+import java.util.Locale;
+import java.util.concurrent.ExecutorService;
+import java.util.concurrent.Executors;
+import component.resource.ResourceService;
+import component.resource.loader.ClasspathResourceLoader;
+import component.resource.loader.FileResourceLoader;
+import component.resource.loader.InMemoryResourceLoader;
+import component.resource.loader.StringResourceLoader;
+import component.resource.reference.ResourceReference;
+
+public class ExpressionLanguageDemo {
+    
+    public static void main(String[] args) throws Exception {
+        ResourceService resourceService = ResourceService.builder()
+                .with(ResourceReference.FILE, FileResourceLoader.instance())
+                .with(ResourceReference.FILE, FileResourceLoader.instance(new File("/Users/florian/Documents/sources/sand-box/demo")))
+                .with(ResourceReference.CLASSPATH, new ClasspathResourceLoader(ClassLoader.getSystemClassLoader()))
+                .with(ResourceReference.MEMORY, InMemoryResourceLoader.builder()
+                        .withResource("test", "Demo in memory String")
+                        .build())
+                .with(ResourceReference.STRING, new StringResourceLoader())
+                .with(ResourceReference.ANY_TYPE, new StringResourceLoader())
+                .build();
+        
+        Syntax syntax = Syntax.builder()
+                .comment("{#", "#}")
+                .execute("{%", "%}")
+                .print("{{", "}}")
+                .wsTrim("-")
+                .build();
+        
+        ExtensionRegistry registry = ExtensionRegistry.builder()
+                .with(new CoreExtension())
+                .build();
+        
+        Lexer lexer = Lexer.builder()
+                .syntax(syntax)
+                .operators(registry.getOperators())
+                .build();
+        
+        Parser parser = new TokenStreamParser(registry.getOperators(), registry.getTokenParsers());
+        ExecutorService executorService = Executors.newFixedThreadPool(3);
+        Engine engine = new Engine(resourceService, lexer, parser, registry, true, Locale.getDefault(), executorService);
+        
+        Template template = engine.load("expressionLanguage/demo");
+        
+        
+        System.out.println(template);
+//        Lexer lexer = new Lexer(syntax, registry.getUnaryOperators(), registry.getBinaryOperators());
+       
+//        Parser parser,
+//        ExtensionRegistry extensionRegistry,
+//        boolean strictVariables, 
+//        Locale defaultLocale, 
+//        ExecutorService executorService
+//        Collection<UnaryOperator> unaries = Arrays.asList();
+//        Collection<BinaryOperator> binaries = Arrays.asList();
+//        Lexer lexer = new Lexer(),
+//        Parser parser,
+//        ExtensionRegistry extensionRegistry,
+//        boolean strictVariables, 
+//        Locale defaultLocale, 
+//        ExecutorService executorService
+        
+//        Engine engine = new Engine();
+    }
+    
+}
diff --git a/src/main/java/demo/expressionLanguage/demo b/src/main/java/demo/expressionLanguage/demo
new file mode 100644
index 0000000..0051d97
--- /dev/null
+++ b/src/main/java/demo/expressionLanguage/demo
@@ -0,0 +1,9 @@
+C'est la dmo !
+
+{% set name = "World" %}
+
+Hello {{ name }}
+
+{% for item in [3, 2, 1, 0] %}
+    ... {{ item }} !
+{% endfor %} 
\ No newline at end of file
diff --git a/src/main/java/demo/resolver/ResolverDemo.java b/src/main/java/demo/resolver/ResolverDemo.java
new file mode 100644
index 0000000..1d09f7a
--- /dev/null
+++ b/src/main/java/demo/resolver/ResolverDemo.java
@@ -0,0 +1,118 @@
+package demo.resolver;
+
+import component.resolver.Resolver;
+import component.resolver.ResolverDelegate;
+import java.util.HashMap;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import component.resource.reference.ResourceReference;
+
+public class ResolverDemo {
+    
+    public static void main(String[] args) {
+        greet();
+        resource();
+        delegate();
+    }
+    
+    public static void greet() {
+        System.out.println("=== GREET ===");
+        greet1();
+    }
+    
+    public static void resource() {
+        System.out.println("=== Resource ===");
+        resource1();
+    }    
+    
+    public static class Greeter {
+        
+        private final Pattern pattern = Pattern.compile("\\{.*?\\}");
+        
+        public Greeter() {
+        }
+        
+        public void greet(String name, String lang) {
+            this.model.put("name", name);
+            Locale locale = new LocaleResolver().resolve(lang).get();
+            if (locale.equals(Locale.FRANCE)) {
+                System.out.println(evaluate("Bonjour {name} !", model));
+            } else if (locale.equals(Locale.ENGLISH)) {
+                System.out.println(evaluate("Hello {name} !", model));
+            }
+        }
+        
+        private Map<String, Object> model = new HashMap<>();
+        private String evaluate(String subject, Map<String, Object> model) {
+            Matcher matcher = this.pattern.matcher(subject);
+            StringBuffer sb = new StringBuffer();
+        
+            while (matcher.find()) {
+                String key = matcher.group().replaceAll("[{}]", "");
+                if (this.model.containsKey(key)) {
+                    matcher.appendReplacement(sb, Objects.toString(this.model.get(key), "null"));
+                }
+            }
+        
+            matcher.appendTail(sb);
+            
+            return sb.toString();
+        }
+
+    };
+    
+    public static class LocaleResolver implements Resolver<String, Locale> {
+        
+        public LocaleResolver() {
+        }
+        
+        @Override
+        public Optional<Locale> resolve(String locale) {
+            switch(locale) {
+                case "fr" :
+                    return Optional.of(Locale.FRANCE);
+                case "en" :
+                    return Optional.of(Locale.ENGLISH);
+                default :
+                    return Optional.of(Locale.getDefault());
+            }
+        }
+    }
+    
+    public static void greet1() {
+        System.out.println("=== GREET 1 ===");
+        Greeter greeter = new Greeter();
+        greeter.greet("world", "fr");
+    }
+    
+    public static void resource1() {
+        System.out.println("=== RESOURCE 2 ===");
+        
+        Resolver<String, ResourceReference> resolver = (String path) -> Optional.of(ResourceReference.file(path));
+        
+        System.out.println(resolver.resolve("/").get());
+    }
+    
+    public static void delegate() {
+        System.out.println("=== delegate ===");
+        
+        ResolverDelegate<String, Object> delegate = new ResolverDelegate<>();
+        
+        delegate.addResolver((s) -> s.startsWith("/"), (String path) -> Optional.of(path + " ../"));
+        delegate.addResolver((s) -> s.startsWith("test"), (String path) -> Optional.of("Ceci est un test"));
+        
+        System.out.println(delegate.resolve("/").get());
+        System.out.println(delegate.resolve("test").get());
+        
+        Resolver<String, ResourceReference> resolver = (String path) -> {
+            return Optional.of(new ResourceReference("file", path));
+        };
+        
+        System.out.println(resolver.resolve("/").get());
+        System.out.println(resolver.resolve("test").get());
+    }
+    }
diff --git a/src/main/java/demo/resource/FileUtils.java b/src/main/java/demo/resource/FileUtils.java
new file mode 100644
index 0000000..51f0329
--- /dev/null
+++ b/src/main/java/demo/resource/FileUtils.java
@@ -0,0 +1,39 @@
+package demo.resource;
+
+import java.io.File;
+import java.util.Arrays;
+import java.util.Objects;
+
+public class FileUtils {
+
+    public static void exists(File file, boolean deep) {
+        System.out.format("File %s exists ? %s \n", file.getPath(), file.exists());
+        if (file.exists()) {
+            directory(file, deep);
+        }
+    }
+
+    public static void directory(File file, boolean deep) {
+        System.out.format("File %s is directory ? %s \n", file.getPath(), file.isDirectory());
+
+        if (file.isDirectory()) {
+            File[] children = file.listFiles();
+            System.out.format("Children : %s \n", Arrays.toString(children));
+
+            if (deep && Objects.nonNull(children)) {
+                Arrays.stream(file.listFiles())
+                        .filter(Objects::nonNull)
+                        .forEach((child) -> details(child, deep));
+            }
+        }
+    }
+
+    public static void details(String path, boolean deep) {
+        details(new File(path), deep);
+    }
+
+    public static void details(File file, boolean deep) {
+        exists(file, deep);
+    }
+
+}
diff --git a/src/main/java/demo/resource/ResourceDemo.java b/src/main/java/demo/resource/ResourceDemo.java
new file mode 100644
index 0000000..11e5f89
--- /dev/null
+++ b/src/main/java/demo/resource/ResourceDemo.java
@@ -0,0 +1,58 @@
+package demo.resource;
+
+import component.resource.ResourceService;
+import component.resource.loader.ClasspathResourceLoader;
+import component.resource.loader.FileResourceLoader;
+import component.resource.loader.InMemoryResourceLoader;
+import component.resource.loader.StringResourceLoader;
+import component.resource.reference.ResourceReference;
+import java.io.File;
+
+public class ResourceDemo {
+
+    public static void main(String[] args) throws ClassNotFoundException, Exception {
+        ResourceService service = service();
+
+//        services.forEach((service) -> {
+//            System.out.println("======= metadata ".concat(service.toString()).concat("======="));
+////            print(service.metadata("file:sources/sand_box/demo/resource/demo_file"));
+//            print(service.metadata("demo"));
+//            print(service.metadata("file:demo_file"));
+////            print(service.metadata("classpath:sources/sand_box/demo/resource/demo_classpath"));
+//            print(service.metadata("classpath:demo_classpath"));
+////            print(service.metadata("classpath:../../src/Test.java"));
+//            print(service.metadata("memory:test"));
+//            print(service.metadata("Voila voila"));
+//            print(service.metadata("test"));
+//            System.out.println("=======Fin - ".concat(service.toString()).concat("======="));
+//        });
+        System.out.println("======= load ".concat(service.toString()).concat("======="));
+//            print(service.metadata("file:sources/sand_box/demo/resource/demo_file"));
+//            print(service.load("demo"));
+//            print(service.load("file:demo_file"));
+//            print(service.metadata("classpath:sources/sand_box/demo/resource/demo_classpath"));
+        //ResourceUtils.print(service.load("classpath:demo_classpath"));
+        //ResourceUtils.print(service.load("classpath:demo_1.txt"));
+        ResourceUtils.print(service.load("classpath:demo/resource/demo_classpath"));
+//            print(service.metadata("classpath:../../src/Test.java"));
+//            print(service.load("memory:test"));
+//            print(service.load("Voila voila"));
+//            print(service.load("test"));
+        System.out.println("=======Fin - ".concat(service.toString()).concat("======="));
+    }
+
+    public static ResourceService service() {
+
+        return ResourceService.builder()
+                .with(ResourceReference.FILE, FileResourceLoader.instance())
+                .with(ResourceReference.FILE, FileResourceLoader.instance(new File("/sources/sand_box/demo/resource")))
+                .with(ResourceReference.FILE, FileResourceLoader.instance(new File("/Users/florian/Documents/sources/sand-box/demo/resource")))
+                .with(ResourceReference.CLASSPATH, new ClasspathResourceLoader(ClassLoader.getSystemClassLoader()))
+                .with(ResourceReference.MEMORY, InMemoryResourceLoader.builder().withResource("test", "Demo in memory String").build())
+                .with(ResourceReference.MEMORY, InMemoryResourceLoader.builder().withResource("test", "Demo in memory String ANY_TYPE").build())
+                .with(ResourceReference.STRING, new StringResourceLoader())
+                .with(ResourceReference.ANY_TYPE, new StringResourceLoader())
+                .build();
+    }
+
+}
diff --git a/src/main/java/demo/resource/ResourceDemo2.java b/src/main/java/demo/resource/ResourceDemo2.java
new file mode 100644
index 0000000..2452cbf
--- /dev/null
+++ b/src/main/java/demo/resource/ResourceDemo2.java
@@ -0,0 +1,40 @@
+package demo.resource;
+
+import component.resource.ResourceService;
+import java.io.File;
+import component.resource.loader.ClasspathResourceLoader;
+import component.resource.loader.FileResourceLoader;
+import component.resource.loader.InMemoryResourceLoader;
+import component.resource.loader.StringResourceLoader;
+import component.resource.reference.ResourceReference;
+
+public class ResourceDemo2 {
+
+    public static void main(String[] args) throws ClassNotFoundException, Exception {
+        ResourceService service = ResourceService.builder()
+                .with(ResourceReference.FILE, FileResourceLoader.instance())
+                .with(ResourceReference.FILE, FileResourceLoader.instance(new File("/Users/florian/Documents/sources/sand-box/demo")))
+                .with(ResourceReference.FILE, FileResourceLoader.instance(new File("D:\\sources/sand-box/demo/resource")))
+                .with(ResourceReference.FILE, FileResourceLoader.instance(new File("D:\\sources\\sand-box\\demo\\resource")))
+                .with(ResourceReference.CLASSPATH, new ClasspathResourceLoader(ClassLoader.getSystemClassLoader()))
+                .with(ResourceReference.MEMORY, InMemoryResourceLoader.builder()
+                        .withResource("test", "Demo in memory String")
+                        .build())
+                .with(ResourceReference.STRING, new StringResourceLoader())
+                .with(ResourceReference.ANY_TYPE, new StringResourceLoader())
+                .build();
+
+        System.out.println("======= load ".concat(service.toString()).concat("======="));
+//        ResourceUtils.print(service.load("resource/demo"));
+//        ResourceUtils.print(service.load("file:resource/demo"));
+//        ResourceUtils.print(service.load("resource/demo_1.txt"));
+//        ResourceUtils.print(service.load("file:D:\\sources\\sand-box\\demo\\resource\\demo_1.txt"));
+        ResourceUtils.print(service.load("D:\\sources/sand-box/demo/resource/demo_1.txt"));
+        ResourceUtils.print(service.load("file:D:\\sources/sand-box/demo/resource/demo_1.txt"));
+        ResourceUtils.print(service.load("classpath:resource/demo_classpath"));
+        ResourceUtils.print(service.load("classpath:resource/demo_1.txt"));
+        ResourceUtils.print(service.load("Hello World !"));
+        ResourceUtils.print(service.load("test"));
+        System.out.println("=======Fin - ".concat(service.toString()).concat("======="));
+    }
+}
diff --git a/src/main/java/demo/resource/ResourceUtils.java b/src/main/java/demo/resource/ResourceUtils.java
new file mode 100644
index 0000000..53c9f2f
--- /dev/null
+++ b/src/main/java/demo/resource/ResourceUtils.java
@@ -0,0 +1,21 @@
+package demo.resource;
+
+import java.io.BufferedReader;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.Reader;
+import component.resource.metatada.ResourceMetadata;
+
+public class ResourceUtils {
+
+    public static void print(InputStream stream) {
+        Reader reader = new InputStreamReader(stream);
+        BufferedReader bf = new BufferedReader(reader);
+        bf.lines().forEach(System.out::println);
+    }
+
+    public static void print(ResourceMetadata metadata) {
+        System.out.println();
+        print(metadata.load());
+    }
+}
diff --git a/src/main/java/demo/resource/demo b/src/main/java/demo/resource/demo
new file mode 100644
index 0000000..537a1dc
--- /dev/null
+++ b/src/main/java/demo/resource/demo
@@ -0,0 +1 @@
+C'est la dmo !
\ No newline at end of file
diff --git a/src/main/java/demo/resource/demo_1.txt b/src/main/java/demo/resource/demo_1.txt
new file mode 100644
index 0000000..ff08dca
--- /dev/null
+++ b/src/main/java/demo/resource/demo_1.txt
@@ -0,0 +1 @@
+C'est la dmo .txt !
\ No newline at end of file
diff --git a/src/main/java/demo/resource/demo_classpath b/src/main/java/demo/resource/demo_classpath
new file mode 100644
index 0000000..c7bb7c7
--- /dev/null
+++ b/src/main/java/demo/resource/demo_classpath
@@ -0,0 +1 @@
+C'est la dmo depuis le classpath !
\ No newline at end of file
diff --git a/src/main/java/demo/resource/demo_file b/src/main/java/demo/resource/demo_file
new file mode 100644
index 0000000..b162ccd
--- /dev/null
+++ b/src/main/java/demo/resource/demo_file
@@ -0,0 +1 @@
+C'est la dmo depuis un fichier !
\ No newline at end of file
diff --git a/src/main/java/demo/templating/TemplatingDemo.java b/src/main/java/demo/templating/TemplatingDemo.java
new file mode 100644
index 0000000..24386df
--- /dev/null
+++ b/src/main/java/demo/templating/TemplatingDemo.java
@@ -0,0 +1,227 @@
+package demo.templating;
+
+import component.resource.ResourceService;
+import component.resource.loader.ClasspathResourceLoader;
+import component.resource.reference.ResourceReference;
+import component.templating.Engine;
+import component.templating.Environment;
+import component.templating.Template;
+
+public class TemplatingDemo {
+//    private static final Pattern PATTERN_STRING = compile("((\").*?(?<!\\\\)(\"))|((').*?(?<!\\\\)('))", Pattern.DOTALL);
+    
+    public static void main(String[] args) throws Exception {
+        ResourceService resourceService = ResourceService.builder()
+                .with(ResourceReference.CLASSPATH, new ClasspathResourceLoader(TemplatingDemo.class))
+                .build();
+        Environment env = Environment.builder()
+                .resourceService(resourceService)
+                .build();
+
+        Engine engine = Engine.builder()
+                .environment(env)
+                .execute("{%", "%}")
+                .comment("{#", "#}")
+                .print("{{", "}}")
+                .build();
+
+        Template demo = engine.load("classpath:demo.view");  
+        engine.render(demo);
+//        engine.render(demo, Renderer.debug());    
+//        engine.render(demo, CoreExtension.debug());   
+    }
+}
+//        engine.render(demo, new StreamRenderer());  
+                
+//        engine.render(demo, (t, e) -> {
+//            t.getTokens().forEach(System.out::println);
+//            System.out.println(t);
+//        });             
+        
+//        Template template = Template.builder().named("first")
+//                .build();
+//        
+//        Template home = Template.builder().named("home")
+//                .extend(template)
+//                .build();
+    
+//    public static class StreamRenderer implements Renderer {
+//        
+//        @Override
+//        public void render(Template template, Environment environment) throws Exception {
+//            Context context = new Context();
+//            Writer writer = new OutputStreamWriter(System.out);
+//            
+//            TokenStream stream = template.stream();
+//            Token token = stream.current();
+//            
+//            while (!Token.isEOF(token)) {
+//                switch (token.getType()) {
+//                    case "comment_open":
+//                        token = stream.expect("comment_open");
+//                        token = stream.expect("expression");
+//                        token = stream.expect("comment_close");                        
+//                        break;
+//                    case "evaluate_open":
+//                        token = stream.expect("evaluate_open");
+//                        token = stream.expect("expression");
+//                        token = stream.expect("evaluate_close");     
+////                        token = stream.next();
+////                        Optional<Object> evaluated = context.evaluate(token.getValue(), Object.class);
+////                        if (evaluated.isPresent()) {
+////                            writer.write(evaluated.get().toString());
+////                        }
+//                        break;
+//                    case "execute_open":
+////                        token = stream.expect("expression");
+//                        // evaluate the expression
+////                        environment.getSyntax().getExpressions().values().forEach((e) -> {
+////                            e.evalute(token.getValue().trim(), context);
+////                        });
+//                        break;
+//                    case "text":
+//                        writer.write(token.getValue());
+//                        break;
+//                    default:
+//                        break;
+//                }
+//                token = stream.next();
+//            }
+//            
+//            writer.flush();
+//        }
+//    }
+//    
+//    public static class ForExpression extends BinaryExpression {
+//        
+//        public ForExpression(String name, String[] operators, BiConsumer consumer) {
+//            super(name, operators, consumer);
+//        }
+//        
+//    }
+
+//        Rule executeStart = Rule.group("start", Pattern.quote("{%"));
+//        Rule executeEnd = Rule.group("end", Pattern.quote("%}"));
+//        
+//        Rule expression = Rule.group("var", ".*");
+//        Rule ltrim = Rule.group("ltrim", "-", "?+");
+//        Rule rtrim = Rule.group("rtrim", "-", "?+");
+//        
+////        Rule execute = Rule.expect("(?<start>\\Q{%\\E)(?<ltrim>\\Q-\\E*)(?<expression>.*)(?<rtrim>\\Q-\\E*)(?<end>\\Q%}\\E)");
+//        
+//        Sequence command = Sequence.builder()
+//                .withRule(executeStart)
+//                .withRule(ltrim)
+//                .withRule(expression)
+//                .withRule(rtrim)
+//                .withRule(executeEnd)
+//                .build();
+//        
+//        System.out.println(command.validate("{% if true %}\nbonjour\n{% endif %}"));
+//        System.out.println(command.groups("{% if true %} bonjour {% endif %}"));
+//        System.out.println(command.groups("{%- if true %}\nbonjour\n{% endif %}"));
+//        System.out.println(command.groups("{% %} {% %}"));
+//        System.out.println(command.groups("aze"));
+//        System.out.println(command.groups("aze"));
+//        System.out.println(command.validate("{# this is a comment #}"));
+        
+
+//        Syntax syntax = Syntax.builder()
+//                .trim("-")
+//                .command("comment", "{#", "#}", (stream, context) -> {})
+//                .command("print", "{{", "}}", (stream, context) -> {
+//                    Token current = stream.current();
+//                    String value = current.getValue();
+//                    
+//                    Optional<Object> result = context.evaluate(value);
+//                    
+//                })
+//                .command("execute", "{%", "%}", (stream, context) -> {})
+//                
+//                .expression("if", (value, context) -> {
+//                    System.out.println("if");
+//                    Optional<Object> result = context.evaluate(value);
+//                    
+//                    if (result.isPresent()) {
+//                        System.out.println(result);
+//                    }
+//                })
+//                .expression("not", (value, context) -> {
+//                    System.out.println("not");
+//                
+//                })
+//                .expression("set", (value, context) -> {
+//                    System.out.println("set");
+//                
+//                })
+//                .expression("for", "in", (value, context) -> {
+//                    System.out.println("for");
+//                
+//                })
+//                .build();
+//        
+
+
+
+//
+//                .expression("if", (String value, Context context) -> {
+//                    Optional<Boolean> result = context.evaluate(value, Boolean.class);
+//                    if (result.isPresent() && result.get()) {
+//                        System.out.println(result.get());
+//                    }
+//                })
+//                .binary("for", new String[]{"in"}, (String value, Context context) -> {
+//                    String[] values = value.split("in");
+//                    
+//                    if (values.length < 2) {
+//                        throw new IllegalArgumentException("'for' should be followed by an itteration exression('a in b')");
+//                    }
+//                    
+////                    Token next = context.getStream().next();
+//                    
+//                    String key = values[0].trim();
+//                    String v = values[1].trim();
+//                    
+//                    // is form : ["", "", "", "", ""] ?
+//                    // is form : {a : "", b : ""} ?
+//                    
+//                    // is a var : a ?
+//                    Optional<Object> evaluated = context.evaluate(v, Object.class);
+//                    
+//                    if (!evaluated.isPresent()) {
+//                        return;
+//                    }
+//                    
+//                    Collection list = new ArrayList();
+//                    Object o = evaluated.get();
+//                    
+//                    if (o instanceof Collection) {
+//                        list = (Collection) o;
+//                    }
+//                    
+//                    if (o instanceof String) {
+//                        char[] chars = ((String) o).toCharArray();
+//                        for(char c : chars) {
+//                            list.add(c);
+//                        }
+//                    }
+//                    
+//                    int i = 0;
+//                    for (Object object : list) {
+//                        context.getModel().put("index", i++);
+//                        context.getModel().put(key, object);
+//                        System.out.println(object);
+//                    }
+//                })
+//                .binary("set", new String[]{"="}, (String value, Context context) -> {
+//                    String[] values = value.split("=");
+//                    
+//                    if (values.length < 2) {
+//                        throw new IllegalArgumentException("'set' should be followed by a attribution exression('a = b')");
+//                    }
+//                    
+//                    String key = values[0].trim();
+//                    String v = values[1].trim().replaceAll("(\\Q\"\\E)", "");
+//                    
+//                    context.getModel().put(key, v);
+//                })
\ No newline at end of file
diff --git a/src/main/java/demo/templating_old/TemplatingDemo.java b/src/main/java/demo/templating_old/TemplatingDemo.java
new file mode 100644
index 0000000..b3310a8
--- /dev/null
+++ b/src/main/java/demo/templating_old/TemplatingDemo.java
@@ -0,0 +1,17 @@
+package demo.templating_old;
+
+public class TemplatingDemo {
+    
+    public static void main(String[] args) throws Exception {
+//        EngineBuilder engineBuilder = new EngineBuilder();
+//        Engine engine = engineBuilder.build();
+//        
+//        Template template = engine.getTemplate("demo/templating/demo.view");
+//        
+//        Writer writer = new StringWriter();
+//        template.evaluate(writer);
+//        
+//        System.out.println(writer.toString());
+        
+    }
+}
diff --git a/src/main/java/demo/templating_old/demo.view b/src/main/java/demo/templating_old/demo.view
new file mode 100644
index 0000000..537a1dc
--- /dev/null
+++ b/src/main/java/demo/templating_old/demo.view
@@ -0,0 +1 @@
+C'est la dmo !
\ No newline at end of file
diff --git a/src/main/resources/demo/templating/demo.view b/src/main/resources/demo/templating/demo.view
new file mode 100644
index 0000000..844e58e
--- /dev/null
+++ b/src/main/resources/demo/templating/demo.view
@@ -0,0 +1,40 @@
+
+
+Leading text
+
+{% show(1) %}
+
+{% show([1, 2, 3, 4]) %}
+
+{% if (a == b) %}
+{% endif %}
+
+{% if not something %}
+{% endif %}
+
+{% if something %}
+{% endif %}
+
+{% block test %}
+    Ceci est dans le block test
+
+    {% if true %}
+        Ceci est dans la if condition
+    {% endif %}
+{% endblock %}
+
+{# comment [1, 2, 3, 4] #}
+
+{{ show [1, 2, 3, 4] }}
+
+Some text, to say hello ...
+
+Hello {{ name }} {{ person.name }}!
+
+{% if true %}
+    This is true !
+{% endif %} 
+
+{% do it %}
+
+qsdqsdsqdsdq
diff --git a/src/main/resources/demo/templating/demo_1.view b/src/main/resources/demo/templating/demo_1.view
new file mode 100644
index 0000000..5373d60
--- /dev/null
+++ b/src/main/resources/demo/templating/demo_1.view
@@ -0,0 +1,42 @@
+
+
+Leading text
+
+{% block 'test' %}
+    Ceci est dans le block test
+
+    {% if t %}
+        Ceci est dans la if condition
+    {% endif %}
+{% endblock %}
+
+{# comment #}
+{% set name = "World" %}
+
+Some text, to say hello ...
+
+Hello {{ name }} !
+
+
+{% if true -%}
+    This is true !
+{%- endif %} 
+
+
+{% if false %}
+    This is not true !
+{% endif %} 
+
+{% for letter in name %}
+    {{ letter }} 
+{% endfor %} 
+
+{% for i in tab %}
+    {% if i > 0 %}
+        Greater than 0
+    {% endif %}
+{% endfor %} 
+
+{{ unclosed 
+
+{% do it %}
diff --git a/src/node/Node.java b/src/node/Node.java
deleted file mode 100644
index cf69cbc..0000000
--- a/src/node/Node.java
+++ /dev/null
@@ -1,200 +0,0 @@
-package node;
-
-import java.util.*;
-import java.util.function.BiConsumer;
-import java.util.function.Consumer;
-import java.util.function.Supplier;
-
-public class Node {
-
-    protected String name;
-    protected String namespace;
-    protected Object value;
-    protected Object defaultValue;
-    protected boolean useDefault;
-    protected boolean required;
-    protected boolean allowEmptyValue = true;
-    protected Map<String, Object> attributes = new HashMap<>();
-    
-    protected Node parent;
-    protected Collection<Node> children;
-
-    public Node() {
-        
-    }
-    
-    public Node(String name) {
-        this.name = name;
-    }
-    
-    public Node(String namespace, String name, Object value, Map<String, Object> attributes) {
-        this.namespace = namespace;
-        this.name = name;
-        this.value = value;
-        this.attributes = attributes;
-    }
-
-    public Node(String namespace, String name, Object value) {
-        this(namespace, name, value, null);
-    }
-
-//    public static NodeBuilder builder() {
-//        return new NodeBuilder();
-//    }
-
-    public Node getParent() {
-        return parent;
-    }
-
-    public void setParent(Node parent) {
-        this.parent = parent;
-    }
-    
-    public Collection<Node> getChildren() {
-        if (children == null) {
-            this.children = new ArrayList<>();
-        }
-        return children;
-    }
-
-    public void setChildren(Collection<Node> children) {
-        this.children = children;
-    }
-
-    public Node attr(String name, Object val) {
-        getAttributes().put(name, val);
-        return this;
-    }
-    
-    public Node child(Node child) {
-        if (children == null) {
-            children = new ArrayList<>();
-        }
-        this.children.add(child);
-        child.setParent(this);
-        return this;
-    }
-
-    public void setDefaultValue(Object defaultValue) {
-        this.useDefault = true;
-        this.defaultValue = defaultValue;
-    }
-
-    public boolean isRequired() {
-        return required;
-    }
-
-    public void setRequired(boolean required) {
-        this.required = required;
-    }
-
-    public boolean isAllowEmptyValue() {
-        return allowEmptyValue;
-    }
-
-    public void setAllowEmptyValue(boolean allowEmptyValue) {
-        this.allowEmptyValue = allowEmptyValue;
-    }
-    
-    public Object getValue() {
-        if (value instanceof Supplier) {
-            return ((Supplier) value).get();
-        }
-        return value;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-    
-    public String getName() {
-        return name;
-    }
-
-    public void setNamespace(String namespace) {
-        this.namespace = namespace;
-    }
-    
-    public String getNamespace() {
-        return namespace;
-    }
-
-    public Map getAttributes() {
-        if (attributes == null) {
-            attributes = new LinkedHashMap<>(3, 1.0f);
-        }
-        return attributes;
-    }
-
-    public void eachChild(Consumer<Node> consumer) {
-        getChildren().forEach((child) -> {
-            consumer.accept(child);
-            child.visit(consumer);
-        });
-    }
-
-    public Node visit(Consumer<Node> consumer) {
-        eachChild(consumer);
-        consumer.accept(this);
-        return this;
-    }
-
-    public Node visitBeforeAndAfter(BiConsumer<Boolean, Node> consumer) {
-        consumer.accept(true, this);
-        getChildren().forEach((child) -> {
-            child.visitBeforeAndAfter(consumer);
-        });
-        consumer.accept(false, this);
-        return this;
-    }
-
-    @Override
-    public int hashCode() {
-        int hash = 5;
-        hash = 97 * hash + Objects.hashCode(this.attributes);
-        hash = 97 * hash + Objects.hashCode(this.value);
-        hash = 97 * hash + Objects.hashCode(this.name);
-        hash = 97 * hash + Objects.hashCode(this.namespace);
-        hash = 97 * hash + Objects.hashCode(this.children);
-        hash = 97 * hash + Objects.hashCode(this.parent);
-        return hash;
-    }
-
-    @Override
-    public boolean equals(Object obj) {
-        if (this == obj) {
-            return true;
-        }
-        if (obj == null) {
-            return false;
-        }
-        if (getClass() != obj.getClass()) {
-            return false;
-        }
-        final Node other = (Node) obj;
-        if (!Objects.equals(this.name, other.name)) {
-            return false;
-        }
-        if (!Objects.equals(this.namespace, other.namespace)) {
-            return false;
-        }
-        if (!Objects.equals(this.attributes, other.attributes)) {
-            return false;
-        }
-        if (!Objects.equals(this.value, other.value)) {
-            return false;
-        }
-        if (!Objects.equals(this.children, other.children)) {
-            return false;
-        }
-        if (!Objects.equals(this.parent, other.parent)) {
-            return false;
-        }
-        return true;
-    }
-
-    @Override
-    public String toString() {
-        return "Node{" + "attributes=" + attributes + ", value=" + value + ", name=" + name + ", namespace=" + namespace + ", children=" + children + '}';
-    }
-}
diff --git a/src/node/NodeFactory.java b/src/node/NodeFactory.java
deleted file mode 100644
index 2593a30..0000000
--- a/src/node/NodeFactory.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package node;
-
-public class NodeFactory {
-    
-}
diff --git a/src/node/builder/NodeBuilder.java b/src/node/builder/NodeBuilder.java
deleted file mode 100644
index eebd243..0000000
--- a/src/node/builder/NodeBuilder.java
+++ /dev/null
@@ -1,63 +0,0 @@
-package node.builder;
-
-import node.Node;
-import builder.Builder;
-import java.util.ArrayList;
-import java.util.Collection;
-
-public class NodeBuilder extends Builder<Node> implements NodeBuilderInterface {
-
-    public static final String DEFAULT_NS = "_default_ns";
-    
-    protected NodeBuilderInterface parent;
-    
-    protected Collection<NodeBuilderInterface> children;
-    
-    public NodeBuilder() {
-        this(new Node());
-    }
-    
-    public NodeBuilder(Node node) {
-        super(node);
-    }
-    
-    public Collection<NodeBuilderInterface> getChildren() {
-        if (this.children == null) {
-            this.children = new ArrayList<>();
-        }
-        return children;
-    }
-
-    public void setChildren(Collection<NodeBuilderInterface> children) {
-        this.children = children;
-    }
-    
-    public void setParent(NodeBuilderInterface parent) {
-        this.parent = parent;
-    }
-
-    @Override
-    public NodeBuilderInterface end() {
-        return parent;
-    }
-    
-    public static NodeBuilder root() {
-        return new NodeBuilder(new Node("root"));
-    }
-
-    @Override
-    public NodeBuilderInterface array(String name) {
-        NodeBuilder builder = new NodeBuilder(node(name));
-        builder.setParent(this);
-        this.getChildren().add(builder);
-        return builder;
-    }
-
-    @Override
-    public NodeBuilderInterface bool(String name) {
-        NodeBuilder builder = new NodeBuilder(child(name));
-        builder.setParent(this);
-        this.getChildren().add(builder);
-        return builder;
-    }
-}
diff --git a/src/node/builder/NodeBuilderInterface.java b/src/node/builder/NodeBuilderInterface.java
deleted file mode 100644
index a1d8eea..0000000
--- a/src/node/builder/NodeBuilderInterface.java
+++ /dev/null
@@ -1,92 +0,0 @@
-package node.builder;
-
-import node.Node;
-import builder.BuilderInterface;
-import java.util.function.Consumer;
-
-public interface NodeBuilderInterface extends BuilderInterface<Node> {
-    
-    public NodeBuilderInterface array(String name);
-    public NodeBuilderInterface bool(String name);
-    public NodeBuilderInterface end();
-    
-    default Node child(String name) {
-        return child(node(name));
-    }
-    
-    default Node child(Node node) {
-        consume((parent) -> {
-            parent.child(node);
-        });
-        return node;
-    }
-    
-    default Node node(String name) {
-        return new Node(name);
-    }
-    
-    default NodeBuilderInterface name(String name) {
-        consume((node) -> {
-            node.setName(name);
-        });
-        return this;
-    }
-    
-    default NodeBuilderInterface visit(Consumer<Node> consumer) {
-        consume((node) -> {
-            node.visit(consumer);
-        });
-        return this;
-    }
-    
-    default NodeBuilderInterface namespace(String namespace) {
-        consume((node) -> {
-            node.setNamespace(namespace);
-        });
-        return this;
-    }
-    
-    default NodeBuilderInterface attribute(String key, Object attribute) {
-        consume((node) -> {
-            node.attr(key, attribute);
-        });
-        return this;
-    }
-    
-    default NodeBuilderInterface defaultValue(Object value) {
-        consume((node) -> {
-            node.setDefaultValue(value);
-        });
-        return this;
-    }
-    
-    default NodeBuilderInterface defaultNull() {
-        return defaultValue(null);
-    }
-    
-    default NodeBuilderInterface defaultTrue() {
-        return defaultValue(true);
-    }
-
-    default NodeBuilderInterface defaultFalse() {
-        return defaultValue(false);
-    }
-    
-    default NodeBuilderInterface required() {
-        consume((node) -> {
-            node.setRequired(true);
-        });
-        return this;
-    }
-    
-    default NodeBuilderInterface cannotBeEmpty() {
-        consume((node) -> {
-            node.setAllowEmptyValue(false);
-        });
-        return this;
-    }
-    
-    default NodeBuilderInterface info(String info) {
-        return attribute("info", info);
-    }
-}
diff --git a/src/node/legacy/ArrayNode.java b/src/node/legacy/ArrayNode.java
deleted file mode 100644
index 0ef87f6..0000000
--- a/src/node/legacy/ArrayNode.java
+++ /dev/null
@@ -1,228 +0,0 @@
-package node.legacy;
-
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Set;
-import utils.ObjectUtils;
-
-public class ArrayNode extends Node {
-
-    protected boolean addIfNotSet = false;
-    protected boolean normalizeKeys = true;
-    protected boolean removeExtraKeys = true;
-    protected boolean deepMerging = true;
-    protected boolean allowNewKeys = true;
-    protected HashMap<String, String> xmlRemapping = new HashMap<>();
-    
-    public ArrayNode(String name) {
-        super(name);
-    }
-
-    @Override
-    protected Object preNormalize(Object value) {
-        
-        if(!isNormalizeKeys() || !(value instanceof Map)) {
-            return value;
-        }
-        
-        Map<String, Object> normalized = new HashMap();
-        
-        Map<String, Object> typedValue = (Map<String, Object>) value;
-        typedValue.forEach((String k, Object val) -> {
-            
-            if(k.contains("-") && !k.contains("_")) {
-                String normalizedKey = k.replace("-", "_");
-                if(!typedValue.containsKey(normalizedKey)) {
-                    k = normalizedKey;
-                }
-            }
-            
-            normalized.put(k, val);
-        });
-        
-        return super.preNormalize(value); //To change body of generated methods, choose Tools | Templates.
-    }
-    
-    @Override
-    protected void validateType(Object value) {
-        if(!ObjectUtils.isArray(value) 
-                && !(value instanceof Map) 
-                && !(value instanceof Set) 
-                && !(value instanceof List)) {
-            String msg = String.format("Invalid type for path %s. Expected array but got %s", this.getPath(), value == null ? null: value.getClass());
-            throw new RuntimeException(msg);
-        }
-    }
-
-    @Override
-    protected Object normalizeValue(Object value) {
-        
-        HashMap<String, Object> normalized = new HashMap<>();
-        
-        if(value == null) {
-            return normalized;
-        }
-        
-        HashMap<String, Object> casted = (HashMap<String, Object>) value;
-        casted = remapXml(casted);
-        
-        casted.forEach((String key, Object val) -> {
-            if(getChildren().containsKey(key)) {
-                normalized.put(key, getChildren().get(key).normalizeValue(val));
-            } else if (!isRemoveExtraKeys()) {
-                normalized.put(key, val);
-            }
-        });
-        
-        return normalized;
-    }
-
-    @Override
-    protected Object mergeValues(Object left, Object right) throws Exception {
-        
-        if(Boolean.FALSE.equals(right)) {
-            return false;
-        }
-        
-        if(Boolean.FALSE.equals(left) || !isDeepMerging()) {
-            return right;
-        }
-        
-        return mergeMap((Map) left, (Map) right);
-    }
-    
-    protected Map<String, Object> mergeMap(Map<String, Object> left, Map<String, Object> right) throws Exception{
-        for (Map.Entry<String, Object> entrySet : right.entrySet()) {
-            String key = entrySet.getKey();
-            Object value = entrySet.getValue();
-            
-            // no conflict
-            if(!left.containsKey(key)) {
-                if(!isAllowNewKeys()) {
-                    String msg = String.format("You are not allowed to define new elements for path '%s'", this.getPath());
-                    throw new Exception(msg);
-                }
-                
-                left.put(key, value);
-                continue;
-            }
-            
-            if(!getChildren().containsKey(key)){
-                throw new Exception("merge() expects a normalized config array.");
-            }
-            
-            left.put(key, getChildren().get(key).merge(left.get(key), value));
-        }
-        
-        return left;
-    }
-
-    @Override
-    protected Object finalizeValue(Object value) {
-        HashMap<String, Object> casted = (HashMap<String, Object>) value;
-        
-        if(getChildren() != null) {
-            for(Map.Entry<String, Node> entry : getChildren().entrySet()) {
-                String key = entry.getKey();
-                Node child = entry.getValue();
-
-                if(!casted.containsKey(key)) {
-                    if(child.isRequired()) {
-                        String msg = String.format("The child node '%s' at path '%s' must be configured.", key, this.getPath());
-                        throw new RuntimeException(msg);
-                    }
-
-                    if(child.hasDefaultValue()) {
-                        casted.put(key, child.getDefaultValue());
-                    }
-
-                    continue;
-                }
-
-                casted.put(key, child.finalize(casted.get(key)));
-            }
-        }
-        
-        return casted;
-    }
-    
-    protected HashMap<String, Object> remapXml(HashMap<String, Object> value){
-        getXmlRemapping().forEach((String singular, String plural) -> {
-            if(value.containsKey(singular)) {
-                value.put(plural, value.get(singular));
-                value.remove(singular);
-            }
-        });
-        
-        return value;
-    }
-    
-    @Override
-    public boolean hasDefaultValue() {
-        return this.addIfNotSet;
-    }
-
-    @Override
-    public Object getDefaultValue() {
-       
-        HashMap<String, Object> defaults = new HashMap<>();
-        
-        getChildren().forEach((String key, Node child) -> {
-            if(child.hasDefaultValue()) {
-                defaults.put(key, child.getDefaultValue());
-            }
-        });
-        
-        return defaults;
-    }
-
-    public void setNormalizeKeys(boolean normalizeKeys) {
-        this.normalizeKeys = normalizeKeys;
-    }
-
-    public void setXmlRemapping(HashMap<String, String> xmlRemapping) {
-        this.xmlRemapping = xmlRemapping;
-    }
-
-    public HashMap<String, String> getXmlRemapping() {
-        return xmlRemapping;
-    }
-
-    public boolean isDeepMerging() {
-        return deepMerging;
-    }
-
-    public boolean isAddIfNotSet() {
-        return addIfNotSet;
-    }
-
-    public boolean isAllowNewKeys() {
-        return allowNewKeys;
-    }
-
-    public boolean isNormalizeKeys() {
-        return normalizeKeys;
-    }
-
-    public boolean isRemoveExtraKeys() {
-        return removeExtraKeys;
-    }
-
-    public void setAddIfNotSet(boolean addIfNotSet) {
-        this.addIfNotSet = addIfNotSet;
-    }
-
-    public void setAllowNewKeys(boolean allowNewKeys) {
-        this.allowNewKeys = allowNewKeys;
-    }
-
-    public void setDeepMerging(boolean deepMerging) {
-        this.deepMerging = deepMerging;
-    }
-
-    public void setRemoveExtraKeys(boolean removeExtraKeys) {
-        this.removeExtraKeys = removeExtraKeys;
-    }
-    
-}
diff --git a/src/node/legacy/BooleanNode.java b/src/node/legacy/BooleanNode.java
deleted file mode 100644
index 5811096..0000000
--- a/src/node/legacy/BooleanNode.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package node.legacy;
-
-public class BooleanNode extends ScalarNode {
-
-    public BooleanNode(String name) {
-        super(name);
-    }
-    
-}
diff --git a/src/node/legacy/EnumNode.java b/src/node/legacy/EnumNode.java
deleted file mode 100644
index bd74643..0000000
--- a/src/node/legacy/EnumNode.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package node.legacy;
-
-public class EnumNode extends ScalarNode {
-
-    protected Object[] values;
-    
-    public EnumNode(String name) {
-        super(name);
-    }
-    
-    public EnumNode(String name, Object[] values) {
-        super(name);
-        this.values = values;
-    }
-    
-}
diff --git a/src/node/legacy/FloatNode.java b/src/node/legacy/FloatNode.java
deleted file mode 100644
index 7fb4bf2..0000000
--- a/src/node/legacy/FloatNode.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package node.legacy;
-
-public class FloatNode extends NumericNode {
-
-    public FloatNode(String name) {
-        super(name);
-    }
-    
-    public FloatNode(String name, Node parent) {
-        super(name, parent);
-    }
-    
-}
diff --git a/src/node/legacy/IntegerNode.java b/src/node/legacy/IntegerNode.java
deleted file mode 100644
index 8645b12..0000000
--- a/src/node/legacy/IntegerNode.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package node.legacy;
-
-public class IntegerNode extends NumericNode {
-
-    public IntegerNode(String name) {
-        super(name);
-    }
-    
-    public IntegerNode(String name, Node parent) {
-        super(name, parent);
-    }
-    
-}
diff --git a/src/node/legacy/Node.java b/src/node/legacy/Node.java
deleted file mode 100644
index 7f37250..0000000
--- a/src/node/legacy/Node.java
+++ /dev/null
@@ -1,219 +0,0 @@
-package node.legacy;
-
-import java.util.HashMap;
-import java.util.LinkedHashMap;
-import java.util.List;
-import java.util.function.Function;
-
-public abstract class Node {
-    
-    protected String name;
-    protected Node parent;
-    protected boolean required;
-    protected boolean allowOverWrite = true;
-    protected boolean useDefault = true;
-    protected Object defaultValue;
-    protected HashMap<String, Object> attributes;
-    
-    protected LinkedHashMap<String, Node> children;
-    
-    protected List<Function<Object, Object>> normalizationClosures;
-    protected List<Function<Object, Object>> finalValidationClosures;
-    
-    public Node(String name) {
-        this.name = name;
-    }
-
-    public Node(String name, Node parent) {
-        this.name = name;
-        this.parent = parent;
-    }
-    
-    protected Object preNormalize(Object value) {
-        return value;
-    }
-    
-    final public Object normalize(Object value) {
-        
-        value = preNormalize(value);
-        
-        if(getNormalizationClosures() != null) {
-            for (Function<Object, Object> closure : getNormalizationClosures()) {
-                value = closure.apply(value);
-            }
-        }
-        
-        // replaces with equivalent values
-        // dans un tableau de valeur
-        
-        validateType(value);
-        
-        return normalizeValue(value);
-    }
-    
-    final public Object merge(Object left, Object right) throws Exception {
-        
-        if(!isAllowOverWrite()) {
-            String msg = String.format("Configuration path %s, can not be overwritten. "
-                    + "You have to define all options for this path, "
-                    + "and any of its sub-paths in one configuration section.", this.getPath());
-            throw new Exception(msg);
-        }
-        
-        // validate type of left side object
-        validateType(left);
-        
-        // validate type of right side object
-        validateType(right);
-        
-        return mergeValues(left, right);
-    }
-    
-    final public Object finalize(Object value) {
-        
-        validateType(value);
-        
-        value = finalizeValue(value);
-        
-        if(getFinalValidationClosures() != null) {
-            for (Function<Object, Object> closure : getFinalValidationClosures()) {
-                value = closure.apply(value);
-            }
-        }
-        
-        return value;
-    }
-    
-    abstract protected void validateType(Object value);
-    
-    abstract protected Object normalizeValue(Object value);
-    
-    abstract protected Object mergeValues(Object left, Object right) throws Exception;
-
-    abstract protected Object finalizeValue(Object value);
-    
-    abstract public boolean hasDefaultValue();
-    
-    abstract public Object getDefaultValue();
-    
-    public void addChild(Node child){
-        
-        if(getChildren() == null) {
-            setChildren(new LinkedHashMap<>());
-        }
-        
-        getChildren().putIfAbsent(child.getName(), child);
-        child.setParent(this);
-    }
-    
-    public final String getPath() {
-        String path = getName();
-        
-        if(getParent() != null) {
-            path = getParent().getName() + "." + path;
-        }
-        
-        return path;
-    }
-
-    public String getName() {
-        return this.name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public boolean isRequired() {
-        return this.required;
-    }
-
-    public void setRequired(boolean required) {
-        this.required = required;
-    }
-
-    public Node getParent() {
-        return this.parent;
-    }
-
-    public void setParent(Node parent) {
-        this.parent = parent;
-    }
-
-    public HashMap<String, Object> getAttributes() {
-        return this.attributes;
-    }
-
-    public void setAttributes(HashMap<String, Object> attributes) {
-        this.attributes = attributes;
-    }
-
-    public boolean isAllowOverWrite() {
-        return this.allowOverWrite;
-    }
-    
-    public void setAllowOverWrite(boolean allowOverWrite) {
-        this.allowOverWrite = allowOverWrite;
-    }
-
-    public List<Function<Object, Object>> getFinalValidationClosures() {
-        return this.finalValidationClosures;
-    }
-
-    public List<Function<Object, Object>> getNormalizationClosures() {
-        return this.normalizationClosures;
-    }
-
-    public void setFinalValidationClosures(List<Function<Object, Object>> finalValidationClosures) {
-        this.finalValidationClosures = finalValidationClosures;
-    }
-
-    public void setNormalizationClosures(List<Function<Object, Object>> normalizationClosures) {
-        this.normalizationClosures = normalizationClosures;
-    }
-
-    public void setChildren(LinkedHashMap<String, Node> children) {
-        this.children = children;
-    }
-
-    public LinkedHashMap<String, Node> getChildren() {
-        return this.children;
-    }
-    
-    private int getRank(){
-        int rank = 0;
-        
-        Node current = this;
-        
-        while(current.parent != null) {
-            rank++;
-            current = current.parent;
-        }
-        
-        return rank;
-    }
-
-//    @Override
-//    public String toString() {
-//        StringBuilder builder = new StringBuilder();
-//        
-//        int rank = this.getRank();
-//        builder.append("|");
-//        
-//        for (int i = 0; i < rank; i++) {
-//            builder.append("-----");
-//        }
-//        
-//        builder.append(this.name);
-//        builder.append("\n");
-//        
-//        if(this.children != null) {
-//            this.children.values().forEach((Node child) -> {
-//                builder.append(child);
-//            });
-//        }
-//        
-//        return builder.toString();
-//    }
-    
-}
diff --git a/src/node/legacy/NumericNode.java b/src/node/legacy/NumericNode.java
deleted file mode 100644
index 1326f9a..0000000
--- a/src/node/legacy/NumericNode.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package node.legacy;
-
-public abstract class NumericNode extends ScalarNode {
-
-    public NumericNode(String name) {
-        super(name);
-    }
-    
-    public NumericNode(String name, Node parent) {
-        super(name, parent);
-    }
-    
-}
diff --git a/src/node/legacy/PrototypedArrayNode.java b/src/node/legacy/PrototypedArrayNode.java
deleted file mode 100644
index b05286a..0000000
--- a/src/node/legacy/PrototypedArrayNode.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package node.legacy;
-
-public class PrototypedArrayNode extends ArrayNode {
-
-    protected Node prototype;
-    
-    public PrototypedArrayNode(String name) {
-        super(name);
-    }
-
-    public Node getPrototype() {
-        return this.prototype;
-    }
-
-    public void setPrototype(Node prototype) {
-        this.prototype = prototype;
-    }
-}
diff --git a/src/node/legacy/ScalarNode.java b/src/node/legacy/ScalarNode.java
deleted file mode 100644
index d35e348..0000000
--- a/src/node/legacy/ScalarNode.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package node.legacy;
-
-public class ScalarNode extends VariableNode {
-
-    public ScalarNode(String name) {
-        super(name);
-    }
-
-    public ScalarNode(String name, Node parent) {
-        super(name, parent);
-    }
-    
-}
diff --git a/src/node/legacy/VariableNode.java b/src/node/legacy/VariableNode.java
deleted file mode 100644
index 3bd58f8..0000000
--- a/src/node/legacy/VariableNode.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package node.legacy;
-
-import java.util.function.Supplier;
-import utils.ObjectUtils;
-
-public class VariableNode extends Node {
-
-    protected boolean defaultValueSet = false;
-    protected boolean allowEmptyValue = true;
-    protected Object defaultValue;
-    
-    public VariableNode(String name) {
-        super(name);
-    }
-
-    public VariableNode(String name, Node parent) {
-        super(name, parent);
-    }
-
-    @Override
-    public boolean hasDefaultValue() {
-        return this.defaultValueSet;
-    }
-
-    public void setDefaultValue(Object defaultValue) {
-        this.defaultValueSet = true;
-        this.defaultValue = defaultValue;
-    }
-
-    @Override
-    public Object getDefaultValue() {
-        Object v = defaultValue;
-        
-        if(v instanceof Supplier) {
-            v = ((Supplier) defaultValue).get();
-        }
-        
-        return v;
-    }
-
-    @Override
-    protected void validateType(Object value) {
-        // do nothing
-    }
-
-    @Override
-    protected Object normalizeValue(Object value) {
-        return value;
-    }
-
-    @Override
-    protected Object mergeValues(Object left, Object right) {
-        return right;
-    }
-
-    @Override
-    protected Object finalizeValue(Object value) {
-        
-        if(!isAllowEmptyValue() && ObjectUtils.isEmpty(value)) {
-            String msg = String.format("The path '%s' cannot contain an empty value, but got %s.", this.getPath(), value);
-            throw new RuntimeException(msg);
-        }
-        
-        return value;
-    }
-
-    public boolean isAllowEmptyValue() {
-        return allowEmptyValue;
-    }
-
-    public void setAllowEmptyValue(boolean allowEmptyValue) {
-        this.allowEmptyValue = allowEmptyValue;
-    }
-}
diff --git a/src/node/normalization/NodeNormalizer.java b/src/node/normalization/NodeNormalizer.java
deleted file mode 100644
index 4c997f6..0000000
--- a/src/node/normalization/NodeNormalizer.java
+++ /dev/null
@@ -1,12 +0,0 @@
-package node.normalization;
-
-import node.Node;
-import normalizer.Normalizer;
-
-public class NodeNormalizer extends Normalizer<Node> {
-    
-    public NodeNormalizer() {
-        super();
-    }
-    
-}
diff --git a/src/node/normalization/NodeValueNormalization.java b/src/node/normalization/NodeValueNormalization.java
deleted file mode 100644
index 5b0d310..0000000
--- a/src/node/normalization/NodeValueNormalization.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package node.normalization;
-
-import java.util.HashMap;
-import java.util.Map;
-import normalizer.Normalization;
-
-public class NodeValueNormalization implements Normalization<Object> {
-
-    @Override
-    public Object apply(Object value) {
-        if(!(value instanceof Map)) {
-            return value;
-        }
-        
-        Map<String, Object> normalized = new HashMap();
-        
-        Map<String, Object> typedValue = (Map<String, Object>) value;
-        typedValue.forEach((String k, Object val) -> {
-            
-            if(k.contains("-") && !k.contains("_")) {
-                String normalizedKey = k.replace("-", "_");
-                if(!typedValue.containsKey(normalizedKey)) {
-                    k = normalizedKey;
-                }
-            }
-            
-            normalized.put(k, val);
-        });
-        
-        return value;
-    }
-    
-}
diff --git a/src/normalizer/Normalization.java b/src/normalizer/Normalization.java
deleted file mode 100644
index 6cef4a0..0000000
--- a/src/normalizer/Normalization.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package normalizer;
-
-import java.util.function.Function;
-
-public interface Normalization<O> extends Function<O , O> {
-
-    @Override
-    public default O apply(O value) {
-        return value;
-    }
-}
diff --git a/src/normalizer/Normalizer.java b/src/normalizer/Normalizer.java
deleted file mode 100644
index 59a4a80..0000000
--- a/src/normalizer/Normalizer.java
+++ /dev/null
@@ -1,45 +0,0 @@
-package normalizer;
-
-import java.util.List;
-import java.util.function.Function;
-
-public abstract class Normalizer<O> implements NormalizerInterface<O> {
-    
-    protected Normalization<O> preNormalization;
-    protected List<Normalization<O>> normalizations;
-    
-    public Normalizer() {
-        super();
-    }
-    
-    public Normalizer(Normalization<O> preNormalizationClosures) {
-        this();
-        this.preNormalization = preNormalizationClosures;
-    }
-
-    public Normalizer(Normalization<O> preNormalization, 
-            List<Normalization<O>> normalizations) {
-        this(preNormalization);
-        this.normalizations = normalizations;
-    }
-    
-    @Override
-    public O normalize(O value) {
-        if(this.preNormalization == null) {
-            return value;
-        }
-        
-        value = this.preNormalization.apply(value);
-        
-        if(this.normalizations == null) {
-            return value;
-        }
-        
-        for (Function<O, O> closure : this.normalizations) {
-            value = closure.apply(value);
-        }
-        
-        return value;
-    }
-    
-}
diff --git a/src/normalizer/NormalizerInterface.java b/src/normalizer/NormalizerInterface.java
deleted file mode 100644
index de6166f..0000000
--- a/src/normalizer/NormalizerInterface.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package normalizer;
-
-public interface NormalizerInterface<O> {
-
-    O normalize(O value);
-    
-}
diff --git a/src/others/Command.java b/src/others/Command.java
deleted file mode 100644
index d6da24b..0000000
--- a/src/others/Command.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package others;
-
-import java.util.regex.Pattern;
-
-public class Command {
-    
-//    private static final String COMMAND_PATTERN = "(?<open>%s+)(?<expression>.*)(?<close>%s+)";
-    
-    private String name;
-    private String open;
-    private String close;
-
-    public Command(String name, String open, String close) {
-        this.name = name;
-        this.open = open;
-        this.close = close;
-    }
-}
diff --git a/src/others/Rule.java b/src/others/Rule.java
deleted file mode 100644
index e5fe158..0000000
--- a/src/others/Rule.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package others;
-
-import java.util.function.Predicate;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-public class Rule {
-    
-    private String name;
-    private Pattern intern;
-    private Predicate<Matcher> validate;
-
-    public Rule(String name, Pattern intern, Predicate<Matcher> validate) {
-        this.name = name;
-        this.intern = intern;
-        this.validate = validate;
-    }
-    
-    public boolean validate(String value) {
-        return this.validate.test(match(value));
-    }
-    
-    public Matcher match(String value) {
-        return this.intern.matcher(value);
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-    
-    public Pattern getIntern() {
-        return intern;
-    }
-
-    public Predicate<Matcher> getValidate() {
-        return validate;
-    }
-
-    public void setIntern(Pattern intern) {
-        this.intern = intern;
-    }
-
-    public void setValidate(Predicate<Matcher> validate) {
-        this.validate = validate;
-    }
-    
-    public String extract(String from) {
-        Matcher matcher = match(from);
-        if (!matcher.find()) {
-            return "";
-        }
-        return matcher.group(name);
-    }
-    
-    public static Rule group(String name, String value) {
-        return group(name, value, "");
-    }
-    
-    public static Rule group(String name, String value, String quantity) {
-        String pattern = "(?<".concat(name).concat(">")
-                .concat(value).concat(quantity).concat(")");
-        return new Rule(name, Pattern.compile(pattern), (matcher) -> {
-            return matcher.find();
-        });
-    }
-}
diff --git a/src/others/Sequence.java b/src/others/Sequence.java
deleted file mode 100644
index a18e5e6..0000000
--- a/src/others/Sequence.java
+++ /dev/null
@@ -1,193 +0,0 @@
-package others;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.Objects;
-import java.util.regex.Pattern;
-import java.util.stream.Collectors;
-import utils.StringUtils;
-
-public class Sequence {
-    
-    private List<Rule> rules;
-    
-    private Sequence parent;
-    
-    private List<Sequence> subSequences;
-
-    public Sequence() {
-        
-    }
-    
-    public Sequence(Sequence parent, List<Rule> rules, List<Sequence> subSequences) {
-        this.parent = parent;
-        this.rules = rules;
-        this.subSequences = subSequences;
-    }
-    
-    public List<String> groups(String value) {
-        List<String> results = new ArrayList<>();
-        
-        if (Objects.isNull(this.rules)) {
-            return results;
-        }
-        
-//        this.rules.stream().map((rule) -> rule.extract(value))
-//                .peek(System.out::println);
-
-        List<String> names = new ArrayList<>();
-        this.rules.stream().map(Rule::getName).forEach(names::add);
-        
-        for (Rule rule : this.rules) {
-            System.out.print("value : ");
-            System.out.println(value);
-            String extracted = rule.extract(value);
-            if (StringUtils.hasText(extracted)) {
-                value = value.replaceFirst(Pattern.quote(extracted), "");
-            }
-            System.out.print("Result : ");
-            System.out.println(extracted);
-        }
-        Pattern compiled = Pattern.compile(this.rules.stream()
-            .peek((rule) -> names.add(rule.getName()))
-            .map((rule) -> rule.getIntern().pattern())
-            .collect(Collectors.joining()));
-        
-        System.out.print("Pattern : ");
-        System.out.println(compiled.pattern());
-//        
-//        Matcher matcher = compiled.matcher(value);
-        
-//        if(!matcher.find()) {
-//            return result;
-//        }
-//        int count = matcher.groupCount();
-        
-//        System.out.print("Count : ");
-//        System.out.println(count);
-//        
-//        System.out.print("Name Count : ");
-//        System.out.println(names.size());
-//        
-//        names.stream().forEach((name) -> {
-//            System.out.print(name);
-//            System.out.print(" : ");
-//            System.out.println(matcher.group(name));
-//            
-//            result.add(matcher.group(name));
-//        });
-//        
-//        System.out.print("Result : ");
-//        System.out.println(result);
-        
-//        for (int i = 0; i < count; i++) {
-//            result.add(matcher.group(i));
-//            System.out.print("Result : ");
-//            System.out.println(result);
-//        }
-        
-//        while(matcher.find()) {
-//            result.add(matcher.group());
-//            System.out.print("Result : ");
-//            System.out.println(result);
-//        }
-        return results;
-    }
-    
-    public boolean validate(String value) {
-        boolean invalid = false;
-        
-        if (!Objects.isNull(this.rules)) {
-            invalid = this.rules.stream().anyMatch((rule) -> !rule.validate(value));
-        }
-        
-        if (!Objects.isNull(this.subSequences)) {
-            invalid = this.subSequences.stream().anyMatch((sequence) -> !sequence.validate(value));
-        }
-        
-        return !invalid;
-    }
-
-    public List<Rule> getRules() {
-        return rules;
-    }
-
-    public void setRules(List<Rule> rules) {
-        this.rules = rules;
-    }
-    
-    public void addRule(Rule rule) {
-        if (Objects.isNull(rules)) {
-            rules = new ArrayList<>();
-        }
-        
-        rules.add(rule);
-    }
-
-    public Sequence getParent() {
-        return parent;
-    }
-
-    public void setParent(Sequence parent) {
-        this.parent = parent;
-    }
-
-    public List<Sequence> getSubSequences() {
-        return subSequences;
-    }
-
-    public void setSubSequences(List<Sequence> subSequences) {
-        this.subSequences = subSequences;
-    }
-    
-    public void subSequence(Sequence sequence) {
-        if (Objects.isNull(subSequences)) {
-            subSequences = new ArrayList<>();
-        }
-        sequence.setParent(this);
-        subSequences.add(sequence);
-    }
-    
-    public static SequenceBuilder builder() {
-        return new SequenceBuilder();
-    }
-    
-    public static class SequenceBuilder {
-        
-        private List<Rule> rules = new ArrayList<>();
-
-        private Sequence parent;
-
-        private List<Sequence> subSequences;
-        
-        public SequenceBuilder withParent(Sequence parent) {
-            this.parent = parent;
-            return this;
-        }
-        
-        public SequenceBuilder withSequence(Sequence... subSequences) {
-            this.subSequences = Arrays.asList(subSequences);
-            return this;
-        }
-        
-        public SequenceBuilder withRule(Rule... rules) {
-            this.rules.addAll(Arrays.asList(rules));
-            return this;
-        }
-        
-        public Sequence build() {
-            Sequence sequence = new Sequence();
-            
-            sequence.setParent(parent);
-            
-            this.rules.forEach(sequence::addRule);
-            
-            if (!Objects.isNull(this.subSequences)) {
-                this.subSequences.forEach(sequence::subSequence);
-            }
-            
-            return sequence;
-        }
-    }
-}
diff --git a/src/resolver/PathResolver.java b/src/resolver/PathResolver.java
deleted file mode 100644
index b4082af..0000000
--- a/src/resolver/PathResolver.java
+++ /dev/null
@@ -1,51 +0,0 @@
-package resolver;
-
-import java.io.IOException;
-import java.util.Arrays;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.stream.Collectors;
-
-public abstract class PathResolver<O> implements Resolver<String, O> {
-
-    private String prefix;
-    private String sufix;
-    
-    public PathResolver() {
-    }
-    
-    public PathResolver(String prefix, String sufix) {
-        this.prefix = prefix;
-        this.sufix = sufix;
-    }
-
-    @Override
-    public Optional<O> resolve(String object) {
-        return doResolve(resolvePath(object));
-    }
-    
-    protected abstract Optional<O> doResolve(String object);
-    
-    protected String resolvePath(String path) {
-        return Arrays.asList(this.prefix, path, this.sufix).stream()
-                .filter(Objects::nonNull)
-                .collect(Collectors.joining());
-    }
-    
-    public String getSufix() {
-        return sufix;
-    }
-
-    public String getPrefix() {
-        return prefix;
-    }
-
-    public void setPrefix(String prefix) {
-        this.prefix = prefix;
-    }
-
-    public void setSufix(String sufix) {
-        this.sufix = sufix;
-    }
-    
-}
diff --git a/src/resolver/Resolver.java b/src/resolver/Resolver.java
deleted file mode 100644
index c447fc8..0000000
--- a/src/resolver/Resolver.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package resolver;
-
-import java.util.Optional;
-
-@FunctionalInterface
-public interface Resolver<I, O> {
-    
-    Optional<O> resolve(I object);
-}
diff --git a/src/resolver/ResolverDelegate.java b/src/resolver/ResolverDelegate.java
deleted file mode 100644
index 3616724..0000000
--- a/src/resolver/ResolverDelegate.java
+++ /dev/null
@@ -1,47 +0,0 @@
-package resolver;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Optional;
-import java.util.function.Predicate;
-
-public class ResolverDelegate<I, O> implements Resolver<I, O> {
-
-    protected Map<Predicate<I>, Resolver<I, O>> resolvers;
-
-    public ResolverDelegate() {
-        this.resolvers = new HashMap<>();
-    }
-    
-    public ResolverDelegate(Map<Predicate<I>, Resolver<I, O>> resolvers) {
-        this.resolvers = resolvers;
-    }
-
-    @Override
-    public Optional<O> resolve(I object) {
-        Optional<Resolver<I, O>> resolver = getResolvers().entrySet().stream()
-                .filter((a) -> a.getKey().test(object))
-                .map((e) -> e.getValue())
-                .findFirst();
-
-        if (resolver.isPresent()) {
-            return resolver.get().resolve(object);
-        }
-        return Optional.empty();
-    }
-
-    public Map<Predicate<I>, Resolver<I, O>> getResolvers() {
-        if(this.resolvers == null) {
-            this.resolvers = new HashMap<>();
-        }
-        return this.resolvers;
-    }
-
-    public void setResolvers(Map<Predicate<I>, Resolver<I, O>> resolvers) {
-        this.resolvers = resolvers;
-    }
-    
-    public void addResolver(Predicate<I> predicate, Resolver<I, O> resolver) {
-        getResolvers().put(predicate, resolver);
-    }
-}
diff --git a/src/resource/FileSystem.java b/src/resource/FileSystem.java
deleted file mode 100644
index 213f46c..0000000
--- a/src/resource/FileSystem.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package resource;
-
-import java.io.File;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.nio.file.InvalidPathException;
-import resource.exceptions.ResourceException;
-
-public class FileSystem {
-    
-    public static final String ROOT_PATH = "/";
-    private final File baseDirectory;
-
-    public FileSystem() {
-        this.baseDirectory = new File(ROOT_PATH);
-    }
-    
-    public FileSystem(File baseDirectory) {
-        this.baseDirectory = baseDirectory;
-    }
-    
-    private File file(String path) {
-        File file = new File(path);
-        if (file.isAbsolute()) {
-            return file;
-        } else {
-            return new File(baseDirectory, path);
-        }
-    }
-    
-    public static boolean isRelative(String path) {
-        return !path.startsWith(ROOT_PATH);
-    }
-    
-    public static String resolve(String parent, String child) {
-        try {
-            return new URI(String.format("%s/../%s", parent, child)).normalize().toString();
-        } catch (InvalidPathException | URISyntaxException e) {
-            throw new ResourceException("Invalid path", e);
-        }
-    }
-    
-}
diff --git a/src/resource/ResourceService.java b/src/resource/ResourceService.java
deleted file mode 100644
index db092f2..0000000
--- a/src/resource/ResourceService.java
+++ /dev/null
@@ -1,90 +0,0 @@
-package resource;
-
-import java.io.InputStream;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import resource.exceptions.ResourceException;
-import resource.loader.ResourceLoader;
-import resource.loader.ResourceLoaderDelegate;
-import resource.metatada.ResourceMetadata;
-import resource.metatada.ResourceReferenceMetadata;
-import resource.reference.ResourceReference;
-import resource.reference.ResourceReferenceExtractor;
-
-public class ResourceService {
-    
-    private final Map<String, ResourceLoader> loaders;
-    
-    private final ResourceReferenceExtractor extractor;
-
-    public ResourceService(Map<String, ResourceLoader> loaders) {
-        this(loaders, ResourceReferenceExtractor.defaultExtractor());
-    }
-    
-    public ResourceService(Map<String, ResourceLoader> loaders, ResourceReferenceExtractor extractor) {
-        this.loaders = loaders;
-        this.extractor = extractor;
-    }
-    
-    public ResourceMetadata metadata(ResourceReference reference) {
-        Optional<ResourceLoader> optional;
-        
-        switch(reference.getType()) {
-            case ResourceReference.ANY_TYPE:
-                optional = this.loaders.values().stream()
-                    .filter((loader) -> loader.exists(reference.getPath()))
-                    .findFirst();
-                break;
-                
-            default:
-                optional = Optional.of(this.loaders.get(reference.getType()));
-                break;
-        }
-        if (!optional.isPresent()) {
-            throw new ResourceException(String.format("Cannot load resource %s. Resource loader for type '%s' not configured", reference, reference.getType()));
-        }
-        
-        return new ResourceReferenceMetadata(optional.get(), reference);
-    }
-    
-    public ResourceMetadata metadata(String path) {
-        ResourceReference reference = this.extractor.extract(path);
-        return metadata(reference);
-    }
-    
-    public InputStream load(String path) {
-        return metadata(path).load();
-    }
-    
-    public static ResourceServiceBuilder builder() {
-        return new ResourceServiceBuilder();
-    }
-    
-    public static class ResourceServiceBuilder {
-        
-        private Map<String, ResourceLoader> loaders;
-
-        public ResourceServiceBuilder() {
-        }
-
-        public ResourceServiceBuilder with(String type, ResourceLoader loader) {
-            if (Objects.isNull(this.loaders)) {
-                this.loaders = new HashMap<>();
-            }
-            
-            if (!this.loaders.containsKey(type)) {
-                this.loaders.put(type, new ResourceLoaderDelegate());
-            }
-            
-            ((ResourceLoaderDelegate) this.loaders.get(type)).with(loader);
-            return this;
-        }
-        
-        public ResourceService build() {
-            ResourceService service = new ResourceService(this.loaders);
-            return service;
-        }
-    }
-}
diff --git a/src/resource/exceptions/ResourceException.java b/src/resource/exceptions/ResourceException.java
deleted file mode 100644
index d2c6b9a..0000000
--- a/src/resource/exceptions/ResourceException.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package resource.exceptions;
-
-public class ResourceException extends RuntimeException {
-    
-    public ResourceException(String message) {
-        super(message);
-    }
-
-    public ResourceException(Throwable cause) {
-        super(cause);
-    }
-
-    public ResourceException(String message, Throwable cause) {
-        super(message, cause);
-    }
-}
diff --git a/src/resource/exceptions/ResourceNotFoundException.java b/src/resource/exceptions/ResourceNotFoundException.java
deleted file mode 100644
index 4df8d41..0000000
--- a/src/resource/exceptions/ResourceNotFoundException.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package resource.exceptions;
-
-public class ResourceNotFoundException extends ResourceException {
-    public ResourceNotFoundException(String message) {
-        super(message);
-    }
-
-    public ResourceNotFoundException(Throwable e) {
-        super(e);
-    }
-}
diff --git a/src/resource/loader/ClasspathResourceLoader.java b/src/resource/loader/ClasspathResourceLoader.java
deleted file mode 100644
index 425583b..0000000
--- a/src/resource/loader/ClasspathResourceLoader.java
+++ /dev/null
@@ -1,56 +0,0 @@
-package resource.loader;
-
-import java.io.InputStream;
-import java.net.URL;
-import java.nio.charset.Charset;
-import java.util.Optional;
-import resource.exceptions.ResourceNotFoundException;
-import utils.ClassUtils;
-
-public class ClasspathResourceLoader implements ResourceLoader {
-    
-    public static final String ROOT_PATH = "/";
-    private final ClassLoader classLoader;
-
-    public ClasspathResourceLoader() {
-        this(ClassUtils.getDefaultClassLoader());
-    }
-    
-    public ClasspathResourceLoader(ClassLoader classLoader) {
-        this.classLoader = classLoader;
-    }
-
-    @Override
-    public Optional<Charset> getCharset(String path) {
-        return Optional.empty();
-    }
-
-    @Override
-    public InputStream load(String path) {
-        InputStream result = classLoader.getResourceAsStream(getPath(path));
-        if (result == null) {
-            throw new ResourceNotFoundException(String.format("Resource '%s' not found", path));
-        }
-        return result;
-    }
-
-    @Override
-    public boolean exists(String path) {
-//        URL result = classLoader.getResource(getPath(path));
-        InputStream result = classLoader.getResourceAsStream(getPath(path));
-        return result != null;
-    }
-
-    @Override
-    public Optional<URL> toUrl(String path) {
-        return Optional.ofNullable(classLoader.getResource(getPath(path)));
-    }
-
-    private String getPath(String path) {
-        if (path.startsWith(ROOT_PATH)) {
-            return path.substring(1);
-        }
-        return path;
-    }
-    
-}
diff --git a/src/resource/loader/FileResourceLoader.java b/src/resource/loader/FileResourceLoader.java
deleted file mode 100644
index 6527826..0000000
--- a/src/resource/loader/FileResourceLoader.java
+++ /dev/null
@@ -1,59 +0,0 @@
-package resource.loader;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.InputStream;
-import java.net.MalformedURLException;
-import java.net.URL;
-import java.util.Optional;
-import resource.exceptions.ResourceNotFoundException;
-
-public class FileResourceLoader implements ResourceLoader {
-    
-    public static FileResourceLoader instance (File file) {
-        return new FileResourceLoader(file);
-    }
-    
-    public static FileResourceLoader instance () {
-        return instance(new File("/"));
-    }
-
-    private final File baseDirectory;
-
-    public FileResourceLoader (File baseDirectory) {
-        this.baseDirectory = baseDirectory;
-    }
-
-    @Override
-    public InputStream load(String path) {
-        try {
-            return new FileInputStream(file(path));
-        } catch (FileNotFoundException e) {
-            throw new ResourceNotFoundException(e);
-        }
-    }
-
-    @Override
-    public boolean exists(String path) {
-        return file(path).exists();
-    }
-
-    @Override
-    public Optional<URL> toUrl(String path) {
-        try {
-            return Optional.of(file(path).toURI().toURL());
-        } catch (MalformedURLException e) {
-            return Optional.empty();
-        }
-    }
-
-    private File file(String path) {
-        File file = new File(path);
-        if (file.isAbsolute()) {
-            return file;
-        } else {
-            return new File(baseDirectory, path);
-        }
-    }
-}
diff --git a/src/resource/loader/InMemoryResourceLoader.java b/src/resource/loader/InMemoryResourceLoader.java
deleted file mode 100644
index 7f69dd5..0000000
--- a/src/resource/loader/InMemoryResourceLoader.java
+++ /dev/null
@@ -1,61 +0,0 @@
-package resource.loader;
-
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-import java.util.HashMap;
-import java.util.Map;
-import java.util.function.Supplier;
-import resource.exceptions.ResourceNotFoundException;
-
-public class InMemoryResourceLoader implements ResourceLoader {
-    public static InMemoryResourceLoader.Builder builder () {
-        return new InMemoryResourceLoader.Builder();
-    }
-
-    private final Map<String, Supplier<InputStream>> inputStreamMap;
-
-    public InMemoryResourceLoader(Map<String, Supplier<InputStream>> inputStreamMap) {
-        this.inputStreamMap = inputStreamMap;
-    }
-
-    @Override
-    public InputStream load(String path) {
-        Supplier<InputStream> streamSupplier = inputStreamMap.get(path);
-        if (streamSupplier == null) {
-            throw new ResourceNotFoundException(String.format("Resource '%s' not found", path));
-        }
-        return streamSupplier.get();
-    }
-
-    @Override
-    public boolean exists(String path) {
-        return inputStreamMap.containsKey(path);
-    }
-    
-    public static class Builder {
-        private final Map<String, Supplier<InputStream>> supplierMap = new HashMap<>();
-
-        public Builder withResource (String key, String content) {
-            supplierMap.put(key, new StringInputStreamSupplier(content));
-            return this;
-        }
-
-        public InMemoryResourceLoader build() {
-            return new InMemoryResourceLoader(supplierMap);
-        }
-    }
-
-    public static class StringInputStreamSupplier implements Supplier<InputStream> {
-        private final String content;
-
-        public StringInputStreamSupplier(String content) {
-            this.content = content;
-        }
-
-        @Override
-        public InputStream get() {
-            return new ByteArrayInputStream(content.getBytes());
-        }
-    }
-    
-}
diff --git a/src/resource/loader/ResourceLoader.java b/src/resource/loader/ResourceLoader.java
deleted file mode 100644
index 6f1db78..0000000
--- a/src/resource/loader/ResourceLoader.java
+++ /dev/null
@@ -1,21 +0,0 @@
-package resource.loader;
-
-import java.io.InputStream;
-import java.net.URL;
-import java.nio.charset.Charset;
-import java.util.Optional;
-
-public interface ResourceLoader {
-    
-    InputStream load (String path);
-    
-    boolean exists (String path);
-    
-    default Optional<Charset> getCharset(String path) {
-        return Optional.empty();
-    }
-    
-    default Optional<URL> toUrl (String path) {
-        return Optional.empty();
-    }
-}
diff --git a/src/resource/loader/ResourceLoaderDelegate.java b/src/resource/loader/ResourceLoaderDelegate.java
deleted file mode 100644
index 8527b33..0000000
--- a/src/resource/loader/ResourceLoaderDelegate.java
+++ /dev/null
@@ -1,65 +0,0 @@
-package resource.loader;
-
-import java.io.InputStream;
-import java.net.URL;
-import java.nio.charset.Charset;
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Optional;
-import resource.exceptions.ResourceNotFoundException;
-
-public class ResourceLoaderDelegate implements ResourceLoader {
-    
-    private Collection<ResourceLoader> loaders = new ArrayList<>();
-
-    public ResourceLoaderDelegate() {
-    }
-    
-    public ResourceLoaderDelegate(Collection<ResourceLoader> loaders) {
-        this.loaders = loaders;
-    }
-
-    @Override
-    public Optional<Charset> getCharset(String path) {
-        Optional<ResourceLoader> loader = matches(path);
-        if (loader.isPresent()) {
-            return loader.get().getCharset(path);
-        }
-        return Optional.empty();
-    }
-
-    @Override
-    public InputStream load(String path) {
-        Optional<ResourceLoader> loader = matches(path);
-        if (loader.isPresent()) {
-            return loader.get().load(path);
-        }
-        
-        throw new ResourceNotFoundException(String.format("Resource '%s' not found", path));
-    }
-
-    @Override
-    public boolean exists(String path) {
-        return matches(path).isPresent();
-    }
-
-    @Override
-    public Optional<URL> toUrl(String path) {
-        Optional<ResourceLoader> loader = matches(path);
-        if (loader.isPresent()) {
-            return loader.get().toUrl(path);
-        }
-        
-        return Optional.empty();
-    }
-    
-    public void with(ResourceLoader loader) {
-        this.loaders.add(loader);
-    }
-    
-    private Optional<ResourceLoader> matches(String path) {
-        return this.loaders.stream()
-                .filter((loader) -> loader.exists(path))
-                .findFirst();
-    }
-}
diff --git a/src/resource/loader/StringResourceLoader.java b/src/resource/loader/StringResourceLoader.java
deleted file mode 100644
index fbcc51d..0000000
--- a/src/resource/loader/StringResourceLoader.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package resource.loader;
-
-import java.io.ByteArrayInputStream;
-import java.io.InputStream;
-
-public class StringResourceLoader implements ResourceLoader {
-
-    public StringResourceLoader() {
-    }
-    
-    @Override
-    public InputStream load(String path) {
-        return new ByteArrayInputStream(path.getBytes());
-    }
-
-    @Override
-    public boolean exists(String path) {
-        return path != null;
-    }
-}
diff --git a/src/resource/loader/TypedResourceLoader.java b/src/resource/loader/TypedResourceLoader.java
deleted file mode 100644
index ed050a9..0000000
--- a/src/resource/loader/TypedResourceLoader.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package resource.loader;
-
-public abstract class TypedResourceLoader implements ResourceLoader {
-    
-    private final String type;
-
-    public TypedResourceLoader(String type) {
-        this.type = type;
-    }
-
-    public String getType() {
-        return type;
-    }
-}
diff --git a/src/resource/metatada/ResourceMetadata.java b/src/resource/metatada/ResourceMetadata.java
deleted file mode 100644
index 7c3eafd..0000000
--- a/src/resource/metatada/ResourceMetadata.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package resource.metatada;
-
-import java.io.InputStream;
-import java.net.URL;
-import java.nio.charset.Charset;
-import java.util.Optional;
-
-public interface ResourceMetadata {
-    boolean exists ();
-    InputStream load();
-    Optional<Charset> getCharset ();
-    Optional<URL> toUrl ();
-}
diff --git a/src/resource/metatada/ResourceReferenceMetadata.java b/src/resource/metatada/ResourceReferenceMetadata.java
deleted file mode 100644
index 2b6ad6d..0000000
--- a/src/resource/metatada/ResourceReferenceMetadata.java
+++ /dev/null
@@ -1,43 +0,0 @@
-package resource.metatada;
-
-import java.io.InputStream;
-import java.net.URL;
-import java.nio.charset.Charset;
-import java.util.Optional;
-import resource.loader.ResourceLoader;
-import resource.reference.ResourceReference;
-
-public class ResourceReferenceMetadata implements ResourceMetadata {
-    
-    private final ResourceLoader resourceLoader;
-    private final ResourceReference resourceReference;
-
-    public ResourceReferenceMetadata(ResourceLoader resourceLoader, ResourceReference resourceReference) {
-        this.resourceLoader = resourceLoader;
-        this.resourceReference = resourceReference;
-    }
-
-    @Override
-    public boolean exists() {
-        return resourceLoader.exists(resourceReference.getPath());
-    }
-
-    @Override
-    public InputStream load() {
-        return resourceLoader.load(resourceReference.getPath());
-    }
-
-    @Override
-    public Optional<Charset> getCharset() {
-        return resourceLoader.getCharset(resourceReference.getPath());
-    }
-
-    @Override
-    public Optional<URL> toUrl () {
-        return resourceLoader.toUrl(resourceReference.getPath());
-    }
-
-    public ResourceReference getResourceReference() {
-        return resourceReference;
-    }
-}
diff --git a/src/resource/reference/PosixResourceReferenceExtractor.java b/src/resource/reference/PosixResourceReferenceExtractor.java
deleted file mode 100644
index a7e9ab2..0000000
--- a/src/resource/reference/PosixResourceReferenceExtractor.java
+++ /dev/null
@@ -1,18 +0,0 @@
-package resource.reference;
-
-import extractor.Extractor;
-
-public class PosixResourceReferenceExtractor implements Extractor<String, ResourceReference> {
-
-    @Override
-    public ResourceReference extract(String spec) {
-        int indexOf = spec.indexOf(":");
-        
-        if (indexOf == -1) {
-            return new ResourceReference(ResourceReference.ANY_TYPE, spec);
-        }
-        
-        return new ResourceReference(spec.substring(0, indexOf), spec.substring(indexOf + 1));
-    }
-    
-}
diff --git a/src/resource/reference/ResourceReference.java b/src/resource/reference/ResourceReference.java
deleted file mode 100644
index a60c5d0..0000000
--- a/src/resource/reference/ResourceReference.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package resource.reference;
-
-import java.io.File;
-import resource.FileSystem;
-
-public class ResourceReference {
-    
-    public static final String ANY_TYPE = "any";
-    public static final String STRING = "string";
-    public static final String FILE = "file";
-    public static final String MEMORY = "memory";
-    public static final String CLASSPATH = "classpath";
-
-    public static ResourceReference reference (String type, String resource) {
-        return new ResourceReference(type, resource);
-    }
-    
-    public static ResourceReference inline (String resource) {
-        return reference(STRING, resource);
-    }
-
-    public static ResourceReference memory (String name) {
-        return reference(MEMORY, name);
-    }
-
-    public static ResourceReference file (String path) {
-        return reference(FILE, path);
-    }
-
-    public static ResourceReference file (File path) {
-        return reference(FILE, path.getAbsolutePath());
-    }
-
-    public static ResourceReference classpath (String path) {
-        return reference(CLASSPATH, path);
-    }
- 
-    private final String type;
-    private final String path;
-
-    public ResourceReference(String type, String path) {
-        this.type = type;
-        this.path = path;
-    }
-
-    public String getType() {
-        return type;
-    }
-
-    public String getPath() {
-        return path;
-    }
-    
-    public ResourceReference relativeTo (ResourceReference parent) {
-        if (!getType().equals(parent.getType())) {
-            // show smthing
-            return this;
-        }
-        
-        if (FileSystem.isRelative(getPath())) {
-            return new ResourceReference(parent.getType(), FileSystem.resolve(parent.getPath(), getPath()));
-        }
-        
-        return this;
-    }
-
-    @Override
-    public String toString() {
-        return "ResourceReference{" + "type=" + type + ", path=" + path + '}';
-    }
-}
diff --git a/src/resource/reference/ResourceReferenceExtractor.java b/src/resource/reference/ResourceReferenceExtractor.java
deleted file mode 100644
index bc8e7c2..0000000
--- a/src/resource/reference/ResourceReferenceExtractor.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package resource.reference;
-
-import extractor.Extractor;
-import java.util.function.Supplier;
-import resource.reference.path.PathType;
-import resource.reference.path.PathTypeSupplier;
-
-public class ResourceReferenceExtractor implements Extractor<String, ResourceReference> {
-    
-    private final Supplier<PathType> pathTypeSupplier;
-    private final Extractor<String, ResourceReference> posixResourceReferenceExtractor;
-    private final Extractor<String, ResourceReference> uncResourceReferenceExtractor;
-
-    public ResourceReferenceExtractor(Supplier<PathType> pathTypeSupplier, 
-            Extractor<String, ResourceReference> posixResourceReferenceExtractor, 
-            Extractor<String, ResourceReference> uncResourceReferenceExtractor) {
-        this.pathTypeSupplier = pathTypeSupplier;
-        this.posixResourceReferenceExtractor = posixResourceReferenceExtractor;
-        this.uncResourceReferenceExtractor = uncResourceReferenceExtractor;
-    }
-
-    @Override
-    public ResourceReference extract(String spec) {
-        if (pathTypeSupplier.get() == PathType.UNC) {
-            return uncResourceReferenceExtractor.extract(spec);
-        }
-        
-        return posixResourceReferenceExtractor.extract(spec);
-    }
-    
-    public static ResourceReferenceExtractor defaultExtractor() {
-        return new ResourceReferenceExtractor(new PathTypeSupplier(), new PosixResourceReferenceExtractor(), new UncResourceReferenceExtractor());
-    }
-}
diff --git a/src/resource/reference/UncResourceReferenceExtractor.java b/src/resource/reference/UncResourceReferenceExtractor.java
deleted file mode 100644
index 71d5468..0000000
--- a/src/resource/reference/UncResourceReferenceExtractor.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package resource.reference;
-
-import extractor.Extractor;
-
-public class UncResourceReferenceExtractor implements Extractor<String, ResourceReference> {
-
-    @Override
-    public ResourceReference extract(String spec) {
-        if (isAbsolute(spec)) {
-            return new ResourceReference(ResourceReference.ANY_TYPE, spec);
-        }
-        
-        int indexOf = spec.indexOf(":");
-        if (indexOf == -1) {
-            return new ResourceReference(ResourceReference.ANY_TYPE, spec);
-        }
-        
-        return new ResourceReference(spec.substring(0, indexOf), spec.substring(indexOf + 1));
-    }
-    
-    private boolean isAbsolute(String spec) {
-        return spec.length() > 2 && spec.charAt(1) == ':' && spec.charAt(2) == '\\';
-    }
-    
-}
diff --git a/src/resource/reference/path/PathType.java b/src/resource/reference/path/PathType.java
deleted file mode 100644
index 1ec6edd..0000000
--- a/src/resource/reference/path/PathType.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package resource.reference.path;
-
-public enum PathType {
-    UNC, POSIX
-}
diff --git a/src/resource/reference/path/PathTypeSupplier.java b/src/resource/reference/path/PathTypeSupplier.java
deleted file mode 100644
index 9322eef..0000000
--- a/src/resource/reference/path/PathTypeSupplier.java
+++ /dev/null
@@ -1,16 +0,0 @@
-package resource.reference.path;
-
-import java.util.function.Supplier;
-
-public class PathTypeSupplier implements Supplier<PathType> {
-
-    @Override
-    public PathType get() {
-        String operatingSystem = System.getProperty("os.name").toLowerCase();
-        if (operatingSystem.contains("win")) {
-            return PathType.UNC;
-        }
-        
-        return PathType.POSIX;
-    }
-}
diff --git a/src/templating/Context.java b/src/templating/Context.java
deleted file mode 100644
index 1e71dd1..0000000
--- a/src/templating/Context.java
+++ /dev/null
@@ -1,71 +0,0 @@
-package templating;
-
-import templating.token.TokenStream;
-import converter.ConverterResolver;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import java.util.Objects;
-import java.util.Optional;
-import templating.token.Token;
-
-public class Context {
-    
-    private Map<String, Object> model = new HashMap<>();
-    
-    private TokenStream stream;
-    
-    private String name;
-    
-    private List<Token> tokens;
-    
-    private ConverterResolver converter = new ConverterResolver();
-
-    public Context(List<Token> tokens, String name) {
-        this.tokens = tokens;
-        this.name = name;
-    }
-    
-    public <T> Optional<T> evaluate(String expression) {
-        if (Objects.isNull(this.model)) {
-            return Optional.empty();
-        }
-        
-//        expression = expression.trim();
-        Object evaluation = this.converter.resolve(expression);
-        if (null != evaluation) {
-            Optional.of(evaluation);
-        }
-//        System.out.println(evaluation);
-
-        return Optional.ofNullable((T) this.model.get(expression));
-    }
-    
-    public <T> Optional<T> evaluate(String expression, Class<T> c) {
-        return evaluate(expression);
-    }
-
-    public Map<String, Object> getModel() {
-        return model;
-    }
-
-    public void setModel(Map<String, Object> model) {
-        this.model = model;
-    }
-
-    public ConverterResolver getConverter() {
-        return converter;
-    }
-    
-    public TokenStream getStream(boolean force) {
-        if (null == this.stream || force) {
-            this.stream = new TokenStream(tokens, name);
-        }
-        return stream;
-    }
-    
-    public TokenStream getStream() {
-        return getStream(false);
-    }
-    
-}
diff --git a/src/templating/Engine.java b/src/templating/Engine.java
deleted file mode 100644
index a949492..0000000
--- a/src/templating/Engine.java
+++ /dev/null
@@ -1,163 +0,0 @@
-package templating;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-import templating.token.Token;
-import java.util.List;
-import java.util.Map;
-import static java.util.regex.Pattern.compile;
-import static java.util.regex.Pattern.quote;
-import templating.expression.Expression;
-import templating.extention.Extension;
-import templating.extention.core.CoreExtension;
-import templating.node.Node;
-import templating.node.NodeParser;
-import templating.token.TokenParser;
-import templating.token.TokenParsers;
-import templating.token.TokenStream;
-import templating.token.Tokenizer;
-
-public class Engine {
-
-    private final Environment environment;
-    
-    private final Map<String, Renderer> renderers;
-    
-    private final Tokenizer tokenizer;
-
-    public Engine(Environment environment, Map<String, Renderer> renderers, Tokenizer tokenizer) {
-        this.environment = environment;
-        this.renderers = renderers;
-        this.tokenizer = tokenizer;
-    }
-
-    public Template load(String path) throws Exception {
-        Source source = getEnvironment().load(path);
-        List<Token> tokens = this.tokenizer.tokenize(source);
-        Context context = new Context(tokens, path);
-        List<Node> parse = NodeParser.fromTypes().parse(context.getStream());
-        return Template.builder().context(context).build();
-    }
-    
-    public void evaluate(Template template) throws Exception {
-        Context context = template.getContext();
-        TokenStream stream = template.getContext().getStream();
-        
-        while (!Token.isEOF(stream.current())) {
-            Token token = stream.current();
-            
-        }
-    }
-
-    public void render(Template template) throws Exception {
-        Context context = template.getContext();
-        TokenStream stream = template.getContext().getStream(true);
-        while (!Token.isEOF(stream.current())) {
-            Token token = stream.current();
-            System.out.println(token.getType() + "(" + token.getValue() + ")");
-            stream.next();
-        }
-    }
-
-    public Environment getEnvironment() {
-        return environment;
-    }
-    
-    public static EngineBuilder builder() {
-        return new EngineBuilder();
-    }
-
-    public static class EngineBuilder {
-        
-        private final static TokenParser n = TokenParser.from("name", compile("^[a-zA-Z_][a-zA-Z0-9_]*"));
-        private final static TokenParser s = TokenParsers.string();
-        private final static TokenParser p = TokenParsers.punctuation();
-        private final static TokenParser nb = TokenParsers.number();
-        private final static TokenParser eof = source -> {
-                if (source.length() == 0) {
-                    return Arrays.asList(Token.EOF());
-                }
-                throw new Exception(String.format("EOF is not reached rest (%s)%n", source));
-            };
-        
-
-        Tokenizer.TokenizerBuilder tokenizerBuilder = Tokenizer.builder();
-        private Environment environment;
-        private List<String> starts = new ArrayList<>();
-        private List<Extension> extensions = new ArrayList<>();
-        private TokenParser execute;
-        private TokenParser comment;
-        private TokenParser print;
-
-        public EngineBuilder environment(Environment environment) {
-            this.environment = environment;
-            return this;
-        }
-        
-        public EngineBuilder extension(Extension extension) {
-            this.extensions.add(extension);
-            return this;
-        }
-        
-        public EngineBuilder extensions(Extension... extensions) {
-            this.extensions.addAll(Arrays.asList(extensions));
-            return this;
-        }
-        
-        public EngineBuilder execute(String open, String close) {
-            TokenParser starter = TokenParser.from("execute_open", compile(quote(open)));
-            TokenParser ender = TokenParser.from("execute_close", compile(quote(close)));
-            
-            TokenParser expression = this.n.or(this.nb).or(this.p).or(this.s).zeroOrMore();
-            
-            this.execute = starter
-                    .then(n)
-                    .then(expression)
-                    .then(ender);
-            this.starts.add(open);
-            return this;
-        }
-
-        public EngineBuilder comment(String open, String close) {
-            TokenParser starter = TokenParser.from("comment_open", compile(quote(open)));
-            TokenParser inner = TokenParser.until("comment", close);
-            TokenParser ender = TokenParser.from("comment_close", compile(quote(close)));
-            
-            this.comment = starter
-                    .then(inner.optional())
-                    .then(ender);
-            this.starts.add(open);
-            return this;
-        }
-        
-        public EngineBuilder print(String open, String close) {
-            TokenParser starter = TokenParser.from("print_open", compile(quote(open)));
-            TokenParser ender = TokenParser.from("print_close", compile(quote(close)));
-            
-            this.print = starter
-                    .then(this.n.or(this.nb).or(this.p).or(this.s).oneOrMore())
-                    .then(ender);
-            this.starts.add(open);
-            return this;
-        }
-        
-        public Engine build() {
-            this.extensions.add(new CoreExtension());
-            
-            TokenParser text = TokenParser.until("text", starts);
-            TokenParser principal = print.or(comment).or(execute).or(text).zeroOrMore().then(eof);
-            this.tokenizerBuilder.parser(principal);
-            Tokenizer tokenizer = this.tokenizerBuilder.build();
-            
-            Map<String, Renderer> renderers = new HashMap<>();
-            this.extensions.forEach(extension -> {
-                renderers.putAll(extension.getRenderers());
-            });
-            
-            Engine engine = new Engine(environment, renderers, tokenizer);
-            return engine;
-        }
-
-    }
-}
diff --git a/src/templating/Environment.java b/src/templating/Environment.java
deleted file mode 100644
index 29362d0..0000000
--- a/src/templating/Environment.java
+++ /dev/null
@@ -1,74 +0,0 @@
-package templating;
-
-import templating.token.Tokenizer;
-import java.io.InputStream;
-import java.io.InputStreamReader;
-import java.io.Reader;
-import java.util.ArrayList;
-import java.util.List;
-import java.util.Optional;
-import resource.ResourceService;
-
-public class Environment {
-    
-    private ResourceService resourceService;
-    
-    private List<Source> sources;
-    
-    public List<Source> getSources() {
-        return sources;
-    }
-    
-    public Source load(String path) {
-        if (null == this.sources) {
-            this.sources = new ArrayList<>();
-        }
-        
-        Optional<Source> result = this.sources.stream()
-                .filter((source) -> source.getName().equals(path)).findFirst();
-        
-        if (!result.isPresent()) {
-            InputStream stream = getResourceService().load(path);
-            Reader reader = new InputStreamReader(stream);
-            Source source = Source.builder(path).read(reader).build();
-            this.sources.add(source);
-            return source;
-        }
-        
-        return result.get();
-    }
-
-    public void setSources(List<Source> sources) {
-        this.sources = sources;
-    }
-    
-    public ResourceService getResourceService() {
-        return resourceService;
-    }
-
-    public void setResourceService(ResourceService resourceService) {
-        this.resourceService = resourceService;
-    }
-
-    public static EnvironmentBuilder builder() {
-        return new EnvironmentBuilder();
-    }
-    
-    public static class EnvironmentBuilder {
-    
-        private ResourceService resourceService;
-        
-        public EnvironmentBuilder resourceService(ResourceService service) {
-            this.resourceService = service;
-            return this;
-        }
-        
-        public Environment build() {
-            Environment env = new Environment();
-            
-            env.setResourceService(resourceService);
-            
-            return env;
-        }
-    }
-}
diff --git a/src/templating/Position.java b/src/templating/Position.java
deleted file mode 100644
index c7b155e..0000000
--- a/src/templating/Position.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package templating;
-
-public class Position {
-    
-    private final String name;
-    private final int line;
-    private final int column;
-
-    public Position(String name, int line, int column) {
-        this.name = name;
-        this.line = line;
-        this.column = column;
-    }
-
-    public int getLine() {
-        return line;
-    }
-
-    public int getColumn() {
-        return column;
-    }
-
-    @Override
-    public String toString() {
-        return String.format("%s (Line: %d, Column: %d)", name, line, column);
-    }
-}
diff --git a/src/templating/Renderer.java b/src/templating/Renderer.java
deleted file mode 100644
index f7fa36e..0000000
--- a/src/templating/Renderer.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package templating;
-
-import templating.token.Token;
-
-@FunctionalInterface
-public interface Renderer {
-    void render(Token token, Context context) throws Exception;
-}
diff --git a/src/templating/Source.java b/src/templating/Source.java
deleted file mode 100644
index 5774cf2..0000000
--- a/src/templating/Source.java
+++ /dev/null
@@ -1,231 +0,0 @@
-package templating;
-
-import java.io.IOException;
-import java.io.Reader;
-import java.io.StringReader;
-import java.util.Arrays;
-import java.util.logging.Level;
-import java.util.logging.Logger;
-
-public class Source implements CharSequence {
-    
-    private Source saved;
-
-    private final String name;
-
-    /**
-     * The characters found within the template.
-     */
-    private final char[] source;
-
-    /**
-     * Number of characters stored in source array remaining to be tokenized
-     */
-    private int size = 0;
-
-    /**
-     * Default capacity
-     */
-    private static final int DEFAULT_CAPACITY = 1024;
-
-    /**
-     * An index of the first character for the remaining un-tokenized source.
-     */
-    private int offset = 0;
-
-    /**
-     * Tracking the line number that we are currently tokenizing.
-     */
-    private int lineNumber = 1;
-    private int columnNumber = 1;
-
-    public Source(String name, char[] source, int size) {
-        this.name = name;
-        this.source = source;
-        this.size = size;
-    }
-    
-    public Source save() {
-        return new Source(name, Arrays.copyOfRange(source, offset, offset + size), size);
-    }
-
-    /**
-     * Moves the start index a certain amount. While traversing this amount we
-     * will count how many newlines have been encountered.
-     *
-     * @param amount Amount of characters to advance by
-     */
-    public void advance(int amount) {
-        int index = 0;
-        while (index < amount) {
-            int sizeOfNewline = advanceThroughNewline(index);
-
-            if (sizeOfNewline > 0) {
-                index += sizeOfNewline;
-            } else {
-                index++;
-            }
-            this.columnNumber++;
-        }
-
-        this.size -= amount;
-        this.offset += amount;
-    }
-
-    public void advanceThroughWhitespace() {
-        int index = 0;
-
-        while (Character.isWhitespace(charAt(index))) {
-            int sizeOfNewline = advanceThroughNewline(index);
-
-            if (sizeOfNewline > 0) {
-                index += sizeOfNewline;
-            } else {
-                index++;
-            }
-            this.columnNumber++;
-        }
-
-        this.size -= index;
-        this.offset += index;
-    }
-
-    /**
-     * Advances through possible newline character and returns how many
-     * characters were used to represent the newline (windows uses two
-     * characters to represent one newline).
-     *
-     * @param index The index of the potential newline character
-     * @return
-     */
-    private int advanceThroughNewline(int index) {
-        char character = this.charAt(index);
-        int numOfCharacters = 0;
-
-        // windows newline
-        if ('\r' == character && '\n' == charAt(index + 1)) {
-
-            this.lineNumber++;
-            this.columnNumber = 0;
-            numOfCharacters = 2;
-
-            // various other newline characters
-        } else if ('\n' == character || '\r' == character 
-                || '\u0085' == character || '\u2028' == character
-                || '\u2029' == character) {
-
-            this.lineNumber++;
-            this.columnNumber = 0;
-            numOfCharacters = 1;
-        }
-        
-        return numOfCharacters;
-    }
-
-    public String substring(int start, int end) {
-        return new String(Arrays.copyOfRange(source, this.offset + start, this.offset + end));
-    }
-
-    public String substring(int end) {
-        return new String(Arrays.copyOfRange(source, offset, offset + end));
-    }
-
-    @Override
-    public int length() {
-        return size;
-    }
-
-    @Override
-    public char charAt(int index) {
-        return source[offset + index];
-    }
-
-    @Override
-    public CharSequence subSequence(int start, int end) {
-        return new String(Arrays.copyOfRange(source, this.offset + start, this.offset + end));
-    }
-
-    @Override
-    public String toString() {
-        return new String(Arrays.copyOfRange(source, offset, offset + size));
-    }
-
-    public int getOffset() {
-        return offset;
-    }
-
-    public void setOffset(int offset) {
-        this.offset = offset;
-    }
-    
-    public Position getPosition() {
-        return new Position(getName(), lineNumber, columnNumber);
-    }
-
-    public int getLineNumber() {
-        return lineNumber;
-    }
-
-    public String getName() {
-        return name;
-    }
-
-    public static SourceBuilder builder(String name) {
-        return new SourceBuilder(name);
-    }
-
-    public static class SourceBuilder {
-
-        private final String name;
-        private char[] source = new char[DEFAULT_CAPACITY];
-        private int size = 0;
-
-        public SourceBuilder(String name) {
-            this.name = name;
-        }
-        
-        public SourceBuilder read(String string) {
-            return read(new StringReader(string));
-        }
-
-        public SourceBuilder read(Reader reader) {
-            try {
-                char[] buffer = new char[1024 * 4];
-                int amountJustRead = 0;
-                while ((amountJustRead = reader.read(buffer)) != -1) {
-                    ensureCapacity(size + amountJustRead);
-                    append(buffer, amountJustRead);
-                }
-                reader.close();
-            } catch (IOException ex) {
-                Logger.getLogger(Source.class.getName()).log(Level.SEVERE, null, ex);
-            }
-            return this;
-        }
-
-        public SourceBuilder append(char[] characters, int amount) {
-            for (int i = 0; i < amount; ++i) {
-                this.source[size + i] = characters[i];
-            }
-            size += amount;
-            return this;
-        }
-
-        public Source build() {
-            return new Source(this.name, this.source, this.size);
-        }
-
-        private void ensureCapacity(int minCapacity) {
-            if (source.length - minCapacity < 0) {
-                grow(minCapacity);
-            }
-        }
-
-        private void grow(int minCapacity) {
-            int oldCapacity = source.length;
-            int newCapacity = Math.max(oldCapacity << 1, minCapacity);
-
-            this.source = Arrays.copyOf(source, newCapacity);
-        }
-    }
-}
diff --git a/src/templating/Template.java b/src/templating/Template.java
deleted file mode 100644
index 8c63c57..0000000
--- a/src/templating/Template.java
+++ /dev/null
@@ -1,94 +0,0 @@
-package templating;
-
-import templating.token.TokenStream;
-import templating.token.Token;
-import java.util.ArrayList;
-import java.util.List;
-
-public class Template {
-    
-    private Context context;
-    
-    private String name;
-    
-    private Template extend;
-    
-    private List<Template> imports;
-    
-    public String getName() {
-        return name;
-    }
-
-    public void setName(String name) {
-        this.name = name;
-    }
-
-    public Template getExtend() {
-        return extend;
-    }
-
-    public List<Template> getImports() {
-        return imports;
-    }
-
-    public void setExtend(Template extend) {
-        this.extend = extend;
-    }
-
-    public void setImports(List<Template> imports) {
-        this.imports = imports;
-    }
-
-    public void setContext(Context context) {
-        this.context = context;
-    }
-
-    public Context getContext() {
-        return context;
-    }
-
-    public static TemplateBuilder builder() {
-        return new TemplateBuilder();
-    }
-    
-    public static class TemplateBuilder {
-        
-        private String name;
-        
-        private Template extend;
-        
-        private List<Template> imports = new ArrayList<>();
-        
-        private Context context;
-    
-        public TemplateBuilder named(String name) {
-            this.name = name;
-            return this;
-        }
-        
-        public TemplateBuilder importTemplate(Template template) {
-            this.imports.add(template);
-            return this;
-        }
-        
-        public TemplateBuilder extend(Template template) {
-            this.extend = template;
-            return this;
-        }
-        
-        public TemplateBuilder context(Context context) {
-            this.context = context;
-            return this;
-        }
-        
-        public Template build() {
-            Template template = new Template();
-            
-            template.setName(this.name);
-            template.setExtend(extend);
-            template.setImports(imports);
-            template.setContext(context);
-            return template;
-        }
-    }
-}
diff --git a/src/templating/expression/Expression.java b/src/templating/expression/Expression.java
deleted file mode 100644
index 3741535..0000000
--- a/src/templating/expression/Expression.java
+++ /dev/null
@@ -1,120 +0,0 @@
-package templating.expression;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.List;
-import templating.Context;
-import templating.token.Token;
-import templating.token.TokenStream;
-
-@FunctionalInterface
-public interface Expression<T> {
-
-    T evaluate(Context context);
-    
-    static Expression parse(TokenStream stream) throws Exception {
-        Token token = stream.current();
-        
-        if (token.isA("punctuation", "[")) {
-            return array(stream);
-        }
-        
-        return subParse(stream);
-    }
-    
-    static Expression subParse(TokenStream stream) throws Exception {
-        Token token = stream.current();
-        switch(token.getType()) {
-            case "name":
-                switch(token.getValue()) {
-                    case "true":
-                    case "TRUE":
-                        return literalBoolean(Boolean.TRUE);
-                    case "false":
-                    case "FALSE":
-                        return literalBoolean(Boolean.FALSE);
-                    case "none":
-                    case "NONE":
-                    case "null":
-                    case "NULL":
-                        return literalNull();
-                    default:
-                        if (stream.peek().isA("punctuation", "(")) {
-                            // function call
-                            return functionName(token.getValue());
-                        }
-                        return varName(token.getValue());
-                }
-            case "number":
-                final String numberValue = token.getValue();
-                if (numberValue.contains(".")) {
-                    return literalDouble(numberValue);
-                }
-                return literalLong(numberValue);
-            case "string":
-                return literalString(token.getValue());
-            default:
-                String msg = String.format("Unexpected token \"%s\" of value \"%s\" at %s.", token.getType(), token.getValue(), token.getPosition());
-                throw new Exception(msg);
-        }
-    }
-    
-    static Expression functionName(String value) {
-        return context -> value;
-    }
-    
-    static Expression varName(String value) {
-        return context -> context.evaluate(value);
-    }
-    
-    static Expression<Boolean> literalNull() {
-        return context -> null;
-    }
-    
-    static Expression<Boolean> literalBoolean(Boolean value) {
-        return context -> value;
-    }
-    
-    static Expression<String> literalString(String value) {
-        return context -> value;
-    }
-    
-    static Expression<Double> literalDouble(String value) {
-        return context -> Double.parseDouble(value);
-    }
-    
-    static Expression<Long> literalLong(String value) {
-        return context -> Long.parseLong(value);
-    }
-    
-    static Expression<List> emptyList() {
-        return context -> Collections.emptyList();
-    }
-    
-    static Expression<List> array(TokenStream stream) throws Exception {
-        stream.expect("punctuation", "[");
-        
-        if (stream.current().isA("punctuation", "]")) {
-            stream.next();
-            return emptyList();
-        }
-        List<Expression> expressions = new ArrayList();
-
-        while (!stream.current().isA("punctuation", "]")) {
-            expressions.add(subParse(stream));
-            stream.expect("punctuation", ",");
-        }
-        
-        stream.expect("punctuation", "]");
-            
-        return (context) -> {
-            List<Object> returnValues = new ArrayList<>(expressions.size());
-            expressions.stream()
-                    .map((expr) -> expr == null ? null : expr.evaluate(context))
-                    .forEach((value) -> {
-                returnValues.add(value);
-            });
-            return returnValues;
-        };
-    }
-}
diff --git a/src/templating/extention/Extension.java b/src/templating/extention/Extension.java
deleted file mode 100644
index 27387d3..0000000
--- a/src/templating/extention/Extension.java
+++ /dev/null
@@ -1,36 +0,0 @@
-package templating.extention;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-import templating.Renderer;
-import templating.node.NodeParser;
-import templating.token.TokenParser;
-
-public interface Extension {
-    
-    default List<Test> getTests() {
-        return new ArrayList<>();
-    }
-    
-    default List<Function> getFunctions() {
-        return new ArrayList<>();
-    }
-    
-    default List<Filter> getFilters() {
-        return new ArrayList<>();
-    }
-    
-    default List<TokenParser> getTokenParsers() {
-        return new ArrayList<>();
-    }
-    
-    default Map<String, NodeParser> getNodeParsers() {
-        return new HashMap<>();
-    }
-    
-    default Map<String, Renderer> getRenderers() {
-        return new HashMap<>();
-    }
-}
diff --git a/src/templating/extention/Filter.java b/src/templating/extention/Filter.java
deleted file mode 100644
index 3e28773..0000000
--- a/src/templating/extention/Filter.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package templating.extention;
-
-import java.util.Map;
-
-@FunctionalInterface
-public interface Filter {
-    
-    <T> T apply(Object input, Map<String, Object> args);
-}
diff --git a/src/templating/extention/Function.java b/src/templating/extention/Function.java
deleted file mode 100644
index 3befad5..0000000
--- a/src/templating/extention/Function.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package templating.extention;
-
-import java.util.Map;
-
-@FunctionalInterface
-public interface Function {
-    
-    <T> T apply(Map<String, Object> args);
-}
diff --git a/src/templating/extention/Test.java b/src/templating/extention/Test.java
deleted file mode 100644
index 00c3d4a..0000000
--- a/src/templating/extention/Test.java
+++ /dev/null
@@ -1,9 +0,0 @@
-package templating.extention;
-
-import java.util.Map;
-
-@FunctionalInterface
-public interface Test {
-    
-    boolean apply(Object input, Map<String, Object> args);
-}
diff --git a/src/templating/extention/core/CoreExtension.java b/src/templating/extention/core/CoreExtension.java
deleted file mode 100644
index d82a328..0000000
--- a/src/templating/extention/core/CoreExtension.java
+++ /dev/null
@@ -1,167 +0,0 @@
-package templating.extention.core;
-
-import java.util.HashMap;
-import java.util.Map;
-import templating.Context;
-import templating.Renderer;
-import templating.extention.Extension;
-import templating.node.NodeParser;
-import templating.token.Token;
-import templating.token.TokenStream;
-
-public class CoreExtension implements Extension {
-
-//    @Override
-//    public List<TokenParser> getTokenParsers() {
-//        List<TokenParser> parsers = new ArrayList<>();
-////        parsers.add(TokenParser.from("ws_trim", "-"));
-////        parsers.add(TokenParser.group("execute", "{%", "%}"));
-////        parsers.add(TokenParser.group("comment", "{#", "#}"));
-////        parsers.add(TokenParser.group("evaluate", "{{", "}}"));
-////        parsers.add(TokenParser.from("punctuation", "(", ")", "[", "]", "{", "}", "?", ":", ".", ",", "|", "="));
-//        parsers.add(TokenParser.group("execute", "{%", "%}", expression()));
-//        parsers.add(TokenParser.group("comment", "{#", "#}"));
-//        parsers.add(TokenParser.group("evaluate", "{{", "}}"));
-//        return parsers;
-//    }
-    
-//    @Override
-//    public Map<String, NodeParser> getNodeParsers() {
-//        Map<String, NodeParser> parsers = new HashMap<>();
-//        parsers.put("text", test("text"));
-//        parsers.put("evaluate", test("evaluate"));
-//        parsers.put("execute", test("execute"));
-//        parsers.put("comment", test("comment"));
-//        parsers.put("ws-trim", test("ws-trim"));
-//        return parsers;
-//    }
-
-    @Override
-    public Map<String, Renderer> getRenderers() {
-        Map<String, Renderer> renderers = new HashMap<>();
-        renderers.put("text", debug("text"));
-        renderers.put("evaluate", debug("evaluate"));
-        renderers.put("execute_open", debug("execute_open"));
-        renderers.put("execute_close", debug("execute_close"));
-        renderers.put("execute", debug("execute"));
-        renderers.put("comment", debug("comment"));
-        renderers.put("ws-trim", debug("ws-trim"));
-        renderers.put("name", debug("name"));
-        return renderers;
-    }
-    
-    static Renderer debug(String name) {
-        return (Token token, Context context) -> {
-            TokenStream stream = context.getStream();
-            token = stream.expect(name);
-            System.out.println(name + "(" + token.getValue() + ")");
-        };
-    }
-    
-//    static NodeParser test(String name) {
-//        return (Token token, Context context) -> {
-//            TokenStream stream = context.getStream();
-//            token = stream.expect(name);
-//            System.out.println(name + "(" + token.getValue() + ")");
-//        };
-//    }
-    
-//    @Override
-//    public Map<String, Renderer> getRenderers() {
-//        Map<String, Renderer> renderers = new HashMap<>();
-//        renderers.put("text", text());
-//        renderers.put("evaluate", debug("evaluate"));
-//        renderers.put("execute", debug("execute"));
-//        renderers.put("comment", comment());
-//        renderers.put("ws-trim", debug("ws-trim"));
-//        return renderers;
-//    }
-//    
-//    static Renderer text() {
-//        return (Token token, Context context) -> {
-//            TokenStream stream = context.getStream();
-//            token = stream.expect("text");
-//            System.out.println(token.getValue());
-//        };
-//    }
-//    
-//    static Renderer comment() {
-//        return (Token token, Context context) -> {
-//            TokenStream stream = context.getStream();
-//            token = stream.expect("comment");
-//        };
-//    }
-//    
-//    public static Renderer debug() {
-//        return Renderer.builder()
-//                .with("text", debug("text"))
-//                .with("evaluate", debug("evaluate"))
-//                .with("execute", debug("execute"))
-//                .with("comment", debug("comment"))
-////                .with("evaluate_open", eval())
-////                .with("text", text())
-////                .with("execute_open", execute())
-////                .with("comment_open", comment())
-//                .build();
-//        return (template, environment) -> {
-//            Context context = environment.getContext();
-//            TokenStream stream = template.stream();
-//            context.setStream(stream);
-//            Token token = stream.current();
-//            while (!Token.isEOF(token)) {
-//                String value = token.getValue();
-////                System.out.println("token(" + token.getType() + ")");
-//                switch (token.getType()) {
-//                    case "evaluate_open":
-//                        stream.next();
-//                        token = stream.expect("expression");
-//                        String expression = token.getValue();
-//                        System.out.println("evaluate(" + expression + ")");
-//                        // parse evaluation
-//                        stream.expect("evaluate_close");
-//                        token = stream.next();
-//                        break;
-//                    case "execute_open":
-//                        stream.next();
-//                        token = stream.expect("expression");
-//                        expression = token.getValue();
-//                        System.out.println("execute(" + expression + ")");
-//                        token = stream.next();
-//                        break;
-//                    case "comment_open":
-//                        stream.next();
-//                        token = stream.expect("expression");
-//                        expression = token.getValue();
-//                        System.out.println("comment(" + expression + ")");
-//                        stream.expect("comment_close");
-//                        token = stream.next();
-//                        break;
-//                    case "print_open":
-//                        System.out.print("print(" + value + "): ");
-//                        stream.next();
-//                        token = stream.expect("expression");
-//                        expression = token.getValue();
-//                        Optional<Object> evaluated = context.evaluate(expression, Object.class);
-//                        if (evaluated.isPresent()) {
-//                            System.out.print(evaluated.get());
-//                        }
-//                        System.out.println(evaluated.get());
-//                        token = stream.next();
-//                        break;
-//                    case "text":
-//                        System.out.println("text(" + value + ")");
-//                        token = stream.next();
-//                        break;
-//                    case "expression":
-//                        System.out.println("expression(" + value + ")");
-//                        token = stream.next();
-//                        break;
-//                    default:
-////                        System.out.println("skip(" + value + ")");
-//                        token = stream.next();
-//                        break;
-//                }
-//            }
-//        };
-//    }
-}
diff --git a/src/templating/node/BodyNode.java b/src/templating/node/BodyNode.java
deleted file mode 100644
index 75fbd53..0000000
--- a/src/templating/node/BodyNode.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package templating.node;
-
-public class BodyNode {
-    
-}
diff --git a/src/templating/node/ExecuteNode.java b/src/templating/node/ExecuteNode.java
deleted file mode 100644
index cefb328..0000000
--- a/src/templating/node/ExecuteNode.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package templating.node;
-
-import templating.expression.Expression;
-
-public class ExecuteNode extends ExpressionNode {
-    
-    public ExecuteNode(Expression expression) {
-        super(expression);
-    }
-
-    @Override
-    public void accept(NodeVisitor visitor) {
-    }
-}
diff --git a/src/templating/node/ExpressionNode.java b/src/templating/node/ExpressionNode.java
deleted file mode 100644
index b3b9358..0000000
--- a/src/templating/node/ExpressionNode.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package templating.node;
-
-import templating.expression.Expression;
-
-public abstract class ExpressionNode implements Node {
-    
-    private Expression expression;
-
-    public ExpressionNode(Expression expression) {
-        this.expression = expression;
-    }
-
-    public Expression getExpression() {
-        return expression;
-    }
-
-    public void setExpression(Expression expression) {
-        this.expression = expression;
-    }
-}
diff --git a/src/templating/node/Node.java b/src/templating/node/Node.java
deleted file mode 100644
index 79069f9..0000000
--- a/src/templating/node/Node.java
+++ /dev/null
@@ -1,8 +0,0 @@
-package templating.node;
-
-public interface Node {
-    
-    default void accept(NodeVisitor visitor) {
-        visitor.visit(this);
-    }
-}
diff --git a/src/templating/node/NodeParser.java b/src/templating/node/NodeParser.java
deleted file mode 100644
index 31ffc22..0000000
--- a/src/templating/node/NodeParser.java
+++ /dev/null
@@ -1,64 +0,0 @@
-package templating.node;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import templating.expression.Expression;
-import templating.token.Token;
-import templating.token.TokenStream;
-
-@FunctionalInterface
-public interface NodeParser {
-    
-    List<Node> parse(TokenStream stream) throws Exception;
-    
-    static NodeParser fromTypes() {
-        
-        Map<String, NodeParser> parsers = new HashMap<>();
-        
-        parsers.put("text", stream -> {
-            Token current = stream.current();
-            List<Node> result = new ArrayList<>();
-            result.add(new TextNode(current.getValue()));
-            return result;
-        });
-        
-        parsers.put("print_open", stream -> {
-            stream.next();
-            List<Node> result = new ArrayList<>();
-            result.add(new PrintNode(Expression.parse(stream)));
-            return result;
-        });
-        
-        parsers.put("execute_open", stream -> {
-            Token token = stream.next();
-            List<Node> result = new ArrayList<>();
-            
-            if (!token.isA("name")) {
-                throw new Exception();
-            }
-            
-            result.add(new ExecuteNode(Expression.parse(stream)));
-            return result;
-        });
-        
-        return stream -> {
-            List<Node> result = new LinkedList<>();
-            
-            while (!Token.isEOF(stream.current())) {
-                Token token = stream.current();
-                NodeParser parser = parsers.get(token.getType());
-                
-                if (null != parser) {
-                    result.addAll(parser.parse(stream));
-                }
-                
-                stream.next();
-            }
-            
-            return result;
-        };
-    }
-}
diff --git a/src/templating/node/NodeVisitor.java b/src/templating/node/NodeVisitor.java
deleted file mode 100644
index ad3a807..0000000
--- a/src/templating/node/NodeVisitor.java
+++ /dev/null
@@ -1,7 +0,0 @@
-package templating.node;
-
-@FunctionalInterface
-public interface NodeVisitor {
-    
-    void visit(Node node);
-}
diff --git a/src/templating/node/PrintNode.java b/src/templating/node/PrintNode.java
deleted file mode 100644
index b88728e..0000000
--- a/src/templating/node/PrintNode.java
+++ /dev/null
@@ -1,14 +0,0 @@
-package templating.node;
-
-import templating.expression.Expression;
-
-public class PrintNode extends ExpressionNode {
-    
-    public PrintNode(Expression expression) {
-        super(expression);
-    }
-
-    @Override
-    public void accept(NodeVisitor visitor) {
-    }
-}
diff --git a/src/templating/node/TextNode.java b/src/templating/node/TextNode.java
deleted file mode 100644
index cc0b4e7..0000000
--- a/src/templating/node/TextNode.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package templating.node;
-
-public class TextNode implements Node{
-
-    private String value;
-
-    public TextNode(String value) {
-        this.value = value;
-    }
-    
-    @Override
-    public void accept(NodeVisitor visitor) {
-    }
-    
-}
diff --git a/src/templating/token/Token.java b/src/templating/token/Token.java
deleted file mode 100644
index 38146cc..0000000
--- a/src/templating/token/Token.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package templating.token;
-
-import java.util.Objects;
-import templating.Position;
-
-public class Token {
-    
-    private String type;
-    
-    private String value;
-    
-    private Position position;
-
-    public Token(String type) {
-        this.type = type;
-    }
-
-    public Token(String type, String value, Position position) {
-        this.type = type;
-        this.value = value;
-        this.position = position;
-    }
-    
-    public boolean isA(String type) {
-        return this.type.equals(type);
-    }
-    
-    public boolean isA(String type, String value) {
-        return isA(type) && Objects.equals(this.value, value);
-    }
-
-    public Position getPosition() {
-        return position;
-    }
-
-    public void setPosition(Position position) {
-        this.position = position;
-    }
-
-    public String getValue() {
-        return value;
-    }
-
-    public void setValue(String value) {
-        this.value = value;
-    }
-    
-    public String getType() {
-        return type;
-    }
-
-    public void setType(String type) {
-        this.type = type;
-    }
-    
-    public static boolean isEOF(Token token) {
-        return token.isA("EOF");
-    }
-    
-    public static Token EOF() {
-        return new Token("EOF");
-    }
-    
-    public static Token text(String text, Position position) {
-        return new Token("text", text, position);
-    }
-
-    @Override
-    public String toString() {
-        return "Token{" + "type=" + type + ", value=" + value + ", position=" + position + '}';
-    }
-    
-}
diff --git a/src/templating/token/TokenParser.java b/src/templating/token/TokenParser.java
deleted file mode 100644
index d631a26..0000000
--- a/src/templating/token/TokenParser.java
+++ /dev/null
@@ -1,193 +0,0 @@
-package templating.token;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.List;
-import java.util.Optional;
-import java.util.function.Function;
-import java.util.function.Predicate;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-import java.util.stream.Collectors;
-import templating.Source;
-
-@FunctionalInterface
-public interface TokenParser {
-    
-    List<Token> parse(Source source) throws Exception;
-    
-    default List<Token> parse(Source source, boolean skipWhiteSpaces) throws Exception{
-        if (skipWhiteSpaces) {
-            source.advanceThroughWhitespace();
-        }
-        return parse(source);
-    }
-    
-    default Optional<List<Token>> tryParse(Source source) {
-        Source saved = source.save();
-//        int offset = source.getOffset();
-        try {
-            return Optional.of(parse(source, true));
-        } catch (Exception exception) {
-            source = saved;
-        }
-        return Optional.empty();
-    };
-    
-    default TokenParser skip(TokenParser skip) {
-        return (source) -> {
-            List<Token> result = parse(source, true);
-            skip.parse(source, true);
-            return result;
-        };
-    }
-    
-    default TokenParser then(TokenParser then) {
-        return (source) -> {
-            List<Token> result = parse(source, true);
-            result.addAll(then.parse(source, true));
-            return result;
-        };
-    }
-    
-    default TokenParser or(TokenParser then) {
-        return (source) -> {
-            int offset = source.getOffset();
-            try {
-                return parse(source, true);
-            } catch(Exception exception) {
-                source.setOffset(offset);
-            }
-            return then.parse(source);
-        };
-    }
-    
-    default TokenParser until(TokenParser end) {
-        return source -> {
-            List<Token> result = new ArrayList<>();
-            while(!end.tryParse(source).isPresent()) {
-                result.addAll(parse(source, true));
-            }
-            
-            return result;
-        };
-    }
-    
-    default TokenParser optional() {
-        return source -> {
-            Optional<List<Token>> result = tryParse(source);
-            if (result.isPresent()) {
-                return result.get();
-            }
-            return Collections.emptyList();
-        };
-    }
-    
-    default TokenParser zeroOrMore() {
-        return source -> {
-            List<Token> result = new ArrayList<>();
-            Optional<List<Token>> element;
-            while((element = tryParse(source)).isPresent()) {
-                result.addAll(element.get());
-            }
-            return result;
-        };
-    }
-    
-    default TokenParser zeroOrMore(TokenParser separator) {
-        return source -> {
-            List<Token> result = new ArrayList<>();
-            Optional<List<Token>> element = tryParse(source);
-            if(element.isPresent()) {
-                result.addAll(element.get());
-                while(separator.tryParse(source).isPresent()) {
-                    result.addAll(parse(source, true));
-                }
-            }
-            return result;
-        };
-    }
-    
-    default TokenParser oneOrMore() {
-        return source -> {
-            List<Token> result = new ArrayList<>();
-            result.addAll(parse(source, true));
-            Optional<List<Token>> element;
-            while((element = tryParse(source)).isPresent()) {
-                result.addAll(element.get());
-            }
-            return result;
-        };
-    }
-    
-    default TokenParser oneOrMore(TokenParser separator) {
-        return source -> {
-            List<Token> result = new ArrayList<>();
-            result.addAll(parse(source, true));
-            while(separator.tryParse(source).isPresent()) {
-                result.addAll(parse(source, true));
-            }
-            return result;
-        };
-    }
-    
-    default TokenParser filter(Predicate predicate) {
-        return source -> {
-            List<Token> result = parse(source, true);
-            
-            if (!predicate.test(result)) {
-                throw new Exception("Does not respect filter");
-            }
-            
-            return result;
-        };
-    }
-    
-    default TokenParser map(Function<List<Token>, List<Token>> function) {
-        return source -> {
-            return function.apply(parse(source, true));
-        };
-    }
-    
-    static TokenParser from(String name, Pattern pattern) {
-        return source -> {
-            Matcher matcher = pattern.matcher(source);
-            if(!matcher.lookingAt()) {
-                String msg = String.format("%s not found at %s", pattern.pattern(), source.getPosition());
-                throw new Exception(msg);
-            }
-            
-            String value = source.substring(matcher.end()).trim();
-            Token token = new Token(name, value, source.getPosition());
-            source.advance(matcher.end());
-            return new ArrayList(Arrays.asList(token));
-        };
-    }
-    
-    static TokenParser until(String name, String... values) {
-        return until(name, Arrays.asList(values));
-    }
-    
-    static TokenParser until(String name, List<String> values) {
-        StringBuilder sb = new StringBuilder("^.*?(?=");
-        sb.append(values.stream().map(Pattern::quote).collect(Collectors.joining("|")));
-        sb.append(")");
-        return from(name, Pattern.compile(sb.toString(), Pattern.DOTALL));
-    }
-    
-    static TokenParser value(String name, String value) {
-        return from(name, Pattern.compile(Pattern.quote(value)));
-    }
-    
-    static TokenParser in(String name, String value) {
-        StringBuilder sb = new StringBuilder();
-        for (char c: value.toCharArray()) {
-            if (sb.length() > 0) {
-                sb.append("|");
-            }
-            sb.append("\\Q").append(c).append("\\E");
-        }
-        return from(name, Pattern.compile(sb.toString()));
-    }
-}
diff --git a/src/templating/token/TokenParsers.java b/src/templating/token/TokenParsers.java
deleted file mode 100644
index cac93cf..0000000
--- a/src/templating/token/TokenParsers.java
+++ /dev/null
@@ -1,35 +0,0 @@
-package templating.token;
-
-import java.util.Arrays;
-import java.util.regex.Pattern;
-
-public interface TokenParsers {
-    
-    public static final Pattern REGEX_STRING = Pattern.compile("((\").*?(?<!\\\\)(\"))|((').*?(?<!\\\\)('))", Pattern.DOTALL);
-    
-    public static final Pattern REGEX_NUMBER = Pattern.compile("^[0-9]+(\\.[0-9]+)?");
-        
-    public static final String PUNCTUATION = "()[]{}?:.,|=";
-
-    static TokenParser string() {
-        return TokenParser.from("string", REGEX_STRING);
-    }
-    
-    static TokenParser number() {
-        return TokenParser.from("number", REGEX_NUMBER);
-    }
-    
-    static TokenParser punctuation() {
-        return TokenParser.in("punctuation", PUNCTUATION);
-    }
-    
-    static TokenParser EOF() {
-        return source -> {
-            if (source.length() == 0) {
-                return Arrays.asList(Token.EOF());
-            }
-            throw new Exception();
-        };
-    }
-    
-}
diff --git a/src/templating/token/TokenStream.java b/src/templating/token/TokenStream.java
deleted file mode 100644
index ba3499e..0000000
--- a/src/templating/token/TokenStream.java
+++ /dev/null
@@ -1,115 +0,0 @@
-package templating.token;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.Objects;
-
-public class TokenStream {
-
-    private final ArrayList<Token> tokens = new ArrayList<>();
-    private final String filename;
-    private int current;
-
-    /**
-     * Constructor for a Token Stream
-     *
-     * @param tokens A collection of tokens
-     * @param name The filename of the template that these tokens came from
-     */
-    public TokenStream(Collection<Token> tokens, String name) {
-        this.tokens.addAll(tokens);
-        this.current = 0;
-        this.filename = name;
-    }
-
-    /**
-     * Consumes and returns the next token in the stream.
-     *
-     * @return The next token
-     */
-    public Token next() {
-        return tokens.get(++current);
-    }
-
-    /**
-     * Checks the current token to see if it matches the provided type. If it
-     * doesn't match this will throw a SyntaxException. This will consume a
-     * token.
-     *
-     * @param type The type of token that we expect
-     * @return Token The current token
-     */
-    public Token expect(String type) {
-        return expect(type, null);
-    }
-
-    /**
-     * Checks the current token to see if it matches the provided type. If it
-     * doesn't match this will throw a SyntaxException. This will consume a
-     * token.
-     *
-     * @param type The type of token that we expect
-     * @param value The expected value of the token
-     * @return Token The current token
-     */
-    public Token expect(String type, String value) {
-        Token token = tokens.get(current);
-
-        boolean success = Objects.isNull(value) 
-                ? token.isA(type) : token.isA(type, value);
-
-        if (!success) {
-            String message = String.format("Unexpected token of value \"%s\" and type %s, expected token of type %s",
-                    token.getValue(), token.getType().toString(), type);
-            throw new IllegalStateException(message);
-        }
-        this.next();
-        return token;
-    }
-
-    /**
-     * Returns the next token in the stream without consuming it.
-     *
-     * @return The next token
-     */
-    public Token peek() {
-        return peek(1);
-    }
-
-    /**
-     * Returns a future token in the stream without consuming any.
-     *
-     * @param number How many tokens to lookahead
-     * @return The token we are peeking at
-     */
-    public Token peek(int number) {
-        return this.tokens.get(this.current + number);
-    }
-
-    @Override
-    public String toString() {
-        return tokens.toString();
-    }
-
-    /**
-     * Looks at the current token. Does not consume the token.
-     *
-     * @return Token The current token
-     */
-    public Token current() {
-        return this.tokens.get(current);
-    }
-
-    public String getFilename() {
-        return filename;
-    }
-
-    /**
-     * used for testing purposes
-     *
-     * @return List of tokens
-     */
-    public ArrayList<Token> getTokens() {
-        return tokens;
-    }
-}
diff --git a/src/templating/token/TokenVisitor.java b/src/templating/token/TokenVisitor.java
deleted file mode 100644
index 247d257..0000000
--- a/src/templating/token/TokenVisitor.java
+++ /dev/null
@@ -1,5 +0,0 @@
-package templating.token;
-
-public interface TokenVisitor {
-    void visit(Token token);
-}
diff --git a/src/templating/token/Tokenizer.java b/src/templating/token/Tokenizer.java
deleted file mode 100644
index a8e0249..0000000
--- a/src/templating/token/Tokenizer.java
+++ /dev/null
@@ -1,40 +0,0 @@
-package templating.token;
-
-import java.util.List;
-import templating.Source;
-
-public class Tokenizer {
-    
-    private TokenParser tokenParser;
-    
-    public List<Token> tokenize(Source source) throws Exception {
-        return this.tokenParser.parse(source, true);
-    }
-    
-    public TokenParser getTokenParser() {
-        return tokenParser;
-    }
-
-    public void setTokenParser(TokenParser tokenParser) {
-        this.tokenParser = tokenParser;
-    }
-    
-    public static TokenizerBuilder builder() {
-        return new TokenizerBuilder();
-    }
-    
-    public static class TokenizerBuilder {
-        private TokenParser tokenParser;
-        
-        public TokenizerBuilder parser(TokenParser parser) {
-            this.tokenParser = parser;
-            return this;
-        }
-        
-        public Tokenizer build() {
-            Tokenizer tokenizer = new Tokenizer();
-            tokenizer.setTokenParser(tokenParser);
-            return tokenizer;
-        }
-    }
-}
diff --git a/src/test/resolver/ResolverDelegateTest.java b/src/test/resolver/ResolverDelegateTest.java
new file mode 100644
index 0000000..4073de1
--- /dev/null
+++ b/src/test/resolver/ResolverDelegateTest.java
@@ -0,0 +1,101 @@
+package resolver;
+
+import java.util.Collection;
+import java.util.Optional;
+import org.junit.After;
+import org.junit.AfterClass;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+public class ResolverDelegateTest {
+    
+    public ResolverDelegateTest() {
+    }
+    
+    @BeforeClass
+    public static void setUpClass() {
+    }
+    
+    @AfterClass
+    public static void tearDownClass() {
+    }
+    
+    @Before
+    public void setUp() {
+    }
+    
+    @After
+    public void tearDown() {
+    }
+
+    /**
+     * Test of support method, of class ResolverDelegate.
+     */
+    @Test
+    public void testSupport() {
+        System.out.println("support");
+        Object object = null;
+        ResolverDelegate instance = new ResolverDelegate();
+        boolean expResult = false;
+//        boolean result = instance.support(object);
+//        assertEquals(expResult, result);
+        // TODO review the generated test code and remove the default call to fail.
+        fail("The test case is a prototype.");
+    }
+
+    /**
+     * Test of resolve method, of class ResolverDelegate.
+     */
+    @Test
+    public void testResolve() {
+        System.out.println("resolve");
+        Object object = null;
+        ResolverDelegate instance = new ResolverDelegate();
+        Optional expResult = null;
+        Optional result = instance.resolve(object);
+        assertEquals(expResult, result);
+        // TODO review the generated test code and remove the default call to fail.
+        fail("The test case is a prototype.");
+    }
+
+    /**
+     * Test of getResolvers method, of class ResolverDelegate.
+     */
+    @Test
+    public void testGetResolvers() {
+        System.out.println("getResolvers");
+        ResolverDelegate instance = new ResolverDelegate();
+//        Collection<Resolver<I, O>> expResult = null;
+//        Collection<Resolver<I, O>> result = instance.getResolvers();
+//        assertEquals(expResult, result);
+        // TODO review the generated test code and remove the default call to fail.
+        fail("The test case is a prototype.");
+    }
+
+    /**
+     * Test of setResolvers method, of class ResolverDelegate.
+     */
+    @Test
+    public void testSetResolvers() {
+        System.out.println("setResolvers");
+        ResolverDelegate instance = new ResolverDelegate();
+        instance.setResolvers(null);
+        // TODO review the generated test code and remove the default call to fail.
+        fail("The test case is a prototype.");
+    }
+
+    /**
+     * Test of addResolver method, of class ResolverDelegate.
+     */
+    @Test
+    public void testAddResolver() {
+        System.out.println("addResolver");
+        ResolverDelegate instance = new ResolverDelegate();
+//        instance.addResolver(null);
+        // TODO review the generated test code and remove the default call to fail.
+        fail("The test case is a prototype.");
+    }
+    
+}
diff --git a/src/util/Assert.java b/src/util/Assert.java
deleted file mode 100644
index e6e7c8b..0000000
--- a/src/util/Assert.java
+++ /dev/null
@@ -1,405 +0,0 @@
-package com.marvin.component.util;
-
-import java.util.Collection;
-import java.util.Map;
-
-public abstract class Assert {
-
-    /**
-     * Assert a boolean expression, throwing {@code IllegalArgumentException} if
-     * the test result is {@code false}.
-     * <pre class="code">Assert.isTrue(i &gt; 0, "The value must be greater than
-     * zero");</pre>
-     *
-     * @param expression a boolean expression
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if expression is {@code false}
-     */
-    public static void isTrue(boolean expression, String message) {
-        if (!expression) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert a boolean expression, throwing {@code IllegalArgumentException} if
-     * the test result is {@code false}.
-     * <pre class="code">Assert.isTrue(i &gt; 0);</pre>
-     *
-     * @param expression a boolean expression
-     * @throws IllegalArgumentException if expression is {@code false}
-     */
-    public static void isTrue(boolean expression) {
-        isTrue(expression, "[Assertion failed] - this expression must be true");
-    }
-
-    /**
-     * Assert that an object is {@code null} .
-     * <pre class="code">Assert.isNull(value, "The value must be null");</pre>
-     *
-     * @param object the object to check
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the object is not {@code null}
-     */
-    public static void isNull(Object object, String message) {
-        if (object != null) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that an object is {@code null} .
-     * <pre class="code">Assert.isNull(value);</pre>
-     *
-     * @param object the object to check
-     * @throws IllegalArgumentException if the object is not {@code null}
-     */
-    public static void isNull(Object object) {
-        isNull(object, "[Assertion failed] - the object argument must be null");
-    }
-
-    /**
-     * Assert that an object is not {@code null} .
-     * <pre class="code">Assert.notNull(clazz, "The class must not be
-     * null");</pre>
-     *
-     * @param object the object to check
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the object is {@code null}
-     */
-    public static void notNull(Object object, String message) {
-        if (object == null) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that an object is not {@code null} .
-     * <pre class="code">Assert.notNull(clazz);</pre>
-     *
-     * @param object the object to check
-     * @throws IllegalArgumentException if the object is {@code null}
-     */
-    public static void notNull(Object object) {
-        notNull(object, "[Assertion failed] - this argument is required; it must not be null");
-    }
-
-    /**
-     * Assert that the given String is not empty; that is, it must not be
-     * {@code null} and not the empty String.
-     * <pre class="code">Assert.hasLength(name, "Name must not be empty");</pre>
-     *
-     * @param text the String to check
-     * @param message the exception message to use if the assertion fails
-     * @see StringUtils#hasLength
-     * @throws IllegalArgumentException if the text is empty
-     */
-    public static void hasLength(String text, String message) {
-        if (!StringUtils.hasLength(text)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that the given String is not empty; that is, it must not be
-     * {@code null} and not the empty String.
-     * <pre class="code">Assert.hasLength(name);</pre>
-     *
-     * @param text the String to check
-     * @see StringUtils#hasLength
-     * @throws IllegalArgumentException if the text is empty
-     */
-    public static void hasLength(String text) {
-        String msg = "[Assertion failed] - this String argument must have length; it must not be null or empty";
-        hasLength(text, msg);
-    }
-
-    /**
-     * Assert that the given String has valid text content; that is, it must not
-     * be {@code null} and must contain at least one non-whitespace character.
-     * <pre class="code">Assert.hasText(name, "'name' must not be empty");</pre>
-     *
-     * @param text the String to check
-     * @param message the exception message to use if the assertion fails
-     * @see StringUtils#hasText
-     * @throws IllegalArgumentException if the text does not contain valid text
-     * content
-     */
-    public static void hasText(String text, String message) {
-        if (!StringUtils.hasText(text)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that the given String has valid text content; that is, it must not
-     * be {@code null} and must contain at least one non-whitespace character.
-     * <pre class="code">Assert.hasText(name, "'name' must not be empty");</pre>
-     *
-     * @param text the String to check
-     * @see StringUtils#hasText
-     * @throws IllegalArgumentException if the text does not contain valid text
-     * content
-     */
-    public static void hasText(String text) {
-        hasText(text,
-                "[Assertion failed] - this String argument must have text; it must not be null, empty, or blank");
-    }
-
-    /**
-     * Assert that the given text does not contain the given substring.
-     * <pre class="code">Assert.doesNotContain(name, "rod", "Name must not
-     * contain 'rod'");</pre>
-     *
-     * @param textToSearch the text to search
-     * @param substring the substring to find within the text
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the text contains the substring
-     */
-    public static void doesNotContain(String textToSearch, String substring, String message) {
-        if (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring)
-                && textToSearch.contains(substring)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that the given text does not contain the given substring.
-     * <pre class="code">Assert.doesNotContain(name, "rod");</pre>
-     *
-     * @param textToSearch the text to search
-     * @param substring the substring to find within the text
-     * @throws IllegalArgumentException if the text contains the substring
-     */
-    public static void doesNotContain(String textToSearch, String substring) {
-        doesNotContain(textToSearch, substring,
-                "[Assertion failed] - this String argument must not contain the substring [" + substring + "]");
-    }
-
-    /**
-     * Assert that an array has elements; that is, it must not be {@code null}
-     * and must have at least one element.
-     * <pre class="code">Assert.notEmpty(array, "The array must have
-     * elements");</pre>
-     *
-     * @param array the array to check
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the object array is {@code null} or
-     * has no elements
-     */
-    public static void notEmpty(Object[] array, String message) {
-        if (ObjectUtils.isEmpty(array)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that an array has elements; that is, it must not be {@code null}
-     * and must have at least one element.
-     * <pre class="code">Assert.notEmpty(array);</pre>
-     *
-     * @param array the array to check
-     * @throws IllegalArgumentException if the object array is {@code null} or
-     * has no elements
-     */
-    public static void notEmpty(Object[] array) {
-        notEmpty(array, "[Assertion failed] - this array must not be empty: it must contain at least 1 element");
-    }
-
-    /**
-     * Assert that an array has no null elements. Note: Does not complain if the
-     * array is empty!
-     * <pre class="code">Assert.noNullElements(array, "The array must have
-     * non-null elements");</pre>
-     *
-     * @param array the array to check
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the object array contains a
-     * {@code null} element
-     */
-    public static void noNullElements(Object[] array, String message) {
-        if (array != null) {
-            for (Object element : array) {
-                if (element == null) {
-                    throw new IllegalArgumentException(message);
-                }
-            }
-        }
-    }
-
-    /**
-     * Assert that an array has no null elements. Note: Does not complain if the
-     * array is empty!
-     * <pre class="code">Assert.noNullElements(array);</pre>
-     *
-     * @param array the array to check
-     * @throws IllegalArgumentException if the object array contains a
-     * {@code null} element
-     */
-    public static void noNullElements(Object[] array) {
-        noNullElements(array, "[Assertion failed] - this array must not contain any null elements");
-    }
-
-    /**
-     * Assert that a collection has elements; that is, it must not be
-     * {@code null} and must have at least one element.
-     * <pre class="code">Assert.notEmpty(collection, "Collection must have
-     * elements");</pre>
-     *
-     * @param collection the collection to check
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the collection is {@code null} or has
-     * no elements
-     */
-    public static void notEmpty(Collection<?> collection, String message) {
-        if (CollectionUtils.isEmpty(collection)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that a collection has elements; that is, it must not be
-     * {@code null} and must have at least one element.
-     * <pre class="code">Assert.notEmpty(collection, "Collection must have
-     * elements");</pre>
-     *
-     * @param collection the collection to check
-     * @throws IllegalArgumentException if the collection is {@code null} or has
-     * no elements
-     */
-    public static void notEmpty(Collection<?> collection) {
-        notEmpty(collection,
-                "[Assertion failed] - this collection must not be empty: it must contain at least 1 element");
-    }
-
-    /**
-     * Assert that a Map has entries; that is, it must not be {@code null} and
-     * must have at least one entry.
-     * <pre class="code">Assert.notEmpty(map, "Map must have entries");</pre>
-     *
-     * @param map the map to check
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the map is {@code null} or has no
-     * entries
-     */
-    public static void notEmpty(Map<?, ?> map, String message) {
-        if (CollectionUtils.isEmpty(map)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that a Map has entries; that is, it must not be {@code null} and
-     * must have at least one entry.
-     * <pre class="code">Assert.notEmpty(map);</pre>
-     *
-     * @param map the map to check
-     * @throws IllegalArgumentException if the map is {@code null} or has no
-     * entries
-     */
-    public static void notEmpty(Map<?, ?> map) {
-        notEmpty(map, "[Assertion failed] - this map must not be empty; it must contain at least one entry");
-    }
-
-    /**
-     * Assert that the provided object is an instance of the provided class.
-     * <pre class="code">Assert.instanceOf(Foo.class, foo);</pre>
-     *
-     * @param clazz the required class
-     * @param obj the object to check
-     * @throws IllegalArgumentException if the object is not an instance of
-     * clazz
-     * @see Class#isInstance
-     */
-    public static void isInstanceOf(Class<?> clazz, Object obj) {
-        isInstanceOf(clazz, obj, "");
-    }
-
-    /**
-     * Assert that the provided object is an instance of the provided class.
-     * <pre class="code">Assert.instanceOf(Foo.class, foo);</pre>
-     *
-     * @param type the type to check against
-     * @param obj the object to check
-     * @param message a message which will be prepended to the message produced
-     * by the function itself, and which may be used to provide context. It
-     * should normally end in ":" or "." so that the generated message looks OK
-     * when appended to it.
-     * @throws IllegalArgumentException if the object is not an instance of
-     * clazz
-     * @see Class#isInstance
-     */
-    public static void isInstanceOf(Class<?> type, Object obj, String message) {
-        notNull(type, "Type to check against must not be null");
-        if (!type.isInstance(obj)) {
-            throw new IllegalArgumentException(
-                    (StringUtils.hasLength(message) ? message + " " : "")
-                    + "Object of class [" + (obj != null ? obj.getClass().getName() : "null")
-                    + "] must be an instance of " + type);
-        }
-    }
-
-    /**
-     * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.
-     * <pre class="code">Assert.isAssignable(Number.class, myClass);</pre>
-     *
-     * @param superType the super type to check
-     * @param subType the sub type to check
-     * @throws IllegalArgumentException if the classes are not assignable
-     */
-    public static void isAssignable(Class<?> superType, Class<?> subType) {
-        isAssignable(superType, subType, "");
-    }
-
-    /**
-     * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.
-     * <pre class="code">Assert.isAssignable(Number.class, myClass);</pre>
-     *
-     * @param superType the super type to check against
-     * @param subType the sub type to check
-     * @param message a message which will be prepended to the message produced
-     * by the function itself, and which may be used to provide context. It
-     * should normally end in ":" or "." so that the generated message looks OK
-     * when appended to it.
-     * @throws IllegalArgumentException if the classes are not assignable
-     */
-    public static void isAssignable(Class<?> superType, Class<?> subType, String message) {
-        notNull(superType, "Type to check against must not be null");
-        if (subType == null || !superType.isAssignableFrom(subType)) {
-            throw new IllegalArgumentException((StringUtils.hasLength(message) ? message + " " : "")
-                    + subType + " is not assignable to " + superType);
-        }
-    }
-
-    /**
-     * Assert a boolean expression, throwing {@code IllegalStateException} if
-     * the test result is {@code false}. Call isTrue if you wish to throw
-     * IllegalArgumentException on an assertion failure.
-     * <pre class="code">Assert.state(id == null, "The id property must not
-     * already be initialized");</pre>
-     *
-     * @param expression a boolean expression
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalStateException if expression is {@code false}
-     */
-    public static void state(boolean expression, String message) {
-        if (!expression) {
-            throw new IllegalStateException(message);
-        }
-    }
-
-    /**
-     * Assert a boolean expression, throwing {@link IllegalStateException} if
-     * the test result is {@code false}.
-     * <p>
-     * Call {@link #isTrue(boolean)} if you wish to throw
-     * {@link IllegalArgumentException} on an assertion failure.
-     * <pre class="code">Assert.state(id == null);</pre>
-     *
-     * @param expression a boolean expression
-     * @throws IllegalStateException if the supplied expression is {@code false}
-     */
-    public static void state(boolean expression) {
-        state(expression, "[Assertion failed] - this state invariant must be true");
-    }
-}
diff --git a/src/util/ClassUtils.java b/src/util/ClassUtils.java
deleted file mode 100644
index 8f0f1d4..0000000
--- a/src/util/ClassUtils.java
+++ /dev/null
@@ -1,1313 +0,0 @@
-/*
- * To change this license header, choose License Headers in Project Properties.
- * To change this template file, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.marvin.component.util;
-
-import java.beans.Introspector;
-import java.lang.reflect.Array;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.Proxy;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.IdentityHashMap;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-/**
- *
- * @author cdi305
- */
-public abstract class ClassUtils {
-
-    /**
-     * Suffix for array class names: "[]"
-     */
-    public static final String ARRAY_SUFFIX = "[]";
-
-    /**
-     * Prefix for internal array class names: "["
-     */
-    private static final String INTERNAL_ARRAY_PREFIX = "[";
-
-    /**
-     * Prefix for internal non-primitive array class names: "[L"
-     */
-    private static final String NON_PRIMITIVE_ARRAY_PREFIX = "[L";
-
-    /**
-     * The package separator character '.'
-     */
-    private static final char PACKAGE_SEPARATOR = '.';
-
-    /**
-     * The path separator character '/'
-     */
-    private static final char PATH_SEPARATOR = '/';
-
-    /**
-     * The inner class separator character '$'
-     */
-    private static final char INNER_CLASS_SEPARATOR = '$';
-
-    /**
-     * The CGLIB class separator character "$$"
-     */
-    public static final String CGLIB_CLASS_SEPARATOR = "$$";
-
-    /**
-     * The ".class" file suffix
-     */
-    public static final String CLASS_FILE_SUFFIX = ".class";
-
-    /**
-     * Map with primitive wrapper type as key and corresponding primitive type
-     * as value, for example: Integer.class -> int.class.
-     */
-    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<>(8);
-
-    /**
-     * Map with primitive type as key and corresponding wrapper type as value,
-     * for example: int.class -> Integer.class.
-     */
-    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<>(8);
-
-    /**
-     * Map with primitive type name as key and corresponding primitive type as
-     * value, for example: "int" -> "int.class".
-     */
-    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<>(32);
-
-    /**
-     * Map with common "java.lang" class name as key and corresponding Class as
-     * value. Primarily for efficient deserialization of remote invocations.
-     */
-    private static final Map<String, Class<?>> commonClassCache = new HashMap<>(32);
-
-    static {
-        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);
-        primitiveWrapperTypeMap.put(Byte.class, byte.class);
-        primitiveWrapperTypeMap.put(Character.class, char.class);
-        primitiveWrapperTypeMap.put(Double.class, double.class);
-        primitiveWrapperTypeMap.put(Float.class, float.class);
-        primitiveWrapperTypeMap.put(Integer.class, int.class);
-        primitiveWrapperTypeMap.put(Long.class, long.class);
-        primitiveWrapperTypeMap.put(Short.class, short.class);
-
-        primitiveWrapperTypeMap.entrySet().stream().map((entry) -> {
-            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());
-            return entry;
-        }).forEach((entry) -> {
-            registerCommonClasses(entry.getKey());
-        });
-
-        Set<Class<?>> primitiveTypes = new HashSet<>(32);
-        primitiveTypes.addAll(primitiveWrapperTypeMap.values());
-        primitiveTypes.addAll(Arrays.asList(new Class<?>[]{
-            boolean[].class, byte[].class, char[].class, double[].class,
-            float[].class, int[].class, long[].class, short[].class}));
-        primitiveTypes.add(void.class);
-        
-        primitiveTypes.stream().forEach((primitiveType) -> {
-            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);
-        });
-
-        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class,
-                Float[].class, Integer[].class, Long[].class, Short[].class);
-        registerCommonClasses(Number.class, Number[].class, String.class, String[].class,
-                Object.class, Object[].class, Class.class, Class[].class);
-        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class,
-                Error.class, StackTraceElement.class, StackTraceElement[].class);
-    }
-
-    /**
-     * Register the given common classes with the ClassUtils cache.
-     */
-    private static void registerCommonClasses(Class<?>... commonClasses) {
-        for (Class<?> clazz : commonClasses) {
-            commonClassCache.put(clazz.getName(), clazz);
-        }
-    }
-
-    /**
-     * Return the default ClassLoader to use: typically the thread context
-     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils
-     * class will be used as fallback.
-     * <p>
-     * Call this method if you intend to use the thread context ClassLoader in a
-     * scenario where you clearly prefer a non-null ClassLoader reference: for
-     * example, for class path resource loading (but not necessarily for
-     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference
-     * as well).
-     *
-     * @return the default ClassLoader (only {@code null} if even the system
-     * ClassLoader isn't accessible)
-     * @see Thread#getContextClassLoader()
-     * @see ClassLoader#getSystemClassLoader()
-     */
-    public static ClassLoader getDefaultClassLoader() {
-        ClassLoader cl = null;
-        try {
-            cl = Thread.currentThread().getContextClassLoader();
-        } catch (Throwable ex) {
-            // Cannot access thread context ClassLoader - falling back...
-        }
-        if (cl == null) {
-            // No thread context class loader -> use class loader of this class.
-            cl = ClassUtils.class.getClassLoader();
-            if (cl == null) {
-                // getClassLoader() returning null indicates the bootstrap ClassLoader
-                try {
-                    cl = ClassLoader.getSystemClassLoader();
-                } catch (Throwable ex) {
-                    // Cannot access system ClassLoader - oh well, maybe the caller can live with null...
-                }
-            }
-        }
-        return cl;
-    }
-
-    /**
-     * Override the thread context ClassLoader with the environment's bean
-     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent
-     * to the thread context ClassLoader already.
-     *
-     * @param classLoaderToUse the actual ClassLoader to use for the thread
-     * context
-     * @return the original thread context ClassLoader, or {@code null} if not
-     * overridden
-     */
-    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {
-        Thread currentThread = Thread.currentThread();
-        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();
-        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {
-            currentThread.setContextClassLoader(classLoaderToUse);
-            return threadContextClassLoader;
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Replacement for {@code Class.forName()} that also returns Class instances
-     * for primitives (e.g. "int") and array class names (e.g. "String[]").
-     * Furthermore, it is also capable of resolving inner class names in Java
-     * source style (e.g. "java.lang.Thread.State" instead of
-     * "java.lang.Thread$State").
-     *
-     * @param name the name of the Class
-     * @param classLoader the class loader to use (may be {@code null}, which
-     * indicates the default class loader)
-     * @return Class instance for the supplied name
-     * @throws ClassNotFoundException if the class was not found
-     * @throws LinkageError if the class file could not be loaded
-     * @see Class#forName(String, boolean, ClassLoader)
-     */
-    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {
-        Assert.notNull(name, "Name must not be null");
-
-        Class<?> clazz = resolvePrimitiveClassName(name);
-        if (clazz == null) {
-            clazz = commonClassCache.get(name);
-        }
-        if (clazz != null) {
-            return clazz;
-        }
-
-        // "java.lang.String[]" style arrays
-        if (name.endsWith(ARRAY_SUFFIX)) {
-            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());
-            Class<?> elementClass = forName(elementClassName, classLoader);
-            return Array.newInstance(elementClass, 0).getClass();
-        }
-
-        // "[Ljava.lang.String;" style arrays
-        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(";")) {
-            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);
-            Class<?> elementClass = forName(elementName, classLoader);
-            return Array.newInstance(elementClass, 0).getClass();
-        }
-
-        // "[[I" or "[[Ljava.lang.String;" style arrays
-        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {
-            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());
-            Class<?> elementClass = forName(elementName, classLoader);
-            return Array.newInstance(elementClass, 0).getClass();
-        }
-
-        ClassLoader clToUse = classLoader;
-        if (clToUse == null) {
-            clToUse = getDefaultClassLoader();
-        }
-        try {
-            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));
-        } catch (ClassNotFoundException ex) {
-            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);
-            if (lastDotIndex != -1) {
-                String innerClassName
-                        = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);
-                try {
-                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));
-                } catch (ClassNotFoundException ex2) {
-                    // Swallow - let original exception get through
-                }
-            }
-            throw ex;
-        }
-    }
-
-    /**
-     * Resolve the given class name into a Class instance. Supports primitives
-     * (like "int") and array class names (like "String[]").
-     * <p>
-     * This is effectively equivalent to the {@code forName} method with the
-     * same arguments, with the only difference being the exceptions thrown in
-     * case of class loading failure.
-     *
-     * @param className the name of the Class
-     * @param classLoader the class loader to use (may be {@code null}, which
-     * indicates the default class loader)
-     * @return Class instance for the supplied name
-     * @throws IllegalArgumentException if the class name was not resolvable
-     * (that is, the class could not be found or the class file could not be
-     * loaded)
-     * @see #forName(String, ClassLoader)
-     */
-    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {
-        try {
-            return forName(className, classLoader);
-        } catch (ClassNotFoundException ex) {
-            throw new IllegalArgumentException("Cannot find class [" + className + "]", ex);
-        } catch (LinkageError ex) {
-            throw new IllegalArgumentException(
-                    "Error loading class [" + className + "]: problem with class file or dependent class.", ex);
-        }
-    }
-
-    /**
-     * Resolve the given class name as primitive class, if appropriate,
-     * according to the JVM's naming rules for primitive classes.
-     * <p>
-     * Also supports the JVM's internal class names for primitive arrays. Does
-     * <i>not</i> support the "[]" suffix notation for primitive arrays; this is
-     * only supported by {@link #forName(String, ClassLoader)}.
-     *
-     * @param name the name of the potentially primitive class
-     * @return the primitive class, or {@code null} if the name does not denote
-     * a primitive class or primitive array class
-     */
-    public static Class<?> resolvePrimitiveClassName(String name) {
-        Class<?> result = null;
-		// Most class names will be quite long, considering that they
-        // SHOULD sit in a package, so a length check is worthwhile.
-        if (name != null && name.length() <= 8) {
-            // Could be a primitive - likely.
-            result = primitiveTypeNameMap.get(name);
-        }
-        return result;
-    }
-
-    /**
-     * Determine whether the {@link Class} identified by the supplied name is
-     * present and can be loaded. Will return {@code false} if either the class
-     * or one of its dependencies is not present or cannot be loaded.
-     *
-     * @param className the name of the class to check
-     * @param classLoader the class loader to use (may be {@code null}, which
-     * indicates the default class loader)
-     * @return whether the specified class is present
-     */
-    public static boolean isPresent(String className, ClassLoader classLoader) {
-        try {
-            forName(className, classLoader);
-            return true;
-        } catch (ClassNotFoundException | LinkageError ex) {
-            // Class or one of its dependencies is not present...
-            return false;
-        }
-    }
-
-    /**
-     * Return the user-defined class for the given instance: usually simply the
-     * class of the given instance, but the original class in case of a
-     * CGLIB-generated subclass.
-     *
-     * @param instance the instance to check
-     * @return the user-defined class
-     */
-    public static Class<?> getUserClass(Object instance) {
-        Assert.notNull(instance, "Instance must not be null");
-        return getUserClass(instance.getClass());
-    }
-
-    /**
-     * Return the user-defined class for the given class: usually simply the
-     * given class, but the original class in case of a CGLIB-generated
-     * subclass.
-     *
-     * @param clazz the class to check
-     * @return the user-defined class
-     */
-    public static Class<?> getUserClass(Class<?> clazz) {
-        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {
-            Class<?> superclass = clazz.getSuperclass();
-            if (superclass != null && Object.class != superclass) {
-                return superclass;
-            }
-        }
-        return clazz;
-    }
-
-    /**
-     * Check whether the given class is cache-safe in the given context, i.e.
-     * whether it is loaded by the given ClassLoader or a parent of it.
-     *
-     * @param clazz the class to analyze
-     * @param classLoader the ClassLoader to potentially cache metadata in
-     * @return 
-     */
-    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {
-        Assert.notNull(clazz, "Class must not be null");
-        try {
-            ClassLoader target = clazz.getClassLoader();
-            if (target == null) {
-                return true;
-            }
-            ClassLoader cur = classLoader;
-            if (cur == target) {
-                return true;
-            }
-            while (cur != null) {
-                cur = cur.getParent();
-                if (cur == target) {
-                    return true;
-                }
-            }
-            return false;
-        } catch (SecurityException ex) {
-            // Probably from the system ClassLoader - let's consider it safe.
-            return true;
-        }
-    }
-
-    /**
-     * Get the class name without the qualified package name.
-     *
-     * @param className the className to get the short name for
-     * @return the class name of the class without the package name
-     * @throws IllegalArgumentException if the className is empty
-     */
-    public static String getShortName(String className) {
-        Assert.hasLength(className, "Class name must not be empty");
-        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);
-        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);
-        if (nameEndIndex == -1) {
-            nameEndIndex = className.length();
-        }
-        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);
-        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);
-        return shortName;
-    }
-
-    /**
-     * Get the class name without the qualified package name.
-     *
-     * @param clazz the class to get the short name for
-     * @return the class name of the class without the package name
-     */
-    public static String getShortName(Class<?> clazz) {
-        return getShortName(getQualifiedName(clazz));
-    }
-
-    /**
-     * Return the short string name of a Java class in uncapitalized JavaBeans
-     * property format. Strips the outer class name in case of an inner class.
-     *
-     * @param clazz the class
-     * @return the short name rendered in a standard JavaBeans property format
-     * @see java.beans.Introspector#decapitalize(String)
-     */
-    public static String getShortNameAsProperty(Class<?> clazz) {
-        String shortName = getShortName(clazz);
-        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);
-        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);
-        return Introspector.decapitalize(shortName);
-    }
-
-    /**
-     * Determine the name of the class file, relative to the containing package:
-     * e.g. "String.class"
-     *
-     * @param clazz the class
-     * @return the file name of the ".class" file
-     */
-    public static String getClassFileName(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        String className = clazz.getName();
-        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);
-        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;
-    }
-
-    /**
-     * Determine the name of the package of the given class, e.g. "java.lang"
-     * for the {@code java.lang.String} class.
-     *
-     * @param clazz the class
-     * @return the package name, or the empty String if the class is defined in
-     * the default package
-     */
-    public static String getPackageName(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        return getPackageName(clazz.getName());
-    }
-
-    /**
-     * Determine the name of the package of the given fully-qualified class
-     * name, e.g. "java.lang" for the {@code java.lang.String} class name.
-     *
-     * @param fqClassName the fully-qualified class name
-     * @return the package name, or the empty String if the class is defined in
-     * the default package
-     */
-    public static String getPackageName(String fqClassName) {
-        Assert.notNull(fqClassName, "Class name must not be null");
-        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);
-        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : "");
-    }
-
-    /**
-     * Return the qualified name of the given class: usually simply the class
-     * name, but component type class name + "[]" for arrays.
-     *
-     * @param clazz the class
-     * @return the qualified name of the class
-     */
-    public static String getQualifiedName(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        if (clazz.isArray()) {
-            return getQualifiedNameForArray(clazz);
-        } else {
-            return clazz.getName();
-        }
-    }
-
-    /**
-     * Build a nice qualified name for an array: component type class name +
-     * "[]".
-     *
-     * @param clazz the array class
-     * @return a qualified name for the array class
-     */
-    private static String getQualifiedNameForArray(Class<?> clazz) {
-        StringBuilder result = new StringBuilder();
-        while (clazz.isArray()) {
-            clazz = clazz.getComponentType();
-            result.append(ARRAY_SUFFIX);
-        }
-        result.insert(0, clazz.getName());
-        return result.toString();
-    }
-
-    /**
-     * Return the qualified name of the given method, consisting of fully
-     * qualified interface/class name + "." + method name.
-     *
-     * @param method the method
-     * @return the qualified name of the method
-     */
-    public static String getQualifiedMethodName(Method method) {
-        Assert.notNull(method, "Method must not be null");
-        return method.getDeclaringClass().getName() + "." + method.getName();
-    }
-
-    /**
-     * Return a descriptive name for the given object's type: usually simply the
-     * class name, but component type class name + "[]" for arrays, and an
-     * appended list of implemented interfaces for JDK proxies.
-     *
-     * @param value the value to introspect
-     * @return the qualified name of the class
-     */
-    public static String getDescriptiveType(Object value) {
-        if (value == null) {
-            return null;
-        }
-        Class<?> clazz = value.getClass();
-        if (Proxy.isProxyClass(clazz)) {
-            StringBuilder result = new StringBuilder(clazz.getName());
-            result.append(" implementing ");
-            Class<?>[] ifcs = clazz.getInterfaces();
-            for (int i = 0; i < ifcs.length; i++) {
-                result.append(ifcs[i].getName());
-                if (i < ifcs.length - 1) {
-                    result.append(',');
-                }
-            }
-            return result.toString();
-        } else if (clazz.isArray()) {
-            return getQualifiedNameForArray(clazz);
-        } else {
-            return clazz.getName();
-        }
-    }
-
-    /**
-     * Check whether the given class matches the user-specified type name.
-     *
-     * @param clazz the class to check
-     * @param typeName the type name to match
-     * @return 
-     */
-    public static boolean matchesTypeName(Class<?> clazz, String typeName) {
-        return (typeName != null
-                && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName())
-                || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));
-    }
-
-    /**
-     * Determine whether the given class has a public constructor with the given
-     * signature.
-     * <p>
-     * Essentially translates {@code NoSuchMethodException} to "false".
-     *
-     * @param clazz the clazz to analyze
-     * @param paramTypes the parameter types of the method
-     * @return whether the class has a corresponding constructor
-     * @see Class#getMethod
-     */
-    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {
-        return (getConstructorIfAvailable(clazz, paramTypes) != null);
-    }
-
-    /**
-     * Determine whether the given class has a public constructor with the given
-     * signature, and return it if available (else return {@code null}).
-     * <p>
-     * Essentially translates {@code NoSuchMethodException} to {@code null}.
-     *
-     * @param <T>
-     * @param clazz the clazz to analyze
-     * @param paramTypes the parameter types of the method
-     * @return the constructor, or {@code null} if not found
-     * @see Class#getConstructor
-     */
-    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {
-        Assert.notNull(clazz, "Class must not be null");
-        try {
-            return clazz.getConstructor(paramTypes);
-        } catch (NoSuchMethodException ex) {
-            return null;
-        }
-    }
-
-    /**
-     * Determine whether the given class has a public method with the given
-     * signature.
-     * <p>
-     * Essentially translates {@code NoSuchMethodException} to "false".
-     *
-     * @param clazz the clazz to analyze
-     * @param methodName the name of the method
-     * @param paramTypes the parameter types of the method
-     * @return whether the class has a corresponding method
-     * @see Class#getMethod
-     */
-    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {
-        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);
-    }
-
-    /**
-     * Determine whether the given class has a public method with the given
-     * signature, and return it if available (else throws an
-     * {@code IllegalStateException}).
-     * <p>
-     * In case of any signature specified, only returns the method if there is a
-     * unique candidate, i.e. a single public method with the specified name.
-     * <p>
-     * Essentially translates {@code NoSuchMethodException} to
-     * {@code IllegalStateException}.
-     *
-     * @param clazz the clazz to analyze
-     * @param methodName the name of the method
-     * @param paramTypes the parameter types of the method (may be {@code null}
-     * to indicate any signature)
-     * @return the method (never {@code null})
-     * @throws IllegalStateException if the method has not been found
-     * @see Class#getMethod
-     */
-    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.notNull(methodName, "Method name must not be null");
-        if (paramTypes != null) {
-            try {
-                return clazz.getMethod(methodName, paramTypes);
-            } catch (NoSuchMethodException ex) {
-                throw new IllegalStateException("Expected method not found: " + ex);
-            }
-        } else {
-            Set<Method> candidates = new HashSet<>(1);
-            Method[] methods = clazz.getMethods();
-            for (Method method : methods) {
-                if (methodName.equals(method.getName())) {
-                    candidates.add(method);
-                }
-            }
-            if (candidates.size() == 1) {
-                return candidates.iterator().next();
-            } else if (candidates.isEmpty()) {
-                throw new IllegalStateException("Expected method not found: " + clazz + "." + methodName);
-            } else {
-                throw new IllegalStateException("No unique method found: " + clazz + "." + methodName);
-            }
-        }
-    }
-
-    /**
-     * Determine whether the given class has a public method with the given
-     * signature, and return it if available (else return {@code null}).
-     * <p>
-     * In case of any signature specified, only returns the method if there is a
-     * unique candidate, i.e. a single public method with the specified name.
-     * <p>
-     * Essentially translates {@code NoSuchMethodException} to {@code null}.
-     *
-     * @param clazz the clazz to analyze
-     * @param methodName the name of the method
-     * @param paramTypes the parameter types of the method (may be {@code null}
-     * to indicate any signature)
-     * @return the method, or {@code null} if not found
-     * @see Class#getMethod
-     */
-    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.notNull(methodName, "Method name must not be null");
-        if (paramTypes != null) {
-            try {
-                return clazz.getMethod(methodName, paramTypes);
-            } catch (NoSuchMethodException ex) {
-                return null;
-            }
-        } else {
-            Set<Method> candidates = new HashSet<>(1);
-            Method[] methods = clazz.getMethods();
-            for (Method method : methods) {
-                if (methodName.equals(method.getName())) {
-                    candidates.add(method);
-                }
-            }
-            if (candidates.size() == 1) {
-                return candidates.iterator().next();
-            }
-            return null;
-        }
-    }
-
-    /**
-     * Return the number of methods with a given name (with any argument types),
-     * for the given class and/or its superclasses. Includes non-public methods.
-     *
-     * @param clazz	the clazz to check
-     * @param methodName the name of the method
-     * @return the number of methods with the given name
-     */
-    public static int getMethodCountForName(Class<?> clazz, String methodName) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.notNull(methodName, "Method name must not be null");
-        int count = 0;
-        Method[] declaredMethods = clazz.getDeclaredMethods();
-        for (Method method : declaredMethods) {
-            if (methodName.equals(method.getName())) {
-                count++;
-            }
-        }
-        Class<?>[] ifcs = clazz.getInterfaces();
-        for (Class<?> ifc : ifcs) {
-            count += getMethodCountForName(ifc, methodName);
-        }
-        if (clazz.getSuperclass() != null) {
-            count += getMethodCountForName(clazz.getSuperclass(), methodName);
-        }
-        return count;
-    }
-
-    /**
-     * Does the given class or one of its superclasses at least have one or more
-     * methods with the supplied name (with any argument types)? Includes
-     * non-public methods.
-     *
-     * @param clazz	the clazz to check
-     * @param methodName the name of the method
-     * @return whether there is at least one method with the given name
-     */
-    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.notNull(methodName, "Method name must not be null");
-        Method[] declaredMethods = clazz.getDeclaredMethods();
-        for (Method method : declaredMethods) {
-            if (method.getName().equals(methodName)) {
-                return true;
-            }
-        }
-        Class<?>[] ifcs = clazz.getInterfaces();
-        for (Class<?> ifc : ifcs) {
-            if (hasAtLeastOneMethodWithName(ifc, methodName)) {
-                return true;
-            }
-        }
-        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));
-    }
-
-    /**
-     * Given a method, which may come from an interface, and a target class used
-     * in the current reflective invocation, find the corresponding target
-     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the
-     * target class may be {@code DefaultFoo}. In this case, the method may be
-     * {@code DefaultFoo.bar()}. This enables attributes on that method to be
-     * found.
-     * <p>
-     * <b>NOTE:</b> In contrast to
-     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},
-     * this method does <i>not</i> resolve Java 5 bridge methods automatically.
-     * Call
-     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}
-     * if bridge method resolution is desirable (e.g. for obtaining metadata
-     * from the original method definition).
-     * <p>
-     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow
-     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,
-     * this implementation will fall back to returning the originally provided
-     * method.
-     *
-     * @param method the method to be invoked, which may come from an interface
-     * @param targetClass the target class for the current invocation. May be
-     * {@code null} or may not even implement the method.
-     * @return the specific target method, or the original method if the
-     * {@code targetClass} doesn't implement it or is {@code null}
-     */
-    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {
-        if (method != null && isOverridable(method, targetClass)
-                && targetClass != null && targetClass != method.getDeclaringClass()) {
-            try {
-                if (Modifier.isPublic(method.getModifiers())) {
-                    try {
-                        return targetClass.getMethod(method.getName(), method.getParameterTypes());
-                    } catch (NoSuchMethodException ex) {
-                        return method;
-                    }
-                } else {
-                    Method specificMethod
-                            = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());
-                    return (specificMethod != null ? specificMethod : method);
-                }
-            } catch (SecurityException ex) {
-                // Security settings are disallowing reflective access; fall back to 'method' below.
-            }
-        }
-        return method;
-    }
-
-    /**
-     * Determine whether the given method is declared by the user or at least
-     * pointing to a user-declared method.
-     * <p>
-     * Checks {@link Method#isSynthetic()} (for implementation methods) as well
-     * as the {@code GroovyObject} interface (for interface methods; on an
-     * implementation class, implementations of the {@code GroovyObject} methods
-     * will be marked as synthetic anyway). Note that, despite being synthetic,
-     * bridge methods ({@link Method#isBridge()}) are considered as user-level
-     * methods since they are eventually pointing to a user-declared generic
-     * method.
-     *
-     * @param method the method to check
-     * @return {@code true} if the method can be considered as user-declared;
-     * [@code false} otherwise
-     */
-    public static boolean isUserLevelMethod(Method method) {
-        Assert.notNull(method, "Method must not be null");
-        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));
-    }
-
-    private static boolean isGroovyObjectMethod(Method method) {
-        return method.getDeclaringClass().getName().equals("groovy.lang.GroovyObject");
-    }
-
-    /**
-     * Determine whether the given method is overridable in the given target
-     * class.
-     *
-     * @param method the method to check
-     * @param targetClass the target class to check against
-     */
-    private static boolean isOverridable(Method method, Class<?> targetClass) {
-        if (Modifier.isPrivate(method.getModifiers())) {
-            return false;
-        }
-        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {
-            return true;
-        }
-        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));
-    }
-
-    /**
-     * Return a public static method of a class.
-     *
-     * @param clazz the class which defines the method
-     * @param methodName the static method name
-     * @param args the parameter types to the method
-     * @return the static method, or {@code null} if no static method was found
-     * @throws IllegalArgumentException if the method name is blank or the clazz
-     * is null
-     */
-    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.notNull(methodName, "Method name must not be null");
-        try {
-            Method method = clazz.getMethod(methodName, args);
-            return Modifier.isStatic(method.getModifiers()) ? method : null;
-        } catch (NoSuchMethodException ex) {
-            return null;
-        }
-    }
-
-    /**
-     * Check if the given class represents a primitive wrapper, i.e. Boolean,
-     * Byte, Character, Short, Integer, Long, Float, or Double.
-     *
-     * @param clazz the class to check
-     * @return whether the given class is a primitive wrapper class
-     */
-    public static boolean isPrimitiveWrapper(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        return primitiveWrapperTypeMap.containsKey(clazz);
-    }
-
-    /**
-     * Check if the given class represents a primitive (i.e. boolean, byte,
-     * char, short, int, long, float, or double) or a primitive wrapper (i.e.
-     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).
-     *
-     * @param clazz the class to check
-     * @return whether the given class is a primitive or primitive wrapper class
-     */
-    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));
-    }
-
-    /**
-     * Check if the given class represents an array of primitives, i.e. boolean,
-     * byte, char, short, int, long, float, or double.
-     *
-     * @param clazz the class to check
-     * @return whether the given class is a primitive array class
-     */
-    public static boolean isPrimitiveArray(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        return (clazz.isArray() && clazz.getComponentType().isPrimitive());
-    }
-
-    /**
-     * Check if the given class represents an array of primitive wrappers, i.e.
-     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.
-     *
-     * @param clazz the class to check
-     * @return whether the given class is a primitive wrapper array class
-     */
-    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));
-    }
-
-    /**
-     * Resolve the given class if it is a primitive class, returning the
-     * corresponding primitive wrapper type instead.
-     *
-     * @param clazz the class to check
-     * @return the original class, or a primitive wrapper for the original
-     * primitive type
-     */
-    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);
-    }
-
-    /**
-     * Check if the right-hand side type may be assigned to the left-hand side
-     * type, assuming setting by reflection. Considers primitive wrapper classes
-     * as assignable to the corresponding primitive types.
-     *
-     * @param lhsType the target type
-     * @param rhsType the value type that should be assigned to the target type
-     * @return if the target type is assignable from the value type
-     * @see TypeUtils#isAssignable
-     */
-    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {
-        Assert.notNull(lhsType, "Left-hand side type must not be null");
-        Assert.notNull(rhsType, "Right-hand side type must not be null");
-        if (lhsType.isAssignableFrom(rhsType)) {
-            return true;
-        }
-        if (lhsType.isPrimitive()) {
-            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);
-            if (lhsType == resolvedPrimitive) {
-                return true;
-            }
-        } else {
-            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);
-            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Determine if the given type is assignable from the given value, assuming
-     * setting by reflection. Considers primitive wrapper classes as assignable
-     * to the corresponding primitive types.
-     *
-     * @param type the target type
-     * @param value the value that should be assigned to the type
-     * @return if the type is assignable from the value
-     */
-    public static boolean isAssignableValue(Class<?> type, Object value) {
-        Assert.notNull(type, "Type must not be null");
-        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());
-    }
-
-    /**
-     * Convert a "/"-based resource path to a "."-based fully qualified class
-     * name.
-     *
-     * @param resourcePath the resource path pointing to a class
-     * @return the corresponding fully qualified class name
-     */
-    public static String convertResourcePathToClassName(String resourcePath) {
-        Assert.notNull(resourcePath, "Resource path must not be null");
-        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);
-    }
-
-    /**
-     * Convert a "."-based fully qualified class name to a "/"-based resource
-     * path.
-     *
-     * @param className the fully qualified class name
-     * @return the corresponding resource path, pointing to the class
-     */
-    public static String convertClassNameToResourcePath(String className) {
-        Assert.notNull(className, "Class name must not be null");
-        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);
-    }
-
-    /**
-     * Return a path suitable for use with {@code ClassLoader.getResource} (also
-     * suitable for use with {@code Class.getResource} by prepending a slash
-     * ('/') to the return value). Built by taking the package of the specified
-     * class file, converting all dots ('.') to slashes ('/'), adding a trailing
-     * slash if necessary, and concatenating the specified resource name to
-     * this.
-     * <br/>As such, this function may be used to build a path suitable for
-     * loading a resource file that is in the same package as a class file,
-     * although {@link org.springframework.core.io.ClassPathResource} is usually
-     * even more convenient.
-     *
-     * @param clazz the Class whose package will be used as the base
-     * @param resourceName the resource name to append. A leading slash is
-     * optional.
-     * @return the built-up resource path
-     * @see ClassLoader#getResource
-     * @see Class#getResource
-     */
-    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {
-        Assert.notNull(resourceName, "Resource name must not be null");
-        if (!resourceName.startsWith("/")) {
-            return classPackageAsResourcePath(clazz) + "/" + resourceName;
-        }
-        return classPackageAsResourcePath(clazz) + resourceName;
-    }
-
-    /**
-     * Given an input class object, return a string which consists of the
-     * class's package name as a pathname, i.e., all dots ('.') are replaced by
-     * slashes ('/'). Neither a leading nor trailing slash is added. The result
-     * could be concatenated with a slash and the name of a resource and fed
-     * directly to {@code ClassLoader.getResource()}. For it to be fed to
-     * {@code Class.getResource} instead, a leading slash would also have to be
-     * prepended to the returned value.
-     *
-     * @param clazz the input class. A {@code null} value or the default (empty)
-     * package will result in an empty string ("") being returned.
-     * @return a path which represents the package name
-     * @see ClassLoader#getResource
-     * @see Class#getResource
-     */
-    public static String classPackageAsResourcePath(Class<?> clazz) {
-        if (clazz == null) {
-            return "";
-        }
-        String className = clazz.getName();
-        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);
-        if (packageEndIndex == -1) {
-            return "";
-        }
-        String packageName = className.substring(0, packageEndIndex);
-        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);
-    }
-
-    /**
-     * Build a String that consists of the names of the classes/interfaces in
-     * the given array.
-     * <p>
-     * Basically like {@code AbstractCollection.toString()}, but stripping the
-     * "class "/"interface " prefix before every class name.
-     *
-     * @param classes a Collection of Class objects (may be {@code null})
-     * @return a String of form "[com.foo.Bar, com.foo.Baz]"
-     * @see java.util.AbstractCollection#toString()
-     */
-    public static String classNamesToString(Class<?>... classes) {
-        return classNamesToString(Arrays.asList(classes));
-    }
-
-    /**
-     * Build a String that consists of the names of the classes/interfaces in
-     * the given collection.
-     * <p>
-     * Basically like {@code AbstractCollection.toString()}, but stripping the
-     * "class "/"interface " prefix before every class name.
-     *
-     * @param classes a Collection of Class objects (may be {@code null})
-     * @return a String of form "[com.foo.Bar, com.foo.Baz]"
-     * @see java.util.AbstractCollection#toString()
-     */
-    public static String classNamesToString(Collection<Class<?>> classes) {
-        if (CollectionUtils.isEmpty(classes)) {
-            return "[]";
-        }
-        StringBuilder sb = new StringBuilder("[");
-        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {
-            Class<?> clazz = it.next();
-            sb.append(clazz.getName());
-            if (it.hasNext()) {
-                sb.append(", ");
-            }
-        }
-        sb.append("]");
-        return sb.toString();
-    }
-
-    /**
-     * Copy the given Collection into a Class array. The Collection must contain
-     * Class elements only.
-     *
-     * @param collection the Collection to copy
-     * @return the Class array ({@code null} if the passed-in Collection was
-     * {@code null})
-     */
-    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {
-        if (collection == null) {
-            return null;
-        }
-        return collection.toArray(new Class<?>[collection.size()]);
-    }
-
-    /**
-     * Return all interfaces that the given instance implements as array,
-     * including ones implemented by superclasses.
-     *
-     * @param instance the instance to analyze for interfaces
-     * @return all interfaces that the given instance implements as array
-     */
-    public static Class<?>[] getAllInterfaces(Object instance) {
-        Assert.notNull(instance, "Instance must not be null");
-        return getAllInterfacesForClass(instance.getClass());
-    }
-
-    /**
-     * Return all interfaces that the given class implements as array, including
-     * ones implemented by superclasses.
-     * <p>
-     * If the class itself is an interface, it gets returned as sole interface.
-     *
-     * @param clazz the class to analyze for interfaces
-     * @return all interfaces that the given object implements as array
-     */
-    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {
-        return getAllInterfacesForClass(clazz, null);
-    }
-
-    /**
-     * Return all interfaces that the given class implements as array, including
-     * ones implemented by superclasses.
-     * <p>
-     * If the class itself is an interface, it gets returned as sole interface.
-     *
-     * @param clazz the class to analyze for interfaces
-     * @param classLoader the ClassLoader that the interfaces need to be visible
-     * in (may be {@code null} when accepting all declared interfaces)
-     * @return all interfaces that the given object implements as array
-     */
-    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {
-        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);
-        return ifcs.toArray(new Class<?>[ifcs.size()]);
-    }
-
-    /**
-     * Return all interfaces that the given instance implements as Set,
-     * including ones implemented by superclasses.
-     *
-     * @param instance the instance to analyze for interfaces
-     * @return all interfaces that the given instance implements as Set
-     */
-    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {
-        Assert.notNull(instance, "Instance must not be null");
-        return getAllInterfacesForClassAsSet(instance.getClass());
-    }
-
-    /**
-     * Return all interfaces that the given class implements as Set, including
-     * ones implemented by superclasses.
-     * <p>
-     * If the class itself is an interface, it gets returned as sole interface.
-     *
-     * @param clazz the class to analyze for interfaces
-     * @return all interfaces that the given object implements as Set
-     */
-    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {
-        return getAllInterfacesForClassAsSet(clazz, null);
-    }
-
-    /**
-     * Return all interfaces that the given class implements as Set, including
-     * ones implemented by superclasses.
-     * <p>
-     * If the class itself is an interface, it gets returned as sole interface.
-     *
-     * @param clazz the class to analyze for interfaces
-     * @param classLoader the ClassLoader that the interfaces need to be visible
-     * in (may be {@code null} when accepting all declared interfaces)
-     * @return all interfaces that the given object implements as Set
-     */
-    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {
-        Assert.notNull(clazz, "Class must not be null");
-        if (clazz.isInterface() && isVisible(clazz, classLoader)) {
-            return Collections.<Class<?>>singleton(clazz);
-        }
-        Set<Class<?>> interfaces = new LinkedHashSet<>();
-        while (clazz != null) {
-            Class<?>[] ifcs = clazz.getInterfaces();
-            for (Class<?> ifc : ifcs) {
-                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));
-            }
-            clazz = clazz.getSuperclass();
-        }
-        return interfaces;
-    }
-
-    /**
-     * Create a composite interface Class for the given interfaces, implementing
-     * the given interfaces in one single Class.
-     * <p>
-     * This implementation builds a JDK proxy class for the given interfaces.
-     *
-     * @param interfaces the interfaces to merge
-     * @param classLoader the ClassLoader to create the composite Class in
-     * @return the merged interface as Class
-     * @see java.lang.reflect.Proxy#getProxyClass
-     */
-    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {
-        Assert.notEmpty(interfaces, "Interfaces must not be empty");
-        Assert.notNull(classLoader, "ClassLoader must not be null");
-        return Proxy.getProxyClass(classLoader, interfaces);
-    }
-
-    /**
-     * Determine the common ancestor of the given classes, if any.
-     *
-     * @param clazz1 the class to introspect
-     * @param clazz2 the other class to introspect
-     * @return the common ancestor (i.e. common superclass, one interface
-     * extending the other), or {@code null} if none found. If any of the given
-     * classes is {@code null}, the other class will be returned.
-     * @since 3.2.6
-     */
-    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {
-        if (clazz1 == null) {
-            return clazz2;
-        }
-        if (clazz2 == null) {
-            return clazz1;
-        }
-        if (clazz1.isAssignableFrom(clazz2)) {
-            return clazz1;
-        }
-        if (clazz2.isAssignableFrom(clazz1)) {
-            return clazz2;
-        }
-        Class<?> ancestor = clazz1;
-        do {
-            ancestor = ancestor.getSuperclass();
-            if (ancestor == null || Object.class == ancestor) {
-                return null;
-            }
-        } while (!ancestor.isAssignableFrom(clazz2));
-        return ancestor;
-    }
-
-    /**
-     * Check whether the given class is visible in the given ClassLoader.
-     *
-     * @param clazz the class to check (typically an interface)
-     * @param classLoader the ClassLoader to check against (may be {@code null},
-     * in which case this method will always return {@code true})
-     */
-    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {
-        if (classLoader == null) {
-            return true;
-        }
-        try {
-            Class<?> actualClass = classLoader.loadClass(clazz.getName());
-            return (clazz == actualClass);
-            // Else: different interface class found...
-        } catch (ClassNotFoundException ex) {
-            // No interface class found...
-            return false;
-        }
-    }
-
-    /**
-     * Check whether the given object is a CGLIB proxy.
-     *
-     * @param object the object to check
-     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)
-     */
-    public static boolean isCglibProxy(Object object) {
-        return isCglibProxyClass(object.getClass());
-    }
-
-    /**
-     * Check whether the specified class is a CGLIB-generated class.
-     *
-     * @param clazz the class to check
-     */
-    public static boolean isCglibProxyClass(Class<?> clazz) {
-        return (clazz != null && isCglibProxyClassName(clazz.getName()));
-    }
-
-    /**
-     * Check whether the specified class name is a CGLIB-generated class.
-     *
-     * @param className the class name to check
-     */
-    public static boolean isCglibProxyClassName(String className) {
-        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));
-    }
-}
diff --git a/src/util/CollectionUtils.java b/src/util/CollectionUtils.java
deleted file mode 100644
index abf041e..0000000
--- a/src/util/CollectionUtils.java
+++ /dev/null
@@ -1,367 +0,0 @@
-/*
- * To change this license header, choose License Headers in Project Properties.
- * To change this template file, choose Tools | Templates
- * and open the template in the editor.
- */
-package com.marvin.component.util;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Enumeration;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-
-/**
- *
- * @author cdi305
- */
-public abstract class CollectionUtils {
-
-    /**
-     * Return {@code true} if the supplied Collection is {@code null} or empty.
-     * Otherwise, return {@code false}.
-     *
-     * @param collection the Collection to check
-     * @return whether the given Collection is empty
-     */
-    public static boolean isEmpty(Collection<?> collection) {
-        return (collection == null || collection.isEmpty());
-    }
-
-    /**
-     * Return {@code true} if the supplied Map is {@code null} or empty.
-     * Otherwise, return {@code false}.
-     *
-     * @param map the Map to check
-     * @return whether the given Map is empty
-     */
-    public static boolean isEmpty(Map<?, ?> map) {
-        return (map == null || map.isEmpty());
-    }
-
-    /**
-     * Convert the supplied array into a List. A primitive array gets converted
-     * into a List of the appropriate wrapper type.
-     * <p>
-     * <b>NOTE:</b> Generally prefer the standard {@link Arrays#asList} method.
-     * This {@code arrayToList} method is just meant to deal with an incoming
-     * Object value that might be an {@code Object[]} or a primitive array at
-     * runtime.
-     * <p>
-     * A {@code null} source value will be converted to an empty List.
-     *
-     * @param source the (potentially primitive) array
-     * @return the converted List result
-     * @see ObjectUtils#toObjectArray(Object)
-     * @see Arrays#asList(Object[])
-     */
-    @SuppressWarnings("rawtypes")
-    public static List arrayToList(Object source) {
-        return Arrays.asList(ObjectUtils.toObjectArray(source));
-    }
-
-    /**
-     * Merge the given array into the given Collection.
-     *
-     * @param <E>
-     * @param array the array to merge (may be {@code null})
-     * @param collection the target Collection to merge the array into
-     */
-    @SuppressWarnings("unchecked")
-    public static <E> void mergeArrayIntoCollection(Object array, Collection<E> collection) {
-        if (collection == null) {
-            throw new IllegalArgumentException("Collection must not be null");
-        }
-        Object[] arr = ObjectUtils.toObjectArray(array);
-        for (Object elem : arr) {
-            collection.add((E) elem);
-        }
-    }
-
-    /**
-     * Merge the given Properties instance into the given Map, copying all
-     * properties (key-value pairs) over.
-     * <p>
-     * Uses {@code Properties.propertyNames()} to even catch default properties
-     * linked into the original Properties instance.
-     *
-     * @param <K>
-     * @param <V>
-     * @param props the Properties instance to merge (may be {@code null})
-     * @param map the target Map to merge the properties into
-     */
-    @SuppressWarnings("unchecked")
-    public static <K, V> void mergePropertiesIntoMap(Properties props, Map<K, V> map) {
-        if (map == null) {
-            throw new IllegalArgumentException("Map must not be null");
-        }
-        if (props != null) {
-            for (Enumeration<?> en = props.propertyNames(); en.hasMoreElements();) {
-                String key = (String) en.nextElement();
-                Object value = props.getProperty(key);
-                if (value == null) {
-                    // Potentially a non-String value...
-                    value = props.get(key);
-                }
-                map.put((K) key, (V) value);
-            }
-        }
-    }
-
-    /**
-     * Check whether the given Iterator contains the given element.
-     *
-     * @param iterator the Iterator to check
-     * @param element the element to look for
-     * @return {@code true} if found, {@code false} else
-     */
-    public static boolean contains(Iterator<?> iterator, Object element) {
-        if (iterator != null) {
-            while (iterator.hasNext()) {
-                Object candidate = iterator.next();
-                if (ObjectUtils.nullSafeEquals(candidate, element)) {
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Check whether the given Enumeration contains the given element.
-     *
-     * @param enumeration the Enumeration to check
-     * @param element the element to look for
-     * @return {@code true} if found, {@code false} else
-     */
-    public static boolean contains(Enumeration<?> enumeration, Object element) {
-        if (enumeration != null) {
-            while (enumeration.hasMoreElements()) {
-                Object candidate = enumeration.nextElement();
-                if (ObjectUtils.nullSafeEquals(candidate, element)) {
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Check whether the given Collection contains the given element instance.
-     * <p>
-     * Enforces the given instance to be present, rather than returning
-     * {@code true} for an equal element as well.
-     *
-     * @param collection the Collection to check
-     * @param element the element to look for
-     * @return {@code true} if found, {@code false} else
-     */
-    public static boolean containsInstance(Collection<?> collection, Object element) {
-        if (collection != null) {
-            if (collection.stream().anyMatch((candidate) -> (candidate == element))) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Return {@code true} if any element in '{@code candidates}' is contained
-     * in '{@code source}'; otherwise returns {@code false}.
-     *
-     * @param source the source Collection
-     * @param candidates the candidates to search for
-     * @return whether any of the candidates has been found
-     */
-    public static boolean containsAny(Collection<?> source, Collection<?> candidates) {
-        if (isEmpty(source) || isEmpty(candidates)) {
-            return false;
-        }
-        return candidates.stream().anyMatch((candidate) -> (source.contains(candidate)));
-    }
-
-    /**
-     * Return the first element in '{@code candidates}' that is contained in
-     * '{@code source}'. If no element in '{@code candidates}' is present in
-     * '{@code source}' returns {@code null}. Iteration order is
-     * {@link Collection} implementation specific.
-     *
-     * @param <E>
-     * @param source the source Collection
-     * @param candidates the candidates to search for
-     * @return the first present object, or {@code null} if not found
-     */
-    @SuppressWarnings("unchecked")
-    public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) {
-        if (isEmpty(source) || isEmpty(candidates)) {
-            return null;
-        }
-        for (Object candidate : candidates) {
-            if (source.contains(candidate)) {
-                return (E) candidate;
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Find a single value of the given type in the given Collection.
-     *
-     * @param <T>
-     * @param collection the Collection to search
-     * @param type the type to look for
-     * @return a value of the given type found if there is a clear match, or
-     * {@code null} if none or more than one such value found
-     */
-    @SuppressWarnings("unchecked")
-    public static <T> T findValueOfType(Collection<?> collection, Class<T> type) {
-        if (isEmpty(collection)) {
-            return null;
-        }
-        T value = null;
-        for (Object element : collection) {
-            if (type == null || type.isInstance(element)) {
-                if (value != null) {
-                    // More than one value found... no clear single value.
-                    return null;
-                }
-                value = (T) element;
-            }
-        }
-        return value;
-    }
-
-    /**
-     * Find a single value of one of the given types in the given Collection:
-     * searching the Collection for a value of the first type, then searching
-     * for a value of the second type, etc.
-     *
-     * @param collection the collection to search
-     * @param types the types to look for, in prioritized order
-     * @return a value of one of the given types found if there is a clear
-     * match, or {@code null} if none or more than one such value found
-     */
-    public static Object findValueOfType(Collection<?> collection, Class<?>[] types) {
-        if (isEmpty(collection) || ObjectUtils.isEmpty(types)) {
-            return null;
-        }
-        for (Class<?> type : types) {
-            Object value = findValueOfType(collection, type);
-            if (value != null) {
-                return value;
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Determine whether the given Collection only contains a single unique
-     * object.
-     *
-     * @param collection the Collection to check
-     * @return {@code true} if the collection contains a single reference or
-     * multiple references to the same instance, {@code false} else
-     */
-    public static boolean hasUniqueObject(Collection<?> collection) {
-        if (isEmpty(collection)) {
-            return false;
-        }
-        boolean hasCandidate = false;
-        Object candidate = null;
-        for (Object elem : collection) {
-            if (!hasCandidate) {
-                hasCandidate = true;
-                candidate = elem;
-            } else if (candidate != elem) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Find the common element type of the given Collection, if any.
-     *
-     * @param collection the Collection to check
-     * @return the common element type, or {@code null} if no clear common type
-     * has been found (or the collection was empty)
-     */
-    public static Class<?> findCommonElementType(Collection<?> collection) {
-        if (isEmpty(collection)) {
-            return null;
-        }
-        Class<?> candidate = null;
-        for (Object val : collection) {
-            if (val != null) {
-                if (candidate == null) {
-                    candidate = val.getClass();
-                } else if (candidate != val.getClass()) {
-                    return null;
-                }
-            }
-        }
-        return candidate;
-    }
-
-    /**
-     * Marshal the elements from the given enumeration into an array of the
-     * given type. Enumeration elements must be assignable to the type of the
-     * given array. The array returned will be a different instance than the
-     * array given.
-     * @param <A>
-     * @param <E>
-     * @param enumeration
-     * @param array
-     * @return 
-     */
-    public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {
-        ArrayList<A> elements = new ArrayList<>();
-        while (enumeration.hasMoreElements()) {
-            elements.add(enumeration.nextElement());
-        }
-        return elements.toArray(array);
-    }
-
-    /**
-     * Adapt an enumeration to an iterator.
-     *
-     * @param <E>
-     * @param enumeration the enumeration
-     * @return the iterator
-     */
-    public static <E> Iterator<E> toIterator(Enumeration<E> enumeration) {
-        return new EnumerationIterator<>(enumeration);
-    }
-
-
-    /**
-     * Iterator wrapping an Enumeration.
-     */
-    private static class EnumerationIterator<E> implements Iterator<E> {
-
-        private final Enumeration<E> enumeration;
-
-        public EnumerationIterator(Enumeration<E> enumeration) {
-            this.enumeration = enumeration;
-        }
-
-        @Override
-        public boolean hasNext() {
-            return this.enumeration.hasMoreElements();
-        }
-
-        @Override
-        public E next() {
-            return this.enumeration.nextElement();
-        }
-
-        @Override
-        public void remove() throws UnsupportedOperationException {
-            throw new UnsupportedOperationException("Not supported");
-        }
-    }
-
-}
diff --git a/src/util/ObjectUtils.java b/src/util/ObjectUtils.java
deleted file mode 100644
index bf4a938..0000000
--- a/src/util/ObjectUtils.java
+++ /dev/null
@@ -1,1013 +0,0 @@
-package com.marvin.component.util;
-
-import java.lang.reflect.Array;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Map;
-import java.util.Optional;
-
-public abstract class ObjectUtils {
-
-    private static final int INITIAL_HASH = 7;
-    private static final int MULTIPLIER = 31;
-
-    private static final String EMPTY_STRING = "";
-    private static final String NULL_STRING = "null";
-    private static final String ARRAY_START = "{";
-    private static final String ARRAY_END = "}";
-    private static final String EMPTY_ARRAY = ARRAY_START + ARRAY_END;
-    private static final String ARRAY_ELEMENT_SEPARATOR = ", ";
-
-    /**
-     * Return whether the given throwable is a checked exception: that is,
-     * neither a RuntimeException nor an Error.
-     *
-     * @param ex the throwable to check
-     * @return whether the throwable is a checked exception
-     * @see java.lang.Exception
-     * @see java.lang.RuntimeException
-     * @see java.lang.Error
-     */
-    public static boolean isCheckedException(Throwable ex) {
-        return !(ex instanceof RuntimeException || ex instanceof Error);
-    }
-
-    /**
-     * Check whether the given exception is compatible with the specified
-     * exception types, as declared in a throws clause.
-     *
-     * @param ex the exception to check
-     * @param declaredExceptions the exception types declared in the throws
-     * clause
-     * @return whether the given exception is compatible
-     */
-    public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions) {
-        if (!isCheckedException(ex)) {
-            return true;
-        }
-        if (declaredExceptions != null) {
-            for (Class<?> declaredException : declaredExceptions) {
-                if (declaredException.isInstance(ex)) {
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Determine whether the given object is an array: either an Object array or
-     * a primitive array.
-     *
-     * @param obj the object to check
-     * @return 
-     */
-    public static boolean isArray(Object obj) {
-        return (obj != null && obj.getClass().isArray());
-    }
-
-    /**
-     * Determine whether the given array is empty: i.e. {@code null} or of zero
-     * length.
-     *
-     * @param array the array to check
-     * @return 
-     * @see #isEmpty(Object)
-     */
-    public static boolean isEmpty(Object[] array) {
-        return (array == null || array.length == 0);
-    }
-
-    /**
-     * Determine whether the given object is empty.
-     * <p>
-     * This method supports the following object types.
-     * <ul>
-     * <li>{@code Optional}: considered empty if {@link Optional#empty()}</li>
-     * <li>{@code Array}: considered empty if its length is zero</li>
-     * <li>{@link CharSequence}: considered empty if its length is zero</li>
-     * <li>{@link Collection}: delegates to {@link Collection#isEmpty()}</li>
-     * <li>{@link Map}: delegates to {@link Map#isEmpty()}</li>
-     * </ul>
-     * <p>
-     * If the given object is non-null and not one of the aforementioned
-     * supported types, this method returns {@code false}.
-     *
-     * @param obj the object to check
-     * @return {@code true} if the object is {@code null} or <em>empty</em>
-     * @since 4.2
-     * @see Optional#isPresent()
-     * @see ObjectUtils#isEmpty(Object[])
-     * @see StringUtils#hasLength(CharSequence)
-     * @see StringUtils#isEmpty(Object)
-     * @see CollectionUtils#isEmpty(java.util.Collection)
-     * @see CollectionUtils#isEmpty(java.util.Map)
-     */
-    @SuppressWarnings("rawtypes")
-    public static boolean isEmpty(Object obj) {
-        if (obj == null) {
-            return true;
-        }
-
-        if (obj instanceof Optional) {
-            return !((Optional) obj).isPresent();
-        }
-        if (obj.getClass().isArray()) {
-            return Array.getLength(obj) == 0;
-        }
-        if (obj instanceof CharSequence) {
-            return ((CharSequence) obj).length() == 0;
-        }
-        if (obj instanceof Collection) {
-            return ((Collection) obj).isEmpty();
-        }
-        if (obj instanceof Map) {
-            return ((Map) obj).isEmpty();
-        }
-
-        // else
-        return false;
-    }
-
-    /**
-     * Unwrap the given object which is potentially a
-     * {@link java.util.Optional}.
-     *
-     * @param obj the candidate object
-     * @return either the value held within the {@code Optional}, {@code null}
-     * if the {@code Optional} is empty, or simply the given object as-is
-     * @since 5.0
-     */
-    public static Object unwrapOptional(Object obj) {
-        if (obj instanceof Optional) {
-            Optional<?> optional = (Optional<?>) obj;
-            if (!optional.isPresent()) {
-                return null;
-            }
-            Object result = optional.get();
-            Assert.isTrue(!(result instanceof Optional), "Multi-level Optional usage not supported");
-            return result;
-        }
-        return obj;
-    }
-
-    /**
-     * Check whether the given array contains the given element.
-     *
-     * @param array the array to check (may be {@code null}, in which case the
-     * return value will always be {@code false})
-     * @param element the element to check for
-     * @return whether the element has been found in the given array
-     */
-    public static boolean containsElement(Object[] array, Object element) {
-        if (array == null) {
-            return false;
-        }
-        for (Object arrayEle : array) {
-            if (nullSafeEquals(arrayEle, element)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Check whether the given array of enum constants contains a constant with
-     * the given name, ignoring case when determining a match.
-     *
-     * @param enumValues the enum values to check, typically the product of a
-     * call to MyEnum.values()
-     * @param constant the constant name to find (must not be null or empty
-     * string)
-     * @return whether the constant has been found in the given array
-     */
-    public static boolean containsConstant(Enum<?>[] enumValues, String constant) {
-        return containsConstant(enumValues, constant, false);
-    }
-
-    /**
-     * Check whether the given array of enum constants contains a constant with
-     * the given name.
-     *
-     * @param enumValues the enum values to check, typically the product of a
-     * call to MyEnum.values()
-     * @param constant the constant name to find (must not be null or empty
-     * string)
-     * @param caseSensitive whether case is significant in determining a match
-     * @return whether the constant has been found in the given array
-     */
-    public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {
-        for (Enum<?> candidate : enumValues) {
-            if (caseSensitive
-                    ? candidate.toString().equals(constant)
-                    : candidate.toString().equalsIgnoreCase(constant)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Case insensitive alternative to {@link Enum#valueOf(Class, String)}.
-     *
-     * @param <E> the concrete Enum type
-     * @param enumValues the array of all Enum constants in question, usually
-     * per Enum.values()
-     * @param constant the constant to get the enum value of
-     * @return 
-     * @throws IllegalArgumentException if the given constant is not found in
-     * the given array of enum values. Use
-     * {@link #containsConstant(Enum[], String)} as a guard to avoid this
-     * exception.
-     */
-    public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant) {
-        for (E candidate : enumValues) {
-            if (candidate.toString().equalsIgnoreCase(constant)) {
-                return candidate;
-            }
-        }
-        throw new IllegalArgumentException(
-                String.format("constant [%s] does not exist in enum type %s",
-                        constant, enumValues.getClass().getComponentType().getName()));
-    }
-
-    /**
-     * Append the given object to the given array, returning a new array
-     * consisting of the input array contents plus the given object.
-     *
-     * @param <A>
-     * @param <O>
-     * @param array the array to append to (can be {@code null})
-     * @param obj the object to append
-     * @return the new array (of the same component type; never {@code null})
-     */
-    public static <A, O extends A> A[] addObjectToArray(A[] array, O obj) {
-        Class<?> compType = Object.class;
-        if (null != array) {
-            compType = array.getClass().getComponentType();
-        } else if (obj != null) {
-            compType = obj.getClass();
-        }
-        int newArrLength = (array != null ? array.length + 1 : 1);
-        @SuppressWarnings("unchecked")
-        A[] newArr = (A[]) Array.newInstance(compType, newArrLength);
-        if (array != null) {
-            System.arraycopy(array, 0, newArr, 0, array.length);
-        }
-        newArr[newArr.length - 1] = obj;
-        return newArr;
-    }
-
-    /**
-     * Convert the given array (which may be a primitive array) to an object
-     * array (if necessary of primitive wrapper objects).
-     * <p>
-     * A {@code null} source value will be converted to an empty Object array.
-     *
-     * @param source the (potentially primitive) array
-     * @return the corresponding object array (never {@code null})
-     * @throws IllegalArgumentException if the parameter is not an array
-     */
-    public static Object[] toObjectArray(Object source) {
-        if (source instanceof Object[]) {
-            return (Object[]) source;
-        }
-        if (source == null) {
-            return new Object[0];
-        }
-        if (!source.getClass().isArray()) {
-            throw new IllegalArgumentException("Source is not an array: " + source);
-        }
-        int length = Array.getLength(source);
-        if (length == 0) {
-            return new Object[0];
-        }
-        Class<?> wrapperType = Array.get(source, 0).getClass();
-        Object[] newArray = (Object[]) Array.newInstance(wrapperType, length);
-        for (int i = 0; i < length; i++) {
-            newArray[i] = Array.get(source, i);
-        }
-        return newArray;
-    }
-
-	//---------------------------------------------------------------------
-    // Convenience methods for content-based equality/hash-code handling
-    //---------------------------------------------------------------------
-    /**
-     * Determine if the given objects are equal, returning {@code true} if both
-     * are {@code null} or {@code false} if only one is {@code null}.
-     * <p>
-     * Compares arrays with {@code Arrays.equals}, performing an equality check
-     * based on the array elements rather than the array reference.
-     *
-     * @param o1 first Object to compare
-     * @param o2 second Object to compare
-     * @return whether the given objects are equal
-     * @see Object#equals(Object)
-     * @see java.util.Arrays#equals
-     */
-    public static boolean nullSafeEquals(Object o1, Object o2) {
-        if (o1 == o2) {
-            return true;
-        }
-        if (o1 == null || o2 == null) {
-            return false;
-        }
-        if (o1.equals(o2)) {
-            return true;
-        }
-        if (o1.getClass().isArray() && o2.getClass().isArray()) {
-            return arrayEquals(o1, o2);
-        }
-        return false;
-    }
-
-    /**
-     * Compare the given arrays with {@code Arrays.equals}, performing an
-     * equality check based on the array elements rather than the array
-     * reference.
-     *
-     * @param o1 first array to compare
-     * @param o2 second array to compare
-     * @return whether the given objects are equal
-     * @see #nullSafeEquals(Object, Object)
-     * @see java.util.Arrays#equals
-     */
-    private static boolean arrayEquals(Object o1, Object o2) {
-        if (o1 instanceof Object[] && o2 instanceof Object[]) {
-            return Arrays.equals((Object[]) o1, (Object[]) o2);
-        }
-        if (o1 instanceof boolean[] && o2 instanceof boolean[]) {
-            return Arrays.equals((boolean[]) o1, (boolean[]) o2);
-        }
-        if (o1 instanceof byte[] && o2 instanceof byte[]) {
-            return Arrays.equals((byte[]) o1, (byte[]) o2);
-        }
-        if (o1 instanceof char[] && o2 instanceof char[]) {
-            return Arrays.equals((char[]) o1, (char[]) o2);
-        }
-        if (o1 instanceof double[] && o2 instanceof double[]) {
-            return Arrays.equals((double[]) o1, (double[]) o2);
-        }
-        if (o1 instanceof float[] && o2 instanceof float[]) {
-            return Arrays.equals((float[]) o1, (float[]) o2);
-        }
-        if (o1 instanceof int[] && o2 instanceof int[]) {
-            return Arrays.equals((int[]) o1, (int[]) o2);
-        }
-        if (o1 instanceof long[] && o2 instanceof long[]) {
-            return Arrays.equals((long[]) o1, (long[]) o2);
-        }
-        if (o1 instanceof short[] && o2 instanceof short[]) {
-            return Arrays.equals((short[]) o1, (short[]) o2);
-        }
-        return false;
-    }
-
-    /**
-     * Return as hash code for the given object; typically the value of
-     * {@code Object#hashCode()}}. If the object is an array, this method will
-     * delegate to any of the {@code nullSafeHashCode} methods for arrays in
-     * this class. If the object is {@code null}, this method returns 0.
-     *
-     * @param obj
-     * @return 
-     * @see Object#hashCode()
-     * @see #nullSafeHashCode(Object[])
-     * @see #nullSafeHashCode(boolean[])
-     * @see #nullSafeHashCode(byte[])
-     * @see #nullSafeHashCode(char[])
-     * @see #nullSafeHashCode(double[])
-     * @see #nullSafeHashCode(float[])
-     * @see #nullSafeHashCode(int[])
-     * @see #nullSafeHashCode(long[])
-     * @see #nullSafeHashCode(short[])
-     */
-    public static int nullSafeHashCode(Object obj) {
-        if (obj == null) {
-            return 0;
-        }
-        if (obj.getClass().isArray()) {
-            if (obj instanceof Object[]) {
-                return nullSafeHashCode((Object[]) obj);
-            }
-            if (obj instanceof boolean[]) {
-                return nullSafeHashCode((boolean[]) obj);
-            }
-            if (obj instanceof byte[]) {
-                return nullSafeHashCode((byte[]) obj);
-            }
-            if (obj instanceof char[]) {
-                return nullSafeHashCode((char[]) obj);
-            }
-            if (obj instanceof double[]) {
-                return nullSafeHashCode((double[]) obj);
-            }
-            if (obj instanceof float[]) {
-                return nullSafeHashCode((float[]) obj);
-            }
-            if (obj instanceof int[]) {
-                return nullSafeHashCode((int[]) obj);
-            }
-            if (obj instanceof long[]) {
-                return nullSafeHashCode((long[]) obj);
-            }
-            if (obj instanceof short[]) {
-                return nullSafeHashCode((short[]) obj);
-            }
-        }
-        return obj.hashCode();
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(Object[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (Object element : array) {
-            hash = MULTIPLIER * hash + nullSafeHashCode(element);
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(boolean[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (boolean element : array) {
-            hash = MULTIPLIER * hash + hashCode(element);
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(byte[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (byte element : array) {
-            hash = MULTIPLIER * hash + element;
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(char[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (char element : array) {
-            hash = MULTIPLIER * hash + element;
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(double[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (double element : array) {
-            hash = MULTIPLIER * hash + hashCode(element);
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(float[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (float element : array) {
-            hash = MULTIPLIER * hash + hashCode(element);
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(int[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (int element : array) {
-            hash = MULTIPLIER * hash + element;
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(long[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (long element : array) {
-            hash = MULTIPLIER * hash + hashCode(element);
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(short[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (short element : array) {
-            hash = MULTIPLIER * hash + element;
-        }
-        return hash;
-    }
-
-    /**
-     * Return the same value as {@link Boolean#hashCode()}}.
-     *
-     * @param bool
-     * @return 
-     * @see Boolean#hashCode()
-     */
-    public static int hashCode(boolean bool) {
-        return (bool ? 1231 : 1237);
-    }
-
-    /**
-     * Return the same value as {@link Double#hashCode()}}.
-     *
-     * @param dbl
-     * @return 
-     * @see Double#hashCode()
-     */
-    public static int hashCode(double dbl) {
-        return hashCode(Double.doubleToLongBits(dbl));
-    }
-
-    /**
-     * Return the same value as {@link Float#hashCode()}}.
-     *
-     * @param flt
-     * @return 
-     * @see Float#hashCode()
-     */
-    public static int hashCode(float flt) {
-        return Float.floatToIntBits(flt);
-    }
-
-    /**
-     * Return the same value as {@link Long#hashCode()}}.
-     *
-     * @param lng
-     * @return 
-     * @see Long#hashCode()
-     */
-    public static int hashCode(long lng) {
-        return (int) (lng ^ (lng >>> 32));
-    }
-
-	//---------------------------------------------------------------------
-    // Convenience methods for toString output
-    //---------------------------------------------------------------------
-    /**
-     * Return a String representation of an object's overall identity.
-     *
-     * @param obj the object (may be {@code null})
-     * @return the object's identity as String representation, or an empty
-     * String if the object was {@code null}
-     */
-    public static String identityToString(Object obj) {
-        if (obj == null) {
-            return EMPTY_STRING;
-        }
-        return obj.getClass().getName() + "@" + getIdentityHexString(obj);
-    }
-
-    /**
-     * Return a hex String form of an object's identity hash code.
-     *
-     * @param obj the object
-     * @return the object's identity code in hex notation
-     */
-    public static String getIdentityHexString(Object obj) {
-        return Integer.toHexString(System.identityHashCode(obj));
-    }
-
-    /**
-     * Return a content-based String representation if {@code obj} is not
-     * {@code null}; otherwise returns an empty String.
-     * <p>
-     * Differs from {@link #nullSafeToString(Object)} in that it returns an
-     * empty String rather than "null" for a {@code null} value.
-     *
-     * @param obj the object to build a display String for
-     * @return a display String representation of {@code obj}
-     * @see #nullSafeToString(Object)
-     */
-    public static String getDisplayString(Object obj) {
-        if (obj == null) {
-            return EMPTY_STRING;
-        }
-        return nullSafeToString(obj);
-    }
-
-    /**
-     * Determine the class name for the given object.
-     * <p>
-     * Returns {@code "null"} if {@code obj} is {@code null}.
-     *
-     * @param obj the object to introspect (may be {@code null})
-     * @return the corresponding class name
-     */
-    public static String nullSafeClassName(Object obj) {
-        return (obj != null ? obj.getClass().getName() : NULL_STRING);
-    }
-
-    /**
-     * Return a String representation of the specified Object.
-     * <p>
-     * Builds a String representation of the contents in case of an array.
-     * Returns {@code "null"} if {@code obj} is {@code null}.
-     *
-     * @param obj the object to build a String representation for
-     * @return a String representation of {@code obj}
-     */
-    public static String nullSafeToString(Object obj) {
-        if (obj == null) {
-            return NULL_STRING;
-        }
-        if (obj instanceof String) {
-            return (String) obj;
-        }
-        if (obj instanceof Object[]) {
-            return nullSafeToString((Object[]) obj);
-        }
-        if (obj instanceof boolean[]) {
-            return nullSafeToString((boolean[]) obj);
-        }
-        if (obj instanceof byte[]) {
-            return nullSafeToString((byte[]) obj);
-        }
-        if (obj instanceof char[]) {
-            return nullSafeToString((char[]) obj);
-        }
-        if (obj instanceof double[]) {
-            return nullSafeToString((double[]) obj);
-        }
-        if (obj instanceof float[]) {
-            return nullSafeToString((float[]) obj);
-        }
-        if (obj instanceof int[]) {
-            return nullSafeToString((int[]) obj);
-        }
-        if (obj instanceof long[]) {
-            return nullSafeToString((long[]) obj);
-        }
-        if (obj instanceof short[]) {
-            return nullSafeToString((short[]) obj);
-        }
-        String str = obj.toString();
-        return (str != null ? str : EMPTY_STRING);
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(Object[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-            sb.append(String.valueOf(array[i]));
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(boolean[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(byte[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(char[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-            sb.append("'").append(array[i]).append("'");
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(double[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(float[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(int[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(long[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(short[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-}
diff --git a/src/util/PathUtils.java b/src/util/PathUtils.java
deleted file mode 100644
index e1ca530..0000000
--- a/src/util/PathUtils.java
+++ /dev/null
@@ -1,92 +0,0 @@
-package com.marvin.component.util;
-
-import java.util.*;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-public abstract class PathUtils {
-
-    private static final Pattern separatorRegex = Pattern.compile("\\\\|/");
-
-    /**
-     * Resolves the given {@code relativePath} based on the given
-     * {@code anchorPath}.
-     *
-     * @param relativePath      the relative path which should be resolved.
-     * @param anchorPath        the anchor path based on which the relative path should be
-     *                          resolved on.
-     * @param expectedSeparator The character expected to be used as a separator; dictated by the Loader.
-     * @return the resolved path or {@code null} when the path could not be
-     * resolved.
-     */
-    public static String resolveRelativePath(String relativePath, String anchorPath, char expectedSeparator) {
-        if (relativePath == null || relativePath.isEmpty()) {
-            return null;
-        }
-
-        // ensure both paths use the same separator character
-        relativePath = sanitize(relativePath, expectedSeparator);
-        anchorPath = sanitize(anchorPath, expectedSeparator);
-
-        if (relativePath.startsWith(".." + expectedSeparator) || relativePath.startsWith("." + expectedSeparator)) {
-            return resolvePathInner(relativePath, anchorPath, expectedSeparator);
-        }
-
-        return null;
-    }
-
-    private static String sanitize(String path, char expectedSeparator){
-        return separatorRegex.matcher(path).replaceAll(Matcher.quoteReplacement(String.valueOf(expectedSeparator)));
-    }
-
-    private static String resolvePathInner(String relativePath, String anchorPath, char separator) {
-        StringBuilder resultingPath = new StringBuilder();
-
-        resolvePathSegments(determineAnchorPathSegments(anchorPath, separator),
-                splitBySeparator(relativePath, separator)).stream().forEach((segment) -> {
-                    resultingPath.append(segment).append(separator);
-        });
-
-        // remove the erroneous separator added at the end
-        return resultingPath.substring(0, resultingPath.length() - 1);
-    }
-
-    private static Collection<String> determineAnchorPathSegments(String anchorPath, char separator) {
-        if (anchorPath == null || anchorPath.isEmpty()) {
-            return new ArrayList<>();
-        }
-        ArrayDeque<String> anchorPathSegments = new ArrayDeque<>(splitBySeparator(anchorPath, separator));
-        if (anchorPath.charAt(anchorPath.length() - 1) != separator) {
-            anchorPathSegments.pollLast();
-        }
-        return anchorPathSegments;
-    }
-
-    private static Collection<String> resolvePathSegments(Collection<String> anchorSegments,
-            Collection<String> relativeSegments) {
-        ArrayDeque<String> result = new ArrayDeque<>(anchorSegments);
-        relativeSegments.stream().forEach((String segment) -> {
-            switch (segment) {
-                case ".": // do nothing
-                    break;
-                case "..":
-                    result.pollLast();
-                    break;
-                default:
-                    result.add(segment);
-                    break;
-            }
-        });
-
-        return result;
-    }
-
-    private static List<String> splitBySeparator(String path, char separator) {
-        return Arrays.asList(path.split(Pattern.quote(String.valueOf(separator))));
-    }
-
-    private PathUtils() {
-        throw new IllegalAccessError();
-    }
-
-}
diff --git a/src/util/ReflectionUtils.java b/src/util/ReflectionUtils.java
deleted file mode 100644
index eaa0e51..0000000
--- a/src/util/ReflectionUtils.java
+++ /dev/null
@@ -1,877 +0,0 @@
-package com.marvin.component.util;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.UndeclaredThrowableException;
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * Simple utility class for working with the reflection API and handling
- * reflection exceptions.
- *
- * <p>
- * Only intended for internal use.
- *
- */
-public abstract class ReflectionUtils {
-
-    /**
-     * Naming prefix for CGLIB-renamed methods.
-     *
-     * @see #isCglibRenamedMethod
-     */
-    private static final String CGLIB_RENAMED_METHOD_PREFIX = "CGLIB$";
-
-    private static final Method[] NO_METHODS = {};
-
-    private static final Field[] NO_FIELDS = {};
-
-    /**
-     * Cache for {@link Class#getDeclaredMethods()} plus equivalent default
-     * methods from Java 8 based interfaces, allowing for fast iteration.
-     */
-    private static final Map<Class<?>, Method[]> declaredMethodsCache
-            = new ConcurrentHashMap<>(256);
-
-    /**
-     * Cache for {@link Class#getDeclaredFields()}, allowing for fast iteration.
-     */
-    private static final Map<Class<?>, Field[]> declaredFieldsCache
-            = new ConcurrentHashMap<>(256);
-
-    /**
-     * Attempt to find a {@link Field field} on the supplied {@link Class} with
-     * the supplied {@code name}. Searches all superclasses up to
-     * {@link Object}.
-     *
-     * @param clazz the class to introspect
-     * @param name the name of the field
-     * @return the corresponding Field object, or {@code null} if not found
-     */
-    public static Field findField(Class<?> clazz, String name) {
-        return findField(clazz, name, null);
-    }
-
-    /**
-     * Attempt to find a {@link Field field} on the supplied {@link Class} with
-     * the supplied {@code name} and/or {@link Class type}. Searches all
-     * superclasses up to {@link Object}.
-     *
-     * @param clazz the class to introspect
-     * @param name the name of the field (may be {@code null} if type is
-     * specified)
-     * @param type the type of the field (may be {@code null} if name is
-     * specified)
-     * @return the corresponding Field object, or {@code null} if not found
-     */
-    public static Field findField(Class<?> clazz, String name, Class<?> type) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.isTrue(name != null || type != null, "Either name or type of the field must be specified");
-        Class<?> searchType = clazz;
-        while (Object.class != searchType && searchType != null) {
-            Field[] fields = getDeclaredFields(searchType);
-            for (Field field : fields) {
-                if ((name == null || name.equals(field.getName()))
-                        && (type == null || type.equals(field.getType()))) {
-                    return field;
-                }
-            }
-            searchType = searchType.getSuperclass();
-        }
-        return null;
-    }
-
-    /**
-     * Set the field represented by the supplied {@link Field field object} on
-     * the specified {@link Object target object} to the specified
-     * {@code value}. In accordance with {@link Field#set(Object, Object)}
-     * semantics, the new value is automatically unwrapped if the underlying
-     * field has a primitive type.
-     * <p>
-     * Thrown exceptions are handled via a call to
-     * {@link #handleReflectionException(Exception)}.
-     *
-     * @param field the field to set
-     * @param target the target object on which to set the field
-     * @param value the value to set (may be {@code null})
-     */
-    public static void setField(Field field, Object target, Object value) {
-        try {
-            field.set(target, value);
-        } catch (IllegalAccessException ex) {
-            handleReflectionException(ex);
-            throw new IllegalStateException(
-                    "Unexpected reflection exception - " + ex.getClass().getName() + ": " + ex.getMessage());
-        }
-    }
-
-    /**
-     * Get the field represented by the supplied {@link Field field object} on
-     * the specified {@link Object target object}. In accordance with
-     * {@link Field#get(Object)} semantics, the returned value is automatically
-     * wrapped if the underlying field has a primitive type.
-     * <p>
-     * Thrown exceptions are handled via a call to
-     * {@link #handleReflectionException(Exception)}.
-     *
-     * @param field the field to get
-     * @param target the target object from which to get the field
-     * @return the field's current value
-     */
-    public static Object getField(Field field, Object target) {
-        try {
-            return field.get(target);
-        } catch (IllegalAccessException ex) {
-            handleReflectionException(ex);
-            throw new IllegalStateException(
-                    "Unexpected reflection exception - " + ex.getClass().getName() + ": " + ex.getMessage());
-        }
-    }
-
-    /**
-     * Attempt to find a {@link Method} on the supplied class with the supplied
-     * name and no parameters. Searches all superclasses up to {@code Object}.
-     * <p>
-     * Returns {@code null} if no {@link Method} can be found.
-     *
-     * @param clazz the class to introspect
-     * @param name the name of the method
-     * @return the Method object, or {@code null} if none found
-     */
-    public static Method findMethod(Class<?> clazz, String name) {
-        return findMethod(clazz, name, new Class<?>[0]);
-    }
-
-    /**
-     * Attempt to find a {@link Method} on the supplied class with the supplied
-     * name and parameter types. Searches all superclasses up to {@code Object}.
-     * <p>
-     * Returns {@code null} if no {@link Method} can be found.
-     *
-     * @param clazz the class to introspect
-     * @param name the name of the method
-     * @param paramTypes the parameter types of the method (may be {@code null}
-     * to indicate any signature)
-     * @return the Method object, or {@code null} if none found
-     */
-    public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.notNull(name, "Method name must not be null");
-        Class<?> searchType = clazz;
-        while (searchType != null) {
-            Method[] methods = (searchType.isInterface() ? searchType.getMethods() : getDeclaredMethods(searchType));
-            for (Method method : methods) {
-                if (name.equals(method.getName())
-                        && (paramTypes == null || Arrays.equals(paramTypes, method.getParameterTypes()))) {
-                    return method;
-                }
-            }
-            searchType = searchType.getSuperclass();
-        }
-        return null;
-    }
-
-    /**
-     * Invoke the specified {@link Method} against the supplied target object
-     * with no arguments. The target object can be {@code null} when invoking a
-     * static {@link Method}.
-     * <p>
-     * Thrown exceptions are handled via a call to
-     * {@link #handleReflectionException}.
-     *
-     * @param method the method to invoke
-     * @param target the target object to invoke the method on
-     * @return the invocation result, if any
-     * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])
-     */
-    public static Object invokeMethod(Method method, Object target) {
-        return invokeMethod(method, target, new Object[0]);
-    }
-
-    /**
-     * Invoke the specified {@link Method} against the supplied target object
-     * with the supplied arguments. The target object can be {@code null} when
-     * invoking a static {@link Method}.
-     * <p>
-     * Thrown exceptions are handled via a call to
-     * {@link #handleReflectionException}.
-     *
-     * @param method the method to invoke
-     * @param target the target object to invoke the method on
-     * @param args the invocation arguments (may be {@code null})
-     * @return the invocation result, if any
-     */
-    public static Object invokeMethod(Method method, Object target, Object... args) {
-        try {
-            return method.invoke(target, args);
-        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
-            handleReflectionException(ex);
-        }
-        throw new IllegalStateException("Should never get here");
-    }
-
-    /**
-     * Invoke the specified JDBC API {@link Method} against the supplied target
-     * object with no arguments.
-     *
-     * @param method the method to invoke
-     * @param target the target object to invoke the method on
-     * @return the invocation result, if any
-     * @throws SQLException the JDBC API SQLException to rethrow (if any)
-     * @see #invokeJdbcMethod(java.lang.reflect.Method, Object, Object[])
-     */
-    public static Object invokeJdbcMethod(Method method, Object target) throws SQLException {
-        return invokeJdbcMethod(method, target, new Object[0]);
-    }
-
-    /**
-     * Invoke the specified JDBC API {@link Method} against the supplied target
-     * object with the supplied arguments.
-     *
-     * @param method the method to invoke
-     * @param target the target object to invoke the method on
-     * @param args the invocation arguments (may be {@code null})
-     * @return the invocation result, if any
-     * @throws SQLException the JDBC API SQLException to rethrow (if any)
-     * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])
-     */
-    public static Object invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException {
-        try {
-            return method.invoke(target, args);
-        } catch (IllegalAccessException ex) {
-            handleReflectionException(ex);
-        } catch (InvocationTargetException ex) {
-            if (ex.getTargetException() instanceof SQLException) {
-                throw (SQLException) ex.getTargetException();
-            }
-            handleInvocationTargetException(ex);
-        }
-        throw new IllegalStateException("Should never get here");
-    }
-
-    /**
-     * Handle the given reflection exception. Should only be called if no
-     * checked exception is expected to be thrown by the target method.
-     * <p>
-     * Throws the underlying RuntimeException or Error in case of an
-     * InvocationTargetException with such a root cause. Throws an
-     * IllegalStateException with an appropriate message or
-     * UndeclaredThrowableException otherwise.
-     *
-     * @param ex the reflection exception to handle
-     */
-    public static void handleReflectionException(Exception ex) {
-        if (ex instanceof NoSuchMethodException) {
-            throw new IllegalStateException("Method not found: " + ex.getMessage());
-        }
-        if (ex instanceof IllegalAccessException) {
-            throw new IllegalStateException("Could not access method: " + ex.getMessage());
-        }
-        if (ex instanceof InvocationTargetException) {
-            handleInvocationTargetException((InvocationTargetException) ex);
-        }
-        if (ex instanceof RuntimeException) {
-            throw (RuntimeException) ex;
-        }
-        throw new UndeclaredThrowableException(ex);
-    }
-
-    /**
-     * Handle the given invocation target exception. Should only be called if no
-     * checked exception is expected to be thrown by the target method.
-     * <p>
-     * Throws the underlying RuntimeException or Error in case of such a root
-     * cause. Throws an UndeclaredThrowableException otherwise.
-     *
-     * @param ex the invocation target exception to handle
-     */
-    public static void handleInvocationTargetException(InvocationTargetException ex) {
-        rethrowRuntimeException(ex.getTargetException());
-    }
-
-    /**
-     * Rethrow the given {@link Throwable exception}, which is presumably the
-     * <em>target exception</em> of an {@link InvocationTargetException}. Should
-     * only be called if no checked exception is expected to be thrown by the
-     * target method.
-     * <p>
-     * Rethrows the underlying exception cast to a {@link RuntimeException} or
-     * {@link Error} if appropriate; otherwise, throws an
-     * {@link UndeclaredThrowableException}.
-     *
-     * @param ex the exception to rethrow
-     * @throws RuntimeException the rethrown exception
-     */
-    public static void rethrowRuntimeException(Throwable ex) {
-        if (ex instanceof RuntimeException) {
-            throw (RuntimeException) ex;
-        }
-        if (ex instanceof Error) {
-            throw (Error) ex;
-        }
-        throw new UndeclaredThrowableException(ex);
-    }
-
-    /**
-     * Rethrow the given {@link Throwable exception}, which is presumably the
-     * <em>target exception</em> of an {@link InvocationTargetException}. Should
-     * only be called if no checked exception is expected to be thrown by the
-     * target method.
-     * <p>
-     * Rethrows the underlying exception cast to an {@link Exception} or
-     * {@link Error} if appropriate; otherwise, throws an
-     * {@link UndeclaredThrowableException}.
-     *
-     * @param ex the exception to rethrow
-     * @throws Exception the rethrown exception (in case of a checked exception)
-     */
-    public static void rethrowException(Throwable ex) throws Exception {
-        if (ex instanceof Exception) {
-            throw (Exception) ex;
-        }
-        if (ex instanceof Error) {
-            throw (Error) ex;
-        }
-        throw new UndeclaredThrowableException(ex);
-    }
-
-    /**
-     * Determine whether the given method explicitly declares the given
-     * exception or one of its superclasses, which means that an exception of
-     * that type can be propagated as-is within a reflective invocation.
-     *
-     * @param method the declaring method
-     * @param exceptionType the exception to throw
-     * @return {@code true} if the exception can be thrown as-is; {@code false}
-     * if it needs to be wrapped
-     */
-    public static boolean declaresException(Method method, Class<?> exceptionType) {
-        Assert.notNull(method, "Method must not be null");
-        Class<?>[] declaredExceptions = method.getExceptionTypes();
-        for (Class<?> declaredException : declaredExceptions) {
-            if (declaredException.isAssignableFrom(exceptionType)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Determine whether the given field is a "public static final" constant.
-     *
-     * @param field the field to check
-     * @return
-     */
-    public static boolean isPublicStaticFinal(Field field) {
-        int modifiers = field.getModifiers();
-        return (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers));
-    }
-
-    /**
-     * Determine whether the given method is an "equals" method.
-     *
-     * @param method
-     * @return
-     * @see java.lang.Object#equals(Object)
-     */
-    public static boolean isEqualsMethod(Method method) {
-        if (method == null || !method.getName().equals("equals")) {
-            return false;
-        }
-        Class<?>[] paramTypes = method.getParameterTypes();
-        return (paramTypes.length == 1 && paramTypes[0] == Object.class);
-    }
-
-    /**
-     * Determine whether the given method is a "hashCode" method.
-     *
-     * @param method
-     * @return
-     * @see java.lang.Object#hashCode()
-     */
-    public static boolean isHashCodeMethod(Method method) {
-        return (method != null && method.getName().equals("hashCode") && method.getParameterCount() == 0);
-    }
-
-    /**
-     * Determine whether the given method is a "toString" method.
-     *
-     * @param method
-     * @return
-     * @see java.lang.Object#toString()
-     */
-    public static boolean isToStringMethod(Method method) {
-        return (method != null && method.getName().equals("toString") && method.getParameterCount() == 0);
-    }
-
-    /**
-     * Determine whether the given method is originally declared by
-     * {@link java.lang.Object}.
-     *
-     * @param method
-     * @return
-     */
-    public static boolean isObjectMethod(Method method) {
-        if (method == null) {
-            return false;
-        }
-        try {
-            Object.class.getDeclaredMethod(method.getName(), method.getParameterTypes());
-            return true;
-        } catch (NoSuchMethodException | SecurityException ex) {
-            return false;
-        }
-    }
-
-    /**
-     * Determine whether the given method is a CGLIB 'renamed' method, following
-     * the pattern "CGLIB$methodName$0".
-     *
-     * @param renamedMethod the method to check
-     * @return
-     * @see org.springframework.cglib.proxy.Enhancer#rename
-     */
-    public static boolean isCglibRenamedMethod(Method renamedMethod) {
-        String name = renamedMethod.getName();
-        if (name.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {
-            int i = name.length() - 1;
-            while (i >= 0 && Character.isDigit(name.charAt(i))) {
-                i--;
-            }
-            return ((i > CGLIB_RENAMED_METHOD_PREFIX.length())
-                    && (i < name.length() - 1) && name.charAt(i) == '$');
-        }
-        return false;
-    }
-
-    /**
-     * Make the given field accessible, explicitly setting it accessible if
-     * necessary. The {@code setAccessible(true)} method is only called when
-     * actually necessary, to avoid unnecessary conflicts with a JVM
-     * SecurityManager (if active).
-     *
-     * @param field the field to make accessible
-     * @see java.lang.reflect.Field#setAccessible
-     */
-    public static void makeAccessible(Field field) {
-        if ((!Modifier.isPublic(field.getModifiers())
-                || !Modifier.isPublic(field.getDeclaringClass().getModifiers())
-                || Modifier.isFinal(field.getModifiers())) && !field.isAccessible()) {
-            field.setAccessible(true);
-        }
-    }
-
-    /**
-     * Make the given method accessible, explicitly setting it accessible if
-     * necessary. The {@code setAccessible(true)} method is only called when
-     * actually necessary, to avoid unnecessary conflicts with a JVM
-     * SecurityManager (if active).
-     *
-     * @param method the method to make accessible
-     * @see java.lang.reflect.Method#setAccessible
-     */
-    public static void makeAccessible(Method method) {
-        if ((!Modifier.isPublic(method.getModifiers())
-                || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible()) {
-            method.setAccessible(true);
-        }
-    }
-
-    /**
-     * Make the given constructor accessible, explicitly setting it accessible
-     * if necessary. The {@code setAccessible(true)} method is only called when
-     * actually necessary, to avoid unnecessary conflicts with a JVM
-     * SecurityManager (if active).
-     *
-     * @param ctor the constructor to make accessible
-     * @see java.lang.reflect.Constructor#setAccessible
-     */
-    public static void makeAccessible(Constructor<?> ctor) {
-        if ((!Modifier.isPublic(ctor.getModifiers())
-                || !Modifier.isPublic(ctor.getDeclaringClass().getModifiers())) && !ctor.isAccessible()) {
-            ctor.setAccessible(true);
-        }
-    }
-
-    /**
-     * Obtain an accessible constructor for the given class and parameters.
-     *
-     * @param clazz the clazz to check
-     * @param parameterTypes the parameter types of the desired constructor
-     * @return the constructor reference
-     * @throws NoSuchMethodException if no such constructor exists
-     * @since 5.0
-     */
-    public static <T> Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes)
-            throws NoSuchMethodException {
-
-        Constructor<T> ctor = clazz.getDeclaredConstructor(parameterTypes);
-        makeAccessible(ctor);
-        return ctor;
-    }
-
-    /**
-     * Perform the given callback operation on all matching methods of the given
-     * class, as locally declared or equivalent thereof (such as default methods
-     * on Java 8 based interfaces that the given class implements).
-     *
-     * @param clazz the class to introspect
-     * @param mc the callback to invoke for each method
-     * @since 4.2
-     * @see #doWithMethods
-     */
-    public static void doWithLocalMethods(Class<?> clazz, MethodCallback mc) {
-        Method[] methods = getDeclaredMethods(clazz);
-        for (Method method : methods) {
-            try {
-                mc.doWith(method);
-            } catch (IllegalAccessException ex) {
-                throw new IllegalStateException("Not allowed to access method '" + method.getName() + "': " + ex);
-            }
-        }
-    }
-
-    /**
-     * Perform the given callback operation on all matching methods of the given
-     * class and superclasses.
-     * <p>
-     * The same named method occurring on subclass and superclass will appear
-     * twice, unless excluded by a {@link MethodFilter}.
-     *
-     * @param clazz the class to introspect
-     * @param mc the callback to invoke for each method
-     * @see #doWithMethods(Class, MethodCallback, MethodFilter)
-     */
-    public static void doWithMethods(Class<?> clazz, MethodCallback mc) {
-        doWithMethods(clazz, mc, null);
-    }
-
-    /**
-     * Perform the given callback operation on all matching methods of the given
-     * class and superclasses (or given interface and super-interfaces).
-     * <p>
-     * The same named method occurring on subclass and superclass will appear
-     * twice, unless excluded by the specified {@link MethodFilter}.
-     *
-     * @param clazz the class to introspect
-     * @param mc the callback to invoke for each method
-     * @param mf the filter that determines the methods to apply the callback to
-     */
-    public static void doWithMethods(Class<?> clazz, MethodCallback mc, MethodFilter mf) {
-        // Keep backing up the inheritance hierarchy.
-        Method[] methods = getDeclaredMethods(clazz);
-        for (Method method : methods) {
-            if (mf != null && !mf.matches(method)) {
-                continue;
-            }
-            try {
-                mc.doWith(method);
-            } catch (IllegalAccessException ex) {
-                throw new IllegalStateException("Not allowed to access method '" + method.getName() + "': " + ex);
-            }
-        }
-        if (clazz.getSuperclass() != null) {
-            doWithMethods(clazz.getSuperclass(), mc, mf);
-        } else if (clazz.isInterface()) {
-            for (Class<?> superIfc : clazz.getInterfaces()) {
-                doWithMethods(superIfc, mc, mf);
-            }
-        }
-    }
-
-    /**
-     * Get all declared methods on the leaf class and all superclasses. Leaf
-     * class methods are included first.
-     *
-     * @param leafClass the class to introspect
-     * @return
-     */
-    public static Method[] getAllDeclaredMethods(Class<?> leafClass) {
-        final List<Method> methods = new ArrayList<>(32);
-        doWithMethods(leafClass, methods::add);
-        return methods.toArray(new Method[methods.size()]);
-    }
-
-    /**
-     * Get the unique set of declared methods on the leaf class and all
-     * superclasses. Leaf class methods are included first and while traversing
-     * the superclass hierarchy any methods found with signatures matching a
-     * method already included are filtered out.
-     *
-     * @param leafClass the class to introspect
-     * @return
-     */
-    public static Method[] getUniqueDeclaredMethods(Class<?> leafClass) {
-        final List<Method> methods = new ArrayList<>(32);
-        doWithMethods(leafClass, (Method method) -> {
-            boolean knownSignature = false;
-            Method methodBeingOverriddenWithCovariantReturnType = null;
-            for (Method existingMethod : methods) {
-                if (method.getName().equals(existingMethod.getName())
-                        && Arrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {
-                    // Is this a covariant return type situation?
-                    if (existingMethod.getReturnType() != method.getReturnType()
-                            && existingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {
-                        methodBeingOverriddenWithCovariantReturnType = existingMethod;
-                    } else {
-                        knownSignature = true;
-                    }
-                    break;
-                }
-            }
-            if (methodBeingOverriddenWithCovariantReturnType != null) {
-                methods.remove(methodBeingOverriddenWithCovariantReturnType);
-            }
-            if (!knownSignature && !isCglibRenamedMethod(method)) {
-                methods.add(method);
-            }
-        });
-        return methods.toArray(new Method[methods.size()]);
-    }
-
-    /**
-     * This variant retrieves {@link Class#getDeclaredMethods()} from a local
-     * cache in order to avoid the JVM's SecurityManager check and defensive
-     * array copying. In addition, it also includes Java 8 default methods from
-     * locally implemented interfaces, since those are effectively to be treated
-     * just like declared methods.
-     *
-     * @param clazz the class to introspect
-     * @return the cached array of methods
-     * @see Class#getDeclaredMethods()
-     */
-    private static Method[] getDeclaredMethods(Class<?> clazz) {
-        Method[] result = declaredMethodsCache.get(clazz);
-        if (result == null) {
-            Method[] declaredMethods = clazz.getDeclaredMethods();
-            List<Method> defaultMethods = findConcreteMethodsOnInterfaces(clazz);
-            if (defaultMethods != null) {
-                result = new Method[declaredMethods.length + defaultMethods.size()];
-                System.arraycopy(declaredMethods, 0, result, 0, declaredMethods.length);
-                int index = declaredMethods.length;
-                for (Method defaultMethod : defaultMethods) {
-                    result[index] = defaultMethod;
-                    index++;
-                }
-            } else {
-                result = declaredMethods;
-            }
-            declaredMethodsCache.put(clazz, (result.length == 0 ? NO_METHODS : result));
-        }
-        return result;
-    }
-
-    private static List<Method> findConcreteMethodsOnInterfaces(Class<?> clazz) {
-        List<Method> result = null;
-        for (Class<?> ifc : clazz.getInterfaces()) {
-            for (Method ifcMethod : ifc.getMethods()) {
-                if (!Modifier.isAbstract(ifcMethod.getModifiers())) {
-                    if (result == null) {
-                        result = new LinkedList<>();
-                    }
-                    result.add(ifcMethod);
-                }
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Invoke the given callback on all fields in the target class, going up the
-     * class hierarchy to get all declared fields.
-     *
-     * @param clazz the target class to analyze
-     * @param fc the callback to invoke for each field
-     * @since 4.2
-     * @see #doWithFields
-     */
-    public static void doWithLocalFields(Class<?> clazz, FieldCallback fc) {
-        for (Field field : getDeclaredFields(clazz)) {
-            try {
-                fc.doWith(field);
-            } catch (IllegalAccessException ex) {
-                throw new IllegalStateException("Not allowed to access field '" + field.getName() + "': " + ex);
-            }
-        }
-    }
-
-    /**
-     * Invoke the given callback on all fields in the target class, going up the
-     * class hierarchy to get all declared fields.
-     *
-     * @param clazz the target class to analyze
-     * @param fc the callback to invoke for each field
-     */
-    public static void doWithFields(Class<?> clazz, FieldCallback fc) {
-        doWithFields(clazz, fc, null);
-    }
-
-    /**
-     * Invoke the given callback on all fields in the target class, going up the
-     * class hierarchy to get all declared fields.
-     *
-     * @param clazz the target class to analyze
-     * @param fc the callback to invoke for each field
-     * @param ff the filter that determines the fields to apply the callback to
-     */
-    public static void doWithFields(Class<?> clazz, FieldCallback fc, FieldFilter ff) {
-        // Keep backing up the inheritance hierarchy.
-        Class<?> targetClass = clazz;
-        do {
-            Field[] fields = getDeclaredFields(targetClass);
-            for (Field field : fields) {
-                if (ff != null && !ff.matches(field)) {
-                    continue;
-                }
-                try {
-                    fc.doWith(field);
-                } catch (IllegalAccessException ex) {
-                    throw new IllegalStateException("Not allowed to access field '" + field.getName() + "': " + ex);
-                }
-            }
-            targetClass = targetClass.getSuperclass();
-        } while (targetClass != null && targetClass != Object.class);
-    }
-
-    /**
-     * This variant retrieves {@link Class#getDeclaredFields()} from a local
-     * cache in order to avoid the JVM's SecurityManager check and defensive
-     * array copying.
-     *
-     * @param clazz the class to introspect
-     * @return the cached array of fields
-     * @see Class#getDeclaredFields()
-     */
-    private static Field[] getDeclaredFields(Class<?> clazz) {
-        Field[] result = declaredFieldsCache.get(clazz);
-        if (result == null) {
-            result = clazz.getDeclaredFields();
-            declaredFieldsCache.put(clazz, (result.length == 0 ? NO_FIELDS : result));
-        }
-        return result;
-    }
-
-    /**
-     * Given the source object and the destination, which must be the same class
-     * or a subclass, copy all fields, including inherited fields. Designed to
-     * work on objects with public no-arg constructors.
-     *
-     * @param src
-     * @param dest
-     */
-    public static void shallowCopyFieldState(final Object src, final Object dest) {
-        if (src == null) {
-            throw new IllegalArgumentException("Source for field copy cannot be null");
-        }
-        if (dest == null) {
-            throw new IllegalArgumentException("Destination for field copy cannot be null");
-        }
-        if (!src.getClass().isAssignableFrom(dest.getClass())) {
-            throw new IllegalArgumentException("Destination class [" + dest.getClass().getName()
-                    + "] must be same or subclass as source class [" + src.getClass().getName() + "]");
-        }
-        doWithFields(src.getClass(), (Field field) -> {
-            makeAccessible(field);
-            Object srcValue = field.get(src);
-            field.set(dest, srcValue);
-        }, COPYABLE_FIELDS);
-    }
-
-    /**
-     * Clear the internal method/field cache.
-     *
-     * @since 4.2.4
-     */
-    public static void clearCache() {
-        declaredMethodsCache.clear();
-        declaredFieldsCache.clear();
-    }
-
-    /**
-     * Action to take on each method.
-     */
-    @FunctionalInterface
-    public interface MethodCallback {
-
-        /**
-         * Perform an operation using the given method.
-         *
-         * @param method the method to operate on
-         * @throws java.lang.IllegalAccessException
-         */
-        void doWith(Method method) throws IllegalArgumentException, IllegalAccessException;
-    }
-
-    /**
-     * Callback optionally used to filter methods to be operated on by a method
-     * callback.
-     */
-    @FunctionalInterface
-    public interface MethodFilter {
-
-        /**
-         * Determine whether the given method matches.
-         *
-         * @param method the method to check
-         * @return
-         */
-        boolean matches(Method method);
-    }
-
-    /**
-     * Callback interface invoked on each field in the hierarchy.
-     */
-    @FunctionalInterface
-    public interface FieldCallback {
-
-        /**
-         * Perform an operation using the given field.
-         *
-         * @param field the field to operate on
-         * @throws java.lang.IllegalAccessException
-         */
-        void doWith(Field field) throws IllegalArgumentException, IllegalAccessException;
-    }
-
-    /**
-     * Callback optionally used to filter fields to be operated on by a field
-     * callback.
-     */
-    @FunctionalInterface
-    public interface FieldFilter {
-
-        /**
-         * Determine whether the given field matches.
-         *
-         * @param field the field to check
-         * @return
-         */
-        boolean matches(Field field);
-    }
-
-    /**
-     * Pre-built FieldFilter that matches all non-static, non-final fields.
-     */
-    public static final FieldFilter COPYABLE_FIELDS = (Field field) -> !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));
-
-    /**
-     * Pre-built MethodFilter that matches all non-bridge methods.
-     */
-    public static final MethodFilter NON_BRIDGED_METHODS = (Method method) -> !method.isBridge();
-
-    /**
-     * Pre-built MethodFilter that matches all non-bridge methods which are not
-     * declared on {@code java.lang.Object}.
-     */
-    public static final MethodFilter USER_DECLARED_METHODS = (Method method) -> (!method.isBridge() && method.getDeclaringClass() != Object.class);
-
-}
diff --git a/src/util/ResourceUtils.java b/src/util/ResourceUtils.java
deleted file mode 100644
index 31016fb..0000000
--- a/src/util/ResourceUtils.java
+++ /dev/null
@@ -1,432 +0,0 @@
-/*
- * Copyright 2002-2015 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package com.marvin.component.util;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLConnection;
-
-/**
- * Utility methods for resolving resource locations to files in the file system.
- * Mainly for internal use within the framework.
- *
- * <p>
- * Consider using Spring's Resource abstraction in the core package for handling
- * all kinds of file resources in a uniform manner.
- * {@link org.springframework.core.io.ResourceLoader}'s {@code getResource()}
- * method can resolve any location to a
- * {@link org.springframework.core.io.Resource} object, which in turn allows one
- * to obtain a {@code java.io.File} in the file system through its
- * {@code getFile()} method.
- *
- * <p>
- * The main reason for these utility methods for resource location handling is
- * to support {@link Log4jConfigurer}, which must be able to resolve resource
- * locations <i>before the logging system has been initialized</i>. Spring's
- * {@code Resource} abstraction in the core package, on the other hand, already
- * expects the logging system to be available.
- *
- * @author Juergen Hoeller
- * @since 1.1.5
- * @see org.springframework.core.io.Resource
- * @see org.springframework.core.io.ClassPathResource
- * @see org.springframework.core.io.FileSystemResource
- * @see org.springframework.core.io.UrlResource
- * @see org.springframework.core.io.ResourceLoader
- */
-public abstract class ResourceUtils {
-
-    /**
-     * Pseudo URL prefix for loading from the class path: "classpath:"
-     */
-    public static final String CLASSPATH_URL_PREFIX = "classpath:";
-
-    /**
-     * URL prefix for loading from the file system: "file:"
-     */
-    public static final String FILE_URL_PREFIX = "file:";
-
-    /**
-     * URL prefix for loading from a jar file: "jar:"
-     */
-    public static final String JAR_URL_PREFIX = "jar:";
-
-    /**
-     * URL prefix for loading from a war file on Tomcat: "war:"
-     */
-    public static final String WAR_URL_PREFIX = "war:";
-
-    /**
-     * URL protocol for a file in the file system: "file"
-     */
-    public static final String URL_PROTOCOL_FILE = "file";
-
-    /**
-     * URL protocol for an entry from a jar file: "jar"
-     */
-    public static final String URL_PROTOCOL_JAR = "jar";
-
-    /**
-     * URL protocol for an entry from a zip file: "zip"
-     */
-    public static final String URL_PROTOCOL_ZIP = "zip";
-
-    /**
-     * URL protocol for an entry from a WebSphere jar file: "wsjar"
-     */
-    public static final String URL_PROTOCOL_WSJAR = "wsjar";
-
-    /**
-     * URL protocol for an entry from a JBoss jar file: "vfszip"
-     */
-    public static final String URL_PROTOCOL_VFSZIP = "vfszip";
-
-    /**
-     * URL protocol for a JBoss file system resource: "vfsfile"
-     */
-    public static final String URL_PROTOCOL_VFSFILE = "vfsfile";
-
-    /**
-     * URL protocol for a general JBoss VFS resource: "vfs"
-     */
-    public static final String URL_PROTOCOL_VFS = "vfs";
-
-    /**
-     * File extension for a regular jar file: ".jar"
-     */
-    public static final String JAR_FILE_EXTENSION = ".jar";
-
-    /**
-     * Separator between JAR URL and file path within the JAR: "!/"
-     */
-    public static final String JAR_URL_SEPARATOR = "!/";
-
-    /**
-     * Special separator between WAR URL and jar part on Tomcat
-     */
-    public static final String WAR_URL_SEPARATOR = "*/";
-
-    /**
-     * Return whether the given resource location is a URL: either a special
-     * "classpath" pseudo URL or a standard URL.
-     *
-     * @param resourceLocation the location String to check
-     * @return whether the location qualifies as a URL
-     * @see #CLASSPATH_URL_PREFIX
-     * @see java.net.URL
-     */
-    public static boolean isUrl(String resourceLocation) {
-        if (resourceLocation == null) {
-            return false;
-        }
-        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
-            return true;
-        }
-        try {
-            URL url = new URL(resourceLocation);
-            return true;
-        } catch (MalformedURLException ex) {
-            return false;
-        }
-    }
-
-    /**
-     * Resolve the given resource location to a {@code java.net.URL}.
-     * <p>
-     * Does not check whether the URL actually exists; simply returns the URL
-     * that the given location would correspond to.
-     *
-     * @param resourceLocation the resource location to resolve: either a
-     * "classpath:" pseudo URL, a "file:" URL, or a plain file path
-     * @return a corresponding URL object
-     * @throws FileNotFoundException if the resource cannot be resolved to a URL
-     */
-    public static URL getURL(String resourceLocation) throws FileNotFoundException {
-        Assert.notNull(resourceLocation, "Resource location must not be null");
-        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
-            String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());
-            ClassLoader cl = ClassUtils.getDefaultClassLoader();
-            URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));
-            if (url == null) {
-                String description = "class path resource [" + path + "]";
-                throw new FileNotFoundException(description
-                        + " cannot be resolved to URL because it does not exist");
-            }
-            return url;
-        }
-        try {
-            // try URL
-            return new URL(resourceLocation);
-        } catch (MalformedURLException ex) {
-            // no URL -> treat as file path
-            try {
-                return new File(resourceLocation).toURI().toURL();
-            } catch (MalformedURLException ex2) {
-                throw new FileNotFoundException("Resource location [" + resourceLocation
-                        + "] is neither a URL not a well-formed file path");
-            }
-        }
-    }
-
-    /**
-     * Resolve the given resource location to a {@code java.io.File}, i.e. to a
-     * file in the file system.
-     * <p>
-     * Does not check whether the file actually exists; simply returns the File
-     * that the given location would correspond to.
-     *
-     * @param resourceLocation the resource location to resolve: either a
-     * "classpath:" pseudo URL, a "file:" URL, or a plain file path
-     * @return a corresponding File object
-     * @throws FileNotFoundException if the resource cannot be resolved to a
-     * file in the file system
-     */
-    public static File getFile(String resourceLocation) throws FileNotFoundException {
-        Assert.notNull(resourceLocation, "Resource location must not be null");
-        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
-            String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());
-            String description = "class path resource [" + path + "]";
-            ClassLoader cl = ClassUtils.getDefaultClassLoader();
-            URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));
-            if (url == null) {
-                throw new FileNotFoundException(description
-                        + " cannot be resolved to absolute file path because it does not exist");
-            }
-            return getFile(url, description);
-        }
-        try {
-            // try URL
-            return getFile(new URL(resourceLocation));
-        } catch (MalformedURLException ex) {
-            // no URL -> treat as file path
-            return new File(resourceLocation);
-        }
-    }
-
-    /**
-     * Resolve the given resource URL to a {@code java.io.File}, i.e. to a file
-     * in the file system.
-     *
-     * @param resourceUrl the resource URL to resolve
-     * @return a corresponding File object
-     * @throws FileNotFoundException if the URL cannot be resolved to a file in
-     * the file system
-     */
-    public static File getFile(URL resourceUrl) throws FileNotFoundException {
-        return getFile(resourceUrl, "URL");
-    }
-
-    /**
-     * Resolve the given resource URL to a {@code java.io.File}, i.e. to a file
-     * in the file system.
-     *
-     * @param resourceUrl the resource URL to resolve
-     * @param description a description of the original resource that the URL
-     * was created for (for example, a class path location)
-     * @return a corresponding File object
-     * @throws FileNotFoundException if the URL cannot be resolved to a file in
-     * the file system
-     */
-    public static File getFile(URL resourceUrl, String description) throws FileNotFoundException {
-        Assert.notNull(resourceUrl, "Resource URL must not be null");
-        if (!URL_PROTOCOL_FILE.equals(resourceUrl.getProtocol())) {
-            throw new FileNotFoundException(
-                    description + " cannot be resolved to absolute file path "
-                    + "because it does not reside in the file system: " + resourceUrl);
-        }
-        try {
-            return new File(toURI(resourceUrl).getSchemeSpecificPart());
-        } catch (URISyntaxException ex) {
-            // Fallback for URLs that are not valid URIs (should hardly ever happen).
-            return new File(resourceUrl.getFile());
-        }
-    }
-
-    /**
-     * Resolve the given resource URI to a {@code java.io.File}, i.e. to a file
-     * in the file system.
-     *
-     * @param resourceUri the resource URI to resolve
-     * @return a corresponding File object
-     * @throws FileNotFoundException if the URL cannot be resolved to a file in
-     * the file system
-     */
-    public static File getFile(URI resourceUri) throws FileNotFoundException {
-        return getFile(resourceUri, "URI");
-    }
-
-    /**
-     * Resolve the given resource URI to a {@code java.io.File}, i.e. to a file
-     * in the file system.
-     *
-     * @param resourceUri the resource URI to resolve
-     * @param description a description of the original resource that the URI
-     * was created for (for example, a class path location)
-     * @return a corresponding File object
-     * @throws FileNotFoundException if the URL cannot be resolved to a file in
-     * the file system
-     */
-    public static File getFile(URI resourceUri, String description) throws FileNotFoundException {
-        Assert.notNull(resourceUri, "Resource URI must not be null");
-        if (!URL_PROTOCOL_FILE.equals(resourceUri.getScheme())) {
-            throw new FileNotFoundException(
-                    description + " cannot be resolved to absolute file path "
-                    + "because it does not reside in the file system: " + resourceUri);
-        }
-        return new File(resourceUri.getSchemeSpecificPart());
-    }
-
-    /**
-     * Determine whether the given URL points to a resource in the file system,
-     * that is, has protocol "file", "vfsfile" or "vfs".
-     *
-     * @param url the URL to check
-     * @return whether the URL has been identified as a file system URL
-     */
-    public static boolean isFileURL(URL url) {
-        String protocol = url.getProtocol();
-        return (URL_PROTOCOL_FILE.equals(protocol) || URL_PROTOCOL_VFSFILE.equals(protocol)
-                || URL_PROTOCOL_VFS.equals(protocol));
-    }
-
-    /**
-     * Determine whether the given URL points to a resource in a jar file, that
-     * is, has protocol "jar", "zip", "vfszip" or "wsjar".
-     *
-     * @param url the URL to check
-     * @return whether the URL has been identified as a JAR URL
-     */
-    public static boolean isJarURL(URL url) {
-        String protocol = url.getProtocol();
-        return (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_ZIP.equals(protocol)
-                || URL_PROTOCOL_VFSZIP.equals(protocol) || URL_PROTOCOL_WSJAR.equals(protocol));
-    }
-
-    /**
-     * Determine whether the given URL points to a jar file itself, that is, has
-     * protocol "file" and ends with the ".jar" extension.
-     *
-     * @param url the URL to check
-     * @return whether the URL has been identified as a JAR file URL
-     * @since 4.1
-     */
-    public static boolean isJarFileURL(URL url) {
-        return (URL_PROTOCOL_FILE.equals(url.getProtocol())
-                && url.getPath().toLowerCase().endsWith(JAR_FILE_EXTENSION));
-    }
-
-    /**
-     * Extract the URL for the actual jar file from the given URL (which may
-     * point to a resource in a jar file or to a jar file itself).
-     *
-     * @param jarUrl the original URL
-     * @return the URL for the actual jar file
-     * @throws MalformedURLException if no valid jar file URL could be extracted
-     */
-    public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException {
-        String urlFile = jarUrl.getFile();
-        int separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR);
-        if (separatorIndex != -1) {
-            String jarFile = urlFile.substring(0, separatorIndex);
-            try {
-                return new URL(jarFile);
-            } catch (MalformedURLException ex) {
-				// Probably no protocol in original jar URL, like "jar:C:/mypath/myjar.jar".
-                // This usually indicates that the jar file resides in the file system.
-                if (!jarFile.startsWith("/")) {
-                    jarFile = "/" + jarFile;
-                }
-                return new URL(FILE_URL_PREFIX + jarFile);
-            }
-        } else {
-            return jarUrl;
-        }
-    }
-
-    /**
-     * Extract the URL for the outermost archive from the given jar/war URL
-     * (which may point to a resource in a jar file or to a jar file itself).
-     * <p>
-     * In the case of a jar file nested within a war file, this will return a
-     * URL to the war file since that is the one resolvable in the file system.
-     *
-     * @param jarUrl the original URL
-     * @return the URL for the actual jar file
-     * @throws MalformedURLException if no valid jar file URL could be extracted
-     * @since 4.1.8
-     * @see #extractJarFileURL(URL)
-     */
-    public static URL extractArchiveURL(URL jarUrl) throws MalformedURLException {
-        String urlFile = jarUrl.getFile();
-
-        int endIndex = urlFile.indexOf(WAR_URL_SEPARATOR);
-        if (endIndex != -1) {
-            // Tomcat's "jar:war:file:...mywar.war*/WEB-INF/lib/myjar.jar!/myentry.txt"
-            String warFile = urlFile.substring(0, endIndex);
-            int startIndex = warFile.indexOf(WAR_URL_PREFIX);
-            if (startIndex != -1) {
-                return new URL(warFile.substring(startIndex + WAR_URL_PREFIX.length()));
-            }
-        }
-
-        // Regular "jar:file:...myjar.jar!/myentry.txt"
-        return extractJarFileURL(jarUrl);
-    }
-
-    /**
-     * Create a URI instance for the given URL, replacing spaces with "%20" URI
-     * encoding first.
-     * <p>
-     * Furthermore, this method works on JDK 1.4 as well, in contrast to the
-     * {@code URL.toURI()} method.
-     *
-     * @param url the URL to convert into a URI instance
-     * @return the URI instance
-     * @throws URISyntaxException if the URL wasn't a valid URI
-     * @see java.net.URL#toURI()
-     */
-    public static URI toURI(URL url) throws URISyntaxException {
-        return toURI(url.toString());
-    }
-
-    /**
-     * Create a URI instance for the given location String, replacing spaces
-     * with "%20" URI encoding first.
-     *
-     * @param location the location String to convert into a URI instance
-     * @return the URI instance
-     * @throws URISyntaxException if the location wasn't a valid URI
-     */
-    public static URI toURI(String location) throws URISyntaxException {
-        return new URI(StringUtils.replace(location, " ", "%20"));
-    }
-
-    /**
-     * Set the {@link URLConnection#setUseCaches "useCaches"} flag on the given
-     * connection, preferring {@code false} but leaving the flag at {@code true}
-     * for JNLP based resources.
-     *
-     * @param con the URLConnection to set the flag on
-     */
-    public static void useCachesIfNecessary(URLConnection con) {
-        con.setUseCaches(con.getClass().getSimpleName().startsWith("JNLP"));
-    }
-
-}
diff --git a/src/util/StringUtils.java b/src/util/StringUtils.java
deleted file mode 100644
index a7b7fb5..0000000
--- a/src/util/StringUtils.java
+++ /dev/null
@@ -1,1304 +0,0 @@
-package com.marvin.component.util;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Locale;
-import java.util.Properties;
-import java.util.Set;
-import java.util.StringTokenizer;
-import java.util.TimeZone;
-
-/**
- *
- * @author cdi305
- */
-public abstract class StringUtils {
-
-    private static final String FOLDER_SEPARATOR = "/";
-
-    private static final String WINDOWS_FOLDER_SEPARATOR = "\\";
-
-    private static final String TOP_PATH = "..";
-
-    private static final String CURRENT_PATH = ".";
-
-    private static final char EXTENSION_SEPARATOR = '.';
-    
-
-    //---------------------------------------------------------------------
-    // General convenience methods for working with Strings
-    //---------------------------------------------------------------------
-    
-    
-    /**
-     * Check whether the given {@code String} is empty.
-     * <p>
-     * This method accepts any Object as an argument, comparing it to
-     * {@code null} and the empty String. As a consequence, this method will
-     * never return {@code true} for a non-null non-String object.
-     * <p>
-     * The Object signature is useful for general attribute handling code that
-     * commonly deals with Strings but generally has to iterate over Objects
-     * since attributes may e.g. be primitive value objects as well.
-     *
-     * @param str the candidate String
-     * @return 
-     * @since 3.2.1
-     */
-    public static boolean isEmpty(Object str) {
-        return (str == null || "".equals(str));
-    }
-
-    /**
-     * Check that the given {@code CharSequence} is neither {@code null} nor of
-     * length 0.
-     * <p>
-     * Note: this method returns {@code true} for a {@code CharSequence} that
-     * purely consists of whitespace.
-     * <p>
-     * <pre class="code">
-     * StringUtils.hasLength(null) = false StringUtils.hasLength("") = false
-     * StringUtils.hasLength(" ") = true StringUtils.hasLength("Hello") = true
-     * </pre>
-     *
-     * @param str the {@code CharSequence} to check (may be {@code null})
-     * @return {@code true} if the {@code CharSequence} is not {@code null} and
-     * has length
-     * @see #hasText(String)
-     */
-    public static boolean hasLength(CharSequence str) {
-        return (str != null && str.length() > 0);
-    }
-
-    /**
-     * Check that the given {@code String} is neither {@code null} nor of length
-     * 0.
-     * <p>
-     * Note: this method returns {@code true} for a {@code String} that purely
-     * consists of whitespace.
-     *
-     * @param str the {@code String} to check (may be {@code null})
-     * @return {@code true} if the {@code String} is not {@code null} and has
-     * length
-     * @see #hasLength(CharSequence)
-     * @see #hasText(String)
-     */
-    public static boolean hasLength(String str) {
-        return hasLength((CharSequence) str);
-    }
-
-    /**
-     * Check whether the given {@code CharSequence} contains actual
-     * <em>text</em>.
-     * <p>
-     * More specifically, this method returns {@code true} if the
-     * {@code CharSequence} is not {@code null}, its length is greater than 0,
-     * and it contains at least one non-whitespace character.
-     * <p>
-     * <pre class="code">
-     * StringUtils.hasText(null) = false StringUtils.hasText("") = false
-     * StringUtils.hasText(" ") = false StringUtils.hasText("12345") = true
-     * StringUtils.hasText(" 12345 ") = true
-     * </pre>
-     *
-     * @param str the {@code CharSequence} to check (may be {@code null})
-     * @return {@code true} if the {@code CharSequence} is not {@code null}, its
-     * length is greater than 0, and it does not contain whitespace only
-     * @see Character#isWhitespace
-     */
-    public static boolean hasText(CharSequence str) {
-        if (!hasLength(str)) {
-            return false;
-        }
-        int strLen = str.length();
-        for (int i = 0; i < strLen; i++) {
-            if (!Character.isWhitespace(str.charAt(i))) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Check whether the given {@code String} contains actual <em>text</em>.
-     * <p>
-     * More specifically, this method returns {@code true} if the {@code String}
-     * is not {@code null}, its length is greater than 0, and it contains at
-     * least one non-whitespace character.
-     *
-     * @param str the {@code String} to check (may be {@code null})
-     * @return {@code true} if the {@code String} is not {@code null}, its
-     * length is greater than 0, and it does not contain whitespace only
-     * @see #hasText(CharSequence)
-     */
-    public static boolean hasText(String str) {
-        return hasText((CharSequence) str);
-    }
-
-    /**
-     * Check whether the given {@code CharSequence} contains any whitespace
-     * characters.
-     *
-     * @param str the {@code CharSequence} to check (may be {@code null})
-     * @return {@code true} if the {@code CharSequence} is not empty and
-     * contains at least 1 whitespace character
-     * @see Character#isWhitespace
-     */
-    public static boolean containsWhitespace(CharSequence str) {
-        if (!hasLength(str)) {
-            return false;
-        }
-        int strLen = str.length();
-        for (int i = 0; i < strLen; i++) {
-            if (Character.isWhitespace(str.charAt(i))) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Check whether the given {@code String} contains any whitespace
-     * characters.
-     *
-     * @param str the {@code String} to check (may be {@code null})
-     * @return {@code true} if the {@code String} is not empty and contains at
-     * least 1 whitespace character
-     * @see #containsWhitespace(CharSequence)
-     */
-    public static boolean containsWhitespace(String str) {
-        return containsWhitespace((CharSequence) str);
-    }
-
-    /**
-     * Trim leading and trailing whitespace from the given {@code String}.
-     *
-     * @param str the {@code String} to check
-     * @return the trimmed {@code String}
-     * @see java.lang.Character#isWhitespace
-     */
-    public static String trimWhitespace(String str) {
-        if (!hasLength(str)) {
-            return str;
-        }
-        StringBuilder sb = new StringBuilder(str);
-        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
-            sb.deleteCharAt(0);
-        }
-        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {
-            sb.deleteCharAt(sb.length() - 1);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Trim <i>all</i> whitespace from the given {@code String}: leading,
-     * trailing, and in between characters.
-     *
-     * @param str the {@code String} to check
-     * @return the trimmed {@code String}
-     * @see java.lang.Character#isWhitespace
-     */
-    public static String trimAllWhitespace(String str) {
-        if (!hasLength(str)) {
-            return str;
-        }
-        int len = str.length();
-        StringBuilder sb = new StringBuilder(str.length());
-        for (int i = 0; i < len; i++) {
-            char c = str.charAt(i);
-            if (!Character.isWhitespace(c)) {
-                sb.append(c);
-            }
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Trim leading whitespace from the given {@code String}.
-     *
-     * @param str the {@code String} to check
-     * @return the trimmed {@code String}
-     * @see java.lang.Character#isWhitespace
-     */
-    public static String trimLeadingWhitespace(String str) {
-        if (!hasLength(str)) {
-            return str;
-        }
-        StringBuilder sb = new StringBuilder(str);
-        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
-            sb.deleteCharAt(0);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Trim trailing whitespace from the given {@code String}.
-     *
-     * @param str the {@code String} to check
-     * @return the trimmed {@code String}
-     * @see java.lang.Character#isWhitespace
-     */
-    public static String trimTrailingWhitespace(String str) {
-        if (!hasLength(str)) {
-            return str;
-        }
-        StringBuilder sb = new StringBuilder(str);
-        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {
-            sb.deleteCharAt(sb.length() - 1);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Trim all occurrences of the supplied leading character from the given
-     * {@code String}.
-     *
-     * @param str the {@code String} to check
-     * @param leadingCharacter the leading character to be trimmed
-     * @return the trimmed {@code String}
-     */
-    public static String trimLeadingCharacter(String str, char leadingCharacter) {
-        if (!hasLength(str)) {
-            return str;
-        }
-        StringBuilder sb = new StringBuilder(str);
-        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {
-            sb.deleteCharAt(0);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Trim all occurrences of the supplied trailing character from the given
-     * {@code String}.
-     *
-     * @param str the {@code String} to check
-     * @param trailingCharacter the trailing character to be trimmed
-     * @return the trimmed {@code String}
-     */
-    public static String trimTrailingCharacter(String str, char trailingCharacter) {
-        if (!hasLength(str)) {
-            return str;
-        }
-        StringBuilder sb = new StringBuilder(str);
-        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {
-            sb.deleteCharAt(sb.length() - 1);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Test if the given {@code String} starts with the specified prefix,
-     * ignoring upper/lower case.
-     *
-     * @param str the {@code String} to check
-     * @param prefix the prefix to look for
-     * @see java.lang.String#startsWith
-     */
-    public static boolean startsWithIgnoreCase(String str, String prefix) {
-        if (str == null || prefix == null) {
-            return false;
-        }
-        if (str.startsWith(prefix)) {
-            return true;
-        }
-        if (str.length() < prefix.length()) {
-            return false;
-        }
-        String lcStr = str.substring(0, prefix.length()).toLowerCase();
-        String lcPrefix = prefix.toLowerCase();
-        return lcStr.equals(lcPrefix);
-    }
-
-    /**
-     * Test if the given {@code String} ends with the specified suffix, ignoring
-     * upper/lower case.
-     *
-     * @param str the {@code String} to check
-     * @param suffix the suffix to look for
-     * @see java.lang.String#endsWith
-     */
-    public static boolean endsWithIgnoreCase(String str, String suffix) {
-        if (str == null || suffix == null) {
-            return false;
-        }
-        if (str.endsWith(suffix)) {
-            return true;
-        }
-        if (str.length() < suffix.length()) {
-            return false;
-        }
-
-        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();
-        String lcSuffix = suffix.toLowerCase();
-        return lcStr.equals(lcSuffix);
-    }
-
-    /**
-     * Test whether the given string matches the given substring at the given
-     * index.
-     *
-     * @param str the original string (or StringBuilder)
-     * @param index the index in the original string to start matching against
-     * @param substring the substring to match at the given index
-     */
-    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {
-        for (int j = 0; j < substring.length(); j++) {
-            int i = index + j;
-            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Count the occurrences of the substring {@code sub} in string {@code str}.
-     *
-     * @param str string to search in. Return 0 if this is {@code null}.
-     * @param sub string to search for. Return 0 if this is {@code null}.
-     */
-    public static int countOccurrencesOf(String str, String sub) {
-        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {
-            return 0;
-        }
-        int count = 0;
-        int pos = 0;
-        int idx;
-        while ((idx = str.indexOf(sub, pos)) != -1) {
-            ++count;
-            pos = idx + sub.length();
-        }
-        return count;
-    }
-
-    /**
-     * Replace all occurrences of a substring within a string with another
-     * string.
-     *
-     * @param inString {@code String} to examine
-     * @param oldPattern {@code String} to replace
-     * @param newPattern {@code String} to insert
-     * @return a {@code String} with the replacements
-     */
-    public static String replace(String inString, String oldPattern, String newPattern) {
-        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {
-            return inString;
-        }
-        StringBuilder sb = new StringBuilder();
-        int pos = 0; // our position in the old string
-        int index = inString.indexOf(oldPattern);
-        // the index of an occurrence we've found, or -1
-        int patLen = oldPattern.length();
-        while (index >= 0) {
-            sb.append(inString.substring(pos, index));
-            sb.append(newPattern);
-            pos = index + patLen;
-            index = inString.indexOf(oldPattern, pos);
-        }
-        sb.append(inString.substring(pos));
-        // remember to append any characters to the right of a match
-        return sb.toString();
-    }
-
-    /**
-     * Delete all occurrences of the given substring.
-     *
-     * @param inString the original {@code String}
-     * @param pattern the pattern to delete all occurrences of
-     * @return the resulting {@code String}
-     */
-    public static String delete(String inString, String pattern) {
-        return replace(inString, pattern, "");
-    }
-
-    /**
-     * Delete any character in a given {@code String}.
-     *
-     * @param inString the original {@code String}
-     * @param charsToDelete a set of characters to delete. E.g. "az\n" will
-     * delete 'a's, 'z's and new lines.
-     * @return the resulting {@code String}
-     */
-    public static String deleteAny(String inString, String charsToDelete) {
-        if (!hasLength(inString) || !hasLength(charsToDelete)) {
-            return inString;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < inString.length(); i++) {
-            char c = inString.charAt(i);
-            if (charsToDelete.indexOf(c) == -1) {
-                sb.append(c);
-            }
-        }
-        return sb.toString();
-    }
-
-	//---------------------------------------------------------------------
-    // Convenience methods for working with formatted Strings
-    //---------------------------------------------------------------------
-    /**
-     * Quote the given {@code String} with single quotes.
-     *
-     * @param str the input {@code String} (e.g. "myString")
-     * @return the quoted {@code String} (e.g. "'myString'"), or {@code null} if
-     * the input was {@code null}
-     */
-    public static String quote(String str) {
-        return (str != null ? "'" + str + "'" : null);
-    }
-
-    /**
-     * Turn the given Object into a {@code String} with single quotes if it is a
-     * {@code String}; keeping the Object as-is else.
-     *
-     * @param obj the input Object (e.g. "myString")
-     * @return the quoted {@code String} (e.g. "'myString'"), or the input
-     * object as-is if not a {@code String}
-     */
-    public static Object quoteIfString(Object obj) {
-        return (obj instanceof String ? quote((String) obj) : obj);
-    }
-
-    /**
-     * Unqualify a string qualified by a '.' dot character. For example,
-     * "this.name.is.qualified", returns "qualified".
-     *
-     * @param qualifiedName the qualified name
-     * @return 
-     */
-    public static String unqualify(String qualifiedName) {
-        return unqualify(qualifiedName, '.');
-    }
-
-    /**
-     * Unqualify a string qualified by a separator character. For example,
-     * "this:name:is:qualified" returns "qualified" if using a ':' separator.
-     *
-     * @param qualifiedName the qualified name
-     * @param separator the separator
-     * @return 
-     */
-    public static String unqualify(String qualifiedName, char separator) {
-        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);
-    }
-
-    /**
-     * Capitalize a {@code String}, changing the first letter to upper case as
-     * per {@link Character#toUpperCase(char)}. No other letters are changed.
-     *
-     * @param str the {@code String} to capitalize, may be {@code null}
-     * @return the capitalized {@code String}, or {@code null} if the supplied
-     * string is {@code null}
-     */
-    public static String capitalize(String str) {
-        return changeFirstCharacterCase(str, true);
-    }
-
-    /**
-     * Uncapitalize a {@code String}, changing the first letter to lower case as
-     * per {@link Character#toLowerCase(char)}. No other letters are changed.
-     *
-     * @param str the {@code String} to uncapitalize, may be {@code null}
-     * @return the uncapitalized {@code String}, or {@code null} if the supplied
-     * string is {@code null}
-     */
-    public static String uncapitalize(String str) {
-        return changeFirstCharacterCase(str, false);
-    }
-
-    private static String changeFirstCharacterCase(String str, boolean capitalize) {
-        if (str == null || str.length() == 0) {
-            return str;
-        }
-        StringBuilder sb = new StringBuilder(str.length());
-        if (capitalize) {
-            sb.append(Character.toUpperCase(str.charAt(0)));
-        } else {
-            sb.append(Character.toLowerCase(str.charAt(0)));
-        }
-        sb.append(str.substring(1));
-        return sb.toString();
-    }
-
-    /**
-     * Extract the filename from the given Java resource path, e.g.
-     * {@code "mypath/myfile.txt" -> "myfile.txt"}.
-     *
-     * @param path the file path (may be {@code null})
-     * @return the extracted filename, or {@code null} if none
-     */
-    public static String getFilename(String path) {
-        if (path == null) {
-            return null;
-        }
-        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);
-        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);
-    }
-
-    /**
-     * Extract the filename extension from the given Java resource path, e.g.
-     * "mypath/myfile.txt" -> "txt".
-     *
-     * @param path the file path (may be {@code null})
-     * @return the extracted filename extension, or {@code null} if none
-     */
-    public static String getFilenameExtension(String path) {
-        if (path == null) {
-            return null;
-        }
-        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);
-        if (extIndex == -1) {
-            return null;
-        }
-        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);
-        if (folderIndex > extIndex) {
-            return null;
-        }
-        return path.substring(extIndex + 1);
-    }
-
-    /**
-     * Strip the filename extension from the given Java resource path, e.g.
-     * "mypath/myfile.txt" -> "mypath/myfile".
-     *
-     * @param path the file path (may be {@code null})
-     * @return the path with stripped filename extension, or {@code null} if
-     * none
-     */
-    public static String stripFilenameExtension(String path) {
-        if (path == null) {
-            return null;
-        }
-        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);
-        if (extIndex == -1) {
-            return path;
-        }
-        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);
-        if (folderIndex > extIndex) {
-            return path;
-        }
-        return path.substring(0, extIndex);
-    }
-
-    /**
-     * Apply the given relative path to the given Java resource path, assuming
-     * standard Java folder separation (i.e. "/" separators).
-     *
-     * @param path the path to start from (usually a full file path)
-     * @param relativePath the relative path to apply (relative to the full file
-     * path above)
-     * @return the full file path that results from applying the relative path
-     */
-    public static String applyRelativePath(String path, String relativePath) {
-        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);
-        if (separatorIndex != -1) {
-            String newPath = path.substring(0, separatorIndex);
-            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {
-                newPath += FOLDER_SEPARATOR;
-            }
-            return newPath + relativePath;
-        } else {
-            return relativePath;
-        }
-    }
-
-    /**
-     * Normalize the path by suppressing sequences like "path/.." and inner
-     * simple dots.
-     * <p>
-     * The result is convenient for path comparison. For other uses, notice that
-     * Windows separators ("\") are replaced by simple slashes.
-     *
-     * @param path the original path
-     * @return the normalized path
-     */
-    public static String cleanPath(String path) {
-        if (path == null) {
-            return null;
-        }
-        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);
-
-		// Strip prefix from path to analyze, to not treat it as part of the
-        // first path element. This is necessary to correctly parse paths like
-        // "file:core/../core/io/Resource.class", where the ".." should just
-        // strip the first "core" directory while keeping the "file:" prefix.
-        int prefixIndex = pathToUse.indexOf(":");
-        String prefix = "";
-        if (prefixIndex != -1) {
-            prefix = pathToUse.substring(0, prefixIndex + 1);
-            if (prefix.contains("/")) {
-                prefix = "";
-            } else {
-                pathToUse = pathToUse.substring(prefixIndex + 1);
-            }
-        }
-        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {
-            prefix = prefix + FOLDER_SEPARATOR;
-            pathToUse = pathToUse.substring(1);
-        }
-
-        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);
-        List<String> pathElements = new LinkedList<>();
-        int tops = 0;
-
-        for (int i = pathArray.length - 1; i >= 0; i--) {
-            String element = pathArray[i];
-            if (null != element) switch (element) {
-                case CURRENT_PATH:
-                    break;
-                case TOP_PATH:
-                    // Registering top path found.
-                    tops++;
-                    break;
-                default:
-                    if (tops > 0) {
-                        // Merging path element with element corresponding to top path.
-                        tops--;
-                    } else {
-                        // Normal path element found.
-                        pathElements.add(0, element);
-                    }   break;
-            }
-        }
-
-        // Remaining top paths need to be retained.
-        for (int i = 0; i < tops; i++) {
-            pathElements.add(0, TOP_PATH);
-        }
-
-        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);
-    }
-
-    /**
-     * Compare two paths after normalization of them.
-     *
-     * @param path1 first path for comparison
-     * @param path2 second path for comparison
-     * @return whether the two paths are equivalent after normalization
-     */
-    public static boolean pathEquals(String path1, String path2) {
-        return cleanPath(path1).equals(cleanPath(path2));
-    }
-
-    /**
-     * Parse the given {@code localeString} value into a {@link Locale}.
-     * <p>
-     * This is the inverse operation of
-     * {@link Locale#toString Locale's toString}.
-     *
-     * @param localeString the locale {@code String}, following {@code Locale's}
-     * {@code toString()} format ("en", "en_UK", etc); also accepts spaces as
-     * separators, as an alternative to underscores
-     * @return a corresponding {@code Locale} instance
-     * @throws IllegalArgumentException in case of an invalid locale
-     * specification
-     */
-    public static Locale parseLocaleString(String localeString) {
-        String[] parts = tokenizeToStringArray(localeString, "_ ", false, false);
-        String language = (parts.length > 0 ? parts[0] : "");
-        String country = (parts.length > 1 ? parts[1] : "");
-        validateLocalePart(language);
-        validateLocalePart(country);
-        String variant = "";
-        if (parts.length > 2) {
-			// There is definitely a variant, and it is everything after the country
-            // code sans the separator between the country code and the variant.
-            int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length();
-            // Strip off any leading '_' and whitespace, what's left is the variant.
-            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));
-            if (variant.startsWith("_")) {
-                variant = trimLeadingCharacter(variant, '_');
-            }
-        }
-        return (language.length() > 0 ? new Locale(language, country, variant) : null);
-    }
-
-    private static void validateLocalePart(String localePart) {
-        for (int i = 0; i < localePart.length(); i++) {
-            char ch = localePart.charAt(i);
-            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {
-                throw new IllegalArgumentException(
-                        "Locale part \"" + localePart + "\" contains invalid characters");
-            }
-        }
-    }
-
-    /**
-     * Determine the RFC 3066 compliant language tag, as used for the HTTP
-     * "Accept-Language" header.
-     *
-     * @param locale the Locale to transform to a language tag
-     * @return the RFC 3066 compliant language tag as {@code String}
-     */
-    public static String toLanguageTag(Locale locale) {
-        return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "");
-    }
-
-    /**
-     * Parse the given {@code timeZoneString} value into a {@link TimeZone}.
-     *
-     * @param timeZoneString the time zone {@code String}, following
-     * {@link TimeZone#getTimeZone(String)} but throwing
-     * {@link IllegalArgumentException} in case of an invalid time zone
-     * specification
-     * @return a corresponding {@link TimeZone} instance
-     * @throws IllegalArgumentException in case of an invalid time zone
-     * specification
-     */
-    public static TimeZone parseTimeZoneString(String timeZoneString) {
-        TimeZone timeZone = TimeZone.getTimeZone(timeZoneString);
-        if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {
-            // We don't want that GMT fallback...
-            throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'");
-        }
-        return timeZone;
-    }
-
-	//---------------------------------------------------------------------
-    // Convenience methods for working with String arrays
-    //---------------------------------------------------------------------
-    /**
-     * Append the given {@code String} to the given {@code String} array,
-     * returning a new array consisting of the input array contents plus the
-     * given {@code String}.
-     *
-     * @param array the array to append to (can be {@code null})
-     * @param str the {@code String} to append
-     * @return the new array (never {@code null})
-     */
-    public static String[] addStringToArray(String[] array, String str) {
-        if (ObjectUtils.isEmpty(array)) {
-            return new String[]{str};
-        }
-        String[] newArr = new String[array.length + 1];
-        System.arraycopy(array, 0, newArr, 0, array.length);
-        newArr[array.length] = str;
-        return newArr;
-    }
-
-    /**
-     * Concatenate the given {@code String} arrays into one, with overlapping
-     * array elements included twice.
-     * <p>
-     * The order of elements in the original arrays is preserved.
-     *
-     * @param array1 the first array (can be {@code null})
-     * @param array2 the second array (can be {@code null})
-     * @return the new array ({@code null} if both given arrays were
-     * {@code null})
-     */
-    public static String[] concatenateStringArrays(String[] array1, String[] array2) {
-        if (ObjectUtils.isEmpty(array1)) {
-            return array2;
-        }
-        if (ObjectUtils.isEmpty(array2)) {
-            return array1;
-        }
-        String[] newArr = new String[array1.length + array2.length];
-        System.arraycopy(array1, 0, newArr, 0, array1.length);
-        System.arraycopy(array2, 0, newArr, array1.length, array2.length);
-        return newArr;
-    }
-
-    /**
-     * Merge the given {@code String} arrays into one, with overlapping array
-     * elements only included once.
-     * <p>
-     * The order of elements in the original arrays is preserved (with the
-     * exception of overlapping elements, which are only included on their first
-     * occurrence).
-     *
-     * @param array1 the first array (can be {@code null})
-     * @param array2 the second array (can be {@code null})
-     * @return the new array ({@code null} if both given arrays were
-     * {@code null})
-     */
-    public static String[] mergeStringArrays(String[] array1, String[] array2) {
-        if (ObjectUtils.isEmpty(array1)) {
-            return array2;
-        }
-        if (ObjectUtils.isEmpty(array2)) {
-            return array1;
-        }
-        List<String> result = new ArrayList<>();
-        result.addAll(Arrays.asList(array1));
-        for (String str : array2) {
-            if (!result.contains(str)) {
-                result.add(str);
-            }
-        }
-        return toStringArray(result);
-    }
-
-    /**
-     * Turn given source {@code String} array into sorted array.
-     *
-     * @param array the source array
-     * @return the sorted array (never {@code null})
-     */
-    public static String[] sortStringArray(String[] array) {
-        if (ObjectUtils.isEmpty(array)) {
-            return new String[0];
-        }
-        Arrays.sort(array);
-        return array;
-    }
-
-    /**
-     * Copy the given {@code Collection} into a {@code String} array.
-     * <p>
-     * The {@code Collection} must contain {@code String} elements only.
-     *
-     * @param collection the {@code Collection} to copy
-     * @return the {@code String} array ({@code null} if the supplied
-     * {@code Collection} was {@code null})
-     */
-    public static String[] toStringArray(Collection<String> collection) {
-        if (collection == null) {
-            return null;
-        }
-        return collection.toArray(new String[collection.size()]);
-    }
-
-    /**
-     * Copy the given Enumeration into a {@code String} array. The Enumeration
-     * must contain {@code String} elements only.
-     *
-     * @param enumeration the Enumeration to copy
-     * @return the {@code String} array ({@code null} if the passed-in
-     * Enumeration was {@code null})
-     */
-    public static String[] toStringArray(Enumeration<String> enumeration) {
-        if (enumeration == null) {
-            return null;
-        }
-        List<String> list = Collections.list(enumeration);
-        return list.toArray(new String[list.size()]);
-    }
-
-    /**
-     * Trim the elements of the given {@code String} array, calling
-     * {@code String.trim()} on each of them.
-     *
-     * @param array the original {@code String} array
-     * @return the resulting array (of the same size) with trimmed elements
-     */
-    public static String[] trimArrayElements(String[] array) {
-        if (ObjectUtils.isEmpty(array)) {
-            return new String[0];
-        }
-        String[] result = new String[array.length];
-        for (int i = 0; i < array.length; i++) {
-            String element = array[i];
-            result[i] = (element != null ? element.trim() : null);
-        }
-        return result;
-    }
-
-    /**
-     * Remove duplicate strings from the given array.
-     * <p>
-     * As of 4.2, it preserves the original order, as it uses a
-     * {@link LinkedHashSet}.
-     *
-     * @param array the {@code String} array
-     * @return an array without duplicates, in natural sort order
-     */
-    public static String[] removeDuplicateStrings(String[] array) {
-        if (ObjectUtils.isEmpty(array)) {
-            return array;
-        }
-        Set<String> set = new LinkedHashSet<>();
-        set.addAll(Arrays.asList(array));
-        return toStringArray(set);
-    }
-
-    /**
-     * Split a {@code String} at the first occurrence of the delimiter. Does not
-     * include the delimiter in the result.
-     *
-     * @param toSplit the string to split
-     * @param delimiter to split the string up with
-     * @return a two element array with index 0 being before the delimiter, and
-     * index 1 being after the delimiter (neither element includes the
-     * delimiter); or {@code null} if the delimiter wasn't found in the given
-     * input {@code String}
-     */
-    public static String[] split(String toSplit, String delimiter) {
-        if (!hasLength(toSplit) || !hasLength(delimiter)) {
-            return null;
-        }
-        int offset = toSplit.indexOf(delimiter);
-        if (offset < 0) {
-            return null;
-        }
-        String beforeDelimiter = toSplit.substring(0, offset);
-        String afterDelimiter = toSplit.substring(offset + delimiter.length());
-        return new String[]{beforeDelimiter, afterDelimiter};
-    }
-
-    /**
-     * Take an array of strings and split each element based on the given
-     * delimiter. A {@code Properties} instance is then generated, with the left
-     * of the delimiter providing the key, and the right of the delimiter
-     * providing the value.
-     * <p>
-     * Will trim both the key and value before adding them to the
-     * {@code Properties} instance.
-     *
-     * @param array the array to process
-     * @param delimiter to split each element using (typically the equals
-     * symbol)
-     * @return a {@code Properties} instance representing the array contents, or
-     * {@code null} if the array to process was {@code null} or empty
-     */
-    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {
-        return splitArrayElementsIntoProperties(array, delimiter, null);
-    }
-
-    /**
-     * Take an array of strings and split each element based on the given
-     * delimiter. A {@code Properties} instance is then generated, with the left
-     * of the delimiter providing the key, and the right of the delimiter
-     * providing the value.
-     * <p>
-     * Will trim both the key and value before adding them to the
-     * {@code Properties} instance.
-     *
-     * @param array the array to process
-     * @param delimiter to split each element using (typically the equals
-     * symbol)
-     * @param charsToDelete one or more characters to remove from each element
-     * prior to attempting the split operation (typically the quotation mark
-     * symbol), or {@code null} if no removal should occur
-     * @return a {@code Properties} instance representing the array contents, or
-     * {@code null} if the array to process was {@code null} or empty
-     */
-    public static Properties splitArrayElementsIntoProperties(
-            String[] array, String delimiter, String charsToDelete) {
-
-        if (ObjectUtils.isEmpty(array)) {
-            return null;
-        }
-        Properties result = new Properties();
-        for (String element : array) {
-            if (charsToDelete != null) {
-                element = deleteAny(element, charsToDelete);
-            }
-            String[] splittedElement = split(element, delimiter);
-            if (splittedElement == null) {
-                continue;
-            }
-            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());
-        }
-        return result;
-    }
-
-    /**
-     * Tokenize the given {@code String} into a {@code String} array via a
-     * {@link StringTokenizer}.
-     * <p>
-     * Trims tokens and omits empty tokens.
-     * <p>
-     * The given {@code delimiters} string can consist of any number of
-     * delimiter characters. Each of those characters can be used to separate
-     * tokens. A delimiter is always a single character; for multi-character
-     * delimiters, consider using {@link #delimitedListToStringArray}.
-     *
-     * @param str the {@code String} to tokenize
-     * @param delimiters the delimiter characters, assembled as a {@code String}
-     * (each of the characters is individually considered as a delimiter)
-     * @return an array of the tokens
-     * @see java.util.StringTokenizer
-     * @see String#trim()
-     * @see #delimitedListToStringArray
-     */
-    public static String[] tokenizeToStringArray(String str, String delimiters) {
-        return tokenizeToStringArray(str, delimiters, true, true);
-    }
-
-    /**
-     * Tokenize the given {@code String} into a {@code String} array via a
-     * {@link StringTokenizer}.
-     * <p>
-     * The given {@code delimiters} string can consist of any number of
-     * delimiter characters. Each of those characters can be used to separate
-     * tokens. A delimiter is always a single character; for multi-character
-     * delimiters, consider using {@link #delimitedListToStringArray}.
-     *
-     * @param str the {@code String} to tokenize
-     * @param delimiters the delimiter characters, assembled as a {@code String}
-     * (each of the characters is individually considered as a delimiter)
-     * @param trimTokens trim the tokens via {@link String#trim()}
-     * @param ignoreEmptyTokens omit empty tokens from the result array (only
-     * applies to tokens that are empty after trimming; StringTokenizer will not
-     * consider subsequent delimiters as token in the first place).
-     * @return an array of the tokens ({@code null} if the input {@code String}
-     * was {@code null})
-     * @see java.util.StringTokenizer
-     * @see String#trim()
-     * @see #delimitedListToStringArray
-     */
-    public static String[] tokenizeToStringArray(
-            String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {
-
-        if (str == null) {
-            return null;
-        }
-        StringTokenizer st = new StringTokenizer(str, delimiters);
-        List<String> tokens = new ArrayList<>();
-        while (st.hasMoreTokens()) {
-            String token = st.nextToken();
-            if (trimTokens) {
-                token = token.trim();
-            }
-            if (!ignoreEmptyTokens || token.length() > 0) {
-                tokens.add(token);
-            }
-        }
-        return toStringArray(tokens);
-    }
-
-    /**
-     * Take a {@code String} that is a delimited list and convert it into a
-     * {@code String} array.
-     * <p>
-     * A single {@code delimiter} may consist of more than one character, but it
-     * will still be considered as a single delimiter string, rather than as
-     * bunch of potential delimiter characters, in contrast to
-     * {@link #tokenizeToStringArray}.
-     *
-     * @param str the input {@code String}
-     * @param delimiter the delimiter between elements (this is a single
-     * delimiter, rather than a bunch individual delimiter characters)
-     * @return an array of the tokens in the list
-     * @see #tokenizeToStringArray
-     */
-    public static String[] delimitedListToStringArray(String str, String delimiter) {
-        return delimitedListToStringArray(str, delimiter, null);
-    }
-
-    /**
-     * Take a {@code String} that is a delimited list and convert it into a
-     * {@code String} array.
-     * <p>
-     * A single {@code delimiter} may consist of more than one character, but it
-     * will still be considered as a single delimiter string, rather than as
-     * bunch of potential delimiter characters, in contrast to
-     * {@link #tokenizeToStringArray}.
-     *
-     * @param str the input {@code String}
-     * @param delimiter the delimiter between elements (this is a single
-     * delimiter, rather than a bunch individual delimiter characters)
-     * @param charsToDelete a set of characters to delete; useful for deleting
-     * unwanted line breaks: e.g. "\r\n\f" will delete all new lines and line
-     * feeds in a {@code String}
-     * @return an array of the tokens in the list
-     * @see #tokenizeToStringArray
-     */
-    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {
-        if (str == null) {
-            return new String[0];
-        }
-        if (delimiter == null) {
-            return new String[]{str};
-        }
-        List<String> result = new ArrayList<>();
-        if ("".equals(delimiter)) {
-            for (int i = 0; i < str.length(); i++) {
-                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));
-            }
-        } else {
-            int pos = 0;
-            int delPos;
-            while ((delPos = str.indexOf(delimiter, pos)) != -1) {
-                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));
-                pos = delPos + delimiter.length();
-            }
-            if (str.length() > 0 && pos <= str.length()) {
-                // Add rest of String, but not in case of empty input.
-                result.add(deleteAny(str.substring(pos), charsToDelete));
-            }
-        }
-        return toStringArray(result);
-    }
-
-    /**
-     * Convert a comma delimited list (e.g., a row from a CSV file) into an
-     * array of strings.
-     *
-     * @param str the input {@code String}
-     * @return an array of strings, or the empty array in case of empty input
-     */
-    public static String[] commaDelimitedListToStringArray(String str) {
-        return delimitedListToStringArray(str, ",");
-    }
-
-    /**
-     * Convert a comma delimited list (e.g., a row from a CSV file) into a set.
-     * <p>
-     * Note that this will suppress duplicates, and as of 4.2, the elements in
-     * the returned set will preserve the original order in a
-     * {@link LinkedHashSet}.
-     *
-     * @param str the input {@code String}
-     * @return a set of {@code String} entries in the list
-     * @see #removeDuplicateStrings(String[])
-     */
-    public static Set<String> commaDelimitedListToSet(String str) {
-        Set<String> set = new LinkedHashSet<>();
-        String[] tokens = commaDelimitedListToStringArray(str);
-        set.addAll(Arrays.asList(tokens));
-        return set;
-    }
-
-    /**
-     * Convert a {@link Collection} to a delimited {@code String} (e.g. CSV).
-     * <p>
-     * Useful for {@code toString()} implementations.
-     *
-     * @param coll the {@code Collection} to convert
-     * @param delim the delimiter to use (typically a ",")
-     * @param prefix the {@code String} to start each element with
-     * @param suffix the {@code String} to end each element with
-     * @return the delimited {@code String}
-     */
-    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {
-        if (CollectionUtils.isEmpty(coll)) {
-            return "";
-        }
-        StringBuilder sb = new StringBuilder();
-        Iterator<?> it = coll.iterator();
-        while (it.hasNext()) {
-            sb.append(prefix).append(it.next()).append(suffix);
-            if (it.hasNext()) {
-                sb.append(delim);
-            }
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Convert a {@code Collection} into a delimited {@code String} (e.g. CSV).
-     * <p>
-     * Useful for {@code toString()} implementations.
-     *
-     * @param coll the {@code Collection} to convert
-     * @param delim the delimiter to use (typically a ",")
-     * @return the delimited {@code String}
-     */
-    public static String collectionToDelimitedString(Collection<?> coll, String delim) {
-        return collectionToDelimitedString(coll, delim, "", "");
-    }
-
-    /**
-     * Convert a {@code Collection} into a delimited {@code String} (e.g., CSV).
-     * <p>
-     * Useful for {@code toString()} implementations.
-     *
-     * @param coll the {@code Collection} to convert
-     * @return the delimited {@code String}
-     */
-    public static String collectionToCommaDelimitedString(Collection<?> coll) {
-        return collectionToDelimitedString(coll, ",");
-    }
-
-    /**
-     * Convert a {@code String} array into a delimited {@code String} (e.g.
-     * CSV).
-     * <p>
-     * Useful for {@code toString()} implementations.
-     *
-     * @param arr the array to display
-     * @param delim the delimiter to use (typically a ",")
-     * @return the delimited {@code String}
-     */
-    public static String arrayToDelimitedString(Object[] arr, String delim) {
-        if (ObjectUtils.isEmpty(arr)) {
-            return "";
-        }
-        if (arr.length == 1) {
-            return ObjectUtils.nullSafeToString(arr[0]);
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < arr.length; i++) {
-            if (i > 0) {
-                sb.append(delim);
-            }
-            sb.append(arr[i]);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Convert a {@code String} array into a comma delimited {@code String}
-     * (i.e., CSV).
-     * <p>
-     * Useful for {@code toString()} implementations.
-     *
-     * @param arr the array to display
-     * @return the delimited {@code String}
-     */
-    public static String arrayToCommaDelimitedString(Object[] arr) {
-        return arrayToDelimitedString(arr, ",");
-    }
-    
-    public static int levenshtein(CharSequence lhs, CharSequence rhs) {      
-        int[][] distance = new int[lhs.length() + 1][rhs.length() + 1];        
-                                                                                 
-        for (int i = 0; i <= lhs.length(); i++) {                                 
-            distance[i][0] = i;                   
-        }
-        
-        for (int j = 1; j <= rhs.length(); j++) {        
-            distance[0][j] = j;   
-        }                                                                       
-                                                   
-        for (int i = 1; i <= lhs.length(); i++) {
-            for (int j = 1; j <= rhs.length(); j++){                 
-                distance[i][j] = Math.min(
-                    Math.min(
-                            distance[i - 1][j] + 1,
-                            distance[i][j - 1] + 1
-                    ) , distance[i - 1][j - 1] + ((lhs.charAt(i - 1) == rhs.charAt(j - 1)) ? 0 : 1)
-                );
-            }  
-        }     
-        
-        return distance[lhs.length()][rhs.length()];                           
-    }
-    
-    public static String findAlternative(String nonExistant, Collection<String> candidates){
-        return findAlternative(nonExistant, candidates, 3);
-    }
-    
-    public static String findAlternative(String nonExistant, Collection<String> candidates, int force){
-        String alternative = null;
-        Integer shortest = null;
-        for (String name : candidates) {
-            if(name.contains(nonExistant)) {
-                // there is a partial match return it !
-                return name;
-            }
-            
-            int lev = levenshtein(nonExistant, name);
-            
-            if(lev <= nonExistant.length() / force && (alternative == null || lev < shortest)) {
-                alternative = name;
-                shortest = lev;
-            }
-            
-        }
-        
-        return alternative;
-    }
-}
diff --git a/src/utils/Assert.java b/src/utils/Assert.java
deleted file mode 100644
index 44bb3d6..0000000
--- a/src/utils/Assert.java
+++ /dev/null
@@ -1,405 +0,0 @@
-package utils;
-
-import java.util.Collection;
-import java.util.Map;
-
-public abstract class Assert {
-
-    /**
-     * Assert a boolean expression, throwing {@code IllegalArgumentException} if
-     * the test result is {@code false}.
-     * <pre class="code">Assert.isTrue(i &gt; 0, "The value must be greater than
-     * zero");</pre>
-     *
-     * @param expression a boolean expression
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if expression is {@code false}
-     */
-    public static void isTrue(boolean expression, String message) {
-        if (!expression) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert a boolean expression, throwing {@code IllegalArgumentException} if
-     * the test result is {@code false}.
-     * <pre class="code">Assert.isTrue(i &gt; 0);</pre>
-     *
-     * @param expression a boolean expression
-     * @throws IllegalArgumentException if expression is {@code false}
-     */
-    public static void isTrue(boolean expression) {
-        isTrue(expression, "[Assertion failed] - this expression must be true");
-    }
-
-    /**
-     * Assert that an object is {@code null} .
-     * <pre class="code">Assert.isNull(value, "The value must be null");</pre>
-     *
-     * @param object the object to check
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the object is not {@code null}
-     */
-    public static void isNull(Object object, String message) {
-        if (object != null) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that an object is {@code null} .
-     * <pre class="code">Assert.isNull(value);</pre>
-     *
-     * @param object the object to check
-     * @throws IllegalArgumentException if the object is not {@code null}
-     */
-    public static void isNull(Object object) {
-        isNull(object, "[Assertion failed] - the object argument must be null");
-    }
-
-    /**
-     * Assert that an object is not {@code null} .
-     * <pre class="code">Assert.notNull(clazz, "The class must not be
-     * null");</pre>
-     *
-     * @param object the object to check
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the object is {@code null}
-     */
-    public static void notNull(Object object, String message) {
-        if (object == null) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that an object is not {@code null} .
-     * <pre class="code">Assert.notNull(clazz);</pre>
-     *
-     * @param object the object to check
-     * @throws IllegalArgumentException if the object is {@code null}
-     */
-    public static void notNull(Object object) {
-        notNull(object, "[Assertion failed] - this argument is required; it must not be null");
-    }
-
-    /**
-     * Assert that the given String is not empty; that is, it must not be
-     * {@code null} and not the empty String.
-     * <pre class="code">Assert.hasLength(name, "Name must not be empty");</pre>
-     *
-     * @param text the String to check
-     * @param message the exception message to use if the assertion fails
-     * @see StringUtils#hasLength
-     * @throws IllegalArgumentException if the text is empty
-     */
-    public static void hasLength(String text, String message) {
-        if (!StringUtils.hasLength(text)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that the given String is not empty; that is, it must not be
-     * {@code null} and not the empty String.
-     * <pre class="code">Assert.hasLength(name);</pre>
-     *
-     * @param text the String to check
-     * @see StringUtils#hasLength
-     * @throws IllegalArgumentException if the text is empty
-     */
-    public static void hasLength(String text) {
-        String msg = "[Assertion failed] - this String argument must have length; it must not be null or empty";
-        hasLength(text, msg);
-    }
-
-    /**
-     * Assert that the given String has valid text content; that is, it must not
-     * be {@code null} and must contain at least one non-whitespace character.
-     * <pre class="code">Assert.hasText(name, "'name' must not be empty");</pre>
-     *
-     * @param text the String to check
-     * @param message the exception message to use if the assertion fails
-     * @see StringUtils#hasText
-     * @throws IllegalArgumentException if the text does not contain valid text
-     * content
-     */
-    public static void hasText(String text, String message) {
-        if (!StringUtils.hasText(text)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that the given String has valid text content; that is, it must not
-     * be {@code null} and must contain at least one non-whitespace character.
-     * <pre class="code">Assert.hasText(name, "'name' must not be empty");</pre>
-     *
-     * @param text the String to check
-     * @see StringUtils#hasText
-     * @throws IllegalArgumentException if the text does not contain valid text
-     * content
-     */
-    public static void hasText(String text) {
-        hasText(text,
-                "[Assertion failed] - this String argument must have text; it must not be null, empty, or blank");
-    }
-
-    /**
-     * Assert that the given text does not contain the given substring.
-     * <pre class="code">Assert.doesNotContain(name, "rod", "Name must not
-     * contain 'rod'");</pre>
-     *
-     * @param textToSearch the text to search
-     * @param substring the substring to find within the text
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the text contains the substring
-     */
-    public static void doesNotContain(String textToSearch, String substring, String message) {
-        if (StringUtils.hasLength(textToSearch) && StringUtils.hasLength(substring)
-                && textToSearch.contains(substring)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that the given text does not contain the given substring.
-     * <pre class="code">Assert.doesNotContain(name, "rod");</pre>
-     *
-     * @param textToSearch the text to search
-     * @param substring the substring to find within the text
-     * @throws IllegalArgumentException if the text contains the substring
-     */
-    public static void doesNotContain(String textToSearch, String substring) {
-        doesNotContain(textToSearch, substring,
-                "[Assertion failed] - this String argument must not contain the substring [" + substring + "]");
-    }
-
-    /**
-     * Assert that an array has elements; that is, it must not be {@code null}
-     * and must have at least one element.
-     * <pre class="code">Assert.notEmpty(array, "The array must have
-     * elements");</pre>
-     *
-     * @param array the array to check
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the object array is {@code null} or
-     * has no elements
-     */
-    public static void notEmpty(Object[] array, String message) {
-        if (ObjectUtils.isEmpty(array)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that an array has elements; that is, it must not be {@code null}
-     * and must have at least one element.
-     * <pre class="code">Assert.notEmpty(array);</pre>
-     *
-     * @param array the array to check
-     * @throws IllegalArgumentException if the object array is {@code null} or
-     * has no elements
-     */
-    public static void notEmpty(Object[] array) {
-        notEmpty(array, "[Assertion failed] - this array must not be empty: it must contain at least 1 element");
-    }
-
-    /**
-     * Assert that an array has no null elements. Note: Does not complain if the
-     * array is empty!
-     * <pre class="code">Assert.noNullElements(array, "The array must have
-     * non-null elements");</pre>
-     *
-     * @param array the array to check
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the object array contains a
-     * {@code null} element
-     */
-    public static void noNullElements(Object[] array, String message) {
-        if (array != null) {
-            for (Object element : array) {
-                if (element == null) {
-                    throw new IllegalArgumentException(message);
-                }
-            }
-        }
-    }
-
-    /**
-     * Assert that an array has no null elements. Note: Does not complain if the
-     * array is empty!
-     * <pre class="code">Assert.noNullElements(array);</pre>
-     *
-     * @param array the array to check
-     * @throws IllegalArgumentException if the object array contains a
-     * {@code null} element
-     */
-    public static void noNullElements(Object[] array) {
-        noNullElements(array, "[Assertion failed] - this array must not contain any null elements");
-    }
-
-    /**
-     * Assert that a collection has elements; that is, it must not be
-     * {@code null} and must have at least one element.
-     * <pre class="code">Assert.notEmpty(collection, "Collection must have
-     * elements");</pre>
-     *
-     * @param collection the collection to check
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the collection is {@code null} or has
-     * no elements
-     */
-    public static void notEmpty(Collection<?> collection, String message) {
-        if (CollectionUtils.isEmpty(collection)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that a collection has elements; that is, it must not be
-     * {@code null} and must have at least one element.
-     * <pre class="code">Assert.notEmpty(collection, "Collection must have
-     * elements");</pre>
-     *
-     * @param collection the collection to check
-     * @throws IllegalArgumentException if the collection is {@code null} or has
-     * no elements
-     */
-    public static void notEmpty(Collection<?> collection) {
-        notEmpty(collection,
-                "[Assertion failed] - this collection must not be empty: it must contain at least 1 element");
-    }
-
-    /**
-     * Assert that a Map has entries; that is, it must not be {@code null} and
-     * must have at least one entry.
-     * <pre class="code">Assert.notEmpty(map, "Map must have entries");</pre>
-     *
-     * @param map the map to check
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalArgumentException if the map is {@code null} or has no
-     * entries
-     */
-    public static void notEmpty(Map<?, ?> map, String message) {
-        if (CollectionUtils.isEmpty(map)) {
-            throw new IllegalArgumentException(message);
-        }
-    }
-
-    /**
-     * Assert that a Map has entries; that is, it must not be {@code null} and
-     * must have at least one entry.
-     * <pre class="code">Assert.notEmpty(map);</pre>
-     *
-     * @param map the map to check
-     * @throws IllegalArgumentException if the map is {@code null} or has no
-     * entries
-     */
-    public static void notEmpty(Map<?, ?> map) {
-        notEmpty(map, "[Assertion failed] - this map must not be empty; it must contain at least one entry");
-    }
-
-    /**
-     * Assert that the provided object is an instance of the provided class.
-     * <pre class="code">Assert.instanceOf(Foo.class, foo);</pre>
-     *
-     * @param clazz the required class
-     * @param obj the object to check
-     * @throws IllegalArgumentException if the object is not an instance of
-     * clazz
-     * @see Class#isInstance
-     */
-    public static void isInstanceOf(Class<?> clazz, Object obj) {
-        isInstanceOf(clazz, obj, "");
-    }
-
-    /**
-     * Assert that the provided object is an instance of the provided class.
-     * <pre class="code">Assert.instanceOf(Foo.class, foo);</pre>
-     *
-     * @param type the type to check against
-     * @param obj the object to check
-     * @param message a message which will be prepended to the message produced
-     * by the function itself, and which may be used to provide context. It
-     * should normally end in ":" or "." so that the generated message looks OK
-     * when appended to it.
-     * @throws IllegalArgumentException if the object is not an instance of
-     * clazz
-     * @see Class#isInstance
-     */
-    public static void isInstanceOf(Class<?> type, Object obj, String message) {
-        notNull(type, "Type to check against must not be null");
-        if (!type.isInstance(obj)) {
-            throw new IllegalArgumentException(
-                    (StringUtils.hasLength(message) ? message + " " : "")
-                    + "Object of class [" + (obj != null ? obj.getClass().getName() : "null")
-                    + "] must be an instance of " + type);
-        }
-    }
-
-    /**
-     * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.
-     * <pre class="code">Assert.isAssignable(Number.class, myClass);</pre>
-     *
-     * @param superType the super type to check
-     * @param subType the sub type to check
-     * @throws IllegalArgumentException if the classes are not assignable
-     */
-    public static void isAssignable(Class<?> superType, Class<?> subType) {
-        isAssignable(superType, subType, "");
-    }
-
-    /**
-     * Assert that {@code superType.isAssignableFrom(subType)} is {@code true}.
-     * <pre class="code">Assert.isAssignable(Number.class, myClass);</pre>
-     *
-     * @param superType the super type to check against
-     * @param subType the sub type to check
-     * @param message a message which will be prepended to the message produced
-     * by the function itself, and which may be used to provide context. It
-     * should normally end in ":" or "." so that the generated message looks OK
-     * when appended to it.
-     * @throws IllegalArgumentException if the classes are not assignable
-     */
-    public static void isAssignable(Class<?> superType, Class<?> subType, String message) {
-        notNull(superType, "Type to check against must not be null");
-        if (subType == null || !superType.isAssignableFrom(subType)) {
-            throw new IllegalArgumentException((StringUtils.hasLength(message) ? message + " " : "")
-                    + subType + " is not assignable to " + superType);
-        }
-    }
-
-    /**
-     * Assert a boolean expression, throwing {@code IllegalStateException} if
-     * the test result is {@code false}. Call isTrue if you wish to throw
-     * IllegalArgumentException on an assertion failure.
-     * <pre class="code">Assert.state(id == null, "The id property must not
-     * already be initialized");</pre>
-     *
-     * @param expression a boolean expression
-     * @param message the exception message to use if the assertion fails
-     * @throws IllegalStateException if expression is {@code false}
-     */
-    public static void state(boolean expression, String message) {
-        if (!expression) {
-            throw new IllegalStateException(message);
-        }
-    }
-
-    /**
-     * Assert a boolean expression, throwing {@link IllegalStateException} if
-     * the test result is {@code false}.
-     * <p>
-     * Call {@link #isTrue(boolean)} if you wish to throw
-     * {@link IllegalArgumentException} on an assertion failure.
-     * <pre class="code">Assert.state(id == null);</pre>
-     *
-     * @param expression a boolean expression
-     * @throws IllegalStateException if the supplied expression is {@code false}
-     */
-    public static void state(boolean expression) {
-        state(expression, "[Assertion failed] - this state invariant must be true");
-    }
-}
diff --git a/src/utils/ClassUtils.java b/src/utils/ClassUtils.java
deleted file mode 100644
index bed9875..0000000
--- a/src/utils/ClassUtils.java
+++ /dev/null
@@ -1,1313 +0,0 @@
-/*
- * To change this license header, choose License Headers in Project Properties.
- * To change this template file, choose Tools | Templates
- * and open the template in the editor.
- */
-package utils;
-
-import java.beans.Introspector;
-import java.lang.reflect.Array;
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.Proxy;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.HashMap;
-import java.util.HashSet;
-import java.util.IdentityHashMap;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.Map;
-import java.util.Set;
-
-/**
- *
- * @author cdi305
- */
-public abstract class ClassUtils {
-
-    /**
-     * Suffix for array class names: "[]"
-     */
-    public static final String ARRAY_SUFFIX = "[]";
-
-    /**
-     * Prefix for internal array class names: "["
-     */
-    private static final String INTERNAL_ARRAY_PREFIX = "[";
-
-    /**
-     * Prefix for internal non-primitive array class names: "[L"
-     */
-    private static final String NON_PRIMITIVE_ARRAY_PREFIX = "[L";
-
-    /**
-     * The package separator character '.'
-     */
-    private static final char PACKAGE_SEPARATOR = '.';
-
-    /**
-     * The path separator character '/'
-     */
-    private static final char PATH_SEPARATOR = '/';
-
-    /**
-     * The inner class separator character '$'
-     */
-    private static final char INNER_CLASS_SEPARATOR = '$';
-
-    /**
-     * The CGLIB class separator character "$$"
-     */
-    public static final String CGLIB_CLASS_SEPARATOR = "$$";
-
-    /**
-     * The ".class" file suffix
-     */
-    public static final String CLASS_FILE_SUFFIX = ".class";
-
-    /**
-     * Map with primitive wrapper type as key and corresponding primitive type
-     * as value, for example: Integer.class -> int.class.
-     */
-    private static final Map<Class<?>, Class<?>> primitiveWrapperTypeMap = new IdentityHashMap<>(8);
-
-    /**
-     * Map with primitive type as key and corresponding wrapper type as value,
-     * for example: int.class -> Integer.class.
-     */
-    private static final Map<Class<?>, Class<?>> primitiveTypeToWrapperMap = new IdentityHashMap<>(8);
-
-    /**
-     * Map with primitive type name as key and corresponding primitive type as
-     * value, for example: "int" -> "int.class".
-     */
-    private static final Map<String, Class<?>> primitiveTypeNameMap = new HashMap<>(32);
-
-    /**
-     * Map with common "java.lang" class name as key and corresponding Class as
-     * value. Primarily for efficient deserialization of remote invocations.
-     */
-    private static final Map<String, Class<?>> commonClassCache = new HashMap<>(32);
-
-    static {
-        primitiveWrapperTypeMap.put(Boolean.class, boolean.class);
-        primitiveWrapperTypeMap.put(Byte.class, byte.class);
-        primitiveWrapperTypeMap.put(Character.class, char.class);
-        primitiveWrapperTypeMap.put(Double.class, double.class);
-        primitiveWrapperTypeMap.put(Float.class, float.class);
-        primitiveWrapperTypeMap.put(Integer.class, int.class);
-        primitiveWrapperTypeMap.put(Long.class, long.class);
-        primitiveWrapperTypeMap.put(Short.class, short.class);
-
-        primitiveWrapperTypeMap.entrySet().stream().map((entry) -> {
-            primitiveTypeToWrapperMap.put(entry.getValue(), entry.getKey());
-            return entry;
-        }).forEach((entry) -> {
-            registerCommonClasses(entry.getKey());
-        });
-
-        Set<Class<?>> primitiveTypes = new HashSet<>(32);
-        primitiveTypes.addAll(primitiveWrapperTypeMap.values());
-        primitiveTypes.addAll(Arrays.asList(new Class<?>[]{
-            boolean[].class, byte[].class, char[].class, double[].class,
-            float[].class, int[].class, long[].class, short[].class}));
-        primitiveTypes.add(void.class);
-        
-        primitiveTypes.stream().forEach((primitiveType) -> {
-            primitiveTypeNameMap.put(primitiveType.getName(), primitiveType);
-        });
-
-        registerCommonClasses(Boolean[].class, Byte[].class, Character[].class, Double[].class,
-                Float[].class, Integer[].class, Long[].class, Short[].class);
-        registerCommonClasses(Number.class, Number[].class, String.class, String[].class,
-                Object.class, Object[].class, Class.class, Class[].class);
-        registerCommonClasses(Throwable.class, Exception.class, RuntimeException.class,
-                Error.class, StackTraceElement.class, StackTraceElement[].class);
-    }
-
-    /**
-     * Register the given common classes with the ClassUtils cache.
-     */
-    private static void registerCommonClasses(Class<?>... commonClasses) {
-        for (Class<?> clazz : commonClasses) {
-            commonClassCache.put(clazz.getName(), clazz);
-        }
-    }
-
-    /**
-     * Return the default ClassLoader to use: typically the thread context
-     * ClassLoader, if available; the ClassLoader that loaded the ClassUtils
-     * class will be used as fallback.
-     * <p>
-     * Call this method if you intend to use the thread context ClassLoader in a
-     * scenario where you clearly prefer a non-null ClassLoader reference: for
-     * example, for class path resource loading (but not necessarily for
-     * {@code Class.forName}, which accepts a {@code null} ClassLoader reference
-     * as well).
-     *
-     * @return the default ClassLoader (only {@code null} if even the system
-     * ClassLoader isn't accessible)
-     * @see Thread#getContextClassLoader()
-     * @see ClassLoader#getSystemClassLoader()
-     */
-    public static ClassLoader getDefaultClassLoader() {
-        ClassLoader cl = null;
-        try {
-            cl = Thread.currentThread().getContextClassLoader();
-        } catch (Throwable ex) {
-            // Cannot access thread context ClassLoader - falling back...
-        }
-        if (cl == null) {
-            // No thread context class loader -> use class loader of this class.
-            cl = ClassUtils.class.getClassLoader();
-            if (cl == null) {
-                // getClassLoader() returning null indicates the bootstrap ClassLoader
-                try {
-                    cl = ClassLoader.getSystemClassLoader();
-                } catch (Throwable ex) {
-                    // Cannot access system ClassLoader - oh well, maybe the caller can live with null...
-                }
-            }
-        }
-        return cl;
-    }
-
-    /**
-     * Override the thread context ClassLoader with the environment's bean
-     * ClassLoader if necessary, i.e. if the bean ClassLoader is not equivalent
-     * to the thread context ClassLoader already.
-     *
-     * @param classLoaderToUse the actual ClassLoader to use for the thread
-     * context
-     * @return the original thread context ClassLoader, or {@code null} if not
-     * overridden
-     */
-    public static ClassLoader overrideThreadContextClassLoader(ClassLoader classLoaderToUse) {
-        Thread currentThread = Thread.currentThread();
-        ClassLoader threadContextClassLoader = currentThread.getContextClassLoader();
-        if (classLoaderToUse != null && !classLoaderToUse.equals(threadContextClassLoader)) {
-            currentThread.setContextClassLoader(classLoaderToUse);
-            return threadContextClassLoader;
-        } else {
-            return null;
-        }
-    }
-
-    /**
-     * Replacement for {@code Class.forName()} that also returns Class instances
-     * for primitives (e.g. "int") and array class names (e.g. "String[]").
-     * Furthermore, it is also capable of resolving inner class names in Java
-     * source style (e.g. "java.lang.Thread.State" instead of
-     * "java.lang.Thread$State").
-     *
-     * @param name the name of the Class
-     * @param classLoader the class loader to use (may be {@code null}, which
-     * indicates the default class loader)
-     * @return Class instance for the supplied name
-     * @throws ClassNotFoundException if the class was not found
-     * @throws LinkageError if the class file could not be loaded
-     * @see Class#forName(String, boolean, ClassLoader)
-     */
-    public static Class<?> forName(String name, ClassLoader classLoader) throws ClassNotFoundException, LinkageError {
-        Assert.notNull(name, "Name must not be null");
-
-        Class<?> clazz = resolvePrimitiveClassName(name);
-        if (clazz == null) {
-            clazz = commonClassCache.get(name);
-        }
-        if (clazz != null) {
-            return clazz;
-        }
-
-        // "java.lang.String[]" style arrays
-        if (name.endsWith(ARRAY_SUFFIX)) {
-            String elementClassName = name.substring(0, name.length() - ARRAY_SUFFIX.length());
-            Class<?> elementClass = forName(elementClassName, classLoader);
-            return Array.newInstance(elementClass, 0).getClass();
-        }
-
-        // "[Ljava.lang.String;" style arrays
-        if (name.startsWith(NON_PRIMITIVE_ARRAY_PREFIX) && name.endsWith(";")) {
-            String elementName = name.substring(NON_PRIMITIVE_ARRAY_PREFIX.length(), name.length() - 1);
-            Class<?> elementClass = forName(elementName, classLoader);
-            return Array.newInstance(elementClass, 0).getClass();
-        }
-
-        // "[[I" or "[[Ljava.lang.String;" style arrays
-        if (name.startsWith(INTERNAL_ARRAY_PREFIX)) {
-            String elementName = name.substring(INTERNAL_ARRAY_PREFIX.length());
-            Class<?> elementClass = forName(elementName, classLoader);
-            return Array.newInstance(elementClass, 0).getClass();
-        }
-
-        ClassLoader clToUse = classLoader;
-        if (clToUse == null) {
-            clToUse = getDefaultClassLoader();
-        }
-        try {
-            return (clToUse != null ? clToUse.loadClass(name) : Class.forName(name));
-        } catch (ClassNotFoundException ex) {
-            int lastDotIndex = name.lastIndexOf(PACKAGE_SEPARATOR);
-            if (lastDotIndex != -1) {
-                String innerClassName
-                        = name.substring(0, lastDotIndex) + INNER_CLASS_SEPARATOR + name.substring(lastDotIndex + 1);
-                try {
-                    return (clToUse != null ? clToUse.loadClass(innerClassName) : Class.forName(innerClassName));
-                } catch (ClassNotFoundException ex2) {
-                    // Swallow - let original exception get through
-                }
-            }
-            throw ex;
-        }
-    }
-
-    /**
-     * Resolve the given class name into a Class instance. Supports primitives
-     * (like "int") and array class names (like "String[]").
-     * <p>
-     * This is effectively equivalent to the {@code forName} method with the
-     * same arguments, with the only difference being the exceptions thrown in
-     * case of class loading failure.
-     *
-     * @param className the name of the Class
-     * @param classLoader the class loader to use (may be {@code null}, which
-     * indicates the default class loader)
-     * @return Class instance for the supplied name
-     * @throws IllegalArgumentException if the class name was not resolvable
-     * (that is, the class could not be found or the class file could not be
-     * loaded)
-     * @see #forName(String, ClassLoader)
-     */
-    public static Class<?> resolveClassName(String className, ClassLoader classLoader) throws IllegalArgumentException {
-        try {
-            return forName(className, classLoader);
-        } catch (ClassNotFoundException ex) {
-            throw new IllegalArgumentException("Cannot find class [" + className + "]", ex);
-        } catch (LinkageError ex) {
-            throw new IllegalArgumentException(
-                    "Error loading class [" + className + "]: problem with class file or dependent class.", ex);
-        }
-    }
-
-    /**
-     * Resolve the given class name as primitive class, if appropriate,
-     * according to the JVM's naming rules for primitive classes.
-     * <p>
-     * Also supports the JVM's internal class names for primitive arrays. Does
-     * <i>not</i> support the "[]" suffix notation for primitive arrays; this is
-     * only supported by {@link #forName(String, ClassLoader)}.
-     *
-     * @param name the name of the potentially primitive class
-     * @return the primitive class, or {@code null} if the name does not denote
-     * a primitive class or primitive array class
-     */
-    public static Class<?> resolvePrimitiveClassName(String name) {
-        Class<?> result = null;
-		// Most class names will be quite long, considering that they
-        // SHOULD sit in a package, so a length check is worthwhile.
-        if (name != null && name.length() <= 8) {
-            // Could be a primitive - likely.
-            result = primitiveTypeNameMap.get(name);
-        }
-        return result;
-    }
-
-    /**
-     * Determine whether the {@link Class} identified by the supplied name is
-     * present and can be loaded. Will return {@code false} if either the class
-     * or one of its dependencies is not present or cannot be loaded.
-     *
-     * @param className the name of the class to check
-     * @param classLoader the class loader to use (may be {@code null}, which
-     * indicates the default class loader)
-     * @return whether the specified class is present
-     */
-    public static boolean isPresent(String className, ClassLoader classLoader) {
-        try {
-            forName(className, classLoader);
-            return true;
-        } catch (ClassNotFoundException | LinkageError ex) {
-            // Class or one of its dependencies is not present...
-            return false;
-        }
-    }
-
-    /**
-     * Return the user-defined class for the given instance: usually simply the
-     * class of the given instance, but the original class in case of a
-     * CGLIB-generated subclass.
-     *
-     * @param instance the instance to check
-     * @return the user-defined class
-     */
-    public static Class<?> getUserClass(Object instance) {
-        Assert.notNull(instance, "Instance must not be null");
-        return getUserClass(instance.getClass());
-    }
-
-    /**
-     * Return the user-defined class for the given class: usually simply the
-     * given class, but the original class in case of a CGLIB-generated
-     * subclass.
-     *
-     * @param clazz the class to check
-     * @return the user-defined class
-     */
-    public static Class<?> getUserClass(Class<?> clazz) {
-        if (clazz != null && clazz.getName().contains(CGLIB_CLASS_SEPARATOR)) {
-            Class<?> superclass = clazz.getSuperclass();
-            if (superclass != null && Object.class != superclass) {
-                return superclass;
-            }
-        }
-        return clazz;
-    }
-
-    /**
-     * Check whether the given class is cache-safe in the given context, i.e.
-     * whether it is loaded by the given ClassLoader or a parent of it.
-     *
-     * @param clazz the class to analyze
-     * @param classLoader the ClassLoader to potentially cache metadata in
-     * @return 
-     */
-    public static boolean isCacheSafe(Class<?> clazz, ClassLoader classLoader) {
-        Assert.notNull(clazz, "Class must not be null");
-        try {
-            ClassLoader target = clazz.getClassLoader();
-            if (target == null) {
-                return true;
-            }
-            ClassLoader cur = classLoader;
-            if (cur == target) {
-                return true;
-            }
-            while (cur != null) {
-                cur = cur.getParent();
-                if (cur == target) {
-                    return true;
-                }
-            }
-            return false;
-        } catch (SecurityException ex) {
-            // Probably from the system ClassLoader - let's consider it safe.
-            return true;
-        }
-    }
-
-    /**
-     * Get the class name without the qualified package name.
-     *
-     * @param className the className to get the short name for
-     * @return the class name of the class without the package name
-     * @throws IllegalArgumentException if the className is empty
-     */
-    public static String getShortName(String className) {
-        Assert.hasLength(className, "Class name must not be empty");
-        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);
-        int nameEndIndex = className.indexOf(CGLIB_CLASS_SEPARATOR);
-        if (nameEndIndex == -1) {
-            nameEndIndex = className.length();
-        }
-        String shortName = className.substring(lastDotIndex + 1, nameEndIndex);
-        shortName = shortName.replace(INNER_CLASS_SEPARATOR, PACKAGE_SEPARATOR);
-        return shortName;
-    }
-
-    /**
-     * Get the class name without the qualified package name.
-     *
-     * @param clazz the class to get the short name for
-     * @return the class name of the class without the package name
-     */
-    public static String getShortName(Class<?> clazz) {
-        return getShortName(getQualifiedName(clazz));
-    }
-
-    /**
-     * Return the short string name of a Java class in uncapitalized JavaBeans
-     * property format. Strips the outer class name in case of an inner class.
-     *
-     * @param clazz the class
-     * @return the short name rendered in a standard JavaBeans property format
-     * @see java.beans.Introspector#decapitalize(String)
-     */
-    public static String getShortNameAsProperty(Class<?> clazz) {
-        String shortName = getShortName(clazz);
-        int dotIndex = shortName.lastIndexOf(PACKAGE_SEPARATOR);
-        shortName = (dotIndex != -1 ? shortName.substring(dotIndex + 1) : shortName);
-        return Introspector.decapitalize(shortName);
-    }
-
-    /**
-     * Determine the name of the class file, relative to the containing package:
-     * e.g. "String.class"
-     *
-     * @param clazz the class
-     * @return the file name of the ".class" file
-     */
-    public static String getClassFileName(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        String className = clazz.getName();
-        int lastDotIndex = className.lastIndexOf(PACKAGE_SEPARATOR);
-        return className.substring(lastDotIndex + 1) + CLASS_FILE_SUFFIX;
-    }
-
-    /**
-     * Determine the name of the package of the given class, e.g. "java.lang"
-     * for the {@code java.lang.String} class.
-     *
-     * @param clazz the class
-     * @return the package name, or the empty String if the class is defined in
-     * the default package
-     */
-    public static String getPackageName(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        return getPackageName(clazz.getName());
-    }
-
-    /**
-     * Determine the name of the package of the given fully-qualified class
-     * name, e.g. "java.lang" for the {@code java.lang.String} class name.
-     *
-     * @param fqClassName the fully-qualified class name
-     * @return the package name, or the empty String if the class is defined in
-     * the default package
-     */
-    public static String getPackageName(String fqClassName) {
-        Assert.notNull(fqClassName, "Class name must not be null");
-        int lastDotIndex = fqClassName.lastIndexOf(PACKAGE_SEPARATOR);
-        return (lastDotIndex != -1 ? fqClassName.substring(0, lastDotIndex) : "");
-    }
-
-    /**
-     * Return the qualified name of the given class: usually simply the class
-     * name, but component type class name + "[]" for arrays.
-     *
-     * @param clazz the class
-     * @return the qualified name of the class
-     */
-    public static String getQualifiedName(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        if (clazz.isArray()) {
-            return getQualifiedNameForArray(clazz);
-        } else {
-            return clazz.getName();
-        }
-    }
-
-    /**
-     * Build a nice qualified name for an array: component type class name +
-     * "[]".
-     *
-     * @param clazz the array class
-     * @return a qualified name for the array class
-     */
-    private static String getQualifiedNameForArray(Class<?> clazz) {
-        StringBuilder result = new StringBuilder();
-        while (clazz.isArray()) {
-            clazz = clazz.getComponentType();
-            result.append(ARRAY_SUFFIX);
-        }
-        result.insert(0, clazz.getName());
-        return result.toString();
-    }
-
-    /**
-     * Return the qualified name of the given method, consisting of fully
-     * qualified interface/class name + "." + method name.
-     *
-     * @param method the method
-     * @return the qualified name of the method
-     */
-    public static String getQualifiedMethodName(Method method) {
-        Assert.notNull(method, "Method must not be null");
-        return method.getDeclaringClass().getName() + "." + method.getName();
-    }
-
-    /**
-     * Return a descriptive name for the given object's type: usually simply the
-     * class name, but component type class name + "[]" for arrays, and an
-     * appended list of implemented interfaces for JDK proxies.
-     *
-     * @param value the value to introspect
-     * @return the qualified name of the class
-     */
-    public static String getDescriptiveType(Object value) {
-        if (value == null) {
-            return null;
-        }
-        Class<?> clazz = value.getClass();
-        if (Proxy.isProxyClass(clazz)) {
-            StringBuilder result = new StringBuilder(clazz.getName());
-            result.append(" implementing ");
-            Class<?>[] ifcs = clazz.getInterfaces();
-            for (int i = 0; i < ifcs.length; i++) {
-                result.append(ifcs[i].getName());
-                if (i < ifcs.length - 1) {
-                    result.append(',');
-                }
-            }
-            return result.toString();
-        } else if (clazz.isArray()) {
-            return getQualifiedNameForArray(clazz);
-        } else {
-            return clazz.getName();
-        }
-    }
-
-    /**
-     * Check whether the given class matches the user-specified type name.
-     *
-     * @param clazz the class to check
-     * @param typeName the type name to match
-     * @return 
-     */
-    public static boolean matchesTypeName(Class<?> clazz, String typeName) {
-        return (typeName != null
-                && (typeName.equals(clazz.getName()) || typeName.equals(clazz.getSimpleName())
-                || (clazz.isArray() && typeName.equals(getQualifiedNameForArray(clazz)))));
-    }
-
-    /**
-     * Determine whether the given class has a public constructor with the given
-     * signature.
-     * <p>
-     * Essentially translates {@code NoSuchMethodException} to "false".
-     *
-     * @param clazz the clazz to analyze
-     * @param paramTypes the parameter types of the method
-     * @return whether the class has a corresponding constructor
-     * @see Class#getMethod
-     */
-    public static boolean hasConstructor(Class<?> clazz, Class<?>... paramTypes) {
-        return (getConstructorIfAvailable(clazz, paramTypes) != null);
-    }
-
-    /**
-     * Determine whether the given class has a public constructor with the given
-     * signature, and return it if available (else return {@code null}).
-     * <p>
-     * Essentially translates {@code NoSuchMethodException} to {@code null}.
-     *
-     * @param <T>
-     * @param clazz the clazz to analyze
-     * @param paramTypes the parameter types of the method
-     * @return the constructor, or {@code null} if not found
-     * @see Class#getConstructor
-     */
-    public static <T> Constructor<T> getConstructorIfAvailable(Class<T> clazz, Class<?>... paramTypes) {
-        Assert.notNull(clazz, "Class must not be null");
-        try {
-            return clazz.getConstructor(paramTypes);
-        } catch (NoSuchMethodException ex) {
-            return null;
-        }
-    }
-
-    /**
-     * Determine whether the given class has a public method with the given
-     * signature.
-     * <p>
-     * Essentially translates {@code NoSuchMethodException} to "false".
-     *
-     * @param clazz the clazz to analyze
-     * @param methodName the name of the method
-     * @param paramTypes the parameter types of the method
-     * @return whether the class has a corresponding method
-     * @see Class#getMethod
-     */
-    public static boolean hasMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {
-        return (getMethodIfAvailable(clazz, methodName, paramTypes) != null);
-    }
-
-    /**
-     * Determine whether the given class has a public method with the given
-     * signature, and return it if available (else throws an
-     * {@code IllegalStateException}).
-     * <p>
-     * In case of any signature specified, only returns the method if there is a
-     * unique candidate, i.e. a single public method with the specified name.
-     * <p>
-     * Essentially translates {@code NoSuchMethodException} to
-     * {@code IllegalStateException}.
-     *
-     * @param clazz the clazz to analyze
-     * @param methodName the name of the method
-     * @param paramTypes the parameter types of the method (may be {@code null}
-     * to indicate any signature)
-     * @return the method (never {@code null})
-     * @throws IllegalStateException if the method has not been found
-     * @see Class#getMethod
-     */
-    public static Method getMethod(Class<?> clazz, String methodName, Class<?>... paramTypes) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.notNull(methodName, "Method name must not be null");
-        if (paramTypes != null) {
-            try {
-                return clazz.getMethod(methodName, paramTypes);
-            } catch (NoSuchMethodException ex) {
-                throw new IllegalStateException("Expected method not found: " + ex);
-            }
-        } else {
-            Set<Method> candidates = new HashSet<>(1);
-            Method[] methods = clazz.getMethods();
-            for (Method method : methods) {
-                if (methodName.equals(method.getName())) {
-                    candidates.add(method);
-                }
-            }
-            if (candidates.size() == 1) {
-                return candidates.iterator().next();
-            } else if (candidates.isEmpty()) {
-                throw new IllegalStateException("Expected method not found: " + clazz + "." + methodName);
-            } else {
-                throw new IllegalStateException("No unique method found: " + clazz + "." + methodName);
-            }
-        }
-    }
-
-    /**
-     * Determine whether the given class has a public method with the given
-     * signature, and return it if available (else return {@code null}).
-     * <p>
-     * In case of any signature specified, only returns the method if there is a
-     * unique candidate, i.e. a single public method with the specified name.
-     * <p>
-     * Essentially translates {@code NoSuchMethodException} to {@code null}.
-     *
-     * @param clazz the clazz to analyze
-     * @param methodName the name of the method
-     * @param paramTypes the parameter types of the method (may be {@code null}
-     * to indicate any signature)
-     * @return the method, or {@code null} if not found
-     * @see Class#getMethod
-     */
-    public static Method getMethodIfAvailable(Class<?> clazz, String methodName, Class<?>... paramTypes) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.notNull(methodName, "Method name must not be null");
-        if (paramTypes != null) {
-            try {
-                return clazz.getMethod(methodName, paramTypes);
-            } catch (NoSuchMethodException ex) {
-                return null;
-            }
-        } else {
-            Set<Method> candidates = new HashSet<>(1);
-            Method[] methods = clazz.getMethods();
-            for (Method method : methods) {
-                if (methodName.equals(method.getName())) {
-                    candidates.add(method);
-                }
-            }
-            if (candidates.size() == 1) {
-                return candidates.iterator().next();
-            }
-            return null;
-        }
-    }
-
-    /**
-     * Return the number of methods with a given name (with any argument types),
-     * for the given class and/or its superclasses. Includes non-public methods.
-     *
-     * @param clazz	the clazz to check
-     * @param methodName the name of the method
-     * @return the number of methods with the given name
-     */
-    public static int getMethodCountForName(Class<?> clazz, String methodName) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.notNull(methodName, "Method name must not be null");
-        int count = 0;
-        Method[] declaredMethods = clazz.getDeclaredMethods();
-        for (Method method : declaredMethods) {
-            if (methodName.equals(method.getName())) {
-                count++;
-            }
-        }
-        Class<?>[] ifcs = clazz.getInterfaces();
-        for (Class<?> ifc : ifcs) {
-            count += getMethodCountForName(ifc, methodName);
-        }
-        if (clazz.getSuperclass() != null) {
-            count += getMethodCountForName(clazz.getSuperclass(), methodName);
-        }
-        return count;
-    }
-
-    /**
-     * Does the given class or one of its superclasses at least have one or more
-     * methods with the supplied name (with any argument types)? Includes
-     * non-public methods.
-     *
-     * @param clazz	the clazz to check
-     * @param methodName the name of the method
-     * @return whether there is at least one method with the given name
-     */
-    public static boolean hasAtLeastOneMethodWithName(Class<?> clazz, String methodName) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.notNull(methodName, "Method name must not be null");
-        Method[] declaredMethods = clazz.getDeclaredMethods();
-        for (Method method : declaredMethods) {
-            if (method.getName().equals(methodName)) {
-                return true;
-            }
-        }
-        Class<?>[] ifcs = clazz.getInterfaces();
-        for (Class<?> ifc : ifcs) {
-            if (hasAtLeastOneMethodWithName(ifc, methodName)) {
-                return true;
-            }
-        }
-        return (clazz.getSuperclass() != null && hasAtLeastOneMethodWithName(clazz.getSuperclass(), methodName));
-    }
-
-    /**
-     * Given a method, which may come from an interface, and a target class used
-     * in the current reflective invocation, find the corresponding target
-     * method if there is one. E.g. the method may be {@code IFoo.bar()} and the
-     * target class may be {@code DefaultFoo}. In this case, the method may be
-     * {@code DefaultFoo.bar()}. This enables attributes on that method to be
-     * found.
-     * <p>
-     * <b>NOTE:</b> In contrast to
-     * {@link org.springframework.aop.support.AopUtils#getMostSpecificMethod},
-     * this method does <i>not</i> resolve Java 5 bridge methods automatically.
-     * Call
-     * {@link org.springframework.core.BridgeMethodResolver#findBridgedMethod}
-     * if bridge method resolution is desirable (e.g. for obtaining metadata
-     * from the original method definition).
-     * <p>
-     * <b>NOTE:</b> Since Spring 3.1.1, if Java security settings disallow
-     * reflective access (e.g. calls to {@code Class#getDeclaredMethods} etc,
-     * this implementation will fall back to returning the originally provided
-     * method.
-     *
-     * @param method the method to be invoked, which may come from an interface
-     * @param targetClass the target class for the current invocation. May be
-     * {@code null} or may not even implement the method.
-     * @return the specific target method, or the original method if the
-     * {@code targetClass} doesn't implement it or is {@code null}
-     */
-    public static Method getMostSpecificMethod(Method method, Class<?> targetClass) {
-        if (method != null && isOverridable(method, targetClass)
-                && targetClass != null && targetClass != method.getDeclaringClass()) {
-            try {
-                if (Modifier.isPublic(method.getModifiers())) {
-                    try {
-                        return targetClass.getMethod(method.getName(), method.getParameterTypes());
-                    } catch (NoSuchMethodException ex) {
-                        return method;
-                    }
-                } else {
-                    Method specificMethod
-                            = ReflectionUtils.findMethod(targetClass, method.getName(), method.getParameterTypes());
-                    return (specificMethod != null ? specificMethod : method);
-                }
-            } catch (SecurityException ex) {
-                // Security settings are disallowing reflective access; fall back to 'method' below.
-            }
-        }
-        return method;
-    }
-
-    /**
-     * Determine whether the given method is declared by the user or at least
-     * pointing to a user-declared method.
-     * <p>
-     * Checks {@link Method#isSynthetic()} (for implementation methods) as well
-     * as the {@code GroovyObject} interface (for interface methods; on an
-     * implementation class, implementations of the {@code GroovyObject} methods
-     * will be marked as synthetic anyway). Note that, despite being synthetic,
-     * bridge methods ({@link Method#isBridge()}) are considered as user-level
-     * methods since they are eventually pointing to a user-declared generic
-     * method.
-     *
-     * @param method the method to check
-     * @return {@code true} if the method can be considered as user-declared;
-     * [@code false} otherwise
-     */
-    public static boolean isUserLevelMethod(Method method) {
-        Assert.notNull(method, "Method must not be null");
-        return (method.isBridge() || (!method.isSynthetic() && !isGroovyObjectMethod(method)));
-    }
-
-    private static boolean isGroovyObjectMethod(Method method) {
-        return method.getDeclaringClass().getName().equals("groovy.lang.GroovyObject");
-    }
-
-    /**
-     * Determine whether the given method is overridable in the given target
-     * class.
-     *
-     * @param method the method to check
-     * @param targetClass the target class to check against
-     */
-    private static boolean isOverridable(Method method, Class<?> targetClass) {
-        if (Modifier.isPrivate(method.getModifiers())) {
-            return false;
-        }
-        if (Modifier.isPublic(method.getModifiers()) || Modifier.isProtected(method.getModifiers())) {
-            return true;
-        }
-        return getPackageName(method.getDeclaringClass()).equals(getPackageName(targetClass));
-    }
-
-    /**
-     * Return a public static method of a class.
-     *
-     * @param clazz the class which defines the method
-     * @param methodName the static method name
-     * @param args the parameter types to the method
-     * @return the static method, or {@code null} if no static method was found
-     * @throws IllegalArgumentException if the method name is blank or the clazz
-     * is null
-     */
-    public static Method getStaticMethod(Class<?> clazz, String methodName, Class<?>... args) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.notNull(methodName, "Method name must not be null");
-        try {
-            Method method = clazz.getMethod(methodName, args);
-            return Modifier.isStatic(method.getModifiers()) ? method : null;
-        } catch (NoSuchMethodException ex) {
-            return null;
-        }
-    }
-
-    /**
-     * Check if the given class represents a primitive wrapper, i.e. Boolean,
-     * Byte, Character, Short, Integer, Long, Float, or Double.
-     *
-     * @param clazz the class to check
-     * @return whether the given class is a primitive wrapper class
-     */
-    public static boolean isPrimitiveWrapper(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        return primitiveWrapperTypeMap.containsKey(clazz);
-    }
-
-    /**
-     * Check if the given class represents a primitive (i.e. boolean, byte,
-     * char, short, int, long, float, or double) or a primitive wrapper (i.e.
-     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double).
-     *
-     * @param clazz the class to check
-     * @return whether the given class is a primitive or primitive wrapper class
-     */
-    public static boolean isPrimitiveOrWrapper(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        return (clazz.isPrimitive() || isPrimitiveWrapper(clazz));
-    }
-
-    /**
-     * Check if the given class represents an array of primitives, i.e. boolean,
-     * byte, char, short, int, long, float, or double.
-     *
-     * @param clazz the class to check
-     * @return whether the given class is a primitive array class
-     */
-    public static boolean isPrimitiveArray(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        return (clazz.isArray() && clazz.getComponentType().isPrimitive());
-    }
-
-    /**
-     * Check if the given class represents an array of primitive wrappers, i.e.
-     * Boolean, Byte, Character, Short, Integer, Long, Float, or Double.
-     *
-     * @param clazz the class to check
-     * @return whether the given class is a primitive wrapper array class
-     */
-    public static boolean isPrimitiveWrapperArray(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        return (clazz.isArray() && isPrimitiveWrapper(clazz.getComponentType()));
-    }
-
-    /**
-     * Resolve the given class if it is a primitive class, returning the
-     * corresponding primitive wrapper type instead.
-     *
-     * @param clazz the class to check
-     * @return the original class, or a primitive wrapper for the original
-     * primitive type
-     */
-    public static Class<?> resolvePrimitiveIfNecessary(Class<?> clazz) {
-        Assert.notNull(clazz, "Class must not be null");
-        return (clazz.isPrimitive() && clazz != void.class ? primitiveTypeToWrapperMap.get(clazz) : clazz);
-    }
-
-    /**
-     * Check if the right-hand side type may be assigned to the left-hand side
-     * type, assuming setting by reflection. Considers primitive wrapper classes
-     * as assignable to the corresponding primitive types.
-     *
-     * @param lhsType the target type
-     * @param rhsType the value type that should be assigned to the target type
-     * @return if the target type is assignable from the value type
-     * @see TypeUtils#isAssignable
-     */
-    public static boolean isAssignable(Class<?> lhsType, Class<?> rhsType) {
-        Assert.notNull(lhsType, "Left-hand side type must not be null");
-        Assert.notNull(rhsType, "Right-hand side type must not be null");
-        if (lhsType.isAssignableFrom(rhsType)) {
-            return true;
-        }
-        if (lhsType.isPrimitive()) {
-            Class<?> resolvedPrimitive = primitiveWrapperTypeMap.get(rhsType);
-            if (lhsType == resolvedPrimitive) {
-                return true;
-            }
-        } else {
-            Class<?> resolvedWrapper = primitiveTypeToWrapperMap.get(rhsType);
-            if (resolvedWrapper != null && lhsType.isAssignableFrom(resolvedWrapper)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Determine if the given type is assignable from the given value, assuming
-     * setting by reflection. Considers primitive wrapper classes as assignable
-     * to the corresponding primitive types.
-     *
-     * @param type the target type
-     * @param value the value that should be assigned to the type
-     * @return if the type is assignable from the value
-     */
-    public static boolean isAssignableValue(Class<?> type, Object value) {
-        Assert.notNull(type, "Type must not be null");
-        return (value != null ? isAssignable(type, value.getClass()) : !type.isPrimitive());
-    }
-
-    /**
-     * Convert a "/"-based resource path to a "."-based fully qualified class
-     * name.
-     *
-     * @param resourcePath the resource path pointing to a class
-     * @return the corresponding fully qualified class name
-     */
-    public static String convertResourcePathToClassName(String resourcePath) {
-        Assert.notNull(resourcePath, "Resource path must not be null");
-        return resourcePath.replace(PATH_SEPARATOR, PACKAGE_SEPARATOR);
-    }
-
-    /**
-     * Convert a "."-based fully qualified class name to a "/"-based resource
-     * path.
-     *
-     * @param className the fully qualified class name
-     * @return the corresponding resource path, pointing to the class
-     */
-    public static String convertClassNameToResourcePath(String className) {
-        Assert.notNull(className, "Class name must not be null");
-        return className.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);
-    }
-
-    /**
-     * Return a path suitable for use with {@code ClassLoader.getResource} (also
-     * suitable for use with {@code Class.getResource} by prepending a slash
-     * ('/') to the return value). Built by taking the package of the specified
-     * class file, converting all dots ('.') to slashes ('/'), adding a trailing
-     * slash if necessary, and concatenating the specified resource name to
-     * this.
-     * <br/>As such, this function may be used to build a path suitable for
-     * loading a resource file that is in the same package as a class file,
-     * although {@link org.springframework.core.io.ClassPathResource} is usually
-     * even more convenient.
-     *
-     * @param clazz the Class whose package will be used as the base
-     * @param resourceName the resource name to append. A leading slash is
-     * optional.
-     * @return the built-up resource path
-     * @see ClassLoader#getResource
-     * @see Class#getResource
-     */
-    public static String addResourcePathToPackagePath(Class<?> clazz, String resourceName) {
-        Assert.notNull(resourceName, "Resource name must not be null");
-        if (!resourceName.startsWith("/")) {
-            return classPackageAsResourcePath(clazz) + "/" + resourceName;
-        }
-        return classPackageAsResourcePath(clazz) + resourceName;
-    }
-
-    /**
-     * Given an input class object, return a string which consists of the
-     * class's package name as a pathname, i.e., all dots ('.') are replaced by
-     * slashes ('/'). Neither a leading nor trailing slash is added. The result
-     * could be concatenated with a slash and the name of a resource and fed
-     * directly to {@code ClassLoader.getResource()}. For it to be fed to
-     * {@code Class.getResource} instead, a leading slash would also have to be
-     * prepended to the returned value.
-     *
-     * @param clazz the input class. A {@code null} value or the default (empty)
-     * package will result in an empty string ("") being returned.
-     * @return a path which represents the package name
-     * @see ClassLoader#getResource
-     * @see Class#getResource
-     */
-    public static String classPackageAsResourcePath(Class<?> clazz) {
-        if (clazz == null) {
-            return "";
-        }
-        String className = clazz.getName();
-        int packageEndIndex = className.lastIndexOf(PACKAGE_SEPARATOR);
-        if (packageEndIndex == -1) {
-            return "";
-        }
-        String packageName = className.substring(0, packageEndIndex);
-        return packageName.replace(PACKAGE_SEPARATOR, PATH_SEPARATOR);
-    }
-
-    /**
-     * Build a String that consists of the names of the classes/interfaces in
-     * the given array.
-     * <p>
-     * Basically like {@code AbstractCollection.toString()}, but stripping the
-     * "class "/"interface " prefix before every class name.
-     *
-     * @param classes a Collection of Class objects (may be {@code null})
-     * @return a String of form "[com.foo.Bar, com.foo.Baz]"
-     * @see java.util.AbstractCollection#toString()
-     */
-    public static String classNamesToString(Class<?>... classes) {
-        return classNamesToString(Arrays.asList(classes));
-    }
-
-    /**
-     * Build a String that consists of the names of the classes/interfaces in
-     * the given collection.
-     * <p>
-     * Basically like {@code AbstractCollection.toString()}, but stripping the
-     * "class "/"interface " prefix before every class name.
-     *
-     * @param classes a Collection of Class objects (may be {@code null})
-     * @return a String of form "[com.foo.Bar, com.foo.Baz]"
-     * @see java.util.AbstractCollection#toString()
-     */
-    public static String classNamesToString(Collection<Class<?>> classes) {
-        if (CollectionUtils.isEmpty(classes)) {
-            return "[]";
-        }
-        StringBuilder sb = new StringBuilder("[");
-        for (Iterator<Class<?>> it = classes.iterator(); it.hasNext();) {
-            Class<?> clazz = it.next();
-            sb.append(clazz.getName());
-            if (it.hasNext()) {
-                sb.append(", ");
-            }
-        }
-        sb.append("]");
-        return sb.toString();
-    }
-
-    /**
-     * Copy the given Collection into a Class array. The Collection must contain
-     * Class elements only.
-     *
-     * @param collection the Collection to copy
-     * @return the Class array ({@code null} if the passed-in Collection was
-     * {@code null})
-     */
-    public static Class<?>[] toClassArray(Collection<Class<?>> collection) {
-        if (collection == null) {
-            return null;
-        }
-        return collection.toArray(new Class<?>[collection.size()]);
-    }
-
-    /**
-     * Return all interfaces that the given instance implements as array,
-     * including ones implemented by superclasses.
-     *
-     * @param instance the instance to analyze for interfaces
-     * @return all interfaces that the given instance implements as array
-     */
-    public static Class<?>[] getAllInterfaces(Object instance) {
-        Assert.notNull(instance, "Instance must not be null");
-        return getAllInterfacesForClass(instance.getClass());
-    }
-
-    /**
-     * Return all interfaces that the given class implements as array, including
-     * ones implemented by superclasses.
-     * <p>
-     * If the class itself is an interface, it gets returned as sole interface.
-     *
-     * @param clazz the class to analyze for interfaces
-     * @return all interfaces that the given object implements as array
-     */
-    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz) {
-        return getAllInterfacesForClass(clazz, null);
-    }
-
-    /**
-     * Return all interfaces that the given class implements as array, including
-     * ones implemented by superclasses.
-     * <p>
-     * If the class itself is an interface, it gets returned as sole interface.
-     *
-     * @param clazz the class to analyze for interfaces
-     * @param classLoader the ClassLoader that the interfaces need to be visible
-     * in (may be {@code null} when accepting all declared interfaces)
-     * @return all interfaces that the given object implements as array
-     */
-    public static Class<?>[] getAllInterfacesForClass(Class<?> clazz, ClassLoader classLoader) {
-        Set<Class<?>> ifcs = getAllInterfacesForClassAsSet(clazz, classLoader);
-        return ifcs.toArray(new Class<?>[ifcs.size()]);
-    }
-
-    /**
-     * Return all interfaces that the given instance implements as Set,
-     * including ones implemented by superclasses.
-     *
-     * @param instance the instance to analyze for interfaces
-     * @return all interfaces that the given instance implements as Set
-     */
-    public static Set<Class<?>> getAllInterfacesAsSet(Object instance) {
-        Assert.notNull(instance, "Instance must not be null");
-        return getAllInterfacesForClassAsSet(instance.getClass());
-    }
-
-    /**
-     * Return all interfaces that the given class implements as Set, including
-     * ones implemented by superclasses.
-     * <p>
-     * If the class itself is an interface, it gets returned as sole interface.
-     *
-     * @param clazz the class to analyze for interfaces
-     * @return all interfaces that the given object implements as Set
-     */
-    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz) {
-        return getAllInterfacesForClassAsSet(clazz, null);
-    }
-
-    /**
-     * Return all interfaces that the given class implements as Set, including
-     * ones implemented by superclasses.
-     * <p>
-     * If the class itself is an interface, it gets returned as sole interface.
-     *
-     * @param clazz the class to analyze for interfaces
-     * @param classLoader the ClassLoader that the interfaces need to be visible
-     * in (may be {@code null} when accepting all declared interfaces)
-     * @return all interfaces that the given object implements as Set
-     */
-    public static Set<Class<?>> getAllInterfacesForClassAsSet(Class<?> clazz, ClassLoader classLoader) {
-        Assert.notNull(clazz, "Class must not be null");
-        if (clazz.isInterface() && isVisible(clazz, classLoader)) {
-            return Collections.<Class<?>>singleton(clazz);
-        }
-        Set<Class<?>> interfaces = new LinkedHashSet<>();
-        while (clazz != null) {
-            Class<?>[] ifcs = clazz.getInterfaces();
-            for (Class<?> ifc : ifcs) {
-                interfaces.addAll(getAllInterfacesForClassAsSet(ifc, classLoader));
-            }
-            clazz = clazz.getSuperclass();
-        }
-        return interfaces;
-    }
-
-    /**
-     * Create a composite interface Class for the given interfaces, implementing
-     * the given interfaces in one single Class.
-     * <p>
-     * This implementation builds a JDK proxy class for the given interfaces.
-     *
-     * @param interfaces the interfaces to merge
-     * @param classLoader the ClassLoader to create the composite Class in
-     * @return the merged interface as Class
-     * @see java.lang.reflect.Proxy#getProxyClass
-     */
-    public static Class<?> createCompositeInterface(Class<?>[] interfaces, ClassLoader classLoader) {
-        Assert.notEmpty(interfaces, "Interfaces must not be empty");
-        Assert.notNull(classLoader, "ClassLoader must not be null");
-        return Proxy.getProxyClass(classLoader, interfaces);
-    }
-
-    /**
-     * Determine the common ancestor of the given classes, if any.
-     *
-     * @param clazz1 the class to introspect
-     * @param clazz2 the other class to introspect
-     * @return the common ancestor (i.e. common superclass, one interface
-     * extending the other), or {@code null} if none found. If any of the given
-     * classes is {@code null}, the other class will be returned.
-     * @since 3.2.6
-     */
-    public static Class<?> determineCommonAncestor(Class<?> clazz1, Class<?> clazz2) {
-        if (clazz1 == null) {
-            return clazz2;
-        }
-        if (clazz2 == null) {
-            return clazz1;
-        }
-        if (clazz1.isAssignableFrom(clazz2)) {
-            return clazz1;
-        }
-        if (clazz2.isAssignableFrom(clazz1)) {
-            return clazz2;
-        }
-        Class<?> ancestor = clazz1;
-        do {
-            ancestor = ancestor.getSuperclass();
-            if (ancestor == null || Object.class == ancestor) {
-                return null;
-            }
-        } while (!ancestor.isAssignableFrom(clazz2));
-        return ancestor;
-    }
-
-    /**
-     * Check whether the given class is visible in the given ClassLoader.
-     *
-     * @param clazz the class to check (typically an interface)
-     * @param classLoader the ClassLoader to check against (may be {@code null},
-     * in which case this method will always return {@code true})
-     */
-    public static boolean isVisible(Class<?> clazz, ClassLoader classLoader) {
-        if (classLoader == null) {
-            return true;
-        }
-        try {
-            Class<?> actualClass = classLoader.loadClass(clazz.getName());
-            return (clazz == actualClass);
-            // Else: different interface class found...
-        } catch (ClassNotFoundException ex) {
-            // No interface class found...
-            return false;
-        }
-    }
-
-    /**
-     * Check whether the given object is a CGLIB proxy.
-     *
-     * @param object the object to check
-     * @see org.springframework.aop.support.AopUtils#isCglibProxy(Object)
-     */
-    public static boolean isCglibProxy(Object object) {
-        return isCglibProxyClass(object.getClass());
-    }
-
-    /**
-     * Check whether the specified class is a CGLIB-generated class.
-     *
-     * @param clazz the class to check
-     */
-    public static boolean isCglibProxyClass(Class<?> clazz) {
-        return (clazz != null && isCglibProxyClassName(clazz.getName()));
-    }
-
-    /**
-     * Check whether the specified class name is a CGLIB-generated class.
-     *
-     * @param className the class name to check
-     */
-    public static boolean isCglibProxyClassName(String className) {
-        return (className != null && className.contains(CGLIB_CLASS_SEPARATOR));
-    }
-}
diff --git a/src/utils/CollectionUtils.java b/src/utils/CollectionUtils.java
deleted file mode 100644
index 4bb8449..0000000
--- a/src/utils/CollectionUtils.java
+++ /dev/null
@@ -1,367 +0,0 @@
-/*
- * To change this license header, choose License Headers in Project Properties.
- * To change this template file, choose Tools | Templates
- * and open the template in the editor.
- */
-package utils;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Enumeration;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
-import java.util.Properties;
-
-/**
- *
- * @author cdi305
- */
-public abstract class CollectionUtils {
-
-    /**
-     * Return {@code true} if the supplied Collection is {@code null} or empty.
-     * Otherwise, return {@code false}.
-     *
-     * @param collection the Collection to check
-     * @return whether the given Collection is empty
-     */
-    public static boolean isEmpty(Collection<?> collection) {
-        return (collection == null || collection.isEmpty());
-    }
-
-    /**
-     * Return {@code true} if the supplied Map is {@code null} or empty.
-     * Otherwise, return {@code false}.
-     *
-     * @param map the Map to check
-     * @return whether the given Map is empty
-     */
-    public static boolean isEmpty(Map<?, ?> map) {
-        return (map == null || map.isEmpty());
-    }
-
-    /**
-     * Convert the supplied array into a List. A primitive array gets converted
-     * into a List of the appropriate wrapper type.
-     * <p>
-     * <b>NOTE:</b> Generally prefer the standard {@link Arrays#asList} method.
-     * This {@code arrayToList} method is just meant to deal with an incoming
-     * Object value that might be an {@code Object[]} or a primitive array at
-     * runtime.
-     * <p>
-     * A {@code null} source value will be converted to an empty List.
-     *
-     * @param source the (potentially primitive) array
-     * @return the converted List result
-     * @see ObjectUtils#toObjectArray(Object)
-     * @see Arrays#asList(Object[])
-     */
-    @SuppressWarnings("rawtypes")
-    public static List arrayToList(Object source) {
-        return Arrays.asList(ObjectUtils.toObjectArray(source));
-    }
-
-    /**
-     * Merge the given array into the given Collection.
-     *
-     * @param <E>
-     * @param array the array to merge (may be {@code null})
-     * @param collection the target Collection to merge the array into
-     */
-    @SuppressWarnings("unchecked")
-    public static <E> void mergeArrayIntoCollection(Object array, Collection<E> collection) {
-        if (collection == null) {
-            throw new IllegalArgumentException("Collection must not be null");
-        }
-        Object[] arr = ObjectUtils.toObjectArray(array);
-        for (Object elem : arr) {
-            collection.add((E) elem);
-        }
-    }
-
-    /**
-     * Merge the given Properties instance into the given Map, copying all
-     * properties (key-value pairs) over.
-     * <p>
-     * Uses {@code Properties.propertyNames()} to even catch default properties
-     * linked into the original Properties instance.
-     *
-     * @param <K>
-     * @param <V>
-     * @param props the Properties instance to merge (may be {@code null})
-     * @param map the target Map to merge the properties into
-     */
-    @SuppressWarnings("unchecked")
-    public static <K, V> void mergePropertiesIntoMap(Properties props, Map<K, V> map) {
-        if (map == null) {
-            throw new IllegalArgumentException("Map must not be null");
-        }
-        if (props != null) {
-            for (Enumeration<?> en = props.propertyNames(); en.hasMoreElements();) {
-                String key = (String) en.nextElement();
-                Object value = props.getProperty(key);
-                if (value == null) {
-                    // Potentially a non-String value...
-                    value = props.get(key);
-                }
-                map.put((K) key, (V) value);
-            }
-        }
-    }
-
-    /**
-     * Check whether the given Iterator contains the given element.
-     *
-     * @param iterator the Iterator to check
-     * @param element the element to look for
-     * @return {@code true} if found, {@code false} else
-     */
-    public static boolean contains(Iterator<?> iterator, Object element) {
-        if (iterator != null) {
-            while (iterator.hasNext()) {
-                Object candidate = iterator.next();
-                if (ObjectUtils.nullSafeEquals(candidate, element)) {
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Check whether the given Enumeration contains the given element.
-     *
-     * @param enumeration the Enumeration to check
-     * @param element the element to look for
-     * @return {@code true} if found, {@code false} else
-     */
-    public static boolean contains(Enumeration<?> enumeration, Object element) {
-        if (enumeration != null) {
-            while (enumeration.hasMoreElements()) {
-                Object candidate = enumeration.nextElement();
-                if (ObjectUtils.nullSafeEquals(candidate, element)) {
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Check whether the given Collection contains the given element instance.
-     * <p>
-     * Enforces the given instance to be present, rather than returning
-     * {@code true} for an equal element as well.
-     *
-     * @param collection the Collection to check
-     * @param element the element to look for
-     * @return {@code true} if found, {@code false} else
-     */
-    public static boolean containsInstance(Collection<?> collection, Object element) {
-        if (collection != null) {
-            if (collection.stream().anyMatch((candidate) -> (candidate == element))) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Return {@code true} if any element in '{@code candidates}' is contained
-     * in '{@code source}'; otherwise returns {@code false}.
-     *
-     * @param source the source Collection
-     * @param candidates the candidates to search for
-     * @return whether any of the candidates has been found
-     */
-    public static boolean containsAny(Collection<?> source, Collection<?> candidates) {
-        if (isEmpty(source) || isEmpty(candidates)) {
-            return false;
-        }
-        return candidates.stream().anyMatch((candidate) -> (source.contains(candidate)));
-    }
-
-    /**
-     * Return the first element in '{@code candidates}' that is contained in
-     * '{@code source}'. If no element in '{@code candidates}' is present in
-     * '{@code source}' returns {@code null}. Iteration order is
-     * {@link Collection} implementation specific.
-     *
-     * @param <E>
-     * @param source the source Collection
-     * @param candidates the candidates to search for
-     * @return the first present object, or {@code null} if not found
-     */
-    @SuppressWarnings("unchecked")
-    public static <E> E findFirstMatch(Collection<?> source, Collection<E> candidates) {
-        if (isEmpty(source) || isEmpty(candidates)) {
-            return null;
-        }
-        for (Object candidate : candidates) {
-            if (source.contains(candidate)) {
-                return (E) candidate;
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Find a single value of the given type in the given Collection.
-     *
-     * @param <T>
-     * @param collection the Collection to search
-     * @param type the type to look for
-     * @return a value of the given type found if there is a clear match, or
-     * {@code null} if none or more than one such value found
-     */
-    @SuppressWarnings("unchecked")
-    public static <T> T findValueOfType(Collection<?> collection, Class<T> type) {
-        if (isEmpty(collection)) {
-            return null;
-        }
-        T value = null;
-        for (Object element : collection) {
-            if (type == null || type.isInstance(element)) {
-                if (value != null) {
-                    // More than one value found... no clear single value.
-                    return null;
-                }
-                value = (T) element;
-            }
-        }
-        return value;
-    }
-
-    /**
-     * Find a single value of one of the given types in the given Collection:
-     * searching the Collection for a value of the first type, then searching
-     * for a value of the second type, etc.
-     *
-     * @param collection the collection to search
-     * @param types the types to look for, in prioritized order
-     * @return a value of one of the given types found if there is a clear
-     * match, or {@code null} if none or more than one such value found
-     */
-    public static Object findValueOfType(Collection<?> collection, Class<?>[] types) {
-        if (isEmpty(collection) || ObjectUtils.isEmpty(types)) {
-            return null;
-        }
-        for (Class<?> type : types) {
-            Object value = findValueOfType(collection, type);
-            if (value != null) {
-                return value;
-            }
-        }
-        return null;
-    }
-
-    /**
-     * Determine whether the given Collection only contains a single unique
-     * object.
-     *
-     * @param collection the Collection to check
-     * @return {@code true} if the collection contains a single reference or
-     * multiple references to the same instance, {@code false} else
-     */
-    public static boolean hasUniqueObject(Collection<?> collection) {
-        if (isEmpty(collection)) {
-            return false;
-        }
-        boolean hasCandidate = false;
-        Object candidate = null;
-        for (Object elem : collection) {
-            if (!hasCandidate) {
-                hasCandidate = true;
-                candidate = elem;
-            } else if (candidate != elem) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Find the common element type of the given Collection, if any.
-     *
-     * @param collection the Collection to check
-     * @return the common element type, or {@code null} if no clear common type
-     * has been found (or the collection was empty)
-     */
-    public static Class<?> findCommonElementType(Collection<?> collection) {
-        if (isEmpty(collection)) {
-            return null;
-        }
-        Class<?> candidate = null;
-        for (Object val : collection) {
-            if (val != null) {
-                if (candidate == null) {
-                    candidate = val.getClass();
-                } else if (candidate != val.getClass()) {
-                    return null;
-                }
-            }
-        }
-        return candidate;
-    }
-
-    /**
-     * Marshal the elements from the given enumeration into an array of the
-     * given type. Enumeration elements must be assignable to the type of the
-     * given array. The array returned will be a different instance than the
-     * array given.
-     * @param <A>
-     * @param <E>
-     * @param enumeration
-     * @param array
-     * @return 
-     */
-    public static <A, E extends A> A[] toArray(Enumeration<E> enumeration, A[] array) {
-        ArrayList<A> elements = new ArrayList<>();
-        while (enumeration.hasMoreElements()) {
-            elements.add(enumeration.nextElement());
-        }
-        return elements.toArray(array);
-    }
-
-    /**
-     * Adapt an enumeration to an iterator.
-     *
-     * @param <E>
-     * @param enumeration the enumeration
-     * @return the iterator
-     */
-    public static <E> Iterator<E> toIterator(Enumeration<E> enumeration) {
-        return new EnumerationIterator<>(enumeration);
-    }
-
-
-    /**
-     * Iterator wrapping an Enumeration.
-     */
-    private static class EnumerationIterator<E> implements Iterator<E> {
-
-        private final Enumeration<E> enumeration;
-
-        public EnumerationIterator(Enumeration<E> enumeration) {
-            this.enumeration = enumeration;
-        }
-
-        @Override
-        public boolean hasNext() {
-            return this.enumeration.hasMoreElements();
-        }
-
-        @Override
-        public E next() {
-            return this.enumeration.nextElement();
-        }
-
-        @Override
-        public void remove() throws UnsupportedOperationException {
-            throw new UnsupportedOperationException("Not supported");
-        }
-    }
-
-}
diff --git a/src/utils/ObjectUtils.java b/src/utils/ObjectUtils.java
deleted file mode 100644
index 438ac9a..0000000
--- a/src/utils/ObjectUtils.java
+++ /dev/null
@@ -1,1013 +0,0 @@
-package utils;
-
-import java.lang.reflect.Array;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Map;
-import java.util.Optional;
-
-public abstract class ObjectUtils {
-
-    private static final int INITIAL_HASH = 7;
-    private static final int MULTIPLIER = 31;
-
-    private static final String EMPTY_STRING = "";
-    private static final String NULL_STRING = "null";
-    private static final String ARRAY_START = "{";
-    private static final String ARRAY_END = "}";
-    private static final String EMPTY_ARRAY = ARRAY_START + ARRAY_END;
-    private static final String ARRAY_ELEMENT_SEPARATOR = ", ";
-
-    /**
-     * Return whether the given throwable is a checked exception: that is,
-     * neither a RuntimeException nor an Error.
-     *
-     * @param ex the throwable to check
-     * @return whether the throwable is a checked exception
-     * @see java.lang.Exception
-     * @see java.lang.RuntimeException
-     * @see java.lang.Error
-     */
-    public static boolean isCheckedException(Throwable ex) {
-        return !(ex instanceof RuntimeException || ex instanceof Error);
-    }
-
-    /**
-     * Check whether the given exception is compatible with the specified
-     * exception types, as declared in a throws clause.
-     *
-     * @param ex the exception to check
-     * @param declaredExceptions the exception types declared in the throws
-     * clause
-     * @return whether the given exception is compatible
-     */
-    public static boolean isCompatibleWithThrowsClause(Throwable ex, Class<?>... declaredExceptions) {
-        if (!isCheckedException(ex)) {
-            return true;
-        }
-        if (declaredExceptions != null) {
-            for (Class<?> declaredException : declaredExceptions) {
-                if (declaredException.isInstance(ex)) {
-                    return true;
-                }
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Determine whether the given object is an array: either an Object array or
-     * a primitive array.
-     *
-     * @param obj the object to check
-     * @return 
-     */
-    public static boolean isArray(Object obj) {
-        return (obj != null && obj.getClass().isArray());
-    }
-
-    /**
-     * Determine whether the given array is empty: i.e. {@code null} or of zero
-     * length.
-     *
-     * @param array the array to check
-     * @return 
-     * @see #isEmpty(Object)
-     */
-    public static boolean isEmpty(Object[] array) {
-        return (array == null || array.length == 0);
-    }
-
-    /**
-     * Determine whether the given object is empty.
-     * <p>
-     * This method supports the following object types.
-     * <ul>
-     * <li>{@code Optional}: considered empty if {@link Optional#empty()}</li>
-     * <li>{@code Array}: considered empty if its length is zero</li>
-     * <li>{@link CharSequence}: considered empty if its length is zero</li>
-     * <li>{@link Collection}: delegates to {@link Collection#isEmpty()}</li>
-     * <li>{@link Map}: delegates to {@link Map#isEmpty()}</li>
-     * </ul>
-     * <p>
-     * If the given object is non-null and not one of the aforementioned
-     * supported types, this method returns {@code false}.
-     *
-     * @param obj the object to check
-     * @return {@code true} if the object is {@code null} or <em>empty</em>
-     * @since 4.2
-     * @see Optional#isPresent()
-     * @see ObjectUtils#isEmpty(Object[])
-     * @see StringUtils#hasLength(CharSequence)
-     * @see StringUtils#isEmpty(Object)
-     * @see CollectionUtils#isEmpty(java.util.Collection)
-     * @see CollectionUtils#isEmpty(java.util.Map)
-     */
-    @SuppressWarnings("rawtypes")
-    public static boolean isEmpty(Object obj) {
-        if (obj == null) {
-            return true;
-        }
-
-        if (obj instanceof Optional) {
-            return !((Optional) obj).isPresent();
-        }
-        if (obj.getClass().isArray()) {
-            return Array.getLength(obj) == 0;
-        }
-        if (obj instanceof CharSequence) {
-            return ((CharSequence) obj).length() == 0;
-        }
-        if (obj instanceof Collection) {
-            return ((Collection) obj).isEmpty();
-        }
-        if (obj instanceof Map) {
-            return ((Map) obj).isEmpty();
-        }
-
-        // else
-        return false;
-    }
-
-    /**
-     * Unwrap the given object which is potentially a
-     * {@link java.util.Optional}.
-     *
-     * @param obj the candidate object
-     * @return either the value held within the {@code Optional}, {@code null}
-     * if the {@code Optional} is empty, or simply the given object as-is
-     * @since 5.0
-     */
-    public static Object unwrapOptional(Object obj) {
-        if (obj instanceof Optional) {
-            Optional<?> optional = (Optional<?>) obj;
-            if (!optional.isPresent()) {
-                return null;
-            }
-            Object result = optional.get();
-            Assert.isTrue(!(result instanceof Optional), "Multi-level Optional usage not supported");
-            return result;
-        }
-        return obj;
-    }
-
-    /**
-     * Check whether the given array contains the given element.
-     *
-     * @param array the array to check (may be {@code null}, in which case the
-     * return value will always be {@code false})
-     * @param element the element to check for
-     * @return whether the element has been found in the given array
-     */
-    public static boolean containsElement(Object[] array, Object element) {
-        if (array == null) {
-            return false;
-        }
-        for (Object arrayEle : array) {
-            if (nullSafeEquals(arrayEle, element)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Check whether the given array of enum constants contains a constant with
-     * the given name, ignoring case when determining a match.
-     *
-     * @param enumValues the enum values to check, typically the product of a
-     * call to MyEnum.values()
-     * @param constant the constant name to find (must not be null or empty
-     * string)
-     * @return whether the constant has been found in the given array
-     */
-    public static boolean containsConstant(Enum<?>[] enumValues, String constant) {
-        return containsConstant(enumValues, constant, false);
-    }
-
-    /**
-     * Check whether the given array of enum constants contains a constant with
-     * the given name.
-     *
-     * @param enumValues the enum values to check, typically the product of a
-     * call to MyEnum.values()
-     * @param constant the constant name to find (must not be null or empty
-     * string)
-     * @param caseSensitive whether case is significant in determining a match
-     * @return whether the constant has been found in the given array
-     */
-    public static boolean containsConstant(Enum<?>[] enumValues, String constant, boolean caseSensitive) {
-        for (Enum<?> candidate : enumValues) {
-            if (caseSensitive
-                    ? candidate.toString().equals(constant)
-                    : candidate.toString().equalsIgnoreCase(constant)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Case insensitive alternative to {@link Enum#valueOf(Class, String)}.
-     *
-     * @param <E> the concrete Enum type
-     * @param enumValues the array of all Enum constants in question, usually
-     * per Enum.values()
-     * @param constant the constant to get the enum value of
-     * @return 
-     * @throws IllegalArgumentException if the given constant is not found in
-     * the given array of enum values. Use
-     * {@link #containsConstant(Enum[], String)} as a guard to avoid this
-     * exception.
-     */
-    public static <E extends Enum<?>> E caseInsensitiveValueOf(E[] enumValues, String constant) {
-        for (E candidate : enumValues) {
-            if (candidate.toString().equalsIgnoreCase(constant)) {
-                return candidate;
-            }
-        }
-        throw new IllegalArgumentException(
-                String.format("constant [%s] does not exist in enum type %s",
-                        constant, enumValues.getClass().getComponentType().getName()));
-    }
-
-    /**
-     * Append the given object to the given array, returning a new array
-     * consisting of the input array contents plus the given object.
-     *
-     * @param <A>
-     * @param <O>
-     * @param array the array to append to (can be {@code null})
-     * @param obj the object to append
-     * @return the new array (of the same component type; never {@code null})
-     */
-    public static <A, O extends A> A[] addObjectToArray(A[] array, O obj) {
-        Class<?> compType = Object.class;
-        if (null != array) {
-            compType = array.getClass().getComponentType();
-        } else if (obj != null) {
-            compType = obj.getClass();
-        }
-        int newArrLength = (array != null ? array.length + 1 : 1);
-        @SuppressWarnings("unchecked")
-        A[] newArr = (A[]) Array.newInstance(compType, newArrLength);
-        if (array != null) {
-            System.arraycopy(array, 0, newArr, 0, array.length);
-        }
-        newArr[newArr.length - 1] = obj;
-        return newArr;
-    }
-
-    /**
-     * Convert the given array (which may be a primitive array) to an object
-     * array (if necessary of primitive wrapper objects).
-     * <p>
-     * A {@code null} source value will be converted to an empty Object array.
-     *
-     * @param source the (potentially primitive) array
-     * @return the corresponding object array (never {@code null})
-     * @throws IllegalArgumentException if the parameter is not an array
-     */
-    public static Object[] toObjectArray(Object source) {
-        if (source instanceof Object[]) {
-            return (Object[]) source;
-        }
-        if (source == null) {
-            return new Object[0];
-        }
-        if (!source.getClass().isArray()) {
-            throw new IllegalArgumentException("Source is not an array: " + source);
-        }
-        int length = Array.getLength(source);
-        if (length == 0) {
-            return new Object[0];
-        }
-        Class<?> wrapperType = Array.get(source, 0).getClass();
-        Object[] newArray = (Object[]) Array.newInstance(wrapperType, length);
-        for (int i = 0; i < length; i++) {
-            newArray[i] = Array.get(source, i);
-        }
-        return newArray;
-    }
-
-	//---------------------------------------------------------------------
-    // Convenience methods for content-based equality/hash-code handling
-    //---------------------------------------------------------------------
-    /**
-     * Determine if the given objects are equal, returning {@code true} if both
-     * are {@code null} or {@code false} if only one is {@code null}.
-     * <p>
-     * Compares arrays with {@code Arrays.equals}, performing an equality check
-     * based on the array elements rather than the array reference.
-     *
-     * @param o1 first Object to compare
-     * @param o2 second Object to compare
-     * @return whether the given objects are equal
-     * @see Object#equals(Object)
-     * @see java.util.Arrays#equals
-     */
-    public static boolean nullSafeEquals(Object o1, Object o2) {
-        if (o1 == o2) {
-            return true;
-        }
-        if (o1 == null || o2 == null) {
-            return false;
-        }
-        if (o1.equals(o2)) {
-            return true;
-        }
-        if (o1.getClass().isArray() && o2.getClass().isArray()) {
-            return arrayEquals(o1, o2);
-        }
-        return false;
-    }
-
-    /**
-     * Compare the given arrays with {@code Arrays.equals}, performing an
-     * equality check based on the array elements rather than the array
-     * reference.
-     *
-     * @param o1 first array to compare
-     * @param o2 second array to compare
-     * @return whether the given objects are equal
-     * @see #nullSafeEquals(Object, Object)
-     * @see java.util.Arrays#equals
-     */
-    private static boolean arrayEquals(Object o1, Object o2) {
-        if (o1 instanceof Object[] && o2 instanceof Object[]) {
-            return Arrays.equals((Object[]) o1, (Object[]) o2);
-        }
-        if (o1 instanceof boolean[] && o2 instanceof boolean[]) {
-            return Arrays.equals((boolean[]) o1, (boolean[]) o2);
-        }
-        if (o1 instanceof byte[] && o2 instanceof byte[]) {
-            return Arrays.equals((byte[]) o1, (byte[]) o2);
-        }
-        if (o1 instanceof char[] && o2 instanceof char[]) {
-            return Arrays.equals((char[]) o1, (char[]) o2);
-        }
-        if (o1 instanceof double[] && o2 instanceof double[]) {
-            return Arrays.equals((double[]) o1, (double[]) o2);
-        }
-        if (o1 instanceof float[] && o2 instanceof float[]) {
-            return Arrays.equals((float[]) o1, (float[]) o2);
-        }
-        if (o1 instanceof int[] && o2 instanceof int[]) {
-            return Arrays.equals((int[]) o1, (int[]) o2);
-        }
-        if (o1 instanceof long[] && o2 instanceof long[]) {
-            return Arrays.equals((long[]) o1, (long[]) o2);
-        }
-        if (o1 instanceof short[] && o2 instanceof short[]) {
-            return Arrays.equals((short[]) o1, (short[]) o2);
-        }
-        return false;
-    }
-
-    /**
-     * Return as hash code for the given object; typically the value of
-     * {@code Object#hashCode()}}. If the object is an array, this method will
-     * delegate to any of the {@code nullSafeHashCode} methods for arrays in
-     * this class. If the object is {@code null}, this method returns 0.
-     *
-     * @param obj
-     * @return 
-     * @see Object#hashCode()
-     * @see #nullSafeHashCode(Object[])
-     * @see #nullSafeHashCode(boolean[])
-     * @see #nullSafeHashCode(byte[])
-     * @see #nullSafeHashCode(char[])
-     * @see #nullSafeHashCode(double[])
-     * @see #nullSafeHashCode(float[])
-     * @see #nullSafeHashCode(int[])
-     * @see #nullSafeHashCode(long[])
-     * @see #nullSafeHashCode(short[])
-     */
-    public static int nullSafeHashCode(Object obj) {
-        if (obj == null) {
-            return 0;
-        }
-        if (obj.getClass().isArray()) {
-            if (obj instanceof Object[]) {
-                return nullSafeHashCode((Object[]) obj);
-            }
-            if (obj instanceof boolean[]) {
-                return nullSafeHashCode((boolean[]) obj);
-            }
-            if (obj instanceof byte[]) {
-                return nullSafeHashCode((byte[]) obj);
-            }
-            if (obj instanceof char[]) {
-                return nullSafeHashCode((char[]) obj);
-            }
-            if (obj instanceof double[]) {
-                return nullSafeHashCode((double[]) obj);
-            }
-            if (obj instanceof float[]) {
-                return nullSafeHashCode((float[]) obj);
-            }
-            if (obj instanceof int[]) {
-                return nullSafeHashCode((int[]) obj);
-            }
-            if (obj instanceof long[]) {
-                return nullSafeHashCode((long[]) obj);
-            }
-            if (obj instanceof short[]) {
-                return nullSafeHashCode((short[]) obj);
-            }
-        }
-        return obj.hashCode();
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(Object[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (Object element : array) {
-            hash = MULTIPLIER * hash + nullSafeHashCode(element);
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(boolean[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (boolean element : array) {
-            hash = MULTIPLIER * hash + hashCode(element);
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(byte[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (byte element : array) {
-            hash = MULTIPLIER * hash + element;
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(char[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (char element : array) {
-            hash = MULTIPLIER * hash + element;
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(double[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (double element : array) {
-            hash = MULTIPLIER * hash + hashCode(element);
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(float[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (float element : array) {
-            hash = MULTIPLIER * hash + hashCode(element);
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(int[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (int element : array) {
-            hash = MULTIPLIER * hash + element;
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(long[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (long element : array) {
-            hash = MULTIPLIER * hash + hashCode(element);
-        }
-        return hash;
-    }
-
-    /**
-     * Return a hash code based on the contents of the specified array. If
-     * {@code array} is {@code null}, this method returns 0.
-     * @param array
-     * @return 
-     */
-    public static int nullSafeHashCode(short[] array) {
-        if (array == null) {
-            return 0;
-        }
-        int hash = INITIAL_HASH;
-        for (short element : array) {
-            hash = MULTIPLIER * hash + element;
-        }
-        return hash;
-    }
-
-    /**
-     * Return the same value as {@link Boolean#hashCode()}}.
-     *
-     * @param bool
-     * @return 
-     * @see Boolean#hashCode()
-     */
-    public static int hashCode(boolean bool) {
-        return (bool ? 1231 : 1237);
-    }
-
-    /**
-     * Return the same value as {@link Double#hashCode()}}.
-     *
-     * @param dbl
-     * @return 
-     * @see Double#hashCode()
-     */
-    public static int hashCode(double dbl) {
-        return hashCode(Double.doubleToLongBits(dbl));
-    }
-
-    /**
-     * Return the same value as {@link Float#hashCode()}}.
-     *
-     * @param flt
-     * @return 
-     * @see Float#hashCode()
-     */
-    public static int hashCode(float flt) {
-        return Float.floatToIntBits(flt);
-    }
-
-    /**
-     * Return the same value as {@link Long#hashCode()}}.
-     *
-     * @param lng
-     * @return 
-     * @see Long#hashCode()
-     */
-    public static int hashCode(long lng) {
-        return (int) (lng ^ (lng >>> 32));
-    }
-
-	//---------------------------------------------------------------------
-    // Convenience methods for toString output
-    //---------------------------------------------------------------------
-    /**
-     * Return a String representation of an object's overall identity.
-     *
-     * @param obj the object (may be {@code null})
-     * @return the object's identity as String representation, or an empty
-     * String if the object was {@code null}
-     */
-    public static String identityToString(Object obj) {
-        if (obj == null) {
-            return EMPTY_STRING;
-        }
-        return obj.getClass().getName() + "@" + getIdentityHexString(obj);
-    }
-
-    /**
-     * Return a hex String form of an object's identity hash code.
-     *
-     * @param obj the object
-     * @return the object's identity code in hex notation
-     */
-    public static String getIdentityHexString(Object obj) {
-        return Integer.toHexString(System.identityHashCode(obj));
-    }
-
-    /**
-     * Return a content-based String representation if {@code obj} is not
-     * {@code null}; otherwise returns an empty String.
-     * <p>
-     * Differs from {@link #nullSafeToString(Object)} in that it returns an
-     * empty String rather than "null" for a {@code null} value.
-     *
-     * @param obj the object to build a display String for
-     * @return a display String representation of {@code obj}
-     * @see #nullSafeToString(Object)
-     */
-    public static String getDisplayString(Object obj) {
-        if (obj == null) {
-            return EMPTY_STRING;
-        }
-        return nullSafeToString(obj);
-    }
-
-    /**
-     * Determine the class name for the given object.
-     * <p>
-     * Returns {@code "null"} if {@code obj} is {@code null}.
-     *
-     * @param obj the object to introspect (may be {@code null})
-     * @return the corresponding class name
-     */
-    public static String nullSafeClassName(Object obj) {
-        return (obj != null ? obj.getClass().getName() : NULL_STRING);
-    }
-
-    /**
-     * Return a String representation of the specified Object.
-     * <p>
-     * Builds a String representation of the contents in case of an array.
-     * Returns {@code "null"} if {@code obj} is {@code null}.
-     *
-     * @param obj the object to build a String representation for
-     * @return a String representation of {@code obj}
-     */
-    public static String nullSafeToString(Object obj) {
-        if (obj == null) {
-            return NULL_STRING;
-        }
-        if (obj instanceof String) {
-            return (String) obj;
-        }
-        if (obj instanceof Object[]) {
-            return nullSafeToString((Object[]) obj);
-        }
-        if (obj instanceof boolean[]) {
-            return nullSafeToString((boolean[]) obj);
-        }
-        if (obj instanceof byte[]) {
-            return nullSafeToString((byte[]) obj);
-        }
-        if (obj instanceof char[]) {
-            return nullSafeToString((char[]) obj);
-        }
-        if (obj instanceof double[]) {
-            return nullSafeToString((double[]) obj);
-        }
-        if (obj instanceof float[]) {
-            return nullSafeToString((float[]) obj);
-        }
-        if (obj instanceof int[]) {
-            return nullSafeToString((int[]) obj);
-        }
-        if (obj instanceof long[]) {
-            return nullSafeToString((long[]) obj);
-        }
-        if (obj instanceof short[]) {
-            return nullSafeToString((short[]) obj);
-        }
-        String str = obj.toString();
-        return (str != null ? str : EMPTY_STRING);
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(Object[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-            sb.append(String.valueOf(array[i]));
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(boolean[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(byte[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(char[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-            sb.append("'").append(array[i]).append("'");
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(double[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(float[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(int[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(long[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-
-    /**
-     * Return a String representation of the contents of the specified array.
-     * <p>
-     * The String representation consists of a list of the array's elements,
-     * enclosed in curly braces ({@code "{}"}). Adjacent elements are separated
-     * by the characters {@code ", "} (a comma followed by a space). Returns
-     * {@code "null"} if {@code array} is {@code null}.
-     *
-     * @param array the array to build a String representation for
-     * @return a String representation of {@code array}
-     */
-    public static String nullSafeToString(short[] array) {
-        if (array == null) {
-            return NULL_STRING;
-        }
-        int length = array.length;
-        if (length == 0) {
-            return EMPTY_ARRAY;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < length; i++) {
-            if (i == 0) {
-                sb.append(ARRAY_START);
-            } else {
-                sb.append(ARRAY_ELEMENT_SEPARATOR);
-            }
-            sb.append(array[i]);
-        }
-        sb.append(ARRAY_END);
-        return sb.toString();
-    }
-}
diff --git a/src/utils/PathUtils.java b/src/utils/PathUtils.java
deleted file mode 100644
index e07a67e..0000000
--- a/src/utils/PathUtils.java
+++ /dev/null
@@ -1,92 +0,0 @@
-package utils;
-
-import java.util.*;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-public abstract class PathUtils {
-
-    private static final Pattern separatorRegex = Pattern.compile("\\\\|/");
-
-    /**
-     * Resolves the given {@code relativePath} based on the given
-     * {@code anchorPath}.
-     *
-     * @param relativePath      the relative path which should be resolved.
-     * @param anchorPath        the anchor path based on which the relative path should be
-     *                          resolved on.
-     * @param expectedSeparator The character expected to be used as a separator; dictated by the Loader.
-     * @return the resolved path or {@code null} when the path could not be
-     * resolved.
-     */
-    public static String resolveRelativePath(String relativePath, String anchorPath, char expectedSeparator) {
-        if (relativePath == null || relativePath.isEmpty()) {
-            return null;
-        }
-
-        // ensure both paths use the same separator character
-        relativePath = sanitize(relativePath, expectedSeparator);
-        anchorPath = sanitize(anchorPath, expectedSeparator);
-
-        if (relativePath.startsWith(".." + expectedSeparator) || relativePath.startsWith("." + expectedSeparator)) {
-            return resolvePathInner(relativePath, anchorPath, expectedSeparator);
-        }
-
-        return null;
-    }
-
-    private static String sanitize(String path, char expectedSeparator){
-        return separatorRegex.matcher(path).replaceAll(Matcher.quoteReplacement(String.valueOf(expectedSeparator)));
-    }
-
-    private static String resolvePathInner(String relativePath, String anchorPath, char separator) {
-        StringBuilder resultingPath = new StringBuilder();
-
-        resolvePathSegments(determineAnchorPathSegments(anchorPath, separator),
-                splitBySeparator(relativePath, separator)).stream().forEach((segment) -> {
-                    resultingPath.append(segment).append(separator);
-        });
-
-        // remove the erroneous separator added at the end
-        return resultingPath.substring(0, resultingPath.length() - 1);
-    }
-
-    private static Collection<String> determineAnchorPathSegments(String anchorPath, char separator) {
-        if (anchorPath == null || anchorPath.isEmpty()) {
-            return new ArrayList<>();
-        }
-        ArrayDeque<String> anchorPathSegments = new ArrayDeque<>(splitBySeparator(anchorPath, separator));
-        if (anchorPath.charAt(anchorPath.length() - 1) != separator) {
-            anchorPathSegments.pollLast();
-        }
-        return anchorPathSegments;
-    }
-
-    private static Collection<String> resolvePathSegments(Collection<String> anchorSegments,
-            Collection<String> relativeSegments) {
-        ArrayDeque<String> result = new ArrayDeque<>(anchorSegments);
-        relativeSegments.stream().forEach((String segment) -> {
-            switch (segment) {
-                case ".": // do nothing
-                    break;
-                case "..":
-                    result.pollLast();
-                    break;
-                default:
-                    result.add(segment);
-                    break;
-            }
-        });
-
-        return result;
-    }
-
-    private static List<String> splitBySeparator(String path, char separator) {
-        return Arrays.asList(path.split(Pattern.quote(String.valueOf(separator))));
-    }
-
-    private PathUtils() {
-        throw new IllegalAccessError();
-    }
-
-}
diff --git a/src/utils/ReflectionUtils.java b/src/utils/ReflectionUtils.java
deleted file mode 100644
index a358602..0000000
--- a/src/utils/ReflectionUtils.java
+++ /dev/null
@@ -1,877 +0,0 @@
-package utils;
-
-import java.lang.reflect.Constructor;
-import java.lang.reflect.Field;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.lang.reflect.Modifier;
-import java.lang.reflect.UndeclaredThrowableException;
-import java.sql.SQLException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Map;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * Simple utility class for working with the reflection API and handling
- * reflection exceptions.
- *
- * <p>
- * Only intended for internal use.
- *
- */
-public abstract class ReflectionUtils {
-
-    /**
-     * Naming prefix for CGLIB-renamed methods.
-     *
-     * @see #isCglibRenamedMethod
-     */
-    private static final String CGLIB_RENAMED_METHOD_PREFIX = "CGLIB$";
-
-    private static final Method[] NO_METHODS = {};
-
-    private static final Field[] NO_FIELDS = {};
-
-    /**
-     * Cache for {@link Class#getDeclaredMethods()} plus equivalent default
-     * methods from Java 8 based interfaces, allowing for fast iteration.
-     */
-    private static final Map<Class<?>, Method[]> declaredMethodsCache
-            = new ConcurrentHashMap<>(256);
-
-    /**
-     * Cache for {@link Class#getDeclaredFields()}, allowing for fast iteration.
-     */
-    private static final Map<Class<?>, Field[]> declaredFieldsCache
-            = new ConcurrentHashMap<>(256);
-
-    /**
-     * Attempt to find a {@link Field field} on the supplied {@link Class} with
-     * the supplied {@code name}. Searches all superclasses up to
-     * {@link Object}.
-     *
-     * @param clazz the class to introspect
-     * @param name the name of the field
-     * @return the corresponding Field object, or {@code null} if not found
-     */
-    public static Field findField(Class<?> clazz, String name) {
-        return findField(clazz, name, null);
-    }
-
-    /**
-     * Attempt to find a {@link Field field} on the supplied {@link Class} with
-     * the supplied {@code name} and/or {@link Class type}. Searches all
-     * superclasses up to {@link Object}.
-     *
-     * @param clazz the class to introspect
-     * @param name the name of the field (may be {@code null} if type is
-     * specified)
-     * @param type the type of the field (may be {@code null} if name is
-     * specified)
-     * @return the corresponding Field object, or {@code null} if not found
-     */
-    public static Field findField(Class<?> clazz, String name, Class<?> type) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.isTrue(name != null || type != null, "Either name or type of the field must be specified");
-        Class<?> searchType = clazz;
-        while (Object.class != searchType && searchType != null) {
-            Field[] fields = getDeclaredFields(searchType);
-            for (Field field : fields) {
-                if ((name == null || name.equals(field.getName()))
-                        && (type == null || type.equals(field.getType()))) {
-                    return field;
-                }
-            }
-            searchType = searchType.getSuperclass();
-        }
-        return null;
-    }
-
-    /**
-     * Set the field represented by the supplied {@link Field field object} on
-     * the specified {@link Object target object} to the specified
-     * {@code value}. In accordance with {@link Field#set(Object, Object)}
-     * semantics, the new value is automatically unwrapped if the underlying
-     * field has a primitive type.
-     * <p>
-     * Thrown exceptions are handled via a call to
-     * {@link #handleReflectionException(Exception)}.
-     *
-     * @param field the field to set
-     * @param target the target object on which to set the field
-     * @param value the value to set (may be {@code null})
-     */
-    public static void setField(Field field, Object target, Object value) {
-        try {
-            field.set(target, value);
-        } catch (IllegalAccessException ex) {
-            handleReflectionException(ex);
-            throw new IllegalStateException(
-                    "Unexpected reflection exception - " + ex.getClass().getName() + ": " + ex.getMessage());
-        }
-    }
-
-    /**
-     * Get the field represented by the supplied {@link Field field object} on
-     * the specified {@link Object target object}. In accordance with
-     * {@link Field#get(Object)} semantics, the returned value is automatically
-     * wrapped if the underlying field has a primitive type.
-     * <p>
-     * Thrown exceptions are handled via a call to
-     * {@link #handleReflectionException(Exception)}.
-     *
-     * @param field the field to get
-     * @param target the target object from which to get the field
-     * @return the field's current value
-     */
-    public static Object getField(Field field, Object target) {
-        try {
-            return field.get(target);
-        } catch (IllegalAccessException ex) {
-            handleReflectionException(ex);
-            throw new IllegalStateException(
-                    "Unexpected reflection exception - " + ex.getClass().getName() + ": " + ex.getMessage());
-        }
-    }
-
-    /**
-     * Attempt to find a {@link Method} on the supplied class with the supplied
-     * name and no parameters. Searches all superclasses up to {@code Object}.
-     * <p>
-     * Returns {@code null} if no {@link Method} can be found.
-     *
-     * @param clazz the class to introspect
-     * @param name the name of the method
-     * @return the Method object, or {@code null} if none found
-     */
-    public static Method findMethod(Class<?> clazz, String name) {
-        return findMethod(clazz, name, new Class<?>[0]);
-    }
-
-    /**
-     * Attempt to find a {@link Method} on the supplied class with the supplied
-     * name and parameter types. Searches all superclasses up to {@code Object}.
-     * <p>
-     * Returns {@code null} if no {@link Method} can be found.
-     *
-     * @param clazz the class to introspect
-     * @param name the name of the method
-     * @param paramTypes the parameter types of the method (may be {@code null}
-     * to indicate any signature)
-     * @return the Method object, or {@code null} if none found
-     */
-    public static Method findMethod(Class<?> clazz, String name, Class<?>... paramTypes) {
-        Assert.notNull(clazz, "Class must not be null");
-        Assert.notNull(name, "Method name must not be null");
-        Class<?> searchType = clazz;
-        while (searchType != null) {
-            Method[] methods = (searchType.isInterface() ? searchType.getMethods() : getDeclaredMethods(searchType));
-            for (Method method : methods) {
-                if (name.equals(method.getName())
-                        && (paramTypes == null || Arrays.equals(paramTypes, method.getParameterTypes()))) {
-                    return method;
-                }
-            }
-            searchType = searchType.getSuperclass();
-        }
-        return null;
-    }
-
-    /**
-     * Invoke the specified {@link Method} against the supplied target object
-     * with no arguments. The target object can be {@code null} when invoking a
-     * static {@link Method}.
-     * <p>
-     * Thrown exceptions are handled via a call to
-     * {@link #handleReflectionException}.
-     *
-     * @param method the method to invoke
-     * @param target the target object to invoke the method on
-     * @return the invocation result, if any
-     * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])
-     */
-    public static Object invokeMethod(Method method, Object target) {
-        return invokeMethod(method, target, new Object[0]);
-    }
-
-    /**
-     * Invoke the specified {@link Method} against the supplied target object
-     * with the supplied arguments. The target object can be {@code null} when
-     * invoking a static {@link Method}.
-     * <p>
-     * Thrown exceptions are handled via a call to
-     * {@link #handleReflectionException}.
-     *
-     * @param method the method to invoke
-     * @param target the target object to invoke the method on
-     * @param args the invocation arguments (may be {@code null})
-     * @return the invocation result, if any
-     */
-    public static Object invokeMethod(Method method, Object target, Object... args) {
-        try {
-            return method.invoke(target, args);
-        } catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {
-            handleReflectionException(ex);
-        }
-        throw new IllegalStateException("Should never get here");
-    }
-
-    /**
-     * Invoke the specified JDBC API {@link Method} against the supplied target
-     * object with no arguments.
-     *
-     * @param method the method to invoke
-     * @param target the target object to invoke the method on
-     * @return the invocation result, if any
-     * @throws SQLException the JDBC API SQLException to rethrow (if any)
-     * @see #invokeJdbcMethod(java.lang.reflect.Method, Object, Object[])
-     */
-    public static Object invokeJdbcMethod(Method method, Object target) throws SQLException {
-        return invokeJdbcMethod(method, target, new Object[0]);
-    }
-
-    /**
-     * Invoke the specified JDBC API {@link Method} against the supplied target
-     * object with the supplied arguments.
-     *
-     * @param method the method to invoke
-     * @param target the target object to invoke the method on
-     * @param args the invocation arguments (may be {@code null})
-     * @return the invocation result, if any
-     * @throws SQLException the JDBC API SQLException to rethrow (if any)
-     * @see #invokeMethod(java.lang.reflect.Method, Object, Object[])
-     */
-    public static Object invokeJdbcMethod(Method method, Object target, Object... args) throws SQLException {
-        try {
-            return method.invoke(target, args);
-        } catch (IllegalAccessException ex) {
-            handleReflectionException(ex);
-        } catch (InvocationTargetException ex) {
-            if (ex.getTargetException() instanceof SQLException) {
-                throw (SQLException) ex.getTargetException();
-            }
-            handleInvocationTargetException(ex);
-        }
-        throw new IllegalStateException("Should never get here");
-    }
-
-    /**
-     * Handle the given reflection exception. Should only be called if no
-     * checked exception is expected to be thrown by the target method.
-     * <p>
-     * Throws the underlying RuntimeException or Error in case of an
-     * InvocationTargetException with such a root cause. Throws an
-     * IllegalStateException with an appropriate message or
-     * UndeclaredThrowableException otherwise.
-     *
-     * @param ex the reflection exception to handle
-     */
-    public static void handleReflectionException(Exception ex) {
-        if (ex instanceof NoSuchMethodException) {
-            throw new IllegalStateException("Method not found: " + ex.getMessage());
-        }
-        if (ex instanceof IllegalAccessException) {
-            throw new IllegalStateException("Could not access method: " + ex.getMessage());
-        }
-        if (ex instanceof InvocationTargetException) {
-            handleInvocationTargetException((InvocationTargetException) ex);
-        }
-        if (ex instanceof RuntimeException) {
-            throw (RuntimeException) ex;
-        }
-        throw new UndeclaredThrowableException(ex);
-    }
-
-    /**
-     * Handle the given invocation target exception. Should only be called if no
-     * checked exception is expected to be thrown by the target method.
-     * <p>
-     * Throws the underlying RuntimeException or Error in case of such a root
-     * cause. Throws an UndeclaredThrowableException otherwise.
-     *
-     * @param ex the invocation target exception to handle
-     */
-    public static void handleInvocationTargetException(InvocationTargetException ex) {
-        rethrowRuntimeException(ex.getTargetException());
-    }
-
-    /**
-     * Rethrow the given {@link Throwable exception}, which is presumably the
-     * <em>target exception</em> of an {@link InvocationTargetException}. Should
-     * only be called if no checked exception is expected to be thrown by the
-     * target method.
-     * <p>
-     * Rethrows the underlying exception cast to a {@link RuntimeException} or
-     * {@link Error} if appropriate; otherwise, throws an
-     * {@link UndeclaredThrowableException}.
-     *
-     * @param ex the exception to rethrow
-     * @throws RuntimeException the rethrown exception
-     */
-    public static void rethrowRuntimeException(Throwable ex) {
-        if (ex instanceof RuntimeException) {
-            throw (RuntimeException) ex;
-        }
-        if (ex instanceof Error) {
-            throw (Error) ex;
-        }
-        throw new UndeclaredThrowableException(ex);
-    }
-
-    /**
-     * Rethrow the given {@link Throwable exception}, which is presumably the
-     * <em>target exception</em> of an {@link InvocationTargetException}. Should
-     * only be called if no checked exception is expected to be thrown by the
-     * target method.
-     * <p>
-     * Rethrows the underlying exception cast to an {@link Exception} or
-     * {@link Error} if appropriate; otherwise, throws an
-     * {@link UndeclaredThrowableException}.
-     *
-     * @param ex the exception to rethrow
-     * @throws Exception the rethrown exception (in case of a checked exception)
-     */
-    public static void rethrowException(Throwable ex) throws Exception {
-        if (ex instanceof Exception) {
-            throw (Exception) ex;
-        }
-        if (ex instanceof Error) {
-            throw (Error) ex;
-        }
-        throw new UndeclaredThrowableException(ex);
-    }
-
-    /**
-     * Determine whether the given method explicitly declares the given
-     * exception or one of its superclasses, which means that an exception of
-     * that type can be propagated as-is within a reflective invocation.
-     *
-     * @param method the declaring method
-     * @param exceptionType the exception to throw
-     * @return {@code true} if the exception can be thrown as-is; {@code false}
-     * if it needs to be wrapped
-     */
-    public static boolean declaresException(Method method, Class<?> exceptionType) {
-        Assert.notNull(method, "Method must not be null");
-        Class<?>[] declaredExceptions = method.getExceptionTypes();
-        for (Class<?> declaredException : declaredExceptions) {
-            if (declaredException.isAssignableFrom(exceptionType)) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Determine whether the given field is a "public static final" constant.
-     *
-     * @param field the field to check
-     * @return
-     */
-    public static boolean isPublicStaticFinal(Field field) {
-        int modifiers = field.getModifiers();
-        return (Modifier.isPublic(modifiers) && Modifier.isStatic(modifiers) && Modifier.isFinal(modifiers));
-    }
-
-    /**
-     * Determine whether the given method is an "equals" method.
-     *
-     * @param method
-     * @return
-     * @see java.lang.Object#equals(Object)
-     */
-    public static boolean isEqualsMethod(Method method) {
-        if (method == null || !method.getName().equals("equals")) {
-            return false;
-        }
-        Class<?>[] paramTypes = method.getParameterTypes();
-        return (paramTypes.length == 1 && paramTypes[0] == Object.class);
-    }
-
-    /**
-     * Determine whether the given method is a "hashCode" method.
-     *
-     * @param method
-     * @return
-     * @see java.lang.Object#hashCode()
-     */
-    public static boolean isHashCodeMethod(Method method) {
-        return (method != null && method.getName().equals("hashCode") && method.getParameterCount() == 0);
-    }
-
-    /**
-     * Determine whether the given method is a "toString" method.
-     *
-     * @param method
-     * @return
-     * @see java.lang.Object#toString()
-     */
-    public static boolean isToStringMethod(Method method) {
-        return (method != null && method.getName().equals("toString") && method.getParameterCount() == 0);
-    }
-
-    /**
-     * Determine whether the given method is originally declared by
-     * {@link java.lang.Object}.
-     *
-     * @param method
-     * @return
-     */
-    public static boolean isObjectMethod(Method method) {
-        if (method == null) {
-            return false;
-        }
-        try {
-            Object.class.getDeclaredMethod(method.getName(), method.getParameterTypes());
-            return true;
-        } catch (NoSuchMethodException | SecurityException ex) {
-            return false;
-        }
-    }
-
-    /**
-     * Determine whether the given method is a CGLIB 'renamed' method, following
-     * the pattern "CGLIB$methodName$0".
-     *
-     * @param renamedMethod the method to check
-     * @return
-     * @see org.springframework.cglib.proxy.Enhancer#rename
-     */
-    public static boolean isCglibRenamedMethod(Method renamedMethod) {
-        String name = renamedMethod.getName();
-        if (name.startsWith(CGLIB_RENAMED_METHOD_PREFIX)) {
-            int i = name.length() - 1;
-            while (i >= 0 && Character.isDigit(name.charAt(i))) {
-                i--;
-            }
-            return ((i > CGLIB_RENAMED_METHOD_PREFIX.length())
-                    && (i < name.length() - 1) && name.charAt(i) == '$');
-        }
-        return false;
-    }
-
-    /**
-     * Make the given field accessible, explicitly setting it accessible if
-     * necessary. The {@code setAccessible(true)} method is only called when
-     * actually necessary, to avoid unnecessary conflicts with a JVM
-     * SecurityManager (if active).
-     *
-     * @param field the field to make accessible
-     * @see java.lang.reflect.Field#setAccessible
-     */
-    public static void makeAccessible(Field field) {
-        if ((!Modifier.isPublic(field.getModifiers())
-                || !Modifier.isPublic(field.getDeclaringClass().getModifiers())
-                || Modifier.isFinal(field.getModifiers())) && !field.isAccessible()) {
-            field.setAccessible(true);
-        }
-    }
-
-    /**
-     * Make the given method accessible, explicitly setting it accessible if
-     * necessary. The {@code setAccessible(true)} method is only called when
-     * actually necessary, to avoid unnecessary conflicts with a JVM
-     * SecurityManager (if active).
-     *
-     * @param method the method to make accessible
-     * @see java.lang.reflect.Method#setAccessible
-     */
-    public static void makeAccessible(Method method) {
-        if ((!Modifier.isPublic(method.getModifiers())
-                || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) && !method.isAccessible()) {
-            method.setAccessible(true);
-        }
-    }
-
-    /**
-     * Make the given constructor accessible, explicitly setting it accessible
-     * if necessary. The {@code setAccessible(true)} method is only called when
-     * actually necessary, to avoid unnecessary conflicts with a JVM
-     * SecurityManager (if active).
-     *
-     * @param ctor the constructor to make accessible
-     * @see java.lang.reflect.Constructor#setAccessible
-     */
-    public static void makeAccessible(Constructor<?> ctor) {
-        if ((!Modifier.isPublic(ctor.getModifiers())
-                || !Modifier.isPublic(ctor.getDeclaringClass().getModifiers())) && !ctor.isAccessible()) {
-            ctor.setAccessible(true);
-        }
-    }
-
-    /**
-     * Obtain an accessible constructor for the given class and parameters.
-     *
-     * @param clazz the clazz to check
-     * @param parameterTypes the parameter types of the desired constructor
-     * @return the constructor reference
-     * @throws NoSuchMethodException if no such constructor exists
-     * @since 5.0
-     */
-    public static <T> Constructor<T> accessibleConstructor(Class<T> clazz, Class<?>... parameterTypes)
-            throws NoSuchMethodException {
-
-        Constructor<T> ctor = clazz.getDeclaredConstructor(parameterTypes);
-        makeAccessible(ctor);
-        return ctor;
-    }
-
-    /**
-     * Perform the given callback operation on all matching methods of the given
-     * class, as locally declared or equivalent thereof (such as default methods
-     * on Java 8 based interfaces that the given class implements).
-     *
-     * @param clazz the class to introspect
-     * @param mc the callback to invoke for each method
-     * @since 4.2
-     * @see #doWithMethods
-     */
-    public static void doWithLocalMethods(Class<?> clazz, MethodCallback mc) {
-        Method[] methods = getDeclaredMethods(clazz);
-        for (Method method : methods) {
-            try {
-                mc.doWith(method);
-            } catch (IllegalAccessException ex) {
-                throw new IllegalStateException("Not allowed to access method '" + method.getName() + "': " + ex);
-            }
-        }
-    }
-
-    /**
-     * Perform the given callback operation on all matching methods of the given
-     * class and superclasses.
-     * <p>
-     * The same named method occurring on subclass and superclass will appear
-     * twice, unless excluded by a {@link MethodFilter}.
-     *
-     * @param clazz the class to introspect
-     * @param mc the callback to invoke for each method
-     * @see #doWithMethods(Class, MethodCallback, MethodFilter)
-     */
-    public static void doWithMethods(Class<?> clazz, MethodCallback mc) {
-        doWithMethods(clazz, mc, null);
-    }
-
-    /**
-     * Perform the given callback operation on all matching methods of the given
-     * class and superclasses (or given interface and super-interfaces).
-     * <p>
-     * The same named method occurring on subclass and superclass will appear
-     * twice, unless excluded by the specified {@link MethodFilter}.
-     *
-     * @param clazz the class to introspect
-     * @param mc the callback to invoke for each method
-     * @param mf the filter that determines the methods to apply the callback to
-     */
-    public static void doWithMethods(Class<?> clazz, MethodCallback mc, MethodFilter mf) {
-        // Keep backing up the inheritance hierarchy.
-        Method[] methods = getDeclaredMethods(clazz);
-        for (Method method : methods) {
-            if (mf != null && !mf.matches(method)) {
-                continue;
-            }
-            try {
-                mc.doWith(method);
-            } catch (IllegalAccessException ex) {
-                throw new IllegalStateException("Not allowed to access method '" + method.getName() + "': " + ex);
-            }
-        }
-        if (clazz.getSuperclass() != null) {
-            doWithMethods(clazz.getSuperclass(), mc, mf);
-        } else if (clazz.isInterface()) {
-            for (Class<?> superIfc : clazz.getInterfaces()) {
-                doWithMethods(superIfc, mc, mf);
-            }
-        }
-    }
-
-    /**
-     * Get all declared methods on the leaf class and all superclasses. Leaf
-     * class methods are included first.
-     *
-     * @param leafClass the class to introspect
-     * @return
-     */
-    public static Method[] getAllDeclaredMethods(Class<?> leafClass) {
-        final List<Method> methods = new ArrayList<>(32);
-        doWithMethods(leafClass, methods::add);
-        return methods.toArray(new Method[methods.size()]);
-    }
-
-    /**
-     * Get the unique set of declared methods on the leaf class and all
-     * superclasses. Leaf class methods are included first and while traversing
-     * the superclass hierarchy any methods found with signatures matching a
-     * method already included are filtered out.
-     *
-     * @param leafClass the class to introspect
-     * @return
-     */
-    public static Method[] getUniqueDeclaredMethods(Class<?> leafClass) {
-        final List<Method> methods = new ArrayList<>(32);
-        doWithMethods(leafClass, (Method method) -> {
-            boolean knownSignature = false;
-            Method methodBeingOverriddenWithCovariantReturnType = null;
-            for (Method existingMethod : methods) {
-                if (method.getName().equals(existingMethod.getName())
-                        && Arrays.equals(method.getParameterTypes(), existingMethod.getParameterTypes())) {
-                    // Is this a covariant return type situation?
-                    if (existingMethod.getReturnType() != method.getReturnType()
-                            && existingMethod.getReturnType().isAssignableFrom(method.getReturnType())) {
-                        methodBeingOverriddenWithCovariantReturnType = existingMethod;
-                    } else {
-                        knownSignature = true;
-                    }
-                    break;
-                }
-            }
-            if (methodBeingOverriddenWithCovariantReturnType != null) {
-                methods.remove(methodBeingOverriddenWithCovariantReturnType);
-            }
-            if (!knownSignature && !isCglibRenamedMethod(method)) {
-                methods.add(method);
-            }
-        });
-        return methods.toArray(new Method[methods.size()]);
-    }
-
-    /**
-     * This variant retrieves {@link Class#getDeclaredMethods()} from a local
-     * cache in order to avoid the JVM's SecurityManager check and defensive
-     * array copying. In addition, it also includes Java 8 default methods from
-     * locally implemented interfaces, since those are effectively to be treated
-     * just like declared methods.
-     *
-     * @param clazz the class to introspect
-     * @return the cached array of methods
-     * @see Class#getDeclaredMethods()
-     */
-    private static Method[] getDeclaredMethods(Class<?> clazz) {
-        Method[] result = declaredMethodsCache.get(clazz);
-        if (result == null) {
-            Method[] declaredMethods = clazz.getDeclaredMethods();
-            List<Method> defaultMethods = findConcreteMethodsOnInterfaces(clazz);
-            if (defaultMethods != null) {
-                result = new Method[declaredMethods.length + defaultMethods.size()];
-                System.arraycopy(declaredMethods, 0, result, 0, declaredMethods.length);
-                int index = declaredMethods.length;
-                for (Method defaultMethod : defaultMethods) {
-                    result[index] = defaultMethod;
-                    index++;
-                }
-            } else {
-                result = declaredMethods;
-            }
-            declaredMethodsCache.put(clazz, (result.length == 0 ? NO_METHODS : result));
-        }
-        return result;
-    }
-
-    private static List<Method> findConcreteMethodsOnInterfaces(Class<?> clazz) {
-        List<Method> result = null;
-        for (Class<?> ifc : clazz.getInterfaces()) {
-            for (Method ifcMethod : ifc.getMethods()) {
-                if (!Modifier.isAbstract(ifcMethod.getModifiers())) {
-                    if (result == null) {
-                        result = new LinkedList<>();
-                    }
-                    result.add(ifcMethod);
-                }
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Invoke the given callback on all fields in the target class, going up the
-     * class hierarchy to get all declared fields.
-     *
-     * @param clazz the target class to analyze
-     * @param fc the callback to invoke for each field
-     * @since 4.2
-     * @see #doWithFields
-     */
-    public static void doWithLocalFields(Class<?> clazz, FieldCallback fc) {
-        for (Field field : getDeclaredFields(clazz)) {
-            try {
-                fc.doWith(field);
-            } catch (IllegalAccessException ex) {
-                throw new IllegalStateException("Not allowed to access field '" + field.getName() + "': " + ex);
-            }
-        }
-    }
-
-    /**
-     * Invoke the given callback on all fields in the target class, going up the
-     * class hierarchy to get all declared fields.
-     *
-     * @param clazz the target class to analyze
-     * @param fc the callback to invoke for each field
-     */
-    public static void doWithFields(Class<?> clazz, FieldCallback fc) {
-        doWithFields(clazz, fc, null);
-    }
-
-    /**
-     * Invoke the given callback on all fields in the target class, going up the
-     * class hierarchy to get all declared fields.
-     *
-     * @param clazz the target class to analyze
-     * @param fc the callback to invoke for each field
-     * @param ff the filter that determines the fields to apply the callback to
-     */
-    public static void doWithFields(Class<?> clazz, FieldCallback fc, FieldFilter ff) {
-        // Keep backing up the inheritance hierarchy.
-        Class<?> targetClass = clazz;
-        do {
-            Field[] fields = getDeclaredFields(targetClass);
-            for (Field field : fields) {
-                if (ff != null && !ff.matches(field)) {
-                    continue;
-                }
-                try {
-                    fc.doWith(field);
-                } catch (IllegalAccessException ex) {
-                    throw new IllegalStateException("Not allowed to access field '" + field.getName() + "': " + ex);
-                }
-            }
-            targetClass = targetClass.getSuperclass();
-        } while (targetClass != null && targetClass != Object.class);
-    }
-
-    /**
-     * This variant retrieves {@link Class#getDeclaredFields()} from a local
-     * cache in order to avoid the JVM's SecurityManager check and defensive
-     * array copying.
-     *
-     * @param clazz the class to introspect
-     * @return the cached array of fields
-     * @see Class#getDeclaredFields()
-     */
-    private static Field[] getDeclaredFields(Class<?> clazz) {
-        Field[] result = declaredFieldsCache.get(clazz);
-        if (result == null) {
-            result = clazz.getDeclaredFields();
-            declaredFieldsCache.put(clazz, (result.length == 0 ? NO_FIELDS : result));
-        }
-        return result;
-    }
-
-    /**
-     * Given the source object and the destination, which must be the same class
-     * or a subclass, copy all fields, including inherited fields. Designed to
-     * work on objects with public no-arg constructors.
-     *
-     * @param src
-     * @param dest
-     */
-    public static void shallowCopyFieldState(final Object src, final Object dest) {
-        if (src == null) {
-            throw new IllegalArgumentException("Source for field copy cannot be null");
-        }
-        if (dest == null) {
-            throw new IllegalArgumentException("Destination for field copy cannot be null");
-        }
-        if (!src.getClass().isAssignableFrom(dest.getClass())) {
-            throw new IllegalArgumentException("Destination class [" + dest.getClass().getName()
-                    + "] must be same or subclass as source class [" + src.getClass().getName() + "]");
-        }
-        doWithFields(src.getClass(), (Field field) -> {
-            makeAccessible(field);
-            Object srcValue = field.get(src);
-            field.set(dest, srcValue);
-        }, COPYABLE_FIELDS);
-    }
-
-    /**
-     * Clear the internal method/field cache.
-     *
-     * @since 4.2.4
-     */
-    public static void clearCache() {
-        declaredMethodsCache.clear();
-        declaredFieldsCache.clear();
-    }
-
-    /**
-     * Action to take on each method.
-     */
-    @FunctionalInterface
-    public interface MethodCallback {
-
-        /**
-         * Perform an operation using the given method.
-         *
-         * @param method the method to operate on
-         * @throws java.lang.IllegalAccessException
-         */
-        void doWith(Method method) throws IllegalArgumentException, IllegalAccessException;
-    }
-
-    /**
-     * Callback optionally used to filter methods to be operated on by a method
-     * callback.
-     */
-    @FunctionalInterface
-    public interface MethodFilter {
-
-        /**
-         * Determine whether the given method matches.
-         *
-         * @param method the method to check
-         * @return
-         */
-        boolean matches(Method method);
-    }
-
-    /**
-     * Callback interface invoked on each field in the hierarchy.
-     */
-    @FunctionalInterface
-    public interface FieldCallback {
-
-        /**
-         * Perform an operation using the given field.
-         *
-         * @param field the field to operate on
-         * @throws java.lang.IllegalAccessException
-         */
-        void doWith(Field field) throws IllegalArgumentException, IllegalAccessException;
-    }
-
-    /**
-     * Callback optionally used to filter fields to be operated on by a field
-     * callback.
-     */
-    @FunctionalInterface
-    public interface FieldFilter {
-
-        /**
-         * Determine whether the given field matches.
-         *
-         * @param field the field to check
-         * @return
-         */
-        boolean matches(Field field);
-    }
-
-    /**
-     * Pre-built FieldFilter that matches all non-static, non-final fields.
-     */
-    public static final FieldFilter COPYABLE_FIELDS = (Field field) -> !(Modifier.isStatic(field.getModifiers()) || Modifier.isFinal(field.getModifiers()));
-
-    /**
-     * Pre-built MethodFilter that matches all non-bridge methods.
-     */
-    public static final MethodFilter NON_BRIDGED_METHODS = (Method method) -> !method.isBridge();
-
-    /**
-     * Pre-built MethodFilter that matches all non-bridge methods which are not
-     * declared on {@code java.lang.Object}.
-     */
-    public static final MethodFilter USER_DECLARED_METHODS = (Method method) -> (!method.isBridge() && method.getDeclaringClass() != Object.class);
-
-}
diff --git a/src/utils/ResourceUtils.java b/src/utils/ResourceUtils.java
deleted file mode 100644
index 4d71e91..0000000
--- a/src/utils/ResourceUtils.java
+++ /dev/null
@@ -1,432 +0,0 @@
-/*
- * Copyright 2002-2015 the original author or authors.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package utils;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.net.MalformedURLException;
-import java.net.URI;
-import java.net.URISyntaxException;
-import java.net.URL;
-import java.net.URLConnection;
-
-/**
- * Utility methods for resolving resource locations to files in the file system.
- * Mainly for internal use within the framework.
- *
- * <p>
- * Consider using Spring's Resource abstraction in the core package for handling
- * all kinds of file resources in a uniform manner.
- * {@link org.springframework.core.io.ResourceLoader}'s {@code getResource()}
- * method can resolve any location to a
- * {@link org.springframework.core.io.Resource} object, which in turn allows one
- * to obtain a {@code java.io.File} in the file system through its
- * {@code getFile()} method.
- *
- * <p>
- * The main reason for these utility methods for resource location handling is
- * to support {@link Log4jConfigurer}, which must be able to resolve resource
- * locations <i>before the logging system has been initialized</i>. Spring's
- * {@code Resource} abstraction in the core package, on the other hand, already
- * expects the logging system to be available.
- *
- * @author Juergen Hoeller
- * @since 1.1.5
- * @see org.springframework.core.io.Resource
- * @see org.springframework.core.io.ClassPathResource
- * @see org.springframework.core.io.FileSystemResource
- * @see org.springframework.core.io.UrlResource
- * @see org.springframework.core.io.ResourceLoader
- */
-public abstract class ResourceUtils {
-
-    /**
-     * Pseudo URL prefix for loading from the class path: "classpath:"
-     */
-    public static final String CLASSPATH_URL_PREFIX = "classpath:";
-
-    /**
-     * URL prefix for loading from the file system: "file:"
-     */
-    public static final String FILE_URL_PREFIX = "file:";
-
-    /**
-     * URL prefix for loading from a jar file: "jar:"
-     */
-    public static final String JAR_URL_PREFIX = "jar:";
-
-    /**
-     * URL prefix for loading from a war file on Tomcat: "war:"
-     */
-    public static final String WAR_URL_PREFIX = "war:";
-
-    /**
-     * URL protocol for a file in the file system: "file"
-     */
-    public static final String URL_PROTOCOL_FILE = "file";
-
-    /**
-     * URL protocol for an entry from a jar file: "jar"
-     */
-    public static final String URL_PROTOCOL_JAR = "jar";
-
-    /**
-     * URL protocol for an entry from a zip file: "zip"
-     */
-    public static final String URL_PROTOCOL_ZIP = "zip";
-
-    /**
-     * URL protocol for an entry from a WebSphere jar file: "wsjar"
-     */
-    public static final String URL_PROTOCOL_WSJAR = "wsjar";
-
-    /**
-     * URL protocol for an entry from a JBoss jar file: "vfszip"
-     */
-    public static final String URL_PROTOCOL_VFSZIP = "vfszip";
-
-    /**
-     * URL protocol for a JBoss file system resource: "vfsfile"
-     */
-    public static final String URL_PROTOCOL_VFSFILE = "vfsfile";
-
-    /**
-     * URL protocol for a general JBoss VFS resource: "vfs"
-     */
-    public static final String URL_PROTOCOL_VFS = "vfs";
-
-    /**
-     * File extension for a regular jar file: ".jar"
-     */
-    public static final String JAR_FILE_EXTENSION = ".jar";
-
-    /**
-     * Separator between JAR URL and file path within the JAR: "!/"
-     */
-    public static final String JAR_URL_SEPARATOR = "!/";
-
-    /**
-     * Special separator between WAR URL and jar part on Tomcat
-     */
-    public static final String WAR_URL_SEPARATOR = "*/";
-
-    /**
-     * Return whether the given resource location is a URL: either a special
-     * "classpath" pseudo URL or a standard URL.
-     *
-     * @param resourceLocation the location String to check
-     * @return whether the location qualifies as a URL
-     * @see #CLASSPATH_URL_PREFIX
-     * @see java.net.URL
-     */
-    public static boolean isUrl(String resourceLocation) {
-        if (resourceLocation == null) {
-            return false;
-        }
-        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
-            return true;
-        }
-        try {
-            URL url = new URL(resourceLocation);
-            return true;
-        } catch (MalformedURLException ex) {
-            return false;
-        }
-    }
-
-    /**
-     * Resolve the given resource location to a {@code java.net.URL}.
-     * <p>
-     * Does not check whether the URL actually exists; simply returns the URL
-     * that the given location would correspond to.
-     *
-     * @param resourceLocation the resource location to resolve: either a
-     * "classpath:" pseudo URL, a "file:" URL, or a plain file path
-     * @return a corresponding URL object
-     * @throws FileNotFoundException if the resource cannot be resolved to a URL
-     */
-    public static URL getURL(String resourceLocation) throws FileNotFoundException {
-        Assert.notNull(resourceLocation, "Resource location must not be null");
-        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
-            String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());
-            ClassLoader cl = ClassUtils.getDefaultClassLoader();
-            URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));
-            if (url == null) {
-                String description = "class path resource [" + path + "]";
-                throw new FileNotFoundException(description
-                        + " cannot be resolved to URL because it does not exist");
-            }
-            return url;
-        }
-        try {
-            // try URL
-            return new URL(resourceLocation);
-        } catch (MalformedURLException ex) {
-            // no URL -> treat as file path
-            try {
-                return new File(resourceLocation).toURI().toURL();
-            } catch (MalformedURLException ex2) {
-                throw new FileNotFoundException("Resource location [" + resourceLocation
-                        + "] is neither a URL not a well-formed file path");
-            }
-        }
-    }
-
-    /**
-     * Resolve the given resource location to a {@code java.io.File}, i.e. to a
-     * file in the file system.
-     * <p>
-     * Does not check whether the file actually exists; simply returns the File
-     * that the given location would correspond to.
-     *
-     * @param resourceLocation the resource location to resolve: either a
-     * "classpath:" pseudo URL, a "file:" URL, or a plain file path
-     * @return a corresponding File object
-     * @throws FileNotFoundException if the resource cannot be resolved to a
-     * file in the file system
-     */
-    public static File getFile(String resourceLocation) throws FileNotFoundException {
-        Assert.notNull(resourceLocation, "Resource location must not be null");
-        if (resourceLocation.startsWith(CLASSPATH_URL_PREFIX)) {
-            String path = resourceLocation.substring(CLASSPATH_URL_PREFIX.length());
-            String description = "class path resource [" + path + "]";
-            ClassLoader cl = ClassUtils.getDefaultClassLoader();
-            URL url = (cl != null ? cl.getResource(path) : ClassLoader.getSystemResource(path));
-            if (url == null) {
-                throw new FileNotFoundException(description
-                        + " cannot be resolved to absolute file path because it does not exist");
-            }
-            return getFile(url, description);
-        }
-        try {
-            // try URL
-            return getFile(new URL(resourceLocation));
-        } catch (MalformedURLException ex) {
-            // no URL -> treat as file path
-            return new File(resourceLocation);
-        }
-    }
-
-    /**
-     * Resolve the given resource URL to a {@code java.io.File}, i.e. to a file
-     * in the file system.
-     *
-     * @param resourceUrl the resource URL to resolve
-     * @return a corresponding File object
-     * @throws FileNotFoundException if the URL cannot be resolved to a file in
-     * the file system
-     */
-    public static File getFile(URL resourceUrl) throws FileNotFoundException {
-        return getFile(resourceUrl, "URL");
-    }
-
-    /**
-     * Resolve the given resource URL to a {@code java.io.File}, i.e. to a file
-     * in the file system.
-     *
-     * @param resourceUrl the resource URL to resolve
-     * @param description a description of the original resource that the URL
-     * was created for (for example, a class path location)
-     * @return a corresponding File object
-     * @throws FileNotFoundException if the URL cannot be resolved to a file in
-     * the file system
-     */
-    public static File getFile(URL resourceUrl, String description) throws FileNotFoundException {
-        Assert.notNull(resourceUrl, "Resource URL must not be null");
-        if (!URL_PROTOCOL_FILE.equals(resourceUrl.getProtocol())) {
-            throw new FileNotFoundException(
-                    description + " cannot be resolved to absolute file path "
-                    + "because it does not reside in the file system: " + resourceUrl);
-        }
-        try {
-            return new File(toURI(resourceUrl).getSchemeSpecificPart());
-        } catch (URISyntaxException ex) {
-            // Fallback for URLs that are not valid URIs (should hardly ever happen).
-            return new File(resourceUrl.getFile());
-        }
-    }
-
-    /**
-     * Resolve the given resource URI to a {@code java.io.File}, i.e. to a file
-     * in the file system.
-     *
-     * @param resourceUri the resource URI to resolve
-     * @return a corresponding File object
-     * @throws FileNotFoundException if the URL cannot be resolved to a file in
-     * the file system
-     */
-    public static File getFile(URI resourceUri) throws FileNotFoundException {
-        return getFile(resourceUri, "URI");
-    }
-
-    /**
-     * Resolve the given resource URI to a {@code java.io.File}, i.e. to a file
-     * in the file system.
-     *
-     * @param resourceUri the resource URI to resolve
-     * @param description a description of the original resource that the URI
-     * was created for (for example, a class path location)
-     * @return a corresponding File object
-     * @throws FileNotFoundException if the URL cannot be resolved to a file in
-     * the file system
-     */
-    public static File getFile(URI resourceUri, String description) throws FileNotFoundException {
-        Assert.notNull(resourceUri, "Resource URI must not be null");
-        if (!URL_PROTOCOL_FILE.equals(resourceUri.getScheme())) {
-            throw new FileNotFoundException(
-                    description + " cannot be resolved to absolute file path "
-                    + "because it does not reside in the file system: " + resourceUri);
-        }
-        return new File(resourceUri.getSchemeSpecificPart());
-    }
-
-    /**
-     * Determine whether the given URL points to a resource in the file system,
-     * that is, has protocol "file", "vfsfile" or "vfs".
-     *
-     * @param url the URL to check
-     * @return whether the URL has been identified as a file system URL
-     */
-    public static boolean isFileURL(URL url) {
-        String protocol = url.getProtocol();
-        return (URL_PROTOCOL_FILE.equals(protocol) || URL_PROTOCOL_VFSFILE.equals(protocol)
-                || URL_PROTOCOL_VFS.equals(protocol));
-    }
-
-    /**
-     * Determine whether the given URL points to a resource in a jar file, that
-     * is, has protocol "jar", "zip", "vfszip" or "wsjar".
-     *
-     * @param url the URL to check
-     * @return whether the URL has been identified as a JAR URL
-     */
-    public static boolean isJarURL(URL url) {
-        String protocol = url.getProtocol();
-        return (URL_PROTOCOL_JAR.equals(protocol) || URL_PROTOCOL_ZIP.equals(protocol)
-                || URL_PROTOCOL_VFSZIP.equals(protocol) || URL_PROTOCOL_WSJAR.equals(protocol));
-    }
-
-    /**
-     * Determine whether the given URL points to a jar file itself, that is, has
-     * protocol "file" and ends with the ".jar" extension.
-     *
-     * @param url the URL to check
-     * @return whether the URL has been identified as a JAR file URL
-     * @since 4.1
-     */
-    public static boolean isJarFileURL(URL url) {
-        return (URL_PROTOCOL_FILE.equals(url.getProtocol())
-                && url.getPath().toLowerCase().endsWith(JAR_FILE_EXTENSION));
-    }
-
-    /**
-     * Extract the URL for the actual jar file from the given URL (which may
-     * point to a resource in a jar file or to a jar file itself).
-     *
-     * @param jarUrl the original URL
-     * @return the URL for the actual jar file
-     * @throws MalformedURLException if no valid jar file URL could be extracted
-     */
-    public static URL extractJarFileURL(URL jarUrl) throws MalformedURLException {
-        String urlFile = jarUrl.getFile();
-        int separatorIndex = urlFile.indexOf(JAR_URL_SEPARATOR);
-        if (separatorIndex != -1) {
-            String jarFile = urlFile.substring(0, separatorIndex);
-            try {
-                return new URL(jarFile);
-            } catch (MalformedURLException ex) {
-				// Probably no protocol in original jar URL, like "jar:C:/mypath/myjar.jar".
-                // This usually indicates that the jar file resides in the file system.
-                if (!jarFile.startsWith("/")) {
-                    jarFile = "/" + jarFile;
-                }
-                return new URL(FILE_URL_PREFIX + jarFile);
-            }
-        } else {
-            return jarUrl;
-        }
-    }
-
-    /**
-     * Extract the URL for the outermost archive from the given jar/war URL
-     * (which may point to a resource in a jar file or to a jar file itself).
-     * <p>
-     * In the case of a jar file nested within a war file, this will return a
-     * URL to the war file since that is the one resolvable in the file system.
-     *
-     * @param jarUrl the original URL
-     * @return the URL for the actual jar file
-     * @throws MalformedURLException if no valid jar file URL could be extracted
-     * @since 4.1.8
-     * @see #extractJarFileURL(URL)
-     */
-    public static URL extractArchiveURL(URL jarUrl) throws MalformedURLException {
-        String urlFile = jarUrl.getFile();
-
-        int endIndex = urlFile.indexOf(WAR_URL_SEPARATOR);
-        if (endIndex != -1) {
-            // Tomcat's "jar:war:file:...mywar.war*/WEB-INF/lib/myjar.jar!/myentry.txt"
-            String warFile = urlFile.substring(0, endIndex);
-            int startIndex = warFile.indexOf(WAR_URL_PREFIX);
-            if (startIndex != -1) {
-                return new URL(warFile.substring(startIndex + WAR_URL_PREFIX.length()));
-            }
-        }
-
-        // Regular "jar:file:...myjar.jar!/myentry.txt"
-        return extractJarFileURL(jarUrl);
-    }
-
-    /**
-     * Create a URI instance for the given URL, replacing spaces with "%20" URI
-     * encoding first.
-     * <p>
-     * Furthermore, this method works on JDK 1.4 as well, in contrast to the
-     * {@code URL.toURI()} method.
-     *
-     * @param url the URL to convert into a URI instance
-     * @return the URI instance
-     * @throws URISyntaxException if the URL wasn't a valid URI
-     * @see java.net.URL#toURI()
-     */
-    public static URI toURI(URL url) throws URISyntaxException {
-        return toURI(url.toString());
-    }
-
-    /**
-     * Create a URI instance for the given location String, replacing spaces
-     * with "%20" URI encoding first.
-     *
-     * @param location the location String to convert into a URI instance
-     * @return the URI instance
-     * @throws URISyntaxException if the location wasn't a valid URI
-     */
-    public static URI toURI(String location) throws URISyntaxException {
-        return new URI(StringUtils.replace(location, " ", "%20"));
-    }
-
-    /**
-     * Set the {@link URLConnection#setUseCaches "useCaches"} flag on the given
-     * connection, preferring {@code false} but leaving the flag at {@code true}
-     * for JNLP based resources.
-     *
-     * @param con the URLConnection to set the flag on
-     */
-    public static void useCachesIfNecessary(URLConnection con) {
-        con.setUseCaches(con.getClass().getSimpleName().startsWith("JNLP"));
-    }
-
-}
diff --git a/src/utils/StringUtils.java b/src/utils/StringUtils.java
deleted file mode 100644
index 80803a6..0000000
--- a/src/utils/StringUtils.java
+++ /dev/null
@@ -1,1304 +0,0 @@
-package utils;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Enumeration;
-import java.util.Iterator;
-import java.util.LinkedHashSet;
-import java.util.LinkedList;
-import java.util.List;
-import java.util.Locale;
-import java.util.Properties;
-import java.util.Set;
-import java.util.StringTokenizer;
-import java.util.TimeZone;
-
-/**
- *
- * @author cdi305
- */
-public abstract class StringUtils {
-
-    private static final String FOLDER_SEPARATOR = "/";
-
-    private static final String WINDOWS_FOLDER_SEPARATOR = "\\";
-
-    private static final String TOP_PATH = "..";
-
-    private static final String CURRENT_PATH = ".";
-
-    private static final char EXTENSION_SEPARATOR = '.';
-    
-
-    //---------------------------------------------------------------------
-    // General convenience methods for working with Strings
-    //---------------------------------------------------------------------
-    
-    
-    /**
-     * Check whether the given {@code String} is empty.
-     * <p>
-     * This method accepts any Object as an argument, comparing it to
-     * {@code null} and the empty String. As a consequence, this method will
-     * never return {@code true} for a non-null non-String object.
-     * <p>
-     * The Object signature is useful for general attribute handling code that
-     * commonly deals with Strings but generally has to iterate over Objects
-     * since attributes may e.g. be primitive value objects as well.
-     *
-     * @param str the candidate String
-     * @return 
-     * @since 3.2.1
-     */
-    public static boolean isEmpty(Object str) {
-        return (str == null || "".equals(str));
-    }
-
-    /**
-     * Check that the given {@code CharSequence} is neither {@code null} nor of
-     * length 0.
-     * <p>
-     * Note: this method returns {@code true} for a {@code CharSequence} that
-     * purely consists of whitespace.
-     * <p>
-     * <pre class="code">
-     * StringUtils.hasLength(null) = false StringUtils.hasLength("") = false
-     * StringUtils.hasLength(" ") = true StringUtils.hasLength("Hello") = true
-     * </pre>
-     *
-     * @param str the {@code CharSequence} to check (may be {@code null})
-     * @return {@code true} if the {@code CharSequence} is not {@code null} and
-     * has length
-     * @see #hasText(String)
-     */
-    public static boolean hasLength(CharSequence str) {
-        return (str != null && str.length() > 0);
-    }
-
-    /**
-     * Check that the given {@code String} is neither {@code null} nor of length
-     * 0.
-     * <p>
-     * Note: this method returns {@code true} for a {@code String} that purely
-     * consists of whitespace.
-     *
-     * @param str the {@code String} to check (may be {@code null})
-     * @return {@code true} if the {@code String} is not {@code null} and has
-     * length
-     * @see #hasLength(CharSequence)
-     * @see #hasText(String)
-     */
-    public static boolean hasLength(String str) {
-        return hasLength((CharSequence) str);
-    }
-
-    /**
-     * Check whether the given {@code CharSequence} contains actual
-     * <em>text</em>.
-     * <p>
-     * More specifically, this method returns {@code true} if the
-     * {@code CharSequence} is not {@code null}, its length is greater than 0,
-     * and it contains at least one non-whitespace character.
-     * <p>
-     * <pre class="code">
-     * StringUtils.hasText(null) = false StringUtils.hasText("") = false
-     * StringUtils.hasText(" ") = false StringUtils.hasText("12345") = true
-     * StringUtils.hasText(" 12345 ") = true
-     * </pre>
-     *
-     * @param str the {@code CharSequence} to check (may be {@code null})
-     * @return {@code true} if the {@code CharSequence} is not {@code null}, its
-     * length is greater than 0, and it does not contain whitespace only
-     * @see Character#isWhitespace
-     */
-    public static boolean hasText(CharSequence str) {
-        if (!hasLength(str)) {
-            return false;
-        }
-        int strLen = str.length();
-        for (int i = 0; i < strLen; i++) {
-            if (!Character.isWhitespace(str.charAt(i))) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Check whether the given {@code String} contains actual <em>text</em>.
-     * <p>
-     * More specifically, this method returns {@code true} if the {@code String}
-     * is not {@code null}, its length is greater than 0, and it contains at
-     * least one non-whitespace character.
-     *
-     * @param str the {@code String} to check (may be {@code null})
-     * @return {@code true} if the {@code String} is not {@code null}, its
-     * length is greater than 0, and it does not contain whitespace only
-     * @see #hasText(CharSequence)
-     */
-    public static boolean hasText(String str) {
-        return hasText((CharSequence) str);
-    }
-
-    /**
-     * Check whether the given {@code CharSequence} contains any whitespace
-     * characters.
-     *
-     * @param str the {@code CharSequence} to check (may be {@code null})
-     * @return {@code true} if the {@code CharSequence} is not empty and
-     * contains at least 1 whitespace character
-     * @see Character#isWhitespace
-     */
-    public static boolean containsWhitespace(CharSequence str) {
-        if (!hasLength(str)) {
-            return false;
-        }
-        int strLen = str.length();
-        for (int i = 0; i < strLen; i++) {
-            if (Character.isWhitespace(str.charAt(i))) {
-                return true;
-            }
-        }
-        return false;
-    }
-
-    /**
-     * Check whether the given {@code String} contains any whitespace
-     * characters.
-     *
-     * @param str the {@code String} to check (may be {@code null})
-     * @return {@code true} if the {@code String} is not empty and contains at
-     * least 1 whitespace character
-     * @see #containsWhitespace(CharSequence)
-     */
-    public static boolean containsWhitespace(String str) {
-        return containsWhitespace((CharSequence) str);
-    }
-
-    /**
-     * Trim leading and trailing whitespace from the given {@code String}.
-     *
-     * @param str the {@code String} to check
-     * @return the trimmed {@code String}
-     * @see java.lang.Character#isWhitespace
-     */
-    public static String trimWhitespace(String str) {
-        if (!hasLength(str)) {
-            return str;
-        }
-        StringBuilder sb = new StringBuilder(str);
-        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
-            sb.deleteCharAt(0);
-        }
-        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {
-            sb.deleteCharAt(sb.length() - 1);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Trim <i>all</i> whitespace from the given {@code String}: leading,
-     * trailing, and in between characters.
-     *
-     * @param str the {@code String} to check
-     * @return the trimmed {@code String}
-     * @see java.lang.Character#isWhitespace
-     */
-    public static String trimAllWhitespace(String str) {
-        if (!hasLength(str)) {
-            return str;
-        }
-        int len = str.length();
-        StringBuilder sb = new StringBuilder(str.length());
-        for (int i = 0; i < len; i++) {
-            char c = str.charAt(i);
-            if (!Character.isWhitespace(c)) {
-                sb.append(c);
-            }
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Trim leading whitespace from the given {@code String}.
-     *
-     * @param str the {@code String} to check
-     * @return the trimmed {@code String}
-     * @see java.lang.Character#isWhitespace
-     */
-    public static String trimLeadingWhitespace(String str) {
-        if (!hasLength(str)) {
-            return str;
-        }
-        StringBuilder sb = new StringBuilder(str);
-        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(0))) {
-            sb.deleteCharAt(0);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Trim trailing whitespace from the given {@code String}.
-     *
-     * @param str the {@code String} to check
-     * @return the trimmed {@code String}
-     * @see java.lang.Character#isWhitespace
-     */
-    public static String trimTrailingWhitespace(String str) {
-        if (!hasLength(str)) {
-            return str;
-        }
-        StringBuilder sb = new StringBuilder(str);
-        while (sb.length() > 0 && Character.isWhitespace(sb.charAt(sb.length() - 1))) {
-            sb.deleteCharAt(sb.length() - 1);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Trim all occurrences of the supplied leading character from the given
-     * {@code String}.
-     *
-     * @param str the {@code String} to check
-     * @param leadingCharacter the leading character to be trimmed
-     * @return the trimmed {@code String}
-     */
-    public static String trimLeadingCharacter(String str, char leadingCharacter) {
-        if (!hasLength(str)) {
-            return str;
-        }
-        StringBuilder sb = new StringBuilder(str);
-        while (sb.length() > 0 && sb.charAt(0) == leadingCharacter) {
-            sb.deleteCharAt(0);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Trim all occurrences of the supplied trailing character from the given
-     * {@code String}.
-     *
-     * @param str the {@code String} to check
-     * @param trailingCharacter the trailing character to be trimmed
-     * @return the trimmed {@code String}
-     */
-    public static String trimTrailingCharacter(String str, char trailingCharacter) {
-        if (!hasLength(str)) {
-            return str;
-        }
-        StringBuilder sb = new StringBuilder(str);
-        while (sb.length() > 0 && sb.charAt(sb.length() - 1) == trailingCharacter) {
-            sb.deleteCharAt(sb.length() - 1);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Test if the given {@code String} starts with the specified prefix,
-     * ignoring upper/lower case.
-     *
-     * @param str the {@code String} to check
-     * @param prefix the prefix to look for
-     * @see java.lang.String#startsWith
-     */
-    public static boolean startsWithIgnoreCase(String str, String prefix) {
-        if (str == null || prefix == null) {
-            return false;
-        }
-        if (str.startsWith(prefix)) {
-            return true;
-        }
-        if (str.length() < prefix.length()) {
-            return false;
-        }
-        String lcStr = str.substring(0, prefix.length()).toLowerCase();
-        String lcPrefix = prefix.toLowerCase();
-        return lcStr.equals(lcPrefix);
-    }
-
-    /**
-     * Test if the given {@code String} ends with the specified suffix, ignoring
-     * upper/lower case.
-     *
-     * @param str the {@code String} to check
-     * @param suffix the suffix to look for
-     * @see java.lang.String#endsWith
-     */
-    public static boolean endsWithIgnoreCase(String str, String suffix) {
-        if (str == null || suffix == null) {
-            return false;
-        }
-        if (str.endsWith(suffix)) {
-            return true;
-        }
-        if (str.length() < suffix.length()) {
-            return false;
-        }
-
-        String lcStr = str.substring(str.length() - suffix.length()).toLowerCase();
-        String lcSuffix = suffix.toLowerCase();
-        return lcStr.equals(lcSuffix);
-    }
-
-    /**
-     * Test whether the given string matches the given substring at the given
-     * index.
-     *
-     * @param str the original string (or StringBuilder)
-     * @param index the index in the original string to start matching against
-     * @param substring the substring to match at the given index
-     */
-    public static boolean substringMatch(CharSequence str, int index, CharSequence substring) {
-        for (int j = 0; j < substring.length(); j++) {
-            int i = index + j;
-            if (i >= str.length() || str.charAt(i) != substring.charAt(j)) {
-                return false;
-            }
-        }
-        return true;
-    }
-
-    /**
-     * Count the occurrences of the substring {@code sub} in string {@code str}.
-     *
-     * @param str string to search in. Return 0 if this is {@code null}.
-     * @param sub string to search for. Return 0 if this is {@code null}.
-     */
-    public static int countOccurrencesOf(String str, String sub) {
-        if (str == null || sub == null || str.length() == 0 || sub.length() == 0) {
-            return 0;
-        }
-        int count = 0;
-        int pos = 0;
-        int idx;
-        while ((idx = str.indexOf(sub, pos)) != -1) {
-            ++count;
-            pos = idx + sub.length();
-        }
-        return count;
-    }
-
-    /**
-     * Replace all occurrences of a substring within a string with another
-     * string.
-     *
-     * @param inString {@code String} to examine
-     * @param oldPattern {@code String} to replace
-     * @param newPattern {@code String} to insert
-     * @return a {@code String} with the replacements
-     */
-    public static String replace(String inString, String oldPattern, String newPattern) {
-        if (!hasLength(inString) || !hasLength(oldPattern) || newPattern == null) {
-            return inString;
-        }
-        StringBuilder sb = new StringBuilder();
-        int pos = 0; // our position in the old string
-        int index = inString.indexOf(oldPattern);
-        // the index of an occurrence we've found, or -1
-        int patLen = oldPattern.length();
-        while (index >= 0) {
-            sb.append(inString.substring(pos, index));
-            sb.append(newPattern);
-            pos = index + patLen;
-            index = inString.indexOf(oldPattern, pos);
-        }
-        sb.append(inString.substring(pos));
-        // remember to append any characters to the right of a match
-        return sb.toString();
-    }
-
-    /**
-     * Delete all occurrences of the given substring.
-     *
-     * @param inString the original {@code String}
-     * @param pattern the pattern to delete all occurrences of
-     * @return the resulting {@code String}
-     */
-    public static String delete(String inString, String pattern) {
-        return replace(inString, pattern, "");
-    }
-
-    /**
-     * Delete any character in a given {@code String}.
-     *
-     * @param inString the original {@code String}
-     * @param charsToDelete a set of characters to delete. E.g. "az\n" will
-     * delete 'a's, 'z's and new lines.
-     * @return the resulting {@code String}
-     */
-    public static String deleteAny(String inString, String charsToDelete) {
-        if (!hasLength(inString) || !hasLength(charsToDelete)) {
-            return inString;
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < inString.length(); i++) {
-            char c = inString.charAt(i);
-            if (charsToDelete.indexOf(c) == -1) {
-                sb.append(c);
-            }
-        }
-        return sb.toString();
-    }
-
-	//---------------------------------------------------------------------
-    // Convenience methods for working with formatted Strings
-    //---------------------------------------------------------------------
-    /**
-     * Quote the given {@code String} with single quotes.
-     *
-     * @param str the input {@code String} (e.g. "myString")
-     * @return the quoted {@code String} (e.g. "'myString'"), or {@code null} if
-     * the input was {@code null}
-     */
-    public static String quote(String str) {
-        return (str != null ? "'" + str + "'" : null);
-    }
-
-    /**
-     * Turn the given Object into a {@code String} with single quotes if it is a
-     * {@code String}; keeping the Object as-is else.
-     *
-     * @param obj the input Object (e.g. "myString")
-     * @return the quoted {@code String} (e.g. "'myString'"), or the input
-     * object as-is if not a {@code String}
-     */
-    public static Object quoteIfString(Object obj) {
-        return (obj instanceof String ? quote((String) obj) : obj);
-    }
-
-    /**
-     * Unqualify a string qualified by a '.' dot character. For example,
-     * "this.name.is.qualified", returns "qualified".
-     *
-     * @param qualifiedName the qualified name
-     * @return 
-     */
-    public static String unqualify(String qualifiedName) {
-        return unqualify(qualifiedName, '.');
-    }
-
-    /**
-     * Unqualify a string qualified by a separator character. For example,
-     * "this:name:is:qualified" returns "qualified" if using a ':' separator.
-     *
-     * @param qualifiedName the qualified name
-     * @param separator the separator
-     * @return 
-     */
-    public static String unqualify(String qualifiedName, char separator) {
-        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);
-    }
-
-    /**
-     * Capitalize a {@code String}, changing the first letter to upper case as
-     * per {@link Character#toUpperCase(char)}. No other letters are changed.
-     *
-     * @param str the {@code String} to capitalize, may be {@code null}
-     * @return the capitalized {@code String}, or {@code null} if the supplied
-     * string is {@code null}
-     */
-    public static String capitalize(String str) {
-        return changeFirstCharacterCase(str, true);
-    }
-
-    /**
-     * Uncapitalize a {@code String}, changing the first letter to lower case as
-     * per {@link Character#toLowerCase(char)}. No other letters are changed.
-     *
-     * @param str the {@code String} to uncapitalize, may be {@code null}
-     * @return the uncapitalized {@code String}, or {@code null} if the supplied
-     * string is {@code null}
-     */
-    public static String uncapitalize(String str) {
-        return changeFirstCharacterCase(str, false);
-    }
-
-    private static String changeFirstCharacterCase(String str, boolean capitalize) {
-        if (str == null || str.length() == 0) {
-            return str;
-        }
-        StringBuilder sb = new StringBuilder(str.length());
-        if (capitalize) {
-            sb.append(Character.toUpperCase(str.charAt(0)));
-        } else {
-            sb.append(Character.toLowerCase(str.charAt(0)));
-        }
-        sb.append(str.substring(1));
-        return sb.toString();
-    }
-
-    /**
-     * Extract the filename from the given Java resource path, e.g.
-     * {@code "mypath/myfile.txt" -> "myfile.txt"}.
-     *
-     * @param path the file path (may be {@code null})
-     * @return the extracted filename, or {@code null} if none
-     */
-    public static String getFilename(String path) {
-        if (path == null) {
-            return null;
-        }
-        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);
-        return (separatorIndex != -1 ? path.substring(separatorIndex + 1) : path);
-    }
-
-    /**
-     * Extract the filename extension from the given Java resource path, e.g.
-     * "mypath/myfile.txt" -> "txt".
-     *
-     * @param path the file path (may be {@code null})
-     * @return the extracted filename extension, or {@code null} if none
-     */
-    public static String getFilenameExtension(String path) {
-        if (path == null) {
-            return null;
-        }
-        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);
-        if (extIndex == -1) {
-            return null;
-        }
-        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);
-        if (folderIndex > extIndex) {
-            return null;
-        }
-        return path.substring(extIndex + 1);
-    }
-
-    /**
-     * Strip the filename extension from the given Java resource path, e.g.
-     * "mypath/myfile.txt" -> "mypath/myfile".
-     *
-     * @param path the file path (may be {@code null})
-     * @return the path with stripped filename extension, or {@code null} if
-     * none
-     */
-    public static String stripFilenameExtension(String path) {
-        if (path == null) {
-            return null;
-        }
-        int extIndex = path.lastIndexOf(EXTENSION_SEPARATOR);
-        if (extIndex == -1) {
-            return path;
-        }
-        int folderIndex = path.lastIndexOf(FOLDER_SEPARATOR);
-        if (folderIndex > extIndex) {
-            return path;
-        }
-        return path.substring(0, extIndex);
-    }
-
-    /**
-     * Apply the given relative path to the given Java resource path, assuming
-     * standard Java folder separation (i.e. "/" separators).
-     *
-     * @param path the path to start from (usually a full file path)
-     * @param relativePath the relative path to apply (relative to the full file
-     * path above)
-     * @return the full file path that results from applying the relative path
-     */
-    public static String applyRelativePath(String path, String relativePath) {
-        int separatorIndex = path.lastIndexOf(FOLDER_SEPARATOR);
-        if (separatorIndex != -1) {
-            String newPath = path.substring(0, separatorIndex);
-            if (!relativePath.startsWith(FOLDER_SEPARATOR)) {
-                newPath += FOLDER_SEPARATOR;
-            }
-            return newPath + relativePath;
-        } else {
-            return relativePath;
-        }
-    }
-
-    /**
-     * Normalize the path by suppressing sequences like "path/.." and inner
-     * simple dots.
-     * <p>
-     * The result is convenient for path comparison. For other uses, notice that
-     * Windows separators ("\") are replaced by simple slashes.
-     *
-     * @param path the original path
-     * @return the normalized path
-     */
-    public static String cleanPath(String path) {
-        if (path == null) {
-            return null;
-        }
-        String pathToUse = replace(path, WINDOWS_FOLDER_SEPARATOR, FOLDER_SEPARATOR);
-
-		// Strip prefix from path to analyze, to not treat it as part of the
-        // first path element. This is necessary to correctly parse paths like
-        // "file:core/../core/io/Resource.class", where the ".." should just
-        // strip the first "core" directory while keeping the "file:" prefix.
-        int prefixIndex = pathToUse.indexOf(":");
-        String prefix = "";
-        if (prefixIndex != -1) {
-            prefix = pathToUse.substring(0, prefixIndex + 1);
-            if (prefix.contains("/")) {
-                prefix = "";
-            } else {
-                pathToUse = pathToUse.substring(prefixIndex + 1);
-            }
-        }
-        if (pathToUse.startsWith(FOLDER_SEPARATOR)) {
-            prefix = prefix + FOLDER_SEPARATOR;
-            pathToUse = pathToUse.substring(1);
-        }
-
-        String[] pathArray = delimitedListToStringArray(pathToUse, FOLDER_SEPARATOR);
-        List<String> pathElements = new LinkedList<>();
-        int tops = 0;
-
-        for (int i = pathArray.length - 1; i >= 0; i--) {
-            String element = pathArray[i];
-            if (null != element) switch (element) {
-                case CURRENT_PATH:
-                    break;
-                case TOP_PATH:
-                    // Registering top path found.
-                    tops++;
-                    break;
-                default:
-                    if (tops > 0) {
-                        // Merging path element with element corresponding to top path.
-                        tops--;
-                    } else {
-                        // Normal path element found.
-                        pathElements.add(0, element);
-                    }   break;
-            }
-        }
-
-        // Remaining top paths need to be retained.
-        for (int i = 0; i < tops; i++) {
-            pathElements.add(0, TOP_PATH);
-        }
-
-        return prefix + collectionToDelimitedString(pathElements, FOLDER_SEPARATOR);
-    }
-
-    /**
-     * Compare two paths after normalization of them.
-     *
-     * @param path1 first path for comparison
-     * @param path2 second path for comparison
-     * @return whether the two paths are equivalent after normalization
-     */
-    public static boolean pathEquals(String path1, String path2) {
-        return cleanPath(path1).equals(cleanPath(path2));
-    }
-
-    /**
-     * Parse the given {@code localeString} value into a {@link Locale}.
-     * <p>
-     * This is the inverse operation of
-     * {@link Locale#toString Locale's toString}.
-     *
-     * @param localeString the locale {@code String}, following {@code Locale's}
-     * {@code toString()} format ("en", "en_UK", etc); also accepts spaces as
-     * separators, as an alternative to underscores
-     * @return a corresponding {@code Locale} instance
-     * @throws IllegalArgumentException in case of an invalid locale
-     * specification
-     */
-    public static Locale parseLocaleString(String localeString) {
-        String[] parts = tokenizeToStringArray(localeString, "_ ", false, false);
-        String language = (parts.length > 0 ? parts[0] : "");
-        String country = (parts.length > 1 ? parts[1] : "");
-        validateLocalePart(language);
-        validateLocalePart(country);
-        String variant = "";
-        if (parts.length > 2) {
-			// There is definitely a variant, and it is everything after the country
-            // code sans the separator between the country code and the variant.
-            int endIndexOfCountryCode = localeString.indexOf(country, language.length()) + country.length();
-            // Strip off any leading '_' and whitespace, what's left is the variant.
-            variant = trimLeadingWhitespace(localeString.substring(endIndexOfCountryCode));
-            if (variant.startsWith("_")) {
-                variant = trimLeadingCharacter(variant, '_');
-            }
-        }
-        return (language.length() > 0 ? new Locale(language, country, variant) : null);
-    }
-
-    private static void validateLocalePart(String localePart) {
-        for (int i = 0; i < localePart.length(); i++) {
-            char ch = localePart.charAt(i);
-            if (ch != '_' && ch != ' ' && !Character.isLetterOrDigit(ch)) {
-                throw new IllegalArgumentException(
-                        "Locale part \"" + localePart + "\" contains invalid characters");
-            }
-        }
-    }
-
-    /**
-     * Determine the RFC 3066 compliant language tag, as used for the HTTP
-     * "Accept-Language" header.
-     *
-     * @param locale the Locale to transform to a language tag
-     * @return the RFC 3066 compliant language tag as {@code String}
-     */
-    public static String toLanguageTag(Locale locale) {
-        return locale.getLanguage() + (hasText(locale.getCountry()) ? "-" + locale.getCountry() : "");
-    }
-
-    /**
-     * Parse the given {@code timeZoneString} value into a {@link TimeZone}.
-     *
-     * @param timeZoneString the time zone {@code String}, following
-     * {@link TimeZone#getTimeZone(String)} but throwing
-     * {@link IllegalArgumentException} in case of an invalid time zone
-     * specification
-     * @return a corresponding {@link TimeZone} instance
-     * @throws IllegalArgumentException in case of an invalid time zone
-     * specification
-     */
-    public static TimeZone parseTimeZoneString(String timeZoneString) {
-        TimeZone timeZone = TimeZone.getTimeZone(timeZoneString);
-        if ("GMT".equals(timeZone.getID()) && !timeZoneString.startsWith("GMT")) {
-            // We don't want that GMT fallback...
-            throw new IllegalArgumentException("Invalid time zone specification '" + timeZoneString + "'");
-        }
-        return timeZone;
-    }
-
-	//---------------------------------------------------------------------
-    // Convenience methods for working with String arrays
-    //---------------------------------------------------------------------
-    /**
-     * Append the given {@code String} to the given {@code String} array,
-     * returning a new array consisting of the input array contents plus the
-     * given {@code String}.
-     *
-     * @param array the array to append to (can be {@code null})
-     * @param str the {@code String} to append
-     * @return the new array (never {@code null})
-     */
-    public static String[] addStringToArray(String[] array, String str) {
-        if (ObjectUtils.isEmpty(array)) {
-            return new String[]{str};
-        }
-        String[] newArr = new String[array.length + 1];
-        System.arraycopy(array, 0, newArr, 0, array.length);
-        newArr[array.length] = str;
-        return newArr;
-    }
-
-    /**
-     * Concatenate the given {@code String} arrays into one, with overlapping
-     * array elements included twice.
-     * <p>
-     * The order of elements in the original arrays is preserved.
-     *
-     * @param array1 the first array (can be {@code null})
-     * @param array2 the second array (can be {@code null})
-     * @return the new array ({@code null} if both given arrays were
-     * {@code null})
-     */
-    public static String[] concatenateStringArrays(String[] array1, String[] array2) {
-        if (ObjectUtils.isEmpty(array1)) {
-            return array2;
-        }
-        if (ObjectUtils.isEmpty(array2)) {
-            return array1;
-        }
-        String[] newArr = new String[array1.length + array2.length];
-        System.arraycopy(array1, 0, newArr, 0, array1.length);
-        System.arraycopy(array2, 0, newArr, array1.length, array2.length);
-        return newArr;
-    }
-
-    /**
-     * Merge the given {@code String} arrays into one, with overlapping array
-     * elements only included once.
-     * <p>
-     * The order of elements in the original arrays is preserved (with the
-     * exception of overlapping elements, which are only included on their first
-     * occurrence).
-     *
-     * @param array1 the first array (can be {@code null})
-     * @param array2 the second array (can be {@code null})
-     * @return the new array ({@code null} if both given arrays were
-     * {@code null})
-     */
-    public static String[] mergeStringArrays(String[] array1, String[] array2) {
-        if (ObjectUtils.isEmpty(array1)) {
-            return array2;
-        }
-        if (ObjectUtils.isEmpty(array2)) {
-            return array1;
-        }
-        List<String> result = new ArrayList<>();
-        result.addAll(Arrays.asList(array1));
-        for (String str : array2) {
-            if (!result.contains(str)) {
-                result.add(str);
-            }
-        }
-        return toStringArray(result);
-    }
-
-    /**
-     * Turn given source {@code String} array into sorted array.
-     *
-     * @param array the source array
-     * @return the sorted array (never {@code null})
-     */
-    public static String[] sortStringArray(String[] array) {
-        if (ObjectUtils.isEmpty(array)) {
-            return new String[0];
-        }
-        Arrays.sort(array);
-        return array;
-    }
-
-    /**
-     * Copy the given {@code Collection} into a {@code String} array.
-     * <p>
-     * The {@code Collection} must contain {@code String} elements only.
-     *
-     * @param collection the {@code Collection} to copy
-     * @return the {@code String} array ({@code null} if the supplied
-     * {@code Collection} was {@code null})
-     */
-    public static String[] toStringArray(Collection<String> collection) {
-        if (collection == null) {
-            return null;
-        }
-        return collection.toArray(new String[collection.size()]);
-    }
-
-    /**
-     * Copy the given Enumeration into a {@code String} array. The Enumeration
-     * must contain {@code String} elements only.
-     *
-     * @param enumeration the Enumeration to copy
-     * @return the {@code String} array ({@code null} if the passed-in
-     * Enumeration was {@code null})
-     */
-    public static String[] toStringArray(Enumeration<String> enumeration) {
-        if (enumeration == null) {
-            return null;
-        }
-        List<String> list = Collections.list(enumeration);
-        return list.toArray(new String[list.size()]);
-    }
-
-    /**
-     * Trim the elements of the given {@code String} array, calling
-     * {@code String.trim()} on each of them.
-     *
-     * @param array the original {@code String} array
-     * @return the resulting array (of the same size) with trimmed elements
-     */
-    public static String[] trimArrayElements(String[] array) {
-        if (ObjectUtils.isEmpty(array)) {
-            return new String[0];
-        }
-        String[] result = new String[array.length];
-        for (int i = 0; i < array.length; i++) {
-            String element = array[i];
-            result[i] = (element != null ? element.trim() : null);
-        }
-        return result;
-    }
-
-    /**
-     * Remove duplicate strings from the given array.
-     * <p>
-     * As of 4.2, it preserves the original order, as it uses a
-     * {@link LinkedHashSet}.
-     *
-     * @param array the {@code String} array
-     * @return an array without duplicates, in natural sort order
-     */
-    public static String[] removeDuplicateStrings(String[] array) {
-        if (ObjectUtils.isEmpty(array)) {
-            return array;
-        }
-        Set<String> set = new LinkedHashSet<>();
-        set.addAll(Arrays.asList(array));
-        return toStringArray(set);
-    }
-
-    /**
-     * Split a {@code String} at the first occurrence of the delimiter. Does not
-     * include the delimiter in the result.
-     *
-     * @param toSplit the string to split
-     * @param delimiter to split the string up with
-     * @return a two element array with index 0 being before the delimiter, and
-     * index 1 being after the delimiter (neither element includes the
-     * delimiter); or {@code null} if the delimiter wasn't found in the given
-     * input {@code String}
-     */
-    public static String[] split(String toSplit, String delimiter) {
-        if (!hasLength(toSplit) || !hasLength(delimiter)) {
-            return null;
-        }
-        int offset = toSplit.indexOf(delimiter);
-        if (offset < 0) {
-            return null;
-        }
-        String beforeDelimiter = toSplit.substring(0, offset);
-        String afterDelimiter = toSplit.substring(offset + delimiter.length());
-        return new String[]{beforeDelimiter, afterDelimiter};
-    }
-
-    /**
-     * Take an array of strings and split each element based on the given
-     * delimiter. A {@code Properties} instance is then generated, with the left
-     * of the delimiter providing the key, and the right of the delimiter
-     * providing the value.
-     * <p>
-     * Will trim both the key and value before adding them to the
-     * {@code Properties} instance.
-     *
-     * @param array the array to process
-     * @param delimiter to split each element using (typically the equals
-     * symbol)
-     * @return a {@code Properties} instance representing the array contents, or
-     * {@code null} if the array to process was {@code null} or empty
-     */
-    public static Properties splitArrayElementsIntoProperties(String[] array, String delimiter) {
-        return splitArrayElementsIntoProperties(array, delimiter, null);
-    }
-
-    /**
-     * Take an array of strings and split each element based on the given
-     * delimiter. A {@code Properties} instance is then generated, with the left
-     * of the delimiter providing the key, and the right of the delimiter
-     * providing the value.
-     * <p>
-     * Will trim both the key and value before adding them to the
-     * {@code Properties} instance.
-     *
-     * @param array the array to process
-     * @param delimiter to split each element using (typically the equals
-     * symbol)
-     * @param charsToDelete one or more characters to remove from each element
-     * prior to attempting the split operation (typically the quotation mark
-     * symbol), or {@code null} if no removal should occur
-     * @return a {@code Properties} instance representing the array contents, or
-     * {@code null} if the array to process was {@code null} or empty
-     */
-    public static Properties splitArrayElementsIntoProperties(
-            String[] array, String delimiter, String charsToDelete) {
-
-        if (ObjectUtils.isEmpty(array)) {
-            return null;
-        }
-        Properties result = new Properties();
-        for (String element : array) {
-            if (charsToDelete != null) {
-                element = deleteAny(element, charsToDelete);
-            }
-            String[] splittedElement = split(element, delimiter);
-            if (splittedElement == null) {
-                continue;
-            }
-            result.setProperty(splittedElement[0].trim(), splittedElement[1].trim());
-        }
-        return result;
-    }
-
-    /**
-     * Tokenize the given {@code String} into a {@code String} array via a
-     * {@link StringTokenizer}.
-     * <p>
-     * Trims tokens and omits empty tokens.
-     * <p>
-     * The given {@code delimiters} string can consist of any number of
-     * delimiter characters. Each of those characters can be used to separate
-     * tokens. A delimiter is always a single character; for multi-character
-     * delimiters, consider using {@link #delimitedListToStringArray}.
-     *
-     * @param str the {@code String} to tokenize
-     * @param delimiters the delimiter characters, assembled as a {@code String}
-     * (each of the characters is individually considered as a delimiter)
-     * @return an array of the tokens
-     * @see java.util.StringTokenizer
-     * @see String#trim()
-     * @see #delimitedListToStringArray
-     */
-    public static String[] tokenizeToStringArray(String str, String delimiters) {
-        return tokenizeToStringArray(str, delimiters, true, true);
-    }
-
-    /**
-     * Tokenize the given {@code String} into a {@code String} array via a
-     * {@link StringTokenizer}.
-     * <p>
-     * The given {@code delimiters} string can consist of any number of
-     * delimiter characters. Each of those characters can be used to separate
-     * tokens. A delimiter is always a single character; for multi-character
-     * delimiters, consider using {@link #delimitedListToStringArray}.
-     *
-     * @param str the {@code String} to tokenize
-     * @param delimiters the delimiter characters, assembled as a {@code String}
-     * (each of the characters is individually considered as a delimiter)
-     * @param trimTokens trim the tokens via {@link String#trim()}
-     * @param ignoreEmptyTokens omit empty tokens from the result array (only
-     * applies to tokens that are empty after trimming; StringTokenizer will not
-     * consider subsequent delimiters as token in the first place).
-     * @return an array of the tokens ({@code null} if the input {@code String}
-     * was {@code null})
-     * @see java.util.StringTokenizer
-     * @see String#trim()
-     * @see #delimitedListToStringArray
-     */
-    public static String[] tokenizeToStringArray(
-            String str, String delimiters, boolean trimTokens, boolean ignoreEmptyTokens) {
-
-        if (str == null) {
-            return null;
-        }
-        StringTokenizer st = new StringTokenizer(str, delimiters);
-        List<String> tokens = new ArrayList<>();
-        while (st.hasMoreTokens()) {
-            String token = st.nextToken();
-            if (trimTokens) {
-                token = token.trim();
-            }
-            if (!ignoreEmptyTokens || token.length() > 0) {
-                tokens.add(token);
-            }
-        }
-        return toStringArray(tokens);
-    }
-
-    /**
-     * Take a {@code String} that is a delimited list and convert it into a
-     * {@code String} array.
-     * <p>
-     * A single {@code delimiter} may consist of more than one character, but it
-     * will still be considered as a single delimiter string, rather than as
-     * bunch of potential delimiter characters, in contrast to
-     * {@link #tokenizeToStringArray}.
-     *
-     * @param str the input {@code String}
-     * @param delimiter the delimiter between elements (this is a single
-     * delimiter, rather than a bunch individual delimiter characters)
-     * @return an array of the tokens in the list
-     * @see #tokenizeToStringArray
-     */
-    public static String[] delimitedListToStringArray(String str, String delimiter) {
-        return delimitedListToStringArray(str, delimiter, null);
-    }
-
-    /**
-     * Take a {@code String} that is a delimited list and convert it into a
-     * {@code String} array.
-     * <p>
-     * A single {@code delimiter} may consist of more than one character, but it
-     * will still be considered as a single delimiter string, rather than as
-     * bunch of potential delimiter characters, in contrast to
-     * {@link #tokenizeToStringArray}.
-     *
-     * @param str the input {@code String}
-     * @param delimiter the delimiter between elements (this is a single
-     * delimiter, rather than a bunch individual delimiter characters)
-     * @param charsToDelete a set of characters to delete; useful for deleting
-     * unwanted line breaks: e.g. "\r\n\f" will delete all new lines and line
-     * feeds in a {@code String}
-     * @return an array of the tokens in the list
-     * @see #tokenizeToStringArray
-     */
-    public static String[] delimitedListToStringArray(String str, String delimiter, String charsToDelete) {
-        if (str == null) {
-            return new String[0];
-        }
-        if (delimiter == null) {
-            return new String[]{str};
-        }
-        List<String> result = new ArrayList<>();
-        if ("".equals(delimiter)) {
-            for (int i = 0; i < str.length(); i++) {
-                result.add(deleteAny(str.substring(i, i + 1), charsToDelete));
-            }
-        } else {
-            int pos = 0;
-            int delPos;
-            while ((delPos = str.indexOf(delimiter, pos)) != -1) {
-                result.add(deleteAny(str.substring(pos, delPos), charsToDelete));
-                pos = delPos + delimiter.length();
-            }
-            if (str.length() > 0 && pos <= str.length()) {
-                // Add rest of String, but not in case of empty input.
-                result.add(deleteAny(str.substring(pos), charsToDelete));
-            }
-        }
-        return toStringArray(result);
-    }
-
-    /**
-     * Convert a comma delimited list (e.g., a row from a CSV file) into an
-     * array of strings.
-     *
-     * @param str the input {@code String}
-     * @return an array of strings, or the empty array in case of empty input
-     */
-    public static String[] commaDelimitedListToStringArray(String str) {
-        return delimitedListToStringArray(str, ",");
-    }
-
-    /**
-     * Convert a comma delimited list (e.g., a row from a CSV file) into a set.
-     * <p>
-     * Note that this will suppress duplicates, and as of 4.2, the elements in
-     * the returned set will preserve the original order in a
-     * {@link LinkedHashSet}.
-     *
-     * @param str the input {@code String}
-     * @return a set of {@code String} entries in the list
-     * @see #removeDuplicateStrings(String[])
-     */
-    public static Set<String> commaDelimitedListToSet(String str) {
-        Set<String> set = new LinkedHashSet<>();
-        String[] tokens = commaDelimitedListToStringArray(str);
-        set.addAll(Arrays.asList(tokens));
-        return set;
-    }
-
-    /**
-     * Convert a {@link Collection} to a delimited {@code String} (e.g. CSV).
-     * <p>
-     * Useful for {@code toString()} implementations.
-     *
-     * @param coll the {@code Collection} to convert
-     * @param delim the delimiter to use (typically a ",")
-     * @param prefix the {@code String} to start each element with
-     * @param suffix the {@code String} to end each element with
-     * @return the delimited {@code String}
-     */
-    public static String collectionToDelimitedString(Collection<?> coll, String delim, String prefix, String suffix) {
-        if (CollectionUtils.isEmpty(coll)) {
-            return "";
-        }
-        StringBuilder sb = new StringBuilder();
-        Iterator<?> it = coll.iterator();
-        while (it.hasNext()) {
-            sb.append(prefix).append(it.next()).append(suffix);
-            if (it.hasNext()) {
-                sb.append(delim);
-            }
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Convert a {@code Collection} into a delimited {@code String} (e.g. CSV).
-     * <p>
-     * Useful for {@code toString()} implementations.
-     *
-     * @param coll the {@code Collection} to convert
-     * @param delim the delimiter to use (typically a ",")
-     * @return the delimited {@code String}
-     */
-    public static String collectionToDelimitedString(Collection<?> coll, String delim) {
-        return collectionToDelimitedString(coll, delim, "", "");
-    }
-
-    /**
-     * Convert a {@code Collection} into a delimited {@code String} (e.g., CSV).
-     * <p>
-     * Useful for {@code toString()} implementations.
-     *
-     * @param coll the {@code Collection} to convert
-     * @return the delimited {@code String}
-     */
-    public static String collectionToCommaDelimitedString(Collection<?> coll) {
-        return collectionToDelimitedString(coll, ",");
-    }
-
-    /**
-     * Convert a {@code String} array into a delimited {@code String} (e.g.
-     * CSV).
-     * <p>
-     * Useful for {@code toString()} implementations.
-     *
-     * @param arr the array to display
-     * @param delim the delimiter to use (typically a ",")
-     * @return the delimited {@code String}
-     */
-    public static String arrayToDelimitedString(Object[] arr, String delim) {
-        if (ObjectUtils.isEmpty(arr)) {
-            return "";
-        }
-        if (arr.length == 1) {
-            return ObjectUtils.nullSafeToString(arr[0]);
-        }
-        StringBuilder sb = new StringBuilder();
-        for (int i = 0; i < arr.length; i++) {
-            if (i > 0) {
-                sb.append(delim);
-            }
-            sb.append(arr[i]);
-        }
-        return sb.toString();
-    }
-
-    /**
-     * Convert a {@code String} array into a comma delimited {@code String}
-     * (i.e., CSV).
-     * <p>
-     * Useful for {@code toString()} implementations.
-     *
-     * @param arr the array to display
-     * @return the delimited {@code String}
-     */
-    public static String arrayToCommaDelimitedString(Object[] arr) {
-        return arrayToDelimitedString(arr, ",");
-    }
-    
-    public static int levenshtein(CharSequence lhs, CharSequence rhs) {      
-        int[][] distance = new int[lhs.length() + 1][rhs.length() + 1];        
-                                                                                 
-        for (int i = 0; i <= lhs.length(); i++) {                                 
-            distance[i][0] = i;                   
-        }
-        
-        for (int j = 1; j <= rhs.length(); j++) {        
-            distance[0][j] = j;   
-        }                                                                       
-                                                   
-        for (int i = 1; i <= lhs.length(); i++) {
-            for (int j = 1; j <= rhs.length(); j++){                 
-                distance[i][j] = Math.min(
-                    Math.min(
-                            distance[i - 1][j] + 1,
-                            distance[i][j - 1] + 1
-                    ) , distance[i - 1][j - 1] + ((lhs.charAt(i - 1) == rhs.charAt(j - 1)) ? 0 : 1)
-                );
-            }  
-        }     
-        
-        return distance[lhs.length()][rhs.length()];                           
-    }
-    
-    public static String findAlternative(String nonExistant, Collection<String> candidates){
-        return findAlternative(nonExistant, candidates, 3);
-    }
-    
-    public static String findAlternative(String nonExistant, Collection<String> candidates, int force){
-        String alternative = null;
-        Integer shortest = null;
-        for (String name : candidates) {
-            if(name.contains(nonExistant)) {
-                // there is a partial match return it !
-                return name;
-            }
-            
-            int lev = levenshtein(nonExistant, name);
-            
-            if(lev <= nonExistant.length() / force && (alternative == null || lev < shortest)) {
-                alternative = name;
-                shortest = lev;
-            }
-            
-        }
-        
-        return alternative;
-    }
-}
diff --git a/test/resolver/ResolverDelegateTest.java b/test/resolver/ResolverDelegateTest.java
deleted file mode 100644
index 4073de1..0000000
--- a/test/resolver/ResolverDelegateTest.java
+++ /dev/null
@@ -1,101 +0,0 @@
-package resolver;
-
-import java.util.Collection;
-import java.util.Optional;
-import org.junit.After;
-import org.junit.AfterClass;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import static org.junit.Assert.*;
-
-public class ResolverDelegateTest {
-    
-    public ResolverDelegateTest() {
-    }
-    
-    @BeforeClass
-    public static void setUpClass() {
-    }
-    
-    @AfterClass
-    public static void tearDownClass() {
-    }
-    
-    @Before
-    public void setUp() {
-    }
-    
-    @After
-    public void tearDown() {
-    }
-
-    /**
-     * Test of support method, of class ResolverDelegate.
-     */
-    @Test
-    public void testSupport() {
-        System.out.println("support");
-        Object object = null;
-        ResolverDelegate instance = new ResolverDelegate();
-        boolean expResult = false;
-//        boolean result = instance.support(object);
-//        assertEquals(expResult, result);
-        // TODO review the generated test code and remove the default call to fail.
-        fail("The test case is a prototype.");
-    }
-
-    /**
-     * Test of resolve method, of class ResolverDelegate.
-     */
-    @Test
-    public void testResolve() {
-        System.out.println("resolve");
-        Object object = null;
-        ResolverDelegate instance = new ResolverDelegate();
-        Optional expResult = null;
-        Optional result = instance.resolve(object);
-        assertEquals(expResult, result);
-        // TODO review the generated test code and remove the default call to fail.
-        fail("The test case is a prototype.");
-    }
-
-    /**
-     * Test of getResolvers method, of class ResolverDelegate.
-     */
-    @Test
-    public void testGetResolvers() {
-        System.out.println("getResolvers");
-        ResolverDelegate instance = new ResolverDelegate();
-//        Collection<Resolver<I, O>> expResult = null;
-//        Collection<Resolver<I, O>> result = instance.getResolvers();
-//        assertEquals(expResult, result);
-        // TODO review the generated test code and remove the default call to fail.
-        fail("The test case is a prototype.");
-    }
-
-    /**
-     * Test of setResolvers method, of class ResolverDelegate.
-     */
-    @Test
-    public void testSetResolvers() {
-        System.out.println("setResolvers");
-        ResolverDelegate instance = new ResolverDelegate();
-        instance.setResolvers(null);
-        // TODO review the generated test code and remove the default call to fail.
-        fail("The test case is a prototype.");
-    }
-
-    /**
-     * Test of addResolver method, of class ResolverDelegate.
-     */
-    @Test
-    public void testAddResolver() {
-        System.out.println("addResolver");
-        ResolverDelegate instance = new ResolverDelegate();
-//        instance.addResolver(null);
-        // TODO review the generated test code and remove the default call to fail.
-        fail("The test case is a prototype.");
-    }
-    
-}
-- 
2.7.2.windows.1

